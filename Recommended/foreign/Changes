diff -rEZbwB '--exclude=*.[lo,d,pdf,mo,po,tgz,gz,save]*' '--exclude=MD5' '--exclude=Makefile*' '--exclude=all.R' '--exclude=Changes' R-recommended/foreign/R/R_systat.R Recommended/foreign/R/R_systat.R
22c22
<     if (!is.character(file)) stop("'file' must be character")
---
>     if (!is.character(file)) stop(gettextf("'%s' argument must be a character string", "file"))
diff -rEZbwB '--exclude=*.[lo,d,pdf,mo,po,tgz,gz,save]*' '--exclude=MD5' '--exclude=Makefile*' '--exclude=all.R' '--exclude=Changes' R-recommended/foreign/R/Sread.R Recommended/foreign/R/Sread.R
66c66
< 		for (i in 1L:len) {
---
> 		for (i in seq_len(len)) {
110c110
< 		result <- call("stop", "Argument is missing")
---
> 		result <- call("stop", gettext("Argument is missing", domain = "R-foreign"))
114c114
< 	    return(paste("Unrecognized S mode", code, "not supported"))
---
> 	    return(gettextf("Unrecognized S mode %s is not supported", code, domain = "R-foreign"))
164,165c164
< 			     paste("Argument ", sQuote(name), " is missing",
<                                    sep=""))
---
> 			     gettextf("Argument %s is missing", sQuote(name), domain = "R-foreign"))
208,209c207
<             stop(gettextf("S mode %s (near byte offset %s) not supported",
<                           sQuote(code), seek(dump)), domain = NA)
---
>             stop(gettextf("S mode %s (near byte offset %s) not supported", sQuote(code), seek(dump)), domain = "R-foreign")
diff -rEZbwB '--exclude=*.[lo,d,pdf,mo,po,tgz,gz,save]*' '--exclude=MD5' '--exclude=Makefile*' '--exclude=all.R' '--exclude=Changes' R-recommended/foreign/R/arff.R Recommended/foreign/R/arff.R
32c32
<         stop("Argument 'file' must be a character string or connection.")
---
>         stop(gettextf("'%s' argument must be a character string or connection", "file"))
108c108
<         stop("Argument 'file' must be a character string or connection.")
---
>         stop(gettextf("'%s' argument must be a character string or connection", "file"))
diff -rEZbwB '--exclude=*.[lo,d,pdf,mo,po,tgz,gz,save]*' '--exclude=MD5' '--exclude=Makefile*' '--exclude=all.R' '--exclude=Changes' R-recommended/foreign/R/dbf.R Recommended/foreign/R/dbf.R
28,30c28
<                 message(gettextf("Field name: %s changed to: %s",
<                                  sQuote(onames[i]), sQuote(inames[i])),
<                         domain = NA)
---
>                 message(gettextf("Field name: %s changed to: %s", sQuote(onames[i]), sQuote(inames[i])), domain = "R-foreign")
59,60c57
<                               "data frame contains columns of unsupported classes %s"),
< 
---
>                               "data frame contains columns of unsupported classes %s", domain = "R-foreign"),
100c97
<                 warning(gettextf("character column %d will be truncated to %d bytes", i, max_nchar), domain = NA)
---
>                 warning(gettextf("character column %d will be truncated to %d bytes", i, max_nchar), domain = "R-foreign")
diff -rEZbwB '--exclude=*.[lo,d,pdf,mo,po,tgz,gz,save]*' '--exclude=MD5' '--exclude=Makefile*' '--exclude=all.R' '--exclude=Changes' R-recommended/foreign/R/octave.R Recommended/foreign/R/octave.R
169,170c169
<         warning(gettextf("cannot handle unknown type %s", sQuote(type)),
<                 domain = NA)
---
>         warning(gettextf("cannot handle unknown type %s", sQuote(type)), domain = "R-foreign")
diff -rEZbwB '--exclude=*.[lo,d,pdf,mo,po,tgz,gz,save]*' '--exclude=MD5' '--exclude=Makefile*' '--exclude=all.R' '--exclude=Changes' R-recommended/foreign/R/spss.R Recommended/foreign/R/spss.R
88c88
<             message(gettextf("re-encoding from %s", cp), domain = NA)
---
>             message(gettextf("re-encoding from %s", cp), domain = "R-foreign")
154,155c154
<                     warning(gettextf("missingness type %s is not handled", tp),
<                             domain = NA)
---
>                     warning(gettextf("missingness type %s is not handled", tp), domain = "R-foreign")
diff -rEZbwB '--exclude=*.[lo,d,pdf,mo,po,tgz,gz,save]*' '--exclude=MD5' '--exclude=Makefile*' '--exclude=all.R' '--exclude=Changes' R-recommended/foreign/R/writeForeignSAS.R Recommended/foreign/R/writeForeignSAS.R
28c28
<       stop(gettextf("Cannot uniquely abbreviate the variable names to %d or fewer characters", nmax), domain = NA)
---
>       stop(gettextf("Cannot uniquely abbreviate the variable names to %d or fewer characters", nmax), domain = "R-foreign")
40,41c40
<     stop("Cannot uniquely abbreviate format names to conform to ",
<          " eight-character limit and not ending in a digit")
---
>     stop("Cannot uniquely abbreviate format names to conform to eight-character limit and not ending in a digit")
90c89
<             for(i in 1L:length(values)){
---
>             for(i in seq_len(length(values))){
135c134
<     for(v in 1L:ncol(df))
---
>     for(v in seq_len(ncol(df)))
141c140
<     for(v in 1L:ncol(df))
---
>     for(v in seq_len(ncol(df)))
147c146
<         for (f in 1L:length(fmtnames))
---
>         for (f in seq_len(length(fmtnames)))
diff -rEZbwB '--exclude=*.[lo,d,pdf,mo,po,tgz,gz,save]*' '--exclude=MD5' '--exclude=Makefile*' '--exclude=all.R' '--exclude=Changes' R-recommended/foreign/src/R_systat.c Recommended/foreign/src/R_systat.c
100a99
> #include "localization.h"
102,103c101
< static void swapb(void *result, int size)
< {
---
> static void swapb(void *result, int size) {
117,118c115
< SEXP readSystat(SEXP file)
< {
---
> SEXP readSystat(SEXP file) {
138c134,135
<     PROTECT(res = allocVector(VECSXP, getnv(use))); pc++;
---
> 	PROTECT(res = allocVector(VECSXP, getnv(use)));
> 	pc++;
146c143,144
<     PROTECT(resnames = allocVector(STRSXP, getnv(use))); pc++;
---
> 	PROTECT(resnames = allocVector(STRSXP, getnv(use)));
> 	pc++;
152c150,151
< 	PROTECT(comment = allocVector(STRSXP, 1)); pc++;
---
> 		PROTECT(comment = allocVector(STRSXP, 1));
> 		pc++;
164c163,164
< 		else REAL(VECTOR_ELT(res, i))[j] = x[j];
---
> 				else
> 					REAL(VECTOR_ELT(res, i))[j] = x[j];
175,176c175
< 		getsvar(use->h.fd, str,
< 			use->str_offset[use->ithstr[i]]);
---
> 				getsvar(use->h.fd, str, use->str_offset[use->ithstr[i]]);
192,193c191
< static void init_use(struct SysFilev3 *use)
< {
---
> static void init_use(struct SysFilev3 *use) {
227,228c224
< static void getuse(const char *fname, struct SysFilev3 *u)
< {
---
> static void getuse(const char *fname, struct SysFilev3 *u) {
243c238,239
<     j = 0; k = 0;
---
> 	j = 0;
> 	k = 0;
258c254,255
<     if(getoctal(&k, u->h.fd) != 1) error(_("getuse: File access error"));
---
> 	if (getoctal(&k, u->h.fd) != 1)
> 		error(_("getuse: File access error"));
286,288c283,287
< 		(u->h.nd % (FORTBUF / (u->h.ntype == 1 ? sizeof(float) : sizeof(double))))
< 		* (u->h.ntype == 1 ? sizeof(float) :
< 		   sizeof(double));
---
> 					(u->h.nd
> 							% (FORTBUF
> 									/ (u->h.ntype == 1 ?
> 											sizeof(float) : sizeof(double))))
> 							* (u->h.ntype == 1 ? sizeof(float) : sizeof(double));
334c333
< 	    sprintf(tmp, "Getuse: failure reading byte %d", end);
---
> 			sprintf(tmp, _("Getuse: failure reading byte %d"), end);
340c339,340
<     if (i >= 512) error(_("getuse: terminal null block"));
---
> 	if (i >= 512)
> 		error(_("getuse: terminal null block"));
346c346
< 	sprintf(tmp, "Getuse: last byte = %o octal", k);
---
> 		sprintf(tmp, _("Getuse: last byte = %o octal"), k);
362,364c362,363
< 	    u->local_offset[i] = (int) u->ithdb[i] *
< 		(u->h.ntype == 1 ? sizeof(float) :
< 		 sizeof(double))	/* the easy
---
> 			u->local_offset[i] = (int) u->ithdb[i]
> 					* (u->h.ntype == 1 ? sizeof(float) : sizeof(double)) /* the easy
368,369c367,371
< 		+ (u->ithdb[i] / (FORTBUF / (u->h.ntype == 1 ?
< 					     sizeof(float) : sizeof(double)))) * 2;
---
> 					+ (u->ithdb[i]
> 							/ (FORTBUF
> 									/ (u->h.ntype == 1 ?
> 											sizeof(float) : sizeof(double))))
> 							* 2;
373,374c375
< 	}
< 	else {			/* or a string */
---
> 		} else { /* or a string */
376,377c377,378
< 	    u->local_offset[i] = (int) (u->h.nd*(u->h.ntype == 1 ?
< 						  sizeof(float) : sizeof(double)))
---
> 			u->local_offset[i] = (int) (u->h.nd
> 					* (u->h.ntype == 1 ? sizeof(float) : sizeof(double)))
379,380c380,384
< 		+ (u->h.nd / (FORTBUF / (u->h.ntype == 1 ?
< 					 sizeof(float) : sizeof(double)))) * 2
---
> 					+ (u->h.nd
> 							/ (FORTBUF
> 									/ (u->h.ntype == 1 ?
> 											sizeof(float) : sizeof(double))))
> 							* 2
387,388c391,392
< 	    if(u->ithstr[i] >= 0
< 	       && u->str_offset[u->ithstr[i]] != 0) k++;
---
> 			if (u->ithstr[i] >= 0 && u->str_offset[u->ithstr[i]] != 0)
> 				k++;
405,406c408
< static void getlab(struct SysFilev3 *u)
< {
---
> static void getlab(struct SysFilev3 *u) {
422c424,425
< 	error(tmp1); }	/* read and throw away zeroth byte=0113 */
---
> 		error(tmp1);
> 	} /* read and throw away zeroth byte=0113 */
426c429,430
< 	error(tmp1); }
---
> 		error(tmp1);
> 	}
438c442,443
< 	error(tmp1);}
---
> 		error(tmp1);
> 	}
449c454,455
< 		error(tmp1); }
---
> 				error(tmp1);
> 			}
455,456c461,464
< 		    error(tmp1); }
< 		if (j == 0) isDollar = (o == '$');
---
> 					error(tmp1);
> 				}
> 				if (j == 0)
> 					isDollar = (o == '$');
460c468,469
< 		error(tmp1); }
---
> 				error(tmp1);
> 			}
478c487,488
< 	    error(tmp1); }
---
> 			error(tmp1);
> 		}
489c499,500
< 	    error(tmp1); }
---
> 			error(tmp1);
> 		}
503,505c514,517
< 	    sprintf(tmp1, _("getlab: byte lab[%d]0 = %o, nv=%d"),
< 		    j, o, u->h.nv);
< 	    error(tmp1); }
---
> 			sprintf(tmp1, _("getlab: byte lab[%d]0 = %o, nv=%d"), j, o,
> 					u->h.nv);
> 			error(tmp1);
> 		}
513c525,526
< 	if(label[8] == '$') u->h.nk++;
---
> 		if (label[8] == '$')
> 			u->h.nk++;
518c531,532
< 	} else u->h.nd++;	/* if the ninth char in label is '$',
---
> 		} else
> 			u->h.nd++; /* if the ninth char in label is '$',
523c537,538
< 	    if(label[i] != ' ') tmp[o++] = label[i];
---
> 			if (label[i] != ' ')
> 				tmp[o++] = label[i];
537c552,553
< 	    error(tmp1); }
---
> 			error(tmp1);
> 		}
550,552c565,567
< static void closeuse(struct SysFilev3 *use)
< {
<     if(use->h.flag != 0) fclose(use->h.fd);
---
> static void closeuse(struct SysFilev3 *use) {
> 	if (use->h.flag != 0)
> 		fclose(use->h.fd);
576,578c590,592
< static int getnv(struct SysFilev3 *use)
< {
<     if (isuse(use) == 0) return(-1);
---
> static int getnv(struct SysFilev3 *use) {
> 	if (isuse(use) == 0)
> 		return (-1);
586,588c600,602
< static int getnd(struct SysFilev3 *use)
< {
<     if (isuse(use) == 0) return(-1);
---
> static int getnd(struct SysFilev3 *use) {
> 	if (isuse(use) == 0)
> 		return (-1);
596,598c610,612
< static int getnk(struct SysFilev3 *use)
< {
<     if (isuse(use) == 0) return(-1);
---
> static int getnk(struct SysFilev3 *use) {
> 	if (isuse(use) == 0)
> 		return (-1);
603,605c617,619
< static char *getvarnam(int i, struct SysFilev3 *use)
< {
<     if (isuse(use) == 0 || i >= use->h.nv) return(NULL);
---
> static char *getvarnam(int i, struct SysFilev3 *use) {
> 	if (isuse(use) == 0 || i >= use->h.nv)
> 		return (NULL);
611,614c624,628
< static int isdb(int i, struct SysFilev3 *use)
< {
<     if (use->ithdb[i] >= 0) return(0);
<     else return(-1);
---
> static int isdb(int i, struct SysFilev3 *use) {
> 	if (use->ithdb[i] >= 0)
> 		return (0);
> 	else
> 		return (-1);
619,620c632
< static int getmtype(struct SysFilev3 *use)
< {
---
> static int getmtype(struct SysFilev3 *use) {
625,626c637
< static int isuse(struct SysFilev3 *use)
< {
---
> static int isuse(struct SysFilev3 *use) {
634,636c645,647
< static int getnobs(struct SysFilev3 *use)
< {
<     if(isuse(use) == 0) return(-1);
---
> static int getnobs(struct SysFilev3 *use) {
> 	if (isuse(use) == 0)
> 		return (-1);
647,648c657
< static int getdb(FILE *fd, short type, double *x)
< {
---
> static int getdb(FILE *fd, short type, double *x) {
653c662,663
< 	if(fread(&fx, sizeof(float), 1, fd) != 1) return(1);
---
> 		if (fread(&fx, sizeof(float), 1, fd) != 1)
> 			return (1);
657c667,668
< 	if(fread(&dx, sizeof(double), 1, fd) != 1) return(1);
---
> 		if (fread(&dx, sizeof(double), 1, fd) != 1)
> 			return (1);
686,689c697,700
<     }
<     else {
< 	if((fread(tmp_str, 1, (LABELSIZ - packet_bound), fd)) !=
< 	   (LABELSIZ - packet_bound)) error(_("file access error"));
---
> 	} else {
> 		if ((fread(tmp_str, 1, (LABELSIZ - packet_bound), fd))
> 				!= (LABELSIZ - packet_bound))
> 			error(_("file access error"));
695c706,707
< 	if((fseek(fd, 2L, SEEK_CUR)) != 0) error(_("file access error"));			/* hop over the packet boundary */
---
> 		if ((fseek(fd, 2L, SEEK_CUR)) != 0)
> 			error(_("file access error")); /* hop over the packet boundary */
697,698c709,710
< 	if((fread(tmp_str, 1, packet_bound, fd)) !=
< 	   packet_bound) error(_("file access error"));
---
> 		if ((fread(tmp_str, 1, packet_bound, fd)) != packet_bound)
> 			error(_("file access error"));
709,710c719
< static void getdbvar(int varno, double *db, struct SysFilev3 *use)
< {
---
> static void getdbvar(int varno, double *db, struct SysFilev3 *use) {
714c723,724
<     if (use->ithdb[varno] < 0) error(_("string variable"));
---
> 	if (use->ithdb[varno] < 0)
> 		error(_("string variable"));
716,717c726,728
<     if((j = fseek(use->h.fd, use->pos+use->local_offset[varno]+1L, SEEK_SET))
<        != 0) error(_("file access error"));
---
> 	if ((j = fseek(use->h.fd, use->pos + use->local_offset[varno] + 1L,
> 			SEEK_SET)) != 0)
> 		error(_("file access error"));
725c736,737
< 	if((j = getdb(use->h.fd, use->h.ntype, &x)) != 0) break;
---
> 		if ((j = getdb(use->h.fd, use->h.ntype, &x)) != 0)
> 			break;
737c749,750
<     if (j != 0) error(_("file access error"));
---
> 	if (j != 0)
> 		error(_("file access error"));
744,745c757
< static int getoctal(int *o, FILE *fp)
< {
---
> static int getoctal(int *o, FILE *fp) {
760,761c772
< static size_t getshort(short *sh, FILE *fp)
< {
---
> static size_t getshort(short *sh, FILE *fp) {
diff -rEZbwB '--exclude=*.[lo,d,pdf,mo,po,tgz,gz,save]*' '--exclude=MD5' '--exclude=Makefile*' '--exclude=all.R' '--exclude=Changes' R-recommended/foreign/src/Rdbfread.c Recommended/foreign/src/Rdbfread.c
30a31
> #include "localization.h"
56c57,58
<     if( hDBF == NULL ) error(_("unable to open DBF file"));
---
> 	if (hDBF == NULL)
> 		error(_("unable to open DBF file"));
61,62c63
<     if( DBFGetFieldCount(hDBF) == 0 )
<     {
---
> 	if (DBFGetFieldCount(hDBF) == 0) {
71c72,73
<     PROTECT(DataTypes = allocVector(STRSXP, nflds)); pc++;
---
> 	PROTECT(DataTypes = allocVector(STRSXP, nflds));
> 	pc++;
94c96,97
< 	buf[0] = hDBF->pachFieldType[i]; buf[1] = '\0';
---
> 		buf[0] = hDBF->pachFieldType[i];
> 		buf[1] = '\0';
98,101c101,105
<     PROTECT(df = allocVector(VECSXP, nRvar)); pc++;
<     PROTECT(varlabels = allocVector(STRSXP, nRvar)); pc++;
<     for(i = 0, nRvar = 0; i < nflds; i++)
<     {
---
> 	PROTECT(df = allocVector(VECSXP, nRvar));
> 	pc++;
> 	PROTECT(varlabels = allocVector(STRSXP, nRvar));
> 	pc++;
> 	for (i = 0, nRvar = 0; i < nflds; i++) {
123,124c127
<     for(iRecord = 0; iRecord < nrecs; iRecord++)
<     {
---
> 	for (iRecord = 0; iRecord < nrecs; iRecord++) {
143c146,147
< 			int ii, *it; double *r;
---
> 						int ii, *it;
> 						double *r;
206c210,211
<     PROTECT(tmp = mkString("data.frame")); pc++;
---
> 	PROTECT(tmp = mkString("data.frame"));
> 	pc++;
210c215,216
<     PROTECT(row_names = allocVector(STRSXP, nrecs)); pc++;
---
> 	PROTECT(row_names = allocVector(STRSXP, nrecs));
> 	pc++;
diff -rEZbwB '--exclude=*.[lo,d,pdf,mo,po,tgz,gz,save]*' '--exclude=MD5' '--exclude=Makefile*' '--exclude=all.R' '--exclude=Changes' R-recommended/foreign/src/Rdbfwrite.c Recommended/foreign/src/Rdbfwrite.c
32c32
< 
---
> #include "localization.h"
44,46c44
< 
< SEXP DoWritedbf(SEXP file, SEXP df, SEXP pr, SEXP sc, SEXP DataTypes)
< {
---
> SEXP DoWritedbf(SEXP file, SEXP df, SEXP pr, SEXP sc, SEXP DataTypes) {
53c51,52
<     if (hDBF == NULL) error(_("unable to open file"));
---
> 	if (hDBF == NULL)
> 		error(_("unable to open file"));
60,63c59,60
< 
< static DBFHandle
< Rdbfwrite(DBFHandle hDBF, SEXP df, SEXP pr, SEXP sc, SEXP DataTypes)
< {
---
> static DBFHandle Rdbfwrite(DBFHandle hDBF, SEXP df, SEXP pr, SEXP sc,
> 		SEXP DataTypes) {
84,85c81,82
< 		DBFAddField(hDBF, nameMangleOut(szTitle,11), FTInteger,
< 			    nWidth, 0);
---
> 				DBFAddField(hDBF, nameMangleOut(szTitle, 11), FTInteger, nWidth,
> 						0);
diff -rEZbwB '--exclude=*.[lo,d,pdf,mo,po,tgz,gz,save]*' '--exclude=MD5' '--exclude=Makefile*' '--exclude=all.R' '--exclude=Changes' R-recommended/foreign/src/SASxport.c Recommended/foreign/src/SASxport.c
31a32
> #include "localization.h"
63,64c63
< static double get_IBM_double(char* c, size_t len)
< {
---
> static double get_IBM_double(char* c, size_t len) {
98c97,98
<     if (c[1] == '\0' && c[0] != '\0') return R_NaReal;
---
> 	if (c[1] == '\0' && c[0] != '\0')
> 		return R_NaReal;
101c101,102
<     for (i = 1; i < 4; i++) buf[i] = c[i];
---
> 	for (i = 1; i < 4; i++)
> 		buf[i] = c[i];
104c105,106
<     for (i = 0; i < 4; i++) buf[i] = c[i + 4];
---
> 	for (i = 0; i < 4; i++)
> 		buf[i] = c[i + 4];
107,109c109,112
<     value = ((double) upper + ((double) lower)/Two32) *
< 	pow(16., (double) exponent);
<     if (negative) value = -value;
---
> 	value = ((double) upper + ((double) lower) / Two32)
> 			* pow(16., (double) exponent);
> 	if (negative)
> 		value = -value;
113,115c116,117
< static int
< get_nam_header(FILE *fp, struct SAS_XPORT_namestr *namestr, int length)
< {
---
> static int get_nam_header(FILE *fp, struct SAS_XPORT_namestr *namestr,
> 		int length) {
142,144c144
< static int
< get_lib_header(FILE *fp, struct SAS_XPORT_header *head)
< {
---
> static int get_lib_header(FILE *fp, struct SAS_XPORT_header *head) {
180,182c180
< static int
< get_mem_header(FILE *fp, struct SAS_XPORT_member *member)
< {
---
> static int get_mem_header(FILE *fp, struct SAS_XPORT_member *member) {
212,214c210
< static int
< init_xport_info(FILE *fp)
< {
---
> static int init_xport_info(FILE *fp) {
231,232c227,228
<     if(n != 80 || strncmp(MEM_HEADER, record, 75) != 0 ||
<        strncmp("  ", record+78, 2) != 0)
---
> 	if (n != 80 || strncmp(MEM_HEADER, record, 75) != 0
> 			|| strncmp("  ", record + 78, 2) != 0)
240,242c236
< static int
< init_mem_info(FILE *fp, char *name)
< {
---
> static int init_mem_info(FILE *fp, char *name) {
256,257c250,251
<     if(n != 80 || strncmp(NAM_HEADER, record, 54) != 0 ||
<        (strrchr(record+58, ' ') - record) != 79) {
---
> 	if (n != 80 || strncmp(NAM_HEADER, record, 54) != 0
> 			|| (strrchr(record + 58, ' ') - record) != 79) {
271c265,266
<     } else name[0] = '\0';
---
> 	} else
> 		name[0] = '\0';
278,282c273,275
< static int
< next_xport_info(FILE *fp, int namestr_length, int nvars, int *headpad,
< 		int *tailpad, int *length, int *ntype, int *nlng,
< 		int *nvar0, SEXP nname, SEXP nlabel, SEXP nform, int *npos)
< {
---
> static int next_xport_info(FILE *fp, int namestr_length, int nvars,
> 		int *headpad, int *tailpad, int *length, int *ntype, int *nlng,
> 		int *nvar0, SEXP nname, SEXP nlabel, SEXP nform, int *npos) {
384,385c377,378
< 	    if(n == 80 && strncmp(MEM_HEADER, record, 75) == 0 &&
< 	       strncmp("  ", record+78, 2) == 0) {
---
> 			if (n == 80 && strncmp(MEM_HEADER, record, 75) == 0
> 					&& strncmp("  ", record + 78, 2) == 0) {
391,392c384
< 	}
< 	else /* beware that the previous member can end on card
---
> 		} else /* beware that the previous member can end on card
394,396c386,387
< 	    if (restOfCard == 80 && n == 80 &&
< 		strncmp(MEM_HEADER, tmp, 75) == 0 &&
< 		strncmp("  ", tmp+78, 2) == 0) {
---
> 		if (restOfCard == 80 && n == 80 && strncmp(MEM_HEADER, tmp, 75) == 0
> 				&& strncmp("  ", tmp + 78, 2) == 0) {
416c407,408
< 	restOfCard = (restOfCard >= totwidth)?
---
> 		restOfCard =
> 				(restOfCard >= totwidth) ?
431,432c423
< static SEXP
< getListElement(SEXP list, char *str) {
---
> static SEXP getListElement(SEXP list, char *str) {
452,464c443,444
< const char *cVarInfoNames[] = {
<     "headpad",
<     "type",
<     "width",
<     "index",
<     "position",
<     "name",
<     "label",
<     "format",
<     "sexptype",
<     "tailpad",
<     "length"
< };
---
> const char *cVarInfoNames[] = { "headpad", "type", "width", "index", "position",
> 		"name", "label", "format", "sexptype", "tailpad", "length" };
493,495c473
< SEXP
< xport_info(SEXP xportFile)
< {
---
> SEXP xport_info(SEXP xportFile) {
522,523c500
<     while(!feof(fp))
<       {
---
> 	while (!feof(fp)) {
541,542c518
< 	namestrLength =
< 	    next_xport_info(fp, namestrLength, memLength,
---
> 		namestrLength = next_xport_info(fp, namestrLength, memLength,
548,551c524,525
< 			    INTEGER(XPORT_VAR_INDEX(varInfo)),
< 			    XPORT_VAR_NAME(varInfo),
< 			    XPORT_VAR_LABEL(varInfo),
< 			    XPORT_VAR_FORM(varInfo),
---
> 				INTEGER(XPORT_VAR_INDEX(varInfo)), XPORT_VAR_NAME(varInfo),
> 				XPORT_VAR_LABEL(varInfo), XPORT_VAR_FORM(varInfo),
557,558c531
< 			   (ntype[i] == REALSXP) ? char_numeric :
< 			   char_character);
---
> 					(ntype[i] == REALSXP) ? char_numeric : char_character);
587,589c560
< SEXP
< xport_read(SEXP xportFile, SEXP xportInfo)
< {
---
> SEXP xport_read(SEXP xportFile, SEXP xportInfo) {
647,648c618,619
< 		    REAL(VECTOR_ELT(data, k))[j] =
< 			get_IBM_double(tmpchar, dataWidth[k]);
---
> 					REAL(VECTOR_ELT(data, k))[j] = get_IBM_double(tmpchar,
> 							dataWidth[k]);
657,658c628
< 				   (c < tmpchar) ? R_BlankString :
< 				   mkChar(tmpchar));
---
> 							(c < tmpchar) ? R_BlankString : mkChar(tmpchar));
diff -rEZbwB '--exclude=*.[lo,d,pdf,mo,po,tgz,gz,save]*' '--exclude=MD5' '--exclude=Makefile*' '--exclude=all.R' '--exclude=Changes' R-recommended/foreign/src/avl.c Recommended/foreign/src/avl.c
28a29
> #include "localization.h"
42,43c43
< static void Free_fn(void *x, void *y)
< {
---
> static void Free_fn(void *x, void *y) {
52,53c52
< R_avl_create (MAYBE_POOL avl_comparison_func cmp, void *param)
< {
---
> R_avl_create(MAYBE_POOL avl_comparison_func cmp, void *param) {
56c55,56
<   if (!(cmp != NULL)) error("assert failed : cmp != NULL");
---
> 	if (!(cmp != NULL))
> 		error(_("assert failed : cmp != NULL"));
84,87c84,86
< void
< R_avl_destroy (avl_tree *tree, avl_node_func free_func)
< {
<   if (!(tree != NULL)) error("assert failed : tree != NULL");
---
> void R_avl_destroy(avl_tree *tree, avl_node_func free_func) {
> 	if (!(tree != NULL))
> 		error(_("assert failed : tree != NULL"));
102,103c101
<       for (;;)
< 	{
---
> 		for (;;) {
105,106c103
< 	  while (p != NULL)
< 	    {
---
> 			while (p != NULL) {
114,115c111
< 	  for (;;)
< 	    {
---
> 			for (;;) {
120,121c116
< 	      if (ab[ap] == 0)
< 		{
---
> 				if (ab[ap] == 0) {
145,147c140
< void
< R_avl_free (avl_tree *tree)
< {
---
> void R_avl_free(avl_tree *tree) {
152,155c145,147
< int
< R_avl_count (const avl_tree *tree)
< {
<   if (!(tree != NULL)) error("assert failed : tree != NULL");
---
> int R_avl_count(const avl_tree *tree) {
> 	if (!(tree != NULL))
> 		error(_("assert failed : tree != NULL"));
172,173c164
< new_node (void)
< {
---
> new_node(void) {
206c197
<   if (!(tree != NULL)) error("assert failed : tree != NULL");
---
> 	if (!(tree != NULL)) error(_("assert failed : tree != NULL"));
244c235
< 	      if (!(qp == qa)) error("assert failed : qp == qa");
---
> 				if (!(qp == qa)) error(_("assert failed : qp == qa"));
281c271
<   if (!(tree && walk_func)) error("assert failed : tree && walk_func");
---
> 	if (!(tree && walk_func)) error(_("assert failed : tree && walk_func"));
318c308
<   if (!(tree && trav)) error("assert failed : tree && trav");
---
> 	if (!(tree && trav)) error(_("assert failed : tree && trav"));
363,364c353
< avl_probe (avl_tree *tree, void *item)
< {
---
> avl_probe(avl_tree *tree, void *item) {
374c363,364
<   if (!(tree != NULL)) error("assert failed : tree != NULL");
---
> 	if (!(tree != NULL))
> 		error(_("assert failed : tree != NULL"));
378,379c368
<   if (s == NULL)
<     {
---
> 	if (s == NULL) {
381c370,371
<       if (!(tree->count == 1)) error("assert failed : tree->count == 1");
---
> 		if (!(tree->count == 1))
> 			error(_("assert failed : tree->count == 1"));
389,390c379
<   for (;;)
<     {
---
> 	for (;;) {
395,396c384
<       if (diff < 0)
< 	{
---
> 		if (diff < 0) {
399,400c387
< 	  if (q == NULL)
< 	    {
---
> 			if (q == NULL) {
406,407c393
<       else if (diff > 0)
< 	{
---
> 		else if (diff > 0) {
410,411c396
< 	  if (q == NULL)
< 	    {
---
> 			if (q == NULL) {
415,416c400
< 	}
<       else
---
> 		} else
434,435c418
<   while (p != q)
<     {
---
> 	while (p != q) {
441,442c424
<   if (s->cache == 0)
<     {
---
> 	if (s->cache == 0) {
444,445c426
<       if (s->bal == 0)
< 	{
---
> 		if (s->bal == 0) {
448,450c429
< 	}
<       else if (s->bal == +1)
< 	{
---
> 		} else if (s->bal == +1) {
455,457c434,436
<       if (!(s->bal == -1)) error("assert failed : s->bal == -1");
<       if (r->bal == -1)
< 	{
---
> 		if (!(s->bal == -1))
> 			error(_("assert failed : s->bal == -1"));
> 		if (r->bal == -1) {
463,465c442
< 	}
<       else
< 	{
---
> 		} else {
467c444,445
< 	  if (!(r->bal == +1)) error("assert failed : r->bal == +1");
---
> 			if (!(r->bal == +1))
> 				error(_("assert failed : r->bal == +1"));
477,479c455,457
< 	  else
< 	    {
< 	      if (!(p->bal == +1)) error("assert failed : p->bal == +1");
---
> 			else {
> 				if (!(p->bal == +1))
> 					error(_("assert failed : p->bal == +1"));
484,486c462
<     }
<   else
<     {
---
> 	} else {
488,489c464
<       if (s->bal == 0)
< 	{
---
> 		if (s->bal == 0) {
492,494c467
< 	}
<       else if (s->bal == -1)
< 	{
---
> 		} else if (s->bal == -1) {
499,501c472,474
<       if (!(s->bal == +1)) error("assert failed : s->bal == +1");
<       if (r->bal == +1)
< 	{
---
> 		if (!(s->bal == +1))
> 			error(_("assert failed : s->bal == +1"));
> 		if (r->bal == +1) {
507,509c480
< 	}
<       else
< 	{
---
> 		} else {
511c482,483
< 	  if (!(r->bal == -1)) error("assert failed : r->bal == -1");
---
> 			if (!(r->bal == -1))
> 				error(_("assert failed : r->bal == -1"));
521,523c493,495
< 	  else
< 	    {
< 	      if (!(p->bal == -1)) error("assert failed : p->bal == -1");
---
> 			else {
> 				if (!(p->bal == -1))
> 					error(_("assert failed : p->bal == -1"));
541,542c513
< R_avl_find (const avl_tree *tree, const void *item)
< {
---
> R_avl_find(const avl_tree *tree, const void *item) {
545,547c516,518
<   if (!(tree != NULL)) error("assert failed : tree != NULL");
<   for (p = tree->root.link[0]; p; )
<     {
---
> 	if (!(tree != NULL))
> 		error(_("assert failed : tree != NULL"));
> 	for (p = tree->root.link[0]; p;) {
583c554
<   if (!(tree != NULL)) error("assert failed : tree != NULL");
---
> 	if (!(tree != NULL)) error(_("assert failed : tree != NULL"));
672c643
<   if (!(k > 0)) error("assert failed : k > 0");
---
> 	if (!(k > 0)) error(_("assert failed : k > 0"));
692c663
< 	  if (!(s->bal == +1)) error("assert failed : s->bal == +1");
---
> 			if (!(s->bal == +1)) error(_("assert failed : s->bal == +1"));
695c666
< 	  if (!(r != NULL)) error("assert failed : r != NULL");
---
> 			if (!(r != NULL)) error(_("assert failed : r != NULL"));
716c687
< 	      if (!(r->bal == -1)) error("assert failed : r->bal == -1");
---
> 				if (!(r->bal == -1)) error(_("assert failed : r->bal == -1"));
728c699
< 		  if (!(p->bal == -1)) error("assert failed : p->bal == -1");
---
> 					if (!(p->bal == -1)) error(_("assert failed : p->bal == -1"));
737c708
< 	  if (!(a[k] == 1)) error("assert failed : a[k] == 1");
---
> 			if (!(a[k] == 1)) error(_("assert failed : a[k] == 1"));
751c722
< 	  if (!(s->bal == -1)) error("assert failed : s->bal == -1");
---
> 			if (!(s->bal == -1)) error(_("assert failed : s->bal == -1"));
785c756
< 		  if (!(p->bal == 1)) error("assert failed : p->bal == 1");
---
> 					if (!(p->bal == 1)) error(_("assert failed : p->bal == 1"));
801,802c772
< R_avl_insert (avl_tree *tree, void *item)
< {
---
> R_avl_insert(avl_tree *tree, void *item) {
805c775,776
<   if (!(tree != NULL)) error("assert failed : tree != NULL");
---
> 	if (!(tree != NULL))
> 		error(_("assert failed : tree != NULL"));
816,817c787
< R_avl_replace (avl_tree *tree, void *item)
< {
---
> R_avl_replace(avl_tree *tree, void *item) {
820c790,791
<   if (!(tree != NULL)) error("assert failed : tree != NULL");
---
> 	if (!(tree != NULL))
> 		error(_("assert failed : tree != NULL"));
825,826c796
<   else
<     {
---
> 	else {
diff -rEZbwB '--exclude=*.[lo,d,pdf,mo,po,tgz,gz,save]*' '--exclude=MD5' '--exclude=Makefile*' '--exclude=all.R' '--exclude=Changes' R-recommended/foreign/src/avl.h Recommended/foreign/src/avl.h
35,36c35
< typedef struct avl_node
<   {
---
> typedef struct avl_node {
42,43c41
<   }
< avl_node;
---
> } avl_node;
46,47c44
< typedef struct avl_traverser
<   {
---
> typedef struct avl_traverser {
52,53c49
<   }
< avl_traverser;
---
> } avl_traverser;
66,67c62
< typedef struct avl_tree
<   {
---
> typedef struct avl_tree {
75,76c70
<   }
< avl_tree;
---
> } avl_tree;
diff -rEZbwB '--exclude=*.[lo,d,pdf,mo,po,tgz,gz,save]*' '--exclude=MD5' '--exclude=Makefile*' '--exclude=all.R' '--exclude=Changes' R-recommended/foreign/src/dbfopen.c Recommended/foreign/src/dbfopen.c
196a197
> #include "localization.h"
276c277
< 	error("binary write error");
---
> 		error(_("binary write error"));
278c279,280
< 	!= psDBF->nFields) error("binary write error");
---
> 			!= psDBF->nFields)
> 		error(_("binary write error"));
283,284c285
<     if( psDBF->nHeaderLength > 32*psDBF->nFields + 32 )
<     {
---
> 	if (psDBF->nHeaderLength > 32 * psDBF->nFields + 32) {
289c290
< 	    error("binary write error");
---
> 			error(_("binary write error"));
304,305c305
<     if( psDBF->bCurrentRecordModified && psDBF->nCurrentRecord > -1 )
<     {
---
> 	if (psDBF->bCurrentRecordModified && psDBF->nCurrentRecord > -1) {
312,313c312,314
< 	if (fwrite( psDBF->pszCurrentRecord, psDBF->nRecordLength, 1, 
< 		    psDBF->fp ) != 1) error("binary write error");
---
> 		if (fwrite(psDBF->pszCurrentRecord, psDBF->nRecordLength, 1, psDBF->fp)
> 				!= 1)
> 			error(_("binary write error"));
334c335
< 	error("binary read error");
---
> 		error(_("binary read error"));
339c340,341
<     abyFileHeader[7] = (unsigned char) ((psDBF->nRecords/(256*256*256)) % 256);
---
> 	abyFileHeader[7] = (unsigned char) ((psDBF->nRecords / (256 * 256 * 256))
> 			% 256);
343c345
< 	error("binary write error");
---
> 		error(_("binary write error"));
380,381c382
<     if( psDBF->fp == NULL )
<     {
---
> 	if (psDBF->fp == NULL) {
394,395c395
<     if( fread( pabyBuf, 32, 1, psDBF->fp ) != 1 )
<     {
---
> 	if (fread(pabyBuf, 32, 1, psDBF->fp) != 1) {
402,403c402,403
<     psDBF->nRecords =
<      pabyBuf[4] + pabyBuf[5]*256 + pabyBuf[6]*256*256 + pabyBuf[7]*256*256*256;
---
> 	psDBF->nRecords = pabyBuf[4] + pabyBuf[5] * 256 + pabyBuf[6] * 256 * 256
> 			+ pabyBuf[7] * 256 * 256 * 256;
420,421c420
<     if( fread( pabyBuf, nHeadLen-32, 1, psDBF->fp ) != 1 )
<     {
---
> 	if (fread(pabyBuf, nHeadLen - 32, 1, psDBF->fp) != 1) {
433,434c432
<     for( iField = 0; iField < nFields; iField++ )
<     {
---
> 	for (iField = 0; iField < nFields; iField++) {
439,440c437
< 	if( pabyFInfo[11] == 'N' || pabyFInfo[11] == 'F' )
< 	{
---
> 		if (pabyFInfo[11] == 'N' || pabyFInfo[11] == 'F') {
443,445c440
< 	}
< 	else
< 	{
---
> 		} else {
454,455c449,450
< 	    psDBF->panFieldOffset[iField] =
< 	      psDBF->panFieldOffset[iField-1] + psDBF->panFieldSize[iField-1];
---
> 			psDBF->panFieldOffset[iField] = psDBF->panFieldOffset[iField - 1]
> 					+ psDBF->panFieldSize[iField - 1];
466,467c461
< DBFClose(DBFHandle psDBF)
< {
---
> DBFClose(DBFHandle psDBF) {
488,489c482
<     if( psDBF->panFieldOffset != NULL )
<     {
---
> 	if (psDBF->panFieldOffset != NULL) {
501,502c494
<     if( pszStringField != NULL )
<     {
---
> 	if (pszStringField != NULL) {
532,533c524,525
< 	       && pszBasename[i] != '\\';
< 	 i-- ) {}
---
> 					&& pszBasename[i] != '\\'; i--) {
> 	}
592,593c584,585
< DBFAddField(DBFHandle psDBF, const char * pszFieldName,
< 	    DBFFieldType eType, int nWidth, int nDecimals )
---
> DBFAddField(DBFHandle psDBF, const char * pszFieldName, DBFFieldType eType,
> 		int nWidth, int nDecimals)
620,621c612,613
<     psDBF->panFieldOffset = (int *)
<       SfRealloc( psDBF->panFieldOffset, sizeof(int) * psDBF->nFields );
---
> 	psDBF->panFieldOffset = (int *) SfRealloc(psDBF->panFieldOffset,
> 			sizeof(int) * psDBF->nFields);
623,624c615,616
<     psDBF->panFieldSize = (int *)
<       SfRealloc( psDBF->panFieldSize, sizeof(int) * psDBF->nFields );
---
> 	psDBF->panFieldSize = (int *) SfRealloc(psDBF->panFieldSize,
> 			sizeof(int) * psDBF->nFields);
626,627c618,619
<     psDBF->panFieldDecimals = (int *)
<       SfRealloc( psDBF->panFieldDecimals, sizeof(int) * psDBF->nFields );
---
> 	psDBF->panFieldDecimals = (int *) SfRealloc(psDBF->panFieldDecimals,
> 			sizeof(int) * psDBF->nFields);
629,630c621,622
<     psDBF->pachFieldType = (char *)
<       SfRealloc( psDBF->pachFieldType, sizeof(char) * psDBF->nFields );
---
> 	psDBF->pachFieldType = (char *) SfRealloc(psDBF->pachFieldType,
> 			sizeof(char) * psDBF->nFields);
655c647,648
<     psDBF->pszHeader = (char *) SfRealloc(psDBF->pszHeader,psDBF->nFields*32);
---
> 	psDBF->pszHeader = (char *) SfRealloc(psDBF->pszHeader,
> 			psDBF->nFields * 32);
669,670c662
<     if( eType == FTString )
<     {
---
> 	if (eType == FTString) {
673,675c665
<     }
<     else
<     {
---
> 	} else {
717,718c707
<     if( psDBF->nCurrentRecord != hEntity )
<     {
---
> 	if (psDBF->nCurrentRecord != hEntity) {
723,725c712,713
< 	if( fseek( psDBF->fp, nRecordOffset, 0 ) != 0 )
< 	{
< 	    REprintf("fseek(%d) failed on DBF file", nRecordOffset);
---
> 		if (fseek(psDBF->fp, nRecordOffset, 0) != 0) {
> 			REprintf(_("fseek(%d) failed on DBF file"), nRecordOffset);
729,732c717,719
< 	if( fread( psDBF->pszCurrentRecord, psDBF->nRecordLength,
< 		   1, psDBF->fp ) != 1 )
< 	{
< 	    REprintf("fread(%d) failed on DBF file", psDBF->nRecordLength );
---
> 		if (fread(psDBF->pszCurrentRecord, psDBF->nRecordLength, 1, psDBF->fp)
> 				!= 1) {
> 			REprintf(_("fread(%d) failed on DBF file"), psDBF->nRecordLength);
744,745c731
<     if( psDBF->panFieldSize[iField]+1 > nStringFieldLen )
<     {
---
> 	if (psDBF->panFieldSize[iField] + 1 > nStringFieldLen) {
763,764c749
<     if( chReqType == 'N' )
<     {
---
> 	if (chReqType == 'N') {
774,775c759
<     else
<     {
---
> 	else {
877c861,862
<     if(pszValue == NULL) return TRUE;
---
> 	if (pszValue == NULL)
> 		return TRUE;
879,880c864
<     switch(psDBF->pachFieldType[iField])
<     {
---
> 	switch (psDBF->pachFieldType[iField]) {
888c872,873
< 	if(pszValue[0] == '*') return TRUE;
---
> 		if (pszValue[0] == '*')
> 			return TRUE;
890c875,876
<              if(pszValue[i] != ' ') return FALSE;
---
> 			if (pszValue[i] != ' ')
> 				return FALSE;
940,941c926,927
< DBFGetFieldInfo( DBFHandle psDBF, int iField, char * pszFieldName,
< 		 int * pnWidth, int * pnDecimals )
---
> DBFGetFieldInfo(DBFHandle psDBF, int iField, char * pszFieldName, int * pnWidth,
> 		int * pnDecimals)
953,954c939
<     if( pszFieldName != NULL )
<     {
---
> 	if (pszFieldName != NULL) {
974,976c959
<     }
<     else
<     {
---
> 	} else {
1007,1008c990
<     if( hEntity == psDBF->nRecords )
<     {
---
> 	if (hEntity == psDBF->nRecords) {
1022,1023c1004
<     if( psDBF->nCurrentRecord != hEntity )
<     {
---
> 	if (psDBF->nCurrentRecord != hEntity) {
1029,1030c1010,1012
< 	if (fread( psDBF->pszCurrentRecord, psDBF->nRecordLength, 1, 
< 		   psDBF->fp ) != 1) error("binary read error");
---
> 		if (fread(psDBF->pszCurrentRecord, psDBF->nRecordLength, 1, psDBF->fp)
> 				!= 1)
> 			error(_("binary read error"));
1045,1048c1027,1028
<     if( pValue == NULL )
<     {
< 	switch(psDBF->pachFieldType[iField])
< 	{
---
> 	if (pValue == NULL) {
> 		switch (psDBF->pachFieldType[iField]) {
1080,1081c1060
<     switch( psDBF->pachFieldType[iField] )
<     {
---
> 	switch (psDBF->pachFieldType[iField]) {
1085,1086c1064
< 	if( psDBF->panFieldDecimals[iField] == 0 )
< 	{
---
> 		if (psDBF->panFieldDecimals[iField] == 0) {
1094,1095c1072
< 	    if( (int)strlen(szSField) > psDBF->panFieldSize[iField] )
< 	    {
---
> 			if ((int) strlen(szSField) > psDBF->panFieldSize[iField]) {
1102,1104c1079
< 	}
< 	else
< 	{
---
> 		} else {
1110,1111c1085,1086
< 	    sprintf( szFormat, "%%%d.%df",
< 		     nWidth, psDBF->panFieldDecimals[iField] );
---
> 			sprintf(szFormat, "%%%d.%df", nWidth,
> 					psDBF->panFieldDecimals[iField]);
1113,1114c1088
< 	    if( (int) strlen(szSField) > psDBF->panFieldSize[iField] )
< 	    {
---
> 			if ((int) strlen(szSField) > psDBF->panFieldSize[iField]) {
1124,1125c1098,1099
< 	if (psDBF->panFieldSize[iField] >= 1  &&
< 	    (*(char*)pValue == 'F' || *(char*)pValue == 'T'))
---
> 		if (psDBF->panFieldSize[iField] >= 1
> 				&& (*(char*) pValue == 'F' || *(char*) pValue == 'T'))
1130,1131c1104
< 	if( (int) strlen((char *) pValue) > psDBF->panFieldSize[iField] )
< 	{
---
> 		if ((int) strlen((char *) pValue) > psDBF->panFieldSize[iField]) {
1134,1136c1107
< 	}
< 	else
< 	{
---
> 		} else {
1177,1178c1148
<     if( hEntity == psDBF->nRecords )
<     {
---
> 	if (hEntity == psDBF->nRecords) {
1192,1193c1162
<     if( psDBF->nCurrentRecord != hEntity )
<     {
---
> 	if (psDBF->nCurrentRecord != hEntity) {
1199,1200c1168,1170
< 	if (fread( psDBF->pszCurrentRecord, psDBF->nRecordLength, 
< 		   1, psDBF->fp ) != 1) error("binary read error");
---
> 		if (fread(psDBF->pszCurrentRecord, psDBF->nRecordLength, 1, psDBF->fp)
> 				!= 1)
> 			error(_("binary read error"));
1212,1213c1182
<     else
<     {
---
> 	else {
1219,1220c1188,1189
<     strncpy((char *) (pabyRec+psDBF->panFieldOffset[iField]),
< 	    (char *) pValue, j );
---
> 	strncpy((char *) (pabyRec + psDBF->panFieldOffset[iField]), (char *) pValue,
> 			j);
1235,1236c1204
< DBFWriteDoubleAttribute( DBFHandle psDBF, int iRecord, int iField,
< 			 double dValue )
---
> DBFWriteDoubleAttribute(DBFHandle psDBF, int iRecord, int iField, double dValue)
1249,1250c1217
< DBFWriteIntegerAttribute( DBFHandle psDBF, int iRecord, int iField,
< 			  int nValue )
---
> DBFWriteIntegerAttribute(DBFHandle psDBF, int iRecord, int iField, int nValue)
1324,1325c1291
<     if( hEntity == psDBF->nRecords )
<     {
---
> 	if (hEntity == psDBF->nRecords) {
1339,1340c1305
<     if( psDBF->nCurrentRecord != hEntity )
<     {
---
> 	if (psDBF->nCurrentRecord != hEntity) {
1346,1347c1311,1313
< 	if (fread( psDBF->pszCurrentRecord, psDBF->nRecordLength, 
< 		   1, psDBF->fp ) != 1) error("binary read error");
---
> 		if (fread(psDBF->pszCurrentRecord, psDBF->nRecordLength, 1, psDBF->fp)
> 				!= 1)
> 			error(_("binary read error"));
1384,1385c1350
<     if( psDBF->nCurrentRecord != hEntity )
<     {
---
> 	if (psDBF->nCurrentRecord != hEntity) {
1391,1392c1356,1358
< 	if (fread( psDBF->pszCurrentRecord, psDBF->nRecordLength, 
< 		   1, psDBF->fp ) != 1) error("binary read error");
---
> 		if (fread(psDBF->pszCurrentRecord, psDBF->nRecordLength, 1, psDBF->fp)
> 				!= 1)
> 			error(_("binary read error"));
1416,1417c1382
< DBFCloneEmpty(DBFHandle psDBF, const char * pszFilename )
< {
---
> DBFCloneEmpty(DBFHandle psDBF, const char * pszFilename) {
1421c1386,1387
<    if ( newDBF == NULL ) return ( NULL );
---
> 	if (newDBF == NULL)
> 		return ( NULL);
1431c1397,1398
<    memcpy ( newDBF->panFieldOffset, psDBF->panFieldOffset, sizeof(int) * psDBF->nFields );
---
> 	memcpy(newDBF->panFieldOffset, psDBF->panFieldOffset,
> 			sizeof(int) * psDBF->nFields);
1433c1400,1401
<    memcpy ( newDBF->panFieldSize, psDBF->panFieldSize, sizeof(int) * psDBF->nFields );
---
> 	memcpy(newDBF->panFieldSize, psDBF->panFieldSize,
> 			sizeof(int) * psDBF->nFields);
1435c1403,1404
<    memcpy ( newDBF->panFieldDecimals, psDBF->panFieldDecimals, sizeof(int) * psDBF->nFields );
---
> 	memcpy(newDBF->panFieldDecimals, psDBF->panFieldDecimals,
> 			sizeof(int) * psDBF->nFields);
1437c1406,1407
<    memcpy ( newDBF->pachFieldType, psDBF->pachFieldType, sizeof(int) * psDBF->nFields );
---
> 	memcpy(newDBF->pachFieldType, psDBF->pachFieldType,
> 			sizeof(int) * psDBF->nFields);
1476,1477c1446
< static void str_to_upper (char *string)
< {
---
> static void str_to_upper(char *string) {
1507,1508c1476
<     for( i = 0; i < DBFGetFieldCount(psDBF); i++ )
<     {
---
> 	for (i = 0; i < DBFGetFieldCount(psDBF); i++) {
diff -rEZbwB '--exclude=*.[lo,d,pdf,mo,po,tgz,gz,save]*' '--exclude=MD5' '--exclude=Makefile*' '--exclude=all.R' '--exclude=Changes' R-recommended/foreign/src/file-handle.c Recommended/foreign/src/file-handle.c
28a29
> #include "localization.h"
diff -rEZbwB '--exclude=*.[lo,d,pdf,mo,po,tgz,gz,save]*' '--exclude=MD5' '--exclude=Makefile*' '--exclude=all.R' '--exclude=Changes' R-recommended/foreign/src/file-handle.h Recommended/foreign/src/file-handle.h
34,35c34
< enum
<   {
---
> enum {
42,43c41
< enum
<   {
---
> enum {
54,55c52
< struct fh_ext_class
<   {
---
> struct fh_ext_class {
64,65c61
< struct file_locator
<   {
---
> struct file_locator {
72,73c68
< struct file_handle
<   {
---
> struct file_handle {
diff -rEZbwB '--exclude=*.[lo,d,pdf,mo,po,tgz,gz,save]*' '--exclude=MD5' '--exclude=Makefile*' '--exclude=all.R' '--exclude=Changes' R-recommended/foreign/src/foreign.h Recommended/foreign/src/foreign.h
30a31
> #include <R_ext/Minmax.h>
33,41d33
< #ifdef ENABLE_NLS
< #include <libintl.h>
< #define _(String) dgettext ("foreign", String)
< #define gettext_noop(String) (String)
< #else
< #define _(String) (String)
< #define gettext_noop(String) (String)
< #endif
< 
68,76d59
< 
< #ifdef max
< # undef max
< #endif
< #ifdef min
< # undef min
< #endif
< #define max(a,b) ((a) >= (b) ? (a) : (b))
< #define min(a,b) ((a) <= (b) ? (a) : (b))
diff -rEZbwB '--exclude=*.[lo,d,pdf,mo,po,tgz,gz,save]*' '--exclude=MD5' '--exclude=Makefile*' '--exclude=all.R' '--exclude=Changes' R-recommended/foreign/src/format.c Recommended/foreign/src/format.c
24a25
> #include "localization.h"
29,30c30
< struct fmt_desc formats[FMT_NUMBER_OF_FORMATS + 1] =
< {
---
> struct fmt_desc formats[FMT_NUMBER_OF_FORMATS + 1] = {
32,33c32
<   {"",         -1, -1,  -1, -1,   -1, 0000, -1, -1},
< };
---
> 		{ "", -1, -1, -1, -1, -1, 0000, -1, -1 }, };
35,44c34,39
< const int translate_fmt[40] =
<   {
<     -1, FMT_A, FMT_AHEX, FMT_COMMA, FMT_DOLLAR, FMT_F, FMT_IB,
<     FMT_PIBHEX, FMT_P, FMT_PIB, FMT_PK, FMT_RB, FMT_RBHEX, -1,
<     -1, FMT_Z, FMT_N, FMT_E, -1, -1, FMT_DATE, FMT_TIME,
<     FMT_DATETIME, FMT_ADATE, FMT_JDATE, FMT_DTIME, FMT_WKDAY,
<     FMT_MONTH, FMT_MOYR, FMT_QYR, FMT_WKYR, FMT_PCT, FMT_DOT,
<     FMT_CCA, FMT_CCB, FMT_CCC, FMT_CCD, FMT_CCE, FMT_EDATE,
<     FMT_SDATE,
<   };
---
> const int translate_fmt[40] = { -1, FMT_A, FMT_AHEX, FMT_COMMA, FMT_DOLLAR,
> 		FMT_F, FMT_IB, FMT_PIBHEX, FMT_P, FMT_PIB, FMT_PK, FMT_RB, FMT_RBHEX,
> 		-1, -1, FMT_Z, FMT_N, FMT_E, -1, -1, FMT_DATE, FMT_TIME, FMT_DATETIME,
> 		FMT_ADATE, FMT_JDATE, FMT_DTIME, FMT_WKDAY, FMT_MONTH, FMT_MOYR,
> 		FMT_QYR, FMT_WKYR, FMT_PCT, FMT_DOT, FMT_CCA, FMT_CCB, FMT_CCC, FMT_CCD,
> 		FMT_CCE, FMT_EDATE, FMT_SDATE, };
85,86c80
< fmt_to_string (const struct fmt_spec *f)
< {
---
> fmt_to_string(const struct fmt_spec *f) {
96,98c90
< int
< check_input_specifier (const struct fmt_spec *spec)
< {
---
> int check_input_specifier(const struct fmt_spec *spec) {
106,107c98
<   if (f->cat & FCAT_OUTPUT_ONLY)
<     {
---
> 	if (f->cat & FCAT_OUTPUT_ONLY) {
111,113c102,105
<   if (spec->w < f->Imin_w || spec->w > f->Imax_w)
<     {
<       error(_("input format %s specifies a bad width %d.  Format %s requires a width between %d and %d"),
---
> 	if (spec->w < f->Imin_w || spec->w > f->Imax_w) {
> 		error(
> 				_(
> 						"input format %s specifies a bad width %d. Format %s requires a width between %d and %d"),
117,119c109,112
<   if ((f->cat & FCAT_EVEN_WIDTH) && spec->w % 2)
<     {
<       error (_("input format %s specifies an odd width %d, but format %s requires an even width between %d and %d"),
---
> 	if ((f->cat & FCAT_EVEN_WIDTH) && spec->w % 2) {
> 		error(
> 				_(
> 						"input format %s specifies an odd width %d, but format %s requires an even width between %d and %d"),
123,125c116,119
<   if (f->n_args > 1 && (spec->d < 0 || spec->d > 16))
<     {
<       error (_("Input format %s specifies a bad number of implied decimal places %d.  Input format %s allows up to 16 implied decimal places"),
---
> 	if (f->n_args > 1 && (spec->d < 0 || spec->d > 16)) {
> 		error(
> 				_(
> 						"Input format %s specifies a bad number of implied decimal places %d. Input format %s allows up to 16 implied decimal places"),
132,134c126
< int
< check_output_specifier (const struct fmt_spec *spec)
< {
---
> int check_output_specifier(const struct fmt_spec *spec) {
142,144c134,137
<   if (spec->w < f->Omin_w || spec->w > f->Omax_w)
<     {
<       error (_("output format %s specifies a bad width %d.  Format %s requires a width between %d and %d"),
---
> 	if (spec->w < f->Omin_w || spec->w > f->Omax_w) {
> 		error(
> 				_(
> 						"output format %s specifies a bad width %d. Format %s requires a width between %d and %d"),
151,153c144,147
<       && spec->w < f->Omin_w + 1 + spec->d)
<     {
<       error (_("output format %s requires minimum width %d to allow %d decimal places.  Try %s%d.%d instead of %s"),
---
> 			&& spec->w < f->Omin_w + 1 + spec->d) {
> 		error(
> 				_(
> 						"output format %s requires minimum width %d to allow %d decimal places. Try %s%d.%d instead of %s"),
158,160c152,155
<   if ((f->cat & FCAT_EVEN_WIDTH) && spec->w % 2)
<     {
<       error (_("output format %s specifies an odd width %d, but output format %s requires an even width between %d and %d"),
---
> 	if ((f->cat & FCAT_EVEN_WIDTH) && spec->w % 2) {
> 		error(
> 				_(
> 						"output format %s specifies an odd width %d, but output format %s requires an even width between %d and %d"),
164,166c159,162
<   if (f->n_args > 1 && (spec->d < 0 || spec->d > 16))
<     {
<       error (_("Output format %s specifies a bad number of implied decimal places %d.  Output format %s allows a number of implied decimal places between 1 and 16"),
---
> 	if (f->n_args > 1 && (spec->d < 0 || spec->d > 16)) {
> 		error(
> 				_(
> 						"Output format %s specifies a bad number of implied decimal places %d. Output format %s allows a number of implied decimal places between 1 and 16"),
175,177c171
< int
< check_string_specifier (const struct fmt_spec *f, int min_len)
< {
---
> int check_string_specifier(const struct fmt_spec *f, int min_len) {
179,181c173,176
<       || (f->type == FMT_AHEX && min_len * 2 > f->w))
<     {
<       error (_("cannot display a string variable of width %d with format specifier %s"),
---
> 			|| (f->type == FMT_AHEX && min_len * 2 > f->w)) {
> 		error(
> 				_(
> 						"cannot display a string variable of width %d with format specifier %s"),
188,190c183
< void
< convert_fmt_ItoO (const struct fmt_spec *input, struct fmt_spec *output)
< {
---
> void convert_fmt_ItoO(const struct fmt_spec *input, struct fmt_spec *output) {
197,198c190
<   switch (input->type)
<     {
---
> 	switch (input->type) {
217,218c209
<     case FMT_PIBHEX:
<       {
---
> 	case FMT_PIBHEX: {
221c212
< 	    error("convert_fmt_ItoO : assert failed");
---
> 			error(_("convert_fmt_ItoO: assert failed"));
243c234
<       error("convert_fmt_ItoO : invalid input->type : %d", input->type);
---
> 		error(_("convert_fmt_ItoO: invalid input->type: %d"), input->type);
277c268
<       error("convert_fmt_ItoO : invalid input->type : %d", input->type);
---
> 		error(_("convert_fmt_ItoO: invalid input->type: %d"), input->type);
Only in Recommended/foreign/src: localization.h
diff -rEZbwB '--exclude=*.[lo,d,pdf,mo,po,tgz,gz,save]*' '--exclude=MD5' '--exclude=Makefile*' '--exclude=all.R' '--exclude=Changes' R-recommended/foreign/src/minitab.c Recommended/foreign/src/minitab.c
30a31
> #include "localization.h"
diff -rEZbwB '--exclude=*.[lo,d,pdf,mo,po,tgz,gz,save]*' '--exclude=MD5' '--exclude=Makefile*' '--exclude=all.R' '--exclude=Changes' R-recommended/foreign/src/pfm-read.c Recommended/foreign/src/pfm-read.c
35a36
> #include "localization.h"
101c102
<   "reading as a portable file",
---
>   N_("reading as a portable file"),
132,134c133
< static int
< fill_buf (struct file_handle *h)
< {
---
> static int fill_buf(struct file_handle *h) {
153,154c152
<   if (ext->trans)
<     {
---
> 	if (ext->trans) {
165,166c163
<  lossage:
<   return 0;
---
> 	lossage: return 0;
170,172c167
< static int
< read_char (struct file_handle *h)
< {
---
> static int read_char(struct file_handle *h) {
186,188c181
< static inline int
< skip_char (struct file_handle *h, int c)
< {
---
> static inline int skip_char(struct file_handle *h, int c) {
191,192c184
<   if (ext->cc == c)
<     {
---
> 	if (ext->cc == c) {
196,197c188
<  lossage:
<   return 0;
---
> 	lossage: return 0;
214,215c205
< pfm_read_dictionary (struct file_handle *h, struct pfm_read_info *inf)
< {
---
> pfm_read_dictionary(struct file_handle *h, struct pfm_read_info *inf) {
220,221c210
<   if (h->class == &pfm_r_class)
<     {
---
> 	if (h->class == &pfm_r_class) {
224,226c213
<     }
<   else if (h->class != NULL)
<     {
---
> 	} else if (h->class != NULL) {
240,241c227
<   if (ext->file == NULL)
<     {
---
> 	if (ext->file == NULL) {
243c229,231
<       error(_("an error occurred while opening \"%s\" for reading as a portable file: %s"),
---
> 		error(
> 				_(
> 						"an error occurred while opening \"%s\" for reading as a portable file: %s"),
301,303c289
< static double
< read_float (struct file_handle *h)
< {
---
> static double read_float(struct file_handle *h) {
315,317c301,303
<   if (pfm_match (137 /* * */))
<     {
<       advance ();	/* Probably a dot (.) but doesn't appear to matter. */
---
> 	if (pfm_match(137 /* * */)) {
> 		advance ();
> 		/* Probably a dot (.) but doesn't appear to matter. */
319,320c305
<     }
<   else if (pfm_match (141 /* - */))
---
> 	} else if (pfm_match(141 /* - */))
323,326c308,309
<   for (;;)
<     {
<       if (ext->cc >= 64 /* 0 */ && ext->cc <= 93 /* T */)
< 	{
---
> 	for (;;) {
> 		if (ext->cc >= 64 /* 0 */&& ext->cc <= 93 /* T */) {
346,347c329
< 	}
<       else if (!got_dot && ext->cc == 127 /* . */)
---
> 		} else if (!got_dot && ext->cc == 127 /* . */)
360,361c342
<   if (ext->cc == 130 /* + */ || ext->cc == 141 /* - */)
<     {
---
> 	if (ext->cc == 130 /* + */|| ext->cc == 141 /* - */) {
366,367c347
<       for (;;)
< 	{
---
> 		for (;;) {
392,393c372
<   else if (exponent > 0)
<     {
---
> 	else if (exponent > 0) {
404,405c383
<  overflow:
<   if (neg)
---
> 	overflow: if (neg)
410,411c388
<  lossage:
<   return NA_REAL;
---
> 	lossage: return NA_REAL;
415,417c392
< int
< read_int (struct file_handle *h)
< {
---
> int read_int(struct file_handle *h) {
426,427c401
<  lossage:
<   return NA_INTEGER;
---
> 	lossage: return NA_INTEGER;
434,435c408
< read_string (struct file_handle *h)
< {
---
> read_string(struct file_handle *h) {
458,459c431
<     for (i = 0; i < n; i++)
<       {
---
> 		for (i = 0; i < n; i++) {
468,469c440
<  lossage:
<   return NULL;
---
> 	lossage: return NULL;
473,475c444
< static int
< read_header (struct file_handle *h)
< {
---
> static int read_header(struct file_handle *h) {
491,492c460
<     for (i = 0; i < 256; i++)
<       {
---
> 		for (i = 0; i < 256; i++) {
509c477,478
< 	ext->trans[i] = trans_temp[i] == -1 ? 0 : (unsigned char) trans_temp[i];
---
> 			ext->trans[i] =
> 					trans_temp[i] == -1 ? 0 : (unsigned char) trans_temp[i];
528,529c497
<  lossage:
<   return 0;
---
> 	lossage: return 0;
534,536c502
< int
< read_version_data (struct file_handle *h, struct pfm_read_info *inf)
< {
---
> int read_version_data(struct file_handle *h, struct pfm_read_info *inf) {
556,557c522
<     for (i = 0; i < 8; i++)
<       {
---
> 		for (i = 0; i < 8; i++) {
563,564c528
<     if (inf)
<       {
---
> 		if (inf) {
583,584c547
<     for (i = 0; i < 6; i++)
<       {
---
> 		for (i = 0; i < 6; i++) {
590,591c553
<     if (inf)
<       {
---
> 		if (inf) {
598,599c560
<   if (pfm_match (65 /* 1 */))
<     {
---
> 	if (pfm_match(65 /* 1 */)) {
607,608c568
<     }
<   else if (inf)
---
> 	} else if (inf)
612,613c572
<   if (pfm_match (67 /* 3 */))
<     {
---
> 	if (pfm_match(67 /* 3 */)) {
621,622c580
<     }
<   else if (inf)
---
> 	} else if (inf)
626,627c584
<  lossage:
<   return 0;
---
> 	lossage: return 0;
630,633c587,588
< static int
< convert_format (struct file_handle *h, int fmt[3], struct fmt_spec *v,
< 		struct variable *vv)
< {
---
> static int convert_format(struct file_handle *h, int fmt[3], struct fmt_spec *v,
> 		struct variable *vv) {
646,651c601,617
<   if ((vv->type == ALPHA) ^ ((formats[v->type].cat & FCAT_STRING) != 0))
<     lose ((_("%s variable %s has %s format specifier %s"),
< 	   vv->type == ALPHA ? "String" : "Numeric",
< 	   vv->name,
< 	   formats[v->type].cat & FCAT_STRING ? "string" : "numeric",
< 	   formats[v->type].name));
---
> 	if ((vv->type == ALPHA) ^ ((formats[v->type].cat & FCAT_STRING) != 0)) {
> 		if (vv->type == ALPHA) {
> 			if (formats[v->type].cat & FCAT_STRING)
> 				lose(
> 						(_("String variable %s has string format specifier %s"), vv->name, formats[v->type].name));
> 			else
> 				lose(
> 						(_("String variable %s has numeric format specifier %s"), vv->name, formats[v->type].name));
> 		} else {
> 			if (formats[v->type].cat & FCAT_STRING)
> 				lose(
> 						(_("Numeric variable %s has string format specifier %s"), vv->name, formats[v->type].name));
> 			else
> 				lose(
> 						(_("Numeric variable %s has numeric format specifier %s"), vv->name, formats[v->type].name));
> 		}
> 	}
654,655c620
<  lossage:
<   return 0;
---
> 	lossage: return 0;
665,666c630
<     "                                                                "
<   };
---
> 						"                                                                " };
669,671c633
< static void
< asciify (char *s)
< {
---
> static void asciify(char *s) {
679,681c641
< static int
< read_variables (struct file_handle *h)
< {
---
> static int read_variables(struct file_handle *h) {
707,708c667
<   if (pfm_match (70 /* 6 */))
<     {
---
> 	if (pfm_match(70 /* 6 */)) {
717,718c676
<   for (i = 0; i < ext->nvars; i++)
<     {
---
> 	for (i = 0; i < ext->nvars; i++) {
738,739c696
<       for (j = 0; j < 6; j++)
< 	{
---
> 		for (j = 0; j < 6; j++) {
750,751c707,708
< 	lose ((_("position %d: Variable name has %u characters"),
< 	       i, strlen ((char *) name)));
---
> 			lose(
> 					(_("position %d: Variable name has %u characters"), i, strlen ((char *) name)));
754,758c711,716
< 	lose ((_("position %d: Variable name begins with invalid character"),
< 	       i));
<       if (name[0] >= 100 /* a */ && name[0] <= 125 /* z */)
< 	{
< 	  warning(_("position %d: Variable name begins with lowercase letter %c"),
---
> 			lose(
> 					(_("position %d: Variable name begins with invalid character"), i));
> 		if (name[0] >= 100 /* a */&& name[0] <= 125 /* z */) {
> 			warning(
> 					_(
> 							"position %d: Variable name begins with lowercase letter %c"),
764,765c722
<       for (j = 1; j < (int) strlen ((char *) name); j++)
< 	{
---
> 		for (j = 1; j < (int) strlen((char *) name); j++) {
768,770c725,728
< 	  if (c >= 100 /* a */ && c <= 125 /* z */)
< 	    {
< 	      warning(_("position %d: Variable name character %d is lowercase letter %c"),
---
> 			if (c >= 100 /* a */&& c <= 125 /* z */) {
> 				warning(
> 						_(
> 								"position %d: Variable name character %d is lowercase letter %c"),
773,775c731,732
< 	    }
< 	  else if ((c >= 64 /* 0 */ && c <= 99 /* Z */)
< 		   || c == 127 /* . */ || c == 152 /* @ */
---
> 			} else if ((c >= 64 /* 0 */&& c <= 99 /* Z */) || c == 127 /* . */
> 					|| c == 152 /* @ */
779,780c736,737
< 	    lose ((_("position %d: character `\\%03o' is not valid in a variable name"),
< 		   i, c));
---
> 				lose(
> 						(_("position %d: character `\\%03o' is not valid in a variable name"), i, c));
787,788c744,745
<       v = create_variable (ext->dict, (char *) name,
< 			   width ? ALPHA : NUMERIC, width);
---
> 		v = create_variable(ext->dict, (char *) name, width ? ALPHA : NUMERIC,
> 				width);
798,799c755
<       if (pfm_match (75 /* B */))
< 	{
---
> 		if (pfm_match(75 /* B */)) {
804,806c760
< 	}
<       else if (pfm_match (74 /* A */))
< 	{
---
> 		} else if (pfm_match(74 /* A */)) {
810,812c764
< 	}
<       else if (pfm_match (73 /* 9 */))
< 	{
---
> 		} else if (pfm_match(73 /* 9 */)) {
819,826c771,774
<       while (pfm_match (72 /* 8 */))
< 	{
< 	  static const int map_next[MISSING_COUNT] =
< 	    {
< 	      MISSING_1, MISSING_2, MISSING_3, -1,
< 	      MISSING_RANGE_1, MISSING_LOW_1, MISSING_HIGH_1,
< 	      -1, -1, -1,
< 	    };
---
> 		while (pfm_match(72 /* 8 */)) {
> 			static const int map_next[MISSING_COUNT] = { MISSING_1, MISSING_2,
> 					MISSING_3, -1, MISSING_RANGE_1, MISSING_LOW_1,
> 					MISSING_HIGH_1, -1, -1, -1, };
828,831c776,777
< 	  static const int map_ofs[MISSING_COUNT] =
< 	    {
< 	      -1, 0, 1, 2, -1, -1, -1, 2, 1, 1,
< 	    };
---
> 			static const int map_ofs[MISSING_COUNT] = { -1, 0, 1, 2, -1, -1, -1,
> 					2, 1, 1, };
843,844c789
<       if (pfm_match (76 /* C */))
< 	{
---
> 		if (pfm_match(76 /* C */)) {
858,859c803,804
<     lose ((_("Weighting variable %s not present in dictionary"),
< 	   ext->dict->weight_var));
---
> 		lose(
> 				(_("Weighting variable %s not present in dictionary"), ext->dict->weight_var));
863,864c808
<  lossage:
<   return 0;
---
> 	lossage: return 0;
868,872c812,814
< static int
< parse_value (struct file_handle *h, union value *v, struct variable *vv)
< {
<   if (vv->type == ALPHA)
<     {
---
> static int parse_value(struct file_handle *h, union value *v,
> 		struct variable *vv) {
> 	if (vv->type == ALPHA) {
886,888c828
<     }
<   else
<     {
---
> 	} else {
898,900c838
< static int
< read_value_label (struct file_handle *h)
< {
---
> static int read_value_label(struct file_handle *h) {
917,918c855
<   for (i = 0; i < nv; i++)
<     {
---
> 	for (i = 0; i < nv; i++) {
929,930c866,867
< 	lose ((_("Cannot assign value labels to %s and %s, which have different variable types or widths"),
< 	       v[0]->name, v[i]->name));
---
> 			lose(
> 					(_("Cannot assign value labels to %s and %s, which have different variable types or widths"), v[0]->name, v[i]->name));
937,938c874
<   for (i = 0; i < n_labels; i++)
<     {
---
> 	for (i = 0; i < n_labels; i++) {
960,961c896
<       for (j = 0; j < nv; j++)
< 	{
---
> 		for (j = 0; j < nv; j++) {
975,976c910,911
< 	    lose ((_("Duplicate label for value %g for variable %s"),
< 		   vl->v.f, var->name));
---
> 				lose(
> 						(_("Duplicate label for value %g for variable %s"), vl->v.f, var->name));
978,979c913,914
< 	    lose ((_("Duplicate label for value `%.*s' for variable %s"),
< 		   var->width, vl->v.s, var->name));
---
> 				lose(
> 						(_("Duplicate label for value '%.*s' for variable %s"), var->width, vl->v.s, var->name));
987,988c922
<  lossage:
<   Free (v);
---
> 	lossage: Free(v);
995,997c929
< static void
< st_bare_pad_copy (char *dest, const char *src, size_t n)
< {
---
> static void st_bare_pad_copy(char *dest, const char *src, size_t n) {
1001,1002c933
<   else
<     {
---
> 	else {
1012,1014c943,944
< int
< pfm_read_case (struct file_handle *h, union value *perm, struct dictionary *dict)
< {
---
> int pfm_read_case(struct file_handle *h, union value *perm,
> 		struct dictionary *dict) {
1029,1030c959
<     if (ext->vars[i] == 0)
<       {
---
> 		if (ext->vars[i] == 0) {
1035,1037c964
<       }
<     else
<       {
---
> 		} else {
1049,1050c976
<   for (i = 0; i < dict->nvar; i++)
<     {
---
> 	for (i = 0; i < dict->nvar; i++) {
1068,1069c994
<  lossage:
<   Free (temp);
---
> 	lossage: Free(temp);
1074,1079c999,1000
< static struct fh_ext_class pfm_r_class =
< {
<   5,
<   "reading as a portable file",
<   pfm_close,
< };
---
> static struct fh_ext_class pfm_r_class = { 5, N_("reading as a portable file"),
> 		pfm_close, };
diff -rEZbwB '--exclude=*.[lo,d,pdf,mo,po,tgz,gz,save]*' '--exclude=MD5' '--exclude=Makefile*' '--exclude=all.R' '--exclude=Changes' R-recommended/foreign/src/pfm.h Recommended/foreign/src/pfm.h
30,33c30,31
< enum
<   {
<     PFM_COMM,
<     PFM_TAPE
---
> enum {
> 	PFM_COMM, PFM_TAPE
38,39c36
< struct pfm_read_info
<   {
---
> struct pfm_read_info {
diff -rEZbwB '--exclude=*.[lo,d,pdf,mo,po,tgz,gz,save]*' '--exclude=MD5' '--exclude=Makefile*' '--exclude=all.R' '--exclude=Changes' R-recommended/foreign/src/sfm-read.c Recommended/foreign/src/sfm-read.c
33a34
> #include "localization.h"
69,71c70
< static double
< second_lowest_double_val()
< {
---
> static double second_lowest_double_val() {
99,100c98
< struct sfm_fhuser_ext
<   {
---
> struct sfm_fhuser_ext {
136c134
<   "reading as a system file",
---
> 	N_("reading as a system file"),
156,158c154
< static void
< sfm_close (struct file_handle * h)
< {
---
> static void sfm_close(struct file_handle * h) {
162c158,159
<   if (!(ext->opened == 0)) error("assert failed : ext->opened == 0");
---
> 	if (!(ext->opened == 0))
> 		error(_("assert failed : ext->opened == 0"));
169,171c166
< void
< sfm_maybe_close (struct file_handle *h)
< {
---
> void sfm_maybe_close(struct file_handle *h) {
188,190c183,188
< static int read_value_labels (struct file_handle * h, struct variable ** var_by_index);
< static int read_variables (struct file_handle * h, struct variable *** var_by_index);
< static int read_machine_int32_info (struct file_handle * h, int size, int count, int *encoding);
---
> static int read_value_labels(struct file_handle * h,
> 		struct variable ** var_by_index);
> static int read_variables(struct file_handle * h,
> 		struct variable *** var_by_index);
> static int read_machine_int32_info(struct file_handle * h, int size, int count,
> 		int *encoding);
192,193c190,191
< static int read_long_var_names (struct file_handle * h, struct dictionary *
< 		, unsigned long size, unsigned int count);
---
> static int read_long_var_names(struct file_handle * h, struct dictionary *,
> 		unsigned long size, unsigned int count);
218,223c216,219
< void
< free_value_label (struct value_label * v)
< {
<   if (!(v->ref_count >= 1)) error("assert failed : v->ref_count >= 1");
<   if (--v->ref_count == 0)
<     {
---
> void free_value_label(struct value_label * v) {
> 	if (!(v->ref_count >= 1))
> 		error(_("assert failed : v->ref_count >= 1"));
> 	if (--v->ref_count == 0) {
231,233c227
< void
< free_val_lab (void *p, void *param)
< {
---
> void free_val_lab(void *p, void *param) {
238,240c232
< void
< free_dictionary (struct dictionary * d)
< {
---
> void free_dictionary(struct dictionary * d) {
250,251c242
<   for (i = 0; i < d->nvar; i++)
<     {
---
> 	for (i = 0; i < d->nvar; i++) {
254,255c245
<       if (v->val_lab)
< 	{
---
> 		if (v->val_lab) {
259,260c249
<       if (v->label)
< 	{
---
> 		if (v->label) {
278,279c267
< sfm_read_dictionary (struct file_handle * h, struct sfm_read_info * inf)
< {
---
> sfm_read_dictionary(struct file_handle * h, struct sfm_read_info * inf) {
288,289c276
<   if (h->class == &sfm_r_class)
<     {
---
> 	if (h->class == &sfm_r_class) {
293,295c280
<     }
<   else if (h->class != NULL)
<     {
---
> 	} else if (h->class != NULL) {
308,309c293
<   if (ext->file == NULL)
<     {
---
> 	if (ext->file == NULL) {
311c295,297
<       error(_("An error occurred while opening '%s' for reading as a system file: %s"),
---
> 		error(
> 				_(
> 						"An error occurred while opening '%s' for reading as a system file: %s"),
337,338c323
<   if (ext->weight_index != -1)
<     {
---
> 	if (ext->weight_index != -1) {
342c327,328
< 	lose ((_("%s: Weighting variable may not be a continuation of a long string variable"), h->fn));
---
> 			lose(
> 					(_("%s: Weighting variable may not be a continuation of a long string variable"), h->fn));
344,345c330,331
< 	lose ((_("%s: Weighting variable may not be a string variable"),
< 	       h->fn));
---
> 			lose(
> 					(_("%s: Weighting variable may not be a string variable"), h->fn));
348,349c334
<     }
<   else
---
> 	} else
353,354c338
<   for (;;)
<     {
---
> 	for (;;) {
361,362c345
<       switch (rec_type)
< 	{
---
> 		switch (rec_type) {
369,370c352,353
< 	  lose ((_("%s: Orphaned variable index record (type 4).  Type 4 records must always immediately follow type 3 records"),
< 		 h->fn));
---
> 			lose(
> 					(_("%s: Orphaned variable index record (type 4). Type 4 records must always immediately follow type 3 records"), h->fn));
377,380c360,361
< 	case 7:
< 	  {
< 	    struct
< 	      {
---
> 		case 7: {
> 			struct {
384,385c365
< 	      }
< 	    data;
---
> 			} data;
390,391c370
< 	    if (ext->reverse_endian)
< 	      {
---
> 			if (ext->reverse_endian) {
404,405c383
< 	    switch (data.subtype)
< 	      {
---
> 			switch (data.subtype) {
442c420,423
< 		warning(_("%s: Unrecognized record type 7, subtype %d encountered in system file"), h->fn, data.subtype);
---
> 				warning(
> 						_(
> 								"%s: Unrecognized record type 7, subtype %d encountered in system file"),
> 						h->fn, data.subtype);
446,447c427
< 	    if (skip)
< 	      {
---
> 			if (skip) {
456,457c436
< 	case 999:
< 	  {
---
> 		case 999: {
473c452
<   warning ("Read system-file dictionary successfully");
---
> 	warning(_("Read system-file dictionary successfully"));
494,496c473,474
< static int
< read_machine_int32_info (struct file_handle * h, int size, int count, int *encoding)
< {
---
> static int read_machine_int32_info(struct file_handle * h, int size, int count,
> 		int *encoding) {
505,506c483,484
<     lose ((_("%s: Bad size (%d) or count (%d) field on record type 7, subtype 3.	Expected size %d, count 8"),
< 	h->fn, size, count, sizeof (R_int32)));
---
> 		lose(
> 				(_("%s: Bad size (%d) or count (%d) field on record type 7, subtype 3. Expected size %d, count 8"), h->fn, size, count, sizeof (R_int32)));
514,515c492
<   switch (FPREP)
<     {
---
> 	switch (FPREP) {
518c495,496
< 	lose ((_("%s: Floating-point representation in system file is not IEEE-754.  read.spss cannot convert between floating-point formats"), h->fn));
---
> 			lose(
> 					(_("%s: Floating-point representation in system file is not IEEE-754. read.spss cannot convert between floating-point formats"), h->fn));
521c499,500
<       if (!(0)) error("assert failed : 0");
---
> 		if (!(0))
> 			error(_("assert failed : 0"));
527,528c506
<   if (ext->reverse_endian)
<     {
---
> 	if (ext->reverse_endian) {
533,534c511,512
<       else
< 	if (!(0)) error("assert failed : 0");
---
> 		else if (!(0))
> 			error(_("assert failed : 0"));
537,540c515,516
<     lose ((_("%s: File-indicated endianness (%s) does not match endianness intuited from file header (%s)"),
< 	   h->fn, file_endian == BIG ? "big-endian" : "little-endian",
< 	   data[6] == 1 ? "big-endian" : (data[6] == 2 ? "little-endian"
< 					  : "unknown")));
---
> 		lose(
> 				(_("%s: File-indicated endianness (%s) does not match endianness intuited from file header (%s)"), h->fn, file_endian == BIG ? "big-endian" : "little-endian", data[6] == 1 ? "big-endian" : (data[6] == 2 ? "little-endian" : "unknown")));
549,550c525,526
<     lose ((_("%s: File-indicated character representation code (%s) is not ASCII"), h->fn,
<        data[7] == 1 ? "EBCDIC" : (data[7] == 4 ? "DEC Kanji" : "Unknown")));
---
> 		lose(
> 				(_("%s: File-indicated character representation code (%s) is not ASCII"), h->fn, data[7] == 1 ? "EBCDIC" : (data[7] == 4 ? "DEC Kanji" : "Unknown")));
554c530,533
<       warning(_("%s: File-indicated character representation code (%d) is unknown"), h->fn, data[7]);
---
> 		warning(
> 				_(
> 						"%s: File-indicated character representation code (%d) is unknown"),
> 				h->fn, data[7]);
557,558c536
< lossage:
<   return 0;
---
> 	lossage: return 0;
562,564c540
< static int
< read_machine_flt64_info (struct file_handle * h, int size, int count)
< {
---
> static int read_machine_flt64_info(struct file_handle * h, int size, int count) {
572,573c548,549
<     lose ((_("%s: Bad size (%d) or count (%d) field on record type 7, subtype 4.	Expected size %d, count 8"),
< 	   h->fn, size, count, sizeof (R_flt64)));
---
> 		lose(
> 				(_("%s: Bad size (%d) or count (%d) field on record type 7, subtype 4. Expected size %d, count 8"), h->fn, size, count, sizeof (R_flt64)));
581,582c557
<       || data[2] != second_lowest_double_val())
<     {
---
> 			|| data[2] != second_lowest_double_val()) {
586,589c561,566
<       warning(_("%s: File-indicated value is different from internal value for at least one of the three system values.  SYSMIS: indicated %g, expected %g; HIGHEST: %g, %g; LOWEST: %g, %g"),
< 	  h->fn, (double) data[0], (double) SYSMIS,
< 	  (double) data[1], (double) DBL_MAX,
< 	  (double) data[2], (double) second_lowest_double_val());
---
> 		warning(
> 				_(
> 						"%s: File-indicated value is different from internal value for at least one of the three system values. SYSMIS: indicated %g, expected %g; HIGHEST: %g, %g; LOWEST: %g, %g"),
> 				h->fn, (double) data[0], (double) SYSMIS, (double) data[1],
> 				(double) DBL_MAX, (double) data[2],
> 				(double) second_lowest_double_val());
594,595c571
< lossage:
<   return 0;
---
> 	lossage: return 0;
601,604c577,578
< static int
< read_long_var_names (struct file_handle * h, struct dictionary * dict
< 		, unsigned long size, unsigned int count)
< {
---
> static int read_long_var_names(struct file_handle * h, struct dictionary * dict,
> 		unsigned long size, unsigned int count) {
612,614c586,589
<     warning("%s: strange record info seen, size=%u, count=%u"
<       ", ignoring long variable names"
<       , h->fn, size, count);
---
> 		warning(
> 				_(
> 						"%s: strange record info seen, size=%u, count=%u, ignoring long variable names"),
> 				h->fn, size, count);
627c602
<       warning("%s: no long variable name for variable '%s'", h->fn, p);
---
> 			warning(_("%s: no long variable name for variable '%s'"), h->fn, p);
639,641c614,617
<         warning("%s: long variable name mapping '%s' to '%s'"
<         "for variable which does not exist"
<         , h->fn, p, val);
---
> 				warning(
> 						_(
> 								"%s: long variable name mapping '%s' to '%s' for variable which does not exist"),
> 						h->fn, p, val);
651,653c627
< static int
< read_header (struct file_handle * h, struct sfm_read_info * inf)
< {
---
> static int read_header(struct file_handle * h, struct sfm_read_info * inf) {
694,695c668,669
<     lose ((_("%s: Bad magic.  Proper system files begin with the four characters `$FL2'. This file will not be read"),
< 	   h->fn));
---
> 		lose(
> 				(_("%s: Bad magic. Proper system files begin with the four characters `$FL2'. This file will not be read"), h->fn));
703,704c677
<     if (!isgraph ((unsigned char) prod_name[i]))
<       {
---
> 		if (!isgraph((unsigned char ) prod_name[i])) {
712,716c685,686
<     static const char *prefix[N_PREFIXES] =
<       {
< 	"@(#) SPSS DATA FILE",
< 	"SPSS SYSTEM FILE.",
<       };
---
> 		static const char *prefix[N_PREFIXES] = { "@(#) SPSS DATA FILE",
> 				"SPSS SYSTEM FILE.", };
721,722c691
<       if (!strncmp (prefix[i], hdr.prod_name, strlen (prefix[i])))
< 	{
---
> 			if (!strncmp(prefix[i], hdr.prod_name, strlen(prefix[i]))) {
732,733c701
<   else
<     {
---
> 	else {
736,737c704,705
< 	lose ((_("%s: File layout code has unexpected value %d.  Value should be 2 or 3, in big-endian or little-endian format"),
< 	       h->fn, hdr.layout_code));
---
> 			lose(
> 					(_("%s: File layout code has unexpected value %d. Value should be 2 or 3, in big-endian or little-endian format"), h->fn, hdr.layout_code));
749,752c717,720
<   if (hdr.case_size <= 0 || ext->case_size > (INT_MAX
< 					      / (int) sizeof (union value) / 2))
<     lose ((_("%s: Number of elements per case (%d) is not between 1 and %d"),
< 	   h->fn, hdr.case_size, INT_MAX / sizeof (union value) / 2));
---
> 	if (hdr.case_size <= 0
> 			|| ext->case_size > (INT_MAX / (int) sizeof(union value) / 2))
> 		lose(
> 				(_("%s: Number of elements per case (%d) is not between 1 and %d"), h->fn, hdr.case_size, INT_MAX / sizeof (union value) / 2));
758,759c726,727
<     lose ((_("%s: Index of weighting variable (%d) is not between 0 and number of elements per case (%d)"),
< 	   h->fn, hdr.weight_index, ext->case_size));
---
> 		lose(
> 				(_("%s: Index of weighting variable (%d) is not between 0 and number of elements per case (%d)"), h->fn, hdr.weight_index, ext->case_size));
763,764c731,732
<     lose ((_("%s: Number of cases in file (%d) is not between -1 and %d"),
< 	   h->fn, ext->ncases, INT_MAX / 2));
---
> 		lose(
> 				(_("%s: Number of cases in file (%d) is not between -1 and %d"), h->fn, ext->ncases, INT_MAX / 2));
779,780c747
< 	  && hdr.file_label[i] != 0)
< 	{
---
> 					&& hdr.file_label[i] != 0) {
788,789c755
<   if (inf)
<     {
---
> 	if (inf) {
815,816c781
< lossage:
<   return 0;
---
> 	lossage: return 0;
819,821c784
< int
< cmp_variable (const void *a, const void *b, void *foo)
< {
---
> int cmp_variable(const void *a, const void *b, void *foo) {
834,836c797,798
< static int
< read_variables (struct file_handle * h, struct variable *** var_by_index)
< {
---
> static int read_variables(struct file_handle * h,
> 		struct variable *** var_by_index) {
852,853c814
<   for (i = 0; i < ext->case_size; i++)
<     {
---
> 	for (i = 0; i < ext->case_size; i++) {
859,860c820
<       if (ext->reverse_endian)
< 	{
---
> 		if (ext->reverse_endian) {
870,871c830,831
< 	lose ((_("%s: position %d: Bad record type (%d); the expected value was 2"),
< 	       h->fn, i, sv.rec_type));
---
> 			lose(
> 					(_("%s: position %d: Bad record type (%d); the expected value was 2"), h->fn, i, sv.rec_type));
876,877c836
<       if (long_string_count)
< 	{
---
> 		if (long_string_count) {
879,880c838,839
< 	    lose ((_("%s: position %d: String variable does not have proper number of continuation records"),
< 		   h->fn, i));
---
> 				lose(
> 						(_("%s: position %d: String variable does not have proper number of continuation records"), h->fn, i));
885,888c844,846
< 	}
<       else if (sv.type == -1)
< 	lose ((_("%s: position %d: Superfluous long string continuation record"),
< 	       h->fn, i));
---
> 		} else if (sv.type == -1)
> 			lose(
> 					(_("%s: position %d: Superfluous long string continuation record"), h->fn, i));
892,893c850,851
< 	lose ((_("%s: position %d: Bad variable type code %d"),
< 	       h->fn, i, sv.type));
---
> 			lose(
> 					(_("%s: position %d: Bad variable type code %d"), h->fn, i, sv.type));
895,896c853,854
< 	lose ((_("%s: position %d: Variable label indicator field is not 0 or 1"),
< 	       h->fn, i));
---
> 			lose(
> 					(_("%s: position %d: Variable label indicator field is not 0 or 1"), h->fn, i));
899c857,858
< 	lose ((_("%s: position %d: Missing value indicator field is not -3, -2, 0, 1, 2, or 3"), h->fn, i));
---
> 			lose(
> 					(_("%s: position %d: Missing value indicator field is not -3, -2, 0, 1, 2, or 3"), h->fn, i));
912,914c871,874
<       if (!isalpha ((unsigned char) sv.name[0])
< 	  && sv.name[0] != '@' && sv.name[0] != '#')
< 	lose ((_("%s: position %d: Variable name begins with invalid character"), h->fn, i));
---
> 		if (!isalpha((unsigned char ) sv.name[0]) && sv.name[0] != '@'
> 				&& sv.name[0] != '#')
> 			lose(
> 					(_("%s: position %d: Variable name begins with invalid character"), h->fn, i));
916c876,878
< 	warning(_("%s: position %d: Variable name begins with lowercase letter %c"),
---
> 			warning(
> 					_(
> 							"%s: position %d: Variable name begins with lowercase letter %c"),
919c881,883
< 	warning(_("%s: position %d: Variable name begins with octothorpe ('#').  Scratch variables should not appear in system files"),
---
> 			warning(
> 					_(
> 							"%s: position %d: Variable name begins with octothorpe ('#'). Scratch variables should not appear in system files"),
924,925c888
<       for (j = 1; j < 8; j++)
< 	{
---
> 		for (j = 1; j < 8; j++) {
930,932c893,896
< 	  else if (islower (c))
< 	    {
< 	      warning(_("%s: position %d: Variable name character %d is lowercase letter %c"),
---
> 			else if (islower(c)) {
> 				warning(
> 						_(
> 								"%s: position %d: Variable name character %d is lowercase letter %c"),
935,937c899,900
< 	    }
< 	  else if (isalnum (c) || c == '.' || c == '@'
< 		   || c == '#' || c == '$' || c == '_' || c > 127)
---
> 			} else if (isalnum(c) || c == '.' || c == '@' || c == '#'
> 					|| c == '$' || c == '_' || c > 127)
940,941c903,904
< 	    lose ((_("%s: position %d: character `\\%03o' (%c) is not valid in a variable name"),
< 		   h->fn, j, c, c)); /* changed from 'i', PR#14465 */
---
> 				lose(
> 						(_("%s: position %d: character `\\%03o' (%c) is not valid in a variable name"), h->fn, j, c, c)); /* changed from 'i', PR#14465 */
947,948c910
<       if (sv.type == 0)
< 	{
---
> 		if (sv.type == 0) {
954,956c916
< 	}
<       else
< 	{
---
> 		} else {
968,969c928
<       if (sv.has_var_label == 1)
< 	{
---
> 		if (sv.has_var_label == 1) {
982,983c941,942
< 	    lose ((_("%s: Variable %s indicates variable label of invalid length %d"),
< 		   h->fn, vv->name, len));
---
> 				lose(
> 						(_("%s: Variable %s indicates variable label of invalid length %d"), h->fn, vv->name, len));
986c945,946
< 	  vv->label = bufread (h, NULL, ROUND_UP (len, sizeof (R_int32)), len + 1);
---
> 			vv->label = bufread(h, NULL, ROUND_UP(len, sizeof(R_int32)),
> 					len + 1);
993,994c953
<       if (sv.n_missing_values != 0)
< 	{
---
> 		if (sv.n_missing_values != 0) {
998c957,958
< 	    lose ((_("%s: Long string variable %s may not have missing values"), h->fn, vv->name));
---
> 				lose(
> 						(_("%s: Long string variable %s may not have missing values"), h->fn, vv->name));
1006,1007c966
< 	  if (sv.n_missing_values > 0)
< 	    {
---
> 			if (sv.n_missing_values > 0) {
1015,1017c974
< 	    }
< 	  else
< 	    {
---
> 			} else {
1021,1022c978,979
< 		lose ((_("%s: String variable %s may not have missing values specified as a range"),
< 		       h->fn, vv->name));
---
> 					lose(
> 							(_("%s: String variable %s may not have missing values specified as a range"), h->fn, vv->name));
1024,1025c981
< 	      if (mv[0] == ext->lowest)
< 		{
---
> 				if (mv[0] == ext->lowest) {
1028,1030c984
< 		}
< 	      else if (mv[1] == ext->highest)
< 		{
---
> 				} else if (mv[1] == ext->highest) {
1033,1035c987
< 		}
< 	      else
< 		{
---
> 				} else {
1041,1042c993
< 	      if (sv.n_missing_values == -3)
< 		{
---
> 				if (sv.n_missing_values == -3) {
1047,1048c998
< 	}
<       else
---
> 		} else
1058,1059c1008,1009
<     lose ((_("%s: Long string continuation records omitted at end of dictionary"),
< 	   h->fn));
---
> 		lose(
> 				(_("%s: Long string continuation records omitted at end of dictionary"), h->fn));
1061,1062c1011,1012
<     lose ((_("%s: System file header indicates %d variable positions but %d were read from file"),
< 	   h->fn, ext->case_size, next_value));
---
> 		lose(
> 				(_("%s: System file header indicates %d variable positions but %d were read from file"), h->fn, ext->case_size, next_value));
1070,1071c1020,1021
<       lose ((_("%s: Duplicate variable name `%s' within system file"),
< 	     h->fn, dict->var[i]->name));
---
> 			lose(
> 					(_("%s: Duplicate variable name `%s' within system file"), h->fn, dict->var[i]->name));
1075,1077c1025
< lossage:
<   for (i = 0; i < dict->nvar; i++)
<     {
---
> 	lossage: for (i = 0; i < dict->nvar; i++) {
1092,1094c1040,1041
< static int
< parse_format_spec (struct file_handle *h, R_int32 s, struct fmt_spec *v, struct variable *vv)
< {
---
> static int parse_format_spec(struct file_handle *h, R_int32 s,
> 		struct fmt_spec *v, struct variable *vv) {
1097,1098c1044,1045
<     lose ((_("%s: Bad format specifier byte (%d)"),
< 	   h->fn, (s >> 16) & 0xff));
---
> 		lose(
> 				(_("%s: Bad format specifier byte (%d)"), h->fn, (s >> 16) & 0xff));
1107,1114c1054,1072
<     lose ((_("%s: Bad format specifier byte (%d)"),
< 	   h->fn, (s >> 16) & 0xff));
<   if ((vv->type == ALPHA) ^ ((formats[v->type].cat & FCAT_STRING) != 0))
<     lose ((_("%s: %s variable %s has %s format specifier %s"),
< 	   h->fn, vv->type == ALPHA ? "String" : "Numeric",
< 	   vv->name,
< 	   formats[v->type].cat & FCAT_STRING ? "string" : "numeric",
< 	   formats[v->type].name));
---
> 		lose(
> 				(_("%s: Bad format specifier byte (%d)"), h->fn, (s >> 16) & 0xff));
> 	if ((vv->type == ALPHA) ^ ((formats[v->type].cat & FCAT_STRING) != 0)) {
> 		if (vv->type == ALPHA) {
> 			if (formats[v->type].cat & FCAT_STRING)
> 				lose(
> 						(_("%s: String variable %s has string format specifier %s"), h->fn, vv->name, formats[v->type].name));
> 			else
> 				lose(
> 						(_("%s: String variable %s has numeric format specifier %s"), h->fn, vv->name, formats[v->type].name));
> 		} else {
> 			if (formats[v->type].cat & FCAT_STRING)
> 				lose(
> 						(_("%s: Numeric variable %s has string format specifier %s"), h->fn, vv->name, formats[v->type].name));
> 			else
> 				lose(
> 						(_("%s: Numeric variable %s has numeric format specifier %s"), h->fn, vv->name, formats[v->type].name));
> 		}
> 	}
1117,1118c1075
< lossage:
<   return 0;
---
> 	lossage: return 0;
1123,1125c1080
< int
< read_value_labels (struct file_handle * h, struct variable ** var_by_index)
< {
---
> int read_value_labels(struct file_handle * h, struct variable ** var_by_index) {
1153,1154c1108
<   for (i = 0; i < n_labels; i++)
<     {
---
> 	for (i = 0; i < n_labels; i++) {
1189c1143,1144
<       lose ((_("%s: Variable index record (type 4) does not immediately follow value label record (type 3) as it ought"), h->fn));
---
> 			lose(
> 					(_("%s: Variable index record (type 4) does not immediately follow value label record (type 3) as it ought"), h->fn));
1198,1199c1153,1154
<     lose ((_("%s: Number of variables associated with a value label (%d) is not between 1 and the number of variables (%d)"),
< 	   h->fn, n_vars, ext->dict->nvar));
---
> 		lose(
> 				(_("%s: Number of variables associated with a value label (%d) is not between 1 and the number of variables (%d)"), h->fn, n_vars, ext->dict->nvar));
1205,1206c1160
<   for (i = 0; i < n_vars; i++)
<     {
---
> 	for (i = 0; i < n_vars; i++) {
1215,1216c1169,1170
< 	lose ((_("%s: Variable index associated with value label (%d) is not between 1 and the number of values (%d)"),
< 	       h->fn, var_index, ext->case_size));
---
> 			lose(
> 					(_("%s: Variable index associated with value label (%d) is not between 1 and the number of values (%d)"), h->fn, var_index, ext->case_size));
1221,1222c1175,1176
< 	lose ((_("%s: Variable index associated with value label (%d) refers to a continuation of a string variable, not to an actual variable"),
< 	       h->fn, var_index));
---
> 			lose(
> 					(_("%s: Variable index associated with value label (%d) refers to a continuation of a string variable, not to an actual variable"), h->fn, var_index));
1224c1178,1179
< 	lose ((_("%s: Value labels are not allowed on long string variables (%s)"), h->fn, v->name));
---
> 			lose(
> 					(_("%s: Value labels are not allowed on long string variables (%s)"), h->fn, v->name));
1232,1235c1187,1194
<     if (var[i]->type != var[0]->type)
<       lose ((_("%s: Variables associated with value label are not all of identical type.  Variable %s has %s type, but variable %s has %s type"), h->fn,
< 	     var[0]->name, var[0]->type == ALPHA ? "string" : "numeric",
< 	     var[i]->name, var[i]->type == ALPHA ? "string" : "numeric"));
---
> 		if (var[i]->type != var[0]->type) {
> 			if (var[0]->type == ALPHA)
> 				lose(
> 						(_("%s: Variables associated with value label are not all of identical type. Variable %s has string type, but variable %s has numeric type"), h->fn, var[0]->name, var[i]->name));
> 			else
> 				lose(
> 						(_("%s: Variables associated with value label are not all of identical type. Variable %s has numeric type, but variable %s has string type"), h->fn, var[0]->name, var[i]->name));
> 		}
1239,1242c1198,1199
<   for (i = 0; i < n_labels; i++)
<     {
<       if (var[0]->type == ALPHA)
< 	{
---
> 	for (i = 0; i < n_labels; i++) {
> 		if (var[0]->type == ALPHA) {
1257,1258c1214
<   for (i = 0; i < n_vars; i++)
<     {
---
> 	for (i = 0; i < n_vars; i++) {
1265c1221,1223
< 	v->val_lab = R_avl_create (val_lab_cmp, (void *) (void *) (void *) (void *) (void *) (void *) (void *) (void *) (void *) &width);
---
> 			v->val_lab =
> 					R_avl_create(val_lab_cmp,
> 							(void *) (void *) (void *) (void *) (void *) (void *) (void *) (void *) (void *) &width);
1268,1270c1226,1228
<       for (j = 0; j < n_labels; j++)
< 	{
< 	  struct value_label *old = R_avl_replace (v->val_lab, cooked_label[j]);
---
> 		for (j = 0; j < n_labels; j++) {
> 			struct value_label *old = R_avl_replace(v->val_lab,
> 					cooked_label[j]);
1275c1233,1235
< 	    warning(_("%s: File contains duplicate label for value %g for variable %s"),
---
> 				warning(
> 						_(
> 								"%s: File contains duplicate label for value %g for variable %s"),
1278,1280c1238,1241
< 	    warning(_("%s: File contains duplicate label for value `%.*s' for variable %s"),
< 		      h->fn, v->width,
< 		 cooked_label[j]->v.s, v->name);
---
> 				warning(
> 						_(
> 								"%s: File contains duplicate label for value `%.*s' for variable %s"),
> 						h->fn, v->width, cooked_label[j]->v.s, v->name);
1291,1292c1252
< lossage:
<   if (cooked_label)
---
> 	lossage: if (cooked_label)
1294,1295c1254
<       if (cooked_label[i])
< 	{
---
> 			if (cooked_label[i]) {
1309,1310c1268
< bufread (struct file_handle * h, void *buf, size_t nbytes, size_t minalloc)
< {
---
> bufread(struct file_handle * h, void *buf, size_t nbytes, size_t minalloc) {
1315,1316c1273
<   if ((nbytes != 0) && (1 != fread (buf, nbytes, 1, ext->file)))
<     {
---
> 	if ((nbytes != 0) && (1 != fread(buf, nbytes, 1, ext->file))) {
1329,1331c1286
< static int
< read_documents (struct file_handle * h)
< {
---
> static int read_documents(struct file_handle * h) {
1337,1338c1292,1293
<     lose ((_("%s: System file contains multiple type 6 (document) records"),
< 	   h->fn));
---
> 		lose(
> 				(_("%s: System file contains multiple type 6 (document) records"), h->fn));
1344c1299,1300
<   if (ext->reverse_endian) bswap_int32 (&n_lines);
---
> 	if (ext->reverse_endian)
> 		bswap_int32(&n_lines);
1347,1348c1303,1304
<     lose ((_("%s: Number of document lines (%d) must be greater than 0"),
< 	   h->fn, dict->n_documents));
---
> 		lose(
> 				(_("%s: Number of document lines (%d) must be greater than 0"), h->fn, dict->n_documents));
1355,1356c1311
< lossage:
<   return 0;
---
> 	lossage: return 0;
1427c1382
<           if (!(0)) warning("assert failed : 0");
---
> 			if (!(0)) warning(_("assert failed : 0"));
1447,1449c1402
< static size_t
< buffer_input (struct file_handle * h)
< {
---
> static size_t buffer_input(struct file_handle * h) {
1456,1457c1409
<   if (ferror (ext->file))
<     {
---
> 	if (ferror(ext->file)) {
1474,1476c1426
< static int
< read_compressed_data (struct file_handle * h, R_flt64 * temp)
< {
---
> static int read_compressed_data(struct file_handle * h, R_flt64 * temp) {
1485,1486c1435
<   for (;;)
<     {
---
> 	for (;;) {
1488,1489c1437
< 	switch (*p)
< 	  {
---
> 			switch (*p) {
1496c1444,1445
< 	      lose ((_("%s: Compressed data is corrupted.  Data ends partway through a case"), h->fn));
---
> 					lose(
> 							(_("%s: Compressed data is corrupted.  Data ends partway through a case"), h->fn));
1502,1503c1451
< 	      if (!buffer_input (h))
< 		{
---
> 					if (!buffer_input(h)) {
1542,1543c1490
< 	if (!buffer_input (h))
< 	  {
---
> 			if (!buffer_input(h)) {
1569,1571c1516,1517
< int
< sfm_read_case (struct file_handle * h, union value * perm, struct dictionary * dict)
< {
---
> int sfm_read_case(struct file_handle * h, union value * perm,
> 		struct dictionary * dict) {
1581c1527,1528
<   if (!(dict->nval > 0)) error("assert failed : dict->nval > 0");
---
> 	if (!(dict->nval > 0))
> 		error(_("assert failed : dict->nval > 0"));
1589,1590c1536
<   if (ext->compressed == 0)
<     {
---
> 	if (ext->compressed == 0) {
1593,1594c1539
<       if (amt != nbytes)
< 	{
---
> 		if (amt != nbytes) {
1601,1602c1546
<     }
<   else if (!read_compressed_data (h, temp))
---
> 	} else if (!read_compressed_data(h, temp))
1607,1608c1551
<   for (i = 0; i < dict->nvar; i++)
<     {
---
> 	for (i = 0; i < dict->nvar; i++) {
1614,1615c1557
<       if (v->type == NUMERIC)
< 	{
---
> 		if (v->type == NUMERIC) {
1620,1621c1562
< 	}
<       else
---
> 		} else
1628,1629c1569
< lossage:
<   Free (temp);
---
> 	lossage: Free(temp);
1634,1639c1574,1575
< static struct fh_ext_class sfm_r_class =
< {
<   3,
<   "reading as a system file",
<   sfm_close,
< };
---
> static struct fh_ext_class sfm_r_class = { 3, N_("reading as a system file"),
> 		sfm_close, };
diff -rEZbwB '--exclude=*.[lo,d,pdf,mo,po,tgz,gz,save]*' '--exclude=MD5' '--exclude=Makefile*' '--exclude=all.R' '--exclude=Changes' R-recommended/foreign/src/sfm.h Recommended/foreign/src/sfm.h
35,36c35
< struct sfm_read_info
< {
---
> struct sfm_read_info {
56,57c55
< struct sfm_write_info
< {
---
> struct sfm_write_info {
diff -rEZbwB '--exclude=*.[lo,d,pdf,mo,po,tgz,gz,save]*' '--exclude=MD5' '--exclude=Makefile*' '--exclude=all.R' '--exclude=Changes' R-recommended/foreign/src/sfmP.h Recommended/foreign/src/sfmP.h
22,23c22
< struct sysfile_header
<   {
---
> struct sysfile_header {
39,40c38
< struct sysfile_variable
<   {
---
> struct sysfile_variable {
diff -rEZbwB '--exclude=*.[lo,d,pdf,mo,po,tgz,gz,save]*' '--exclude=MD5' '--exclude=Makefile*' '--exclude=all.R' '--exclude=Changes' R-recommended/foreign/src/shapefil.h Recommended/foreign/src/shapefil.h
197,198c197
< typedef struct
< {
---
> typedef struct {
257,258c255
< typedef struct
< {
---
> typedef struct {
305,307c302,303
<       SHPCreateObject( int nSHPType, int nShapeId,
< 		       int nParts, int * panPartStart, int * panPartType,
< 		       int nVertices, double * padfX, double * padfY,
---
> SHPCreateObject(int nSHPType, int nShapeId, int nParts, int * panPartStart,
> 		int * panPartType, int nVertices, double * padfX, double * padfY,
310,311c306,307
<       SHPCreateSimpleObject( int nSHPType, int nVertices,
< 			     double * padfX, double * padfY, double * padfZ );
---
> SHPCreateSimpleObject(int nSHPType, int nVertices, double * padfX,
> 		double * padfY, double * padfZ);
331,332c327
< typedef struct shape_tree_node
< {
---
> typedef struct shape_tree_node {
348,349c343
< typedef struct
< {
---
> typedef struct {
380,383c374,375
<       SHPTreeFindLikelyShapes( SHPTree * hTree,
< 			       double * padfBoundsMin,
< 			       double * padfBoundsMax,
< 			       int * );
---
> SHPTreeFindLikelyShapes(SHPTree * hTree, double * padfBoundsMin,
> 		double * padfBoundsMax, int *);
390,391c382
< typedef struct
< {
---
> typedef struct {
417,422c408
<   FTString,
<   FTInteger,
<   FTDouble,
<   FTLogical,
<   FTDate,
<   FTInvalid
---
> 	FTString, FTInteger, FTDouble, FTLogical, FTDate, FTInvalid
437,438c423,424
<       DBFAddField( DBFHandle hDBF, const char * pszFieldName,
< 		   DBFFieldType eType, int nWidth, int nDecimals );
---
> DBFAddField(DBFHandle hDBF, const char * pszFieldName, DBFFieldType eType,
> 		int nWidth, int nDecimals);
441,442c427,428
<       DBFGetFieldInfo( DBFHandle psDBF, int iField,
< 		       char * pszFieldName, int * pnWidth, int * pnDecimals );
---
> DBFGetFieldInfo(DBFHandle psDBF, int iField, char * pszFieldName, int * pnWidth,
> 		int * pnDecimals);
diff -rEZbwB '--exclude=*.[lo,d,pdf,mo,po,tgz,gz,save]*' '--exclude=MD5' '--exclude=Makefile*' '--exclude=all.R' '--exclude=Changes' R-recommended/foreign/src/spss.c Recommended/foreign/src/spss.c
29a30
> #include "localization.h"
81,82c82
< find_dict_variable (const struct dictionary *d, const char *name)
< {
---
> find_dict_variable(const struct dictionary *d, const char *name) {
88,91c88,89
< static inline void
< common_init_stuff (struct dictionary *dict, struct variable *v,
< 		   const char *name, int type, int width)
< {
---
> static inline void common_init_stuff(struct dictionary *dict,
> 		struct variable *v, const char *name, int type, int width) {
102,103c100
<   if (v->type == NUMERIC)
<     {
---
> 	if (v->type == NUMERIC) {
107,109c104
<     }
<   else
<     {
---
> 	} else {
119,122c114,115
< void
< init_variable (struct dictionary *dict, struct variable *v, const char *name,
< 	       int type, int width)
< {
---
> void init_variable(struct dictionary *dict, struct variable *v,
> 		const char *name, int type, int width) {
138,140c131
< create_variable (struct dictionary *dict, const char *name,
< 		 int type, int width)
< {
---
> create_variable(struct dictionary *dict, const char *name, int type, int width) {
160,162c151
< int
< val_lab_cmp (const void *a, const void *b, void *param)
< {
---
> int val_lab_cmp(const void *a, const void *b, void *param) {
166,169c155,156
< 		    (char *)((struct value_label *) b)->v.s,
< 		    width);
<   else
<     {
---
> 				(char *) ((struct value_label *) b)->v.s, width);
> 	else {
200,201c186
<       while (p != NULL)
< 	{
---
> 		while (p != NULL) {
220,222c205
< 
< static SEXP getSPSSvaluelabels(struct dictionary *dict)
< {
---
> static SEXP getSPSSvaluelabels(struct dictionary *dict) {
230c213,214
<     if (nvars == 0) return R_NilValue;
---
> 	if (nvars == 0)
> 		return R_NilValue;
235c219,220
< 	if (!labelset) continue;
---
> 		if (!labelset)
> 			continue;
265,266c250
< static SEXP getSPSSmissing(struct dictionary *dict, int *have_miss)
< {
---
> static SEXP getSPSSmissing(struct dictionary *dict, int *have_miss) {
271c255,256
<     if (nvars == 0) return R_NilValue;
---
> 	if (nvars == 0)
> 		return R_NilValue;
321c306,307
< 	if (strcmp(type, "none")) (*have_miss)++;
---
> 		if (strcmp(type, "none"))
> 			(*have_miss)++;
334c320,321
< 		for(j = 0; j < n; j++) rx[j] = v->missing[j].f;
---
> 				for (j = 0; j < n; j++)
> 					rx[j] = v->missing[j].f;
354,356c341
< static SEXP
< read_SPSS_PORT(const char *filename)
< {
---
> static SEXP read_SPSS_PORT(const char *filename) {
370c355,356
<     SEXP miss_labels; int have_miss = 0;
---
> 	SEXP miss_labels;
> 	int have_miss = 0;
396,397c382
< 	    case_vals[v->fv].c =
< 		(unsigned char *) R_alloc(v->width + 1, 1);
---
> 			case_vals[v->fv].c = (unsigned char *) R_alloc(v->width + 1, 1);
472,474c457
< static SEXP
< read_SPSS_SAVE(const char *filename)
< {
---
> static SEXP read_SPSS_SAVE(const char *filename) {
486c469,470
<     SEXP miss_labels; int have_miss = 0;
---
> 	SEXP miss_labels;
> 	int have_miss = 0;
518,519c502
< 	    case_vals[v->fv].c =
< 		(unsigned char *) R_alloc(v->width + 1, 1);
---
> 			case_vals[v->fv].c = (unsigned char *) R_alloc(v->width + 1, 1);
582,584c565
< static size_t
< fread_pfm(void *ptr, size_t size, size_t nobj, FILE *stream)
< {
---
> static size_t fread_pfm(void *ptr, size_t size, size_t nobj, FILE *stream) {
610,612c591
< static int
< is_PORT(FILE *fp)
< {
---
> static int is_PORT(FILE *fp) {
661,663c640
< SEXP
< do_read_SPSS(SEXP file)
< {
---
> SEXP do_read_SPSS(SEXP file) {
683,684c660
< 	    error(_("file '%s' is not in any supported SPSS format"),
< 		  filename);
---
> 			error(_("file '%s' is not in any supported SPSS format"), filename);
693,695c669
< void
< spss_init(void)
< {
---
> void spss_init(void) {
diff -rEZbwB '--exclude=*.[lo,d,pdf,mo,po,tgz,gz,save]*' '--exclude=MD5' '--exclude=Makefile*' '--exclude=all.R' '--exclude=Changes' R-recommended/foreign/src/stataread.c Recommended/foreign/src/stataread.c
46a47
> #include "localization.h"
91,92c91
< static int InIntegerBinary(FILE * fp, int naok, int swapends)
< {
---
> static int InIntegerBinary(FILE * fp, int naok, int swapends) {
101,102c100
< static int InByteBinary(FILE * fp, int naok)
< {
---
> static int InByteBinary(FILE * fp, int naok) {
109,110c107
< static int RawByteBinary(FILE * fp, int naok)
< {
---
> static int RawByteBinary(FILE * fp, int naok) {
117,118c114
< static int InShortIntBinary(FILE * fp, int naok,int swapends)
< {
---
> static int InShortIntBinary(FILE * fp, int naok, int swapends) {
129c125,126
<   if (result > STATA_SHORTINT_NA) result -= 65536;
---
> 	if (result > STATA_SHORTINT_NA)
> 		result -= 65536;
133,135c130
< 
< static double InDoubleBinary(FILE * fp, int naok, int swapends)
< {
---
> static double InDoubleBinary(FILE * fp, int naok, int swapends) {
144,145c139
< static double InFloatBinary(FILE * fp, int naok, int swapends)
< {
---
> static double InFloatBinary(FILE * fp, int naok, int swapends) {
154,155c148
< static void InStringBinary(FILE * fp, int nchar, char* buffer)
< {
---
> static void InStringBinary(FILE * fp, int nchar, char* buffer) {
180,185c173,175
< 
< 
< SEXP R_LoadStataData(FILE *fp)
< {
<     int i, j = 0, nvar, nobs, charlen, version, swapends, 
< 	varnamelength, nlabels, totlen, res;
---
> SEXP R_LoadStataData(FILE *fp) {
> 	int i, j = 0, nvar, nobs, charlen, version, swapends, varnamelength,
> 			nlabels, totlen, res;
338c326,327
<     for (i = 0; i < 2*(nvar+1); i++) RawByteBinary(fp, 1);
---
> 	for (i = 0; i < 2 * (nvar + 1); i++)
> 		RawByteBinary(fp, 1);
422c410,411
< 	    for (i = 0; i < charlen; i++) InByteBinary(fp, 1);
---
> 			for (i = 0; i < charlen; i++)
> 				InByteBinary(fp, 1);
433,434c422,424
< 	error(_("something strange in the file\n (Type 0 characteristic of nonzero length)"));
< 
---
> 		error(
> 				_(
> 						"something strange in the file\n (Type 0 characteristic of nonzero length)"));
446c436,437
< 		    REAL(VECTOR_ELT(df,j))[i] = InDoubleBinary(fp, 0, swapends);
---
> 					REAL(VECTOR_ELT(df, j))[i] = InDoubleBinary(fp, 0,
> 							swapends);
449c440,441
< 		    INTEGER(VECTOR_ELT(df,j))[i] = InIntegerBinary(fp, 0, swapends);
---
> 					INTEGER(VECTOR_ELT(df, j))[i] = InIntegerBinary(fp, 0,
> 							swapends);
452c444,445
< 		    INTEGER(VECTOR_ELT(df,j))[i] = InShortIntBinary(fp, 0, swapends);
---
> 					INTEGER(VECTOR_ELT(df, j))[i] = InShortIntBinary(fp, 0,
> 							swapends);
460c453,455
< 			warning("invalid character string length -- truncating to 244 bytes");
---
> 						warning(
> 								_(
> 										"invalid character string length -- truncating to 244 bytes"));
478c473,474
< 		    REAL(VECTOR_ELT(df,j))[i] = InDoubleBinary(fp, 0, swapends);
---
> 					REAL(VECTOR_ELT(df, j))[i] = InDoubleBinary(fp, 0,
> 							swapends);
481c477,478
< 		    INTEGER(VECTOR_ELT(df,j))[i] = InIntegerBinary(fp, 0, swapends);
---
> 					INTEGER(VECTOR_ELT(df, j))[i] = InIntegerBinary(fp, 0,
> 							swapends);
484c481,482
< 		    INTEGER(VECTOR_ELT(df,j))[i] = InShortIntBinary(fp, 0, swapends);
---
> 					INTEGER(VECTOR_ELT(df, j))[i] = InShortIntBinary(fp, 0,
> 							swapends);
492c490,492
< 			warning("invalid character string length -- truncating to 244 bytes");
---
> 						warning(
> 								_(
> 										"invalid character string length -- truncating to 244 bytes"));
513,514c512,515
< 	    if (feof(fp)) break;
< 	    if (res != 1) warning(_("a binary read error occurred"));
---
> 			if (feof(fp))
> 				break;
> 			if (res != 1)
> 				warning(_("a binary read error occurred"));
522c523,525
< 	    RawByteBinary(fp, 1); RawByteBinary(fp, 1); RawByteBinary(fp, 1); /*padding*/
---
> 			RawByteBinary(fp, 1);
> 			RawByteBinary(fp, 1);
> 			RawByteBinary(fp, 1); /*padding*/
562,563c565,568
< 	if(j > 0) setAttrib(df, install("label.table"), labeltable);
< 	UNPROTECT(1); /*labeltable*/;
---
> 		if (j > 0)
> 			setAttrib(df, install("label.table"), labeltable);
> 		UNPROTECT(1); /*labeltable*/
> 		;
572,573c577
< SEXP do_readStata(SEXP call)
< {
---
> SEXP do_readStata(SEXP call) {
596,597c598
< static void OutIntegerBinary(int i, FILE * fp, int naok)
< {
---
> static void OutIntegerBinary(int i, FILE * fp, int naok) {
604,605c605
< static void OutByteBinary(unsigned char i, FILE * fp)
< {
---
> static void OutByteBinary(unsigned char i, FILE * fp) {
609,610c609
< static void OutDataByteBinary(int i, FILE * fp)
< {
---
> static void OutDataByteBinary(int i, FILE * fp) {
616,617c615
< static void OutShortIntBinary(int i,FILE * fp)
< {
---
> static void OutShortIntBinary(int i, FILE * fp) {
633,635c631
< 
< static void  OutDoubleBinary(double d, FILE * fp, int naok)
< {
---
> static void OutDoubleBinary(double d, FILE * fp, int naok) {
641,644c637,639
< 
< static void OutStringBinary(const char *buffer, FILE * fp, int nchar)
< {
<     if (nchar == 0) return;
---
> static void OutStringBinary(const char *buffer, FILE * fp, int nchar) {
> 	if (nchar == 0)
> 		return;
649,650c644
< static char* nameMangleOut(char *stataname, int len)
< {
---
> static char* nameMangleOut(char *stataname, int len) {
652c646,647
<       if (stataname[i] == '.') stataname[i] = '_';
---
> 		if (stataname[i] == '.')
> 			stataname[i] = '_';
660,663c655,657
< static Rboolean 
< writeStataValueLabel(const char *labelName, const SEXP theselabels,
< 		     const SEXP theselevels, const int namelength, FILE *fp)
< {
---
> static Rboolean writeStataValueLabel(const char *labelName,
> 		const SEXP theselabels, const SEXP theselevels, const int namelength,
> 		FILE *fp) {
670,672c664,666
<     if (!isNull(theselevels) && 
< 	((TYPEOF(theselevels)!=INTSXP && TYPEOF(theselevels)!=REALSXP)  || 
< 	 LENGTH(theselabels) != LENGTH(theselevels)))
---
> 	if (!isNull(theselevels)
> 			&& ((TYPEOF(theselevels) != INTSXP && TYPEOF(theselevels) != REALSXP)
> 					|| LENGTH(theselabels) != LENGTH(theselevels)))
683,684c677,678
<     OutStringBinary(nameMangleOut(labelName2, (int)strlen(labelName)),
< 		    fp, namelength);
---
> 	OutStringBinary(nameMangleOut(labelName2, (int) strlen(labelName)), fp,
> 			namelength);
686c680,682
<     OutByteBinary(0, fp); OutByteBinary(0, fp); OutByteBinary(0, fp); /*padding*/
---
> 	OutByteBinary(0, fp);
> 	OutByteBinary(0, fp);
> 	OutByteBinary(0, fp); /*padding*/
699,700c695
<     }
<     else{
---
> 	} else {
704,705c699
< 	}
< 	else{
---
> 		} else {
716c710,711
< 	if (txtlen < 0) error(_("this should happen: overrun"));
---
> 		if (txtlen < 0)
> 			error(_("this should happen: overrun"));
718c713,714
<     if (txtlen > 0) error(_("this should happen: underrun"));
---
> 	if (txtlen > 0)
> 		error(_("this should happen: underrun"));
724,725c720
< void R_SaveStataData(FILE *fp, SEXP df, int version, SEXP leveltable)
< {
---
> void R_SaveStataData(FILE *fp, SEXP df, int version, SEXP leveltable) {
727,728c722,723
<     char datalabel[81] = "Written by R.              ",
< 	timestamp[18], aname[33];
---
> 	char datalabel[81] = "Written by R.              ", timestamp[18],
> 			aname[33];
731,732c726,727
<     SEXP names, types, theselabels, orig_names, vlabels, dlabel, 
< 	exp_fields, exp_field, curr_val_labels, label_table, names_lt,
---
> 	SEXP names, types, theselabels, orig_names, vlabels, dlabel, exp_fields,
> 			exp_field, curr_val_labels, label_table, names_lt,
738,739c733,736
<     if (version >= 7) namelength=32;
<     if (version >= 10) fmtlist_len = 49;
---
> 	if (version >= 7)
> 		namelength = 32;
> 	if (version >= 10)
> 		fmtlist_len = 49;
770c766,767
<     for(i = 0; i < 18; i++) timestamp[i] = 0;
---
> 	for (i = 0; i < 18; i++)
> 		timestamp[i] = 0;
800c795,796
< 		    if (k > charlen) charlen = k;
---
> 					if (k > charlen)
> 						charlen = k;
803c799,802
< 		    warning("character strings of >244 bytes in column %d will be truncated", i+1);
---
> 					warning(
> 							_(
> 									"character strings of >244 bytes in column %d will be truncated"),
> 							i + 1);
805c804,805
< 		OutByteBinary((unsigned char)(charlen+STATA_STRINGOFFSET), fp);
---
> 				OutByteBinary((unsigned char) (charlen + STATA_STRINGOFFSET),
> 						fp);
830c830,831
< 		    if (k > charlen) charlen = k;
---
> 					if (k > charlen)
> 						charlen = k;
833c834,837
< 		    warning("character strings of >244 bytes in column %d will be truncated", i+1);
---
> 					warning(
> 							_(
> 									"character strings of >244 bytes in column %d will be truncated"),
> 							i + 1);
835c839,840
< 		OutByteBinary((unsigned char)(charlen+STATA_SE_STRINGOFFSET), fp);
---
> 				OutByteBinary((unsigned char) (charlen + STATA_SE_STRINGOFFSET),
> 						fp);
856c859,860
<     for (i = 0; i < 2*(nvar+1); i++) OutByteBinary(0, fp);
---
> 	for (i = 0; i < 2 * (nvar + 1); i++)
> 		OutByteBinary(0, fp);
878c882,883
< 	    for(j = 0; j < namelength+1; j++) OutByteBinary(0, fp);
---
> 			for (j = 0; j < namelength + 1; j++)
> 				OutByteBinary(0, fp);
883c888,889
< 	    	strncpy(aname, CHAR(STRING_ELT(curr_val_labels, i)), namelength);
---
> 				strncpy(aname, CHAR(STRING_ELT(curr_val_labels, i)),
> 						namelength);
903,904c908
<     }
<     else{
---
> 	} else {
921c924,925
<     if(!isNull(exp_fields) && TYPEOF(exp_fields) == VECSXP && abs(version) >= 7){
---
> 	if (!isNull(exp_fields) && TYPEOF(exp_fields) == VECSXP
> 			&& abs(version) >= 7) {
925c929,930
< 	    if(!isNull(exp_field) && isString(exp_field) && LENGTH(exp_field) == 3) {
---
> 			if (!isNull(exp_field) && isString(exp_field)
> 					&& LENGTH(exp_field) == 3) {
927c932,935
< 		OutIntegerBinary(2*(namelength+1) + (length(STRING_ELT(exp_field,2))+1), fp, 1);
---
> 				OutIntegerBinary(
> 						2 * (namelength + 1)
> 								+ (length(STRING_ELT(exp_field, 2)) + 1), fp,
> 						1);
936c944,945
< 		OutStringBinary(CHAR(STRING_ELT(exp_field, 2)), fp, length(STRING_ELT(exp_field, 2)));
---
> 				OutStringBinary(CHAR(STRING_ELT(exp_field, 2)), fp,
> 						length(STRING_ELT(exp_field, 2)));
970,971c978,982
< 		    error("empty string is not valid in Stata's documented format");
< 		if(k > 244) k = 244;
---
> 					error(
> 							_(
> 									"empty string is not valid in Stata's documented format"));
> 				if (k > 244)
> 					k = 244;
973c984,985
< 		for(l = INTEGER(types)[j]-k; l > 0; l--) OutByteBinary(0, fp);
---
> 				for (l = INTEGER(types)[j] - k; l > 0; l--)
> 					OutByteBinary(0, fp);
989,990c1001,1004
< 	    if(!isNull(curr_val_labels) && isString(curr_val_labels) && LENGTH(curr_val_labels) > i)
< 	    	strncpy(aname, CHAR(STRING_ELT(curr_val_labels, i)), namelength);
---
> 			if (!isNull(curr_val_labels) && isString(curr_val_labels)
> 					&& LENGTH(curr_val_labels) > i)
> 				strncpy(aname, CHAR(STRING_ELT(curr_val_labels, i)),
> 						namelength);
994c1008,1009
< 	    writeStataValueLabel(aname, theselabels, R_NilValue, namelength, fp);
---
> 			writeStataValueLabel(aname, theselabels, R_NilValue, namelength,
> 					fp);
1006c1021,1023
< 					if(strncmp(thisnamechar, CHAR(STRING_ELT(curr_val_labels, j)), namelength) == 0)
---
> 						if (strncmp(thisnamechar,
> 								CHAR(STRING_ELT(curr_val_labels, j)),
> 								namelength) == 0)
1009c1026,1027
< 				if(j<LENGTH(curr_val_labels)) continue;
---
> 					if (j < LENGTH(curr_val_labels))
> 						continue;
1014,1015c1032,1036
< 				PROTECT(theselabels = getAttrib(theselabelslevels, R_NamesSymbol));
< 				writeStataValueLabel(thisnamechar, theselabels, theselabelslevels, namelength, fp);
---
> 					PROTECT(
> 							theselabels = getAttrib(theselabelslevels,
> 									R_NamesSymbol));
> 					writeStataValueLabel(thisnamechar, theselabels,
> 							theselabelslevels, namelength, fp);
1026,1027c1047
< SEXP do_writeStata(SEXP call)
< {
---
> SEXP do_writeStata(SEXP call) {
1044c1063,1064
<     if (!fp) error(_("unable to open file for writing: '%s'"), strerror(errno));
---
> 	if (!fp)
> 		error(_("unable to open file for writing: '%s'"), strerror(errno));
diff -rEZbwB '--exclude=*.[lo,d,pdf,mo,po,tgz,gz,save]*' '--exclude=MD5' '--exclude=Makefile*' '--exclude=all.R' '--exclude=Changes' R-recommended/foreign/src/var.h Recommended/foreign/src/var.h
52,53c52
< union value
<   {
---
> union value {
78,79c77
< struct value_label
<   {
---
> struct value_label {
88,89c86
< struct freq
<   {
---
> struct freq {
95,98c92,93
< enum
<   {
<     FRQM_GENERAL,
<     FRQM_INTEGER
---
> enum {
> 	FRQM_GENERAL, FRQM_INTEGER
102,103c97
< struct freq_tab
<   {
---
> struct freq_tab {
128,129c122
< struct freq_tab_set
<   {
---
> struct freq_tab_set {
143,144c136
< struct crosstab_proc
<   {
---
> struct crosstab_proc {
152,156c144,159
< enum
<   {
<     frq_mean = 0, frq_semean, frq_median, frq_mode, frq_stddev, frq_variance,
<     frq_kurt, frq_sekurt, frq_skew, frq_seskew, frq_range, frq_min, frq_max,
<     frq_sum, frq_n_stats
---
> enum {
> 	frq_mean = 0,
> 	frq_semean,
> 	frq_median,
> 	frq_mode,
> 	frq_stddev,
> 	frq_variance,
> 	frq_kurt,
> 	frq_sekurt,
> 	frq_skew,
> 	frq_seskew,
> 	frq_range,
> 	frq_min,
> 	frq_max,
> 	frq_sum,
> 	frq_n_stats
159,160c162
< struct frequencies_proc
<   {
---
> struct frequencies_proc {
173,174c175
< struct list_proc
<   {
---
> struct list_proc {
182,183c183
< enum
<   {
---
> enum {
187,189c187,199
<     dsc_mean = 0, dsc_semean, dsc_stddev, dsc_variance, dsc_kurt,
<     dsc_sekurt, dsc_skew, dsc_seskew, dsc_range, dsc_min,
<     dsc_max, dsc_sum, dsc_n_stats
---
> 	dsc_mean = 0,
> 	dsc_semean,
> 	dsc_stddev,
> 	dsc_variance,
> 	dsc_kurt,
> 	dsc_sekurt,
> 	dsc_skew,
> 	dsc_seskew,
> 	dsc_range,
> 	dsc_min,
> 	dsc_max,
> 	dsc_sum,
> 	dsc_n_stats
192,193c202
< struct descriptives_proc
<   {
---
> struct descriptives_proc {
211,212c220
< struct get_proc
<   {
---
> struct get_proc {
217,218c225
< enum
<   {
---
> enum {
224,225c231
< struct sort_cases_proc
<   {
---
> struct sort_cases_proc {
230,231c236
< struct modify_vars_proc
<   {
---
> struct modify_vars_proc {
238,239c243
< struct means_proc
<   {
---
> struct means_proc {
245,246c249
< enum
<   {
---
> enum {
257,258c260
< struct matrix_data_proc
<   {
---
> struct matrix_data_proc {
264,265c266
< struct match_files_proc
<   {
---
> struct match_files_proc {
273,274c274
< enum
<   {
---
> enum {
285,286c285
< enum
<   {
---
> enum {
303,304c302
< struct variable
<   {
---
> struct variable {
331,332c329
<     union
<       {
---
> 	union {
342,343c339
<       }
<     p;
---
> 	} p;
350,351c346
< struct ccase
<   {
---
> struct ccase {
358,359c353
< struct dictionary
<   {
---
> struct dictionary {
422,423c416
< enum
<   {
---
> enum {
469,470c462
< void replace_variable (struct variable *, const char *name,
< 		       int type, int width);
---
> void replace_variable(struct variable *, const char *name, int type, int width);
491,492c483
< struct trns_header
<   {
---
> struct trns_header {
520,521c511
< enum
<   {
---
> enum {
535,536c525,526
< int parse_variables (struct dictionary *dict, struct variable ***v,
< 		     int *nv, int pv_opts);
---
> int parse_variables(struct dictionary *dict, struct variable ***v, int *nv,
> 		int pv_opts);
