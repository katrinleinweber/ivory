diff -rEZbwB '--exclude=*.[lo,d,pdf,mo,po,tgz,gz,save]*' '--exclude=MD5' '--exclude=Makefile*' '--exclude=all.R' '--exclude=Changes' R-recommended/mgcv/R/bam.r Recommended/mgcv/R/bam.r
13c13
<  for (i in 1:n) sz[i] <- object.size(x[[i]])
---
>  for (i in seq_len(n)) sz[i] <- object.size(x[[i]])
38,39c38,39
<   ipiv <- piv <- attr(R,"pivot");ipiv[piv] <- 1:p
<   rank <- attr(R,"rank");ind <- 1:rank
---
>   ipiv <- piv <- attr(R,"pivot");ipiv[piv] <- seq_len(p)
>   rank <- attr(R,"rank");ind <- seq_len(rank)
71,72c71,72
<     fn <- qr.qty(qrx,yn)[1:p]
<     rp <- qrx$pivot;rp[rp] <- 1:p # reverse pivot
---
>     fn <- qr.qty(qrx,yn)[seq_len(p)]
>     rp <- qrx$pivot;rp[rp] <- seq_len(p) # reverse pivot
85c85
<   for (b in 1:arg$n.block) {
---
>   for (b in seq_len(arg$n.block)) {
134c134
<   for (i in 1:d) if (is.factor(dat[,i])) {  
---
>   for (i in seq_len(d)) if (is.factor(dat[,i])) {  
147c147
<     for (i in 1:d) if (!is.factor(dat[,i])) { ## round the metric variables
---
>     for (i in seq_len(d)) if (!is.factor(dat[,i])) { ## round the metric variables
171c171
<   ii <- sample(1:nrow(xu),nrow(xu),replace=FALSE) ## shuffling index
---
>   ii <- sample(seq_len(nrow(xu)),nrow(xu),replace=FALSE) ## shuffling index
237c237
<   for (i in 1:length(gp$smooth.spec)) nk <- nk + as.numeric(gp$smooth.spec[[i]]$by!="NA") +
---
>   for (i in seq_len(length(gp$smooth.spec))) nk <- nk + as.numeric(gp$smooth.spec[[i]]$by!="NA") +
240c240
<   k.start <- 1:(nk+1) ## record last column for each term
---
>   k.start <- seq_len(nk+1) ## record last column for each term
248c248
<   for (i in 1:length(gp$smooth.spec)) {
---
>   for (i in seq_len(length(gp$smooth.spec))) {
254c254
<     for (jj in 1:maxj) { ## loop through marginals
---
>     for (jj in seq_len(maxj)) { ## loop through marginals
313c313
<     for (i in 1:length(mf0)) {
---
>     for (i in seq_len(length(mf0))) {
327c327
<     mf <- mf[sample(1:nrow(mf),maxr,replace=TRUE),]
---
>     mf <- mf[sample(seq_len(nrow(mf)),maxr,replace=TRUE),]
350c350
<           ii0 <- if (ik>1) 1:(ik-1) else rep(0,0) ## earlier
---
>           ii0 <- if (ik>1) seq_len(ik-1) else rep(0,0) ## earlier
354c354
<           kk0 <- if (ik>1) 1:(k.start[ik]-1) else rep(0,0) ## earlier
---
>           kk0 <- if (ik>1) seq_len(k.start[ik]-1) else rep(0,0) ## earlier
375c375
<   for (j in 1:length(mf)) mn <- mn + if (is.factor(mf[[j]])) length(levels(mf[[j]])) else 2
---
>   for (j in seq_len(length(mf))) mn <- mn + if (is.factor(mf[[j]])) length(levels(mf[[j]])) else 2
389c389
<   ind <- sample(1:n,chunk.size)
---
>   ind <- sample(seq_len(n),chunk.size)
397c397
<   ind <- sample(1:n,n,replace=FALSE) ## randomized index for stratified sampling w.r.t. factor levels
---
>   ind <- sample(seq_len(n),n,replace=FALSE) ## randomized index for stratified sampling w.r.t. factor levels
400c400
<   for (j in 1:length(mf)) if (is.numeric(mf0[[j]])) {
---
>   for (j in seq_len(length(mf))) if (is.numeric(mf0[[j]])) {
402,403c402,403
<       j.min <- min((1:n)[as.logical(rowSums(mf[[j]]==min(mf[[j]])))])
<       j.max <- min((1:n)[as.logical(rowSums(mf[[j]]==max(mf[[j]])))])
---
>       j.min <- min((seq_len(n))[as.logical(rowSums(mf[[j]]==min(mf[[j]])))])
>       j.max <- min((seq_len(n))[as.logical(rowSums(mf[[j]]==max(mf[[j]])))])
460c460
<       ar.row <- c(1,rep(1:N,rep(2,N))[-c(1,2*N)]) ## index of rows to reweight
---
>       ar.row <- c(1,rep(seq_len(N),rep(2,N))[-c(1,2*N)]) ## index of rows to reweight
462c462
<       ar.stop <- c(1,1:(N-1)*2+1)    ## (stop[i-1]+1):stop[i] are the rows to reweight to get ith row
---
>       ar.stop <- c(1,seq_len(N-1)*2+1)    ## (stop[i-1]+1):stop[i] are the rows to reweight to get ith row
520c520
<     for (b in 1:length(Sl)) rank <- rank + Sl[[b]]$rank
---
>     for (b in seq_len(length(Sl))) rank <- rank + Sl[[b]]$rank
524c524
<     for (iter in 1L:control$maxit) { ## main fitting loop 
---
>     for (iter in seq_len(control$maxit)) { ## main fitting loop 
576c576
< 	      theta <- theta[1:family$n.theta]
---
> 	      theta <- theta[seq_len(family$n.theta)]
666c666
<         prop <- Sl.fitChol(Sl,qrx$XX,qrx$Xy,rho=lsp[1:n.sp],yy=qrx$y.norm2,L=G$L,rho0=G$lsp0,log.phi=log.phi,
---
>         prop <- Sl.fitChol(Sl,qrx$XX,qrx$Xy,rho=lsp[seq_len(n.sp)],yy=qrx$y.norm2,L=G$L,rho0=G$lsp0,log.phi=log.phi,
682c682
<           warning(gettextf("non-finite coefficients at iteration %d",
---
>           warning(gettextf("Non-finite coefficients at iteration %d",
690c690
<        warning("algorithm did not converge")
---
>        warning("Algorithm did not converge")
702c702
<   if (length(G$smooth)>1) for (i in 1:length(G$smooth)) Mp <- Mp + G$smooth[[i]]$null.space.dim
---
>   if (length(G$smooth)>1) for (i in seq_len(length(G$smooth))) Mp <- Mp + G$smooth[[i]]$null.space.dim
710c710
<   for (i in 1:ncol(prop$db)) prop$db[,i] <- ## d beta / d rho matrix
---
>   for (i in seq_len(ncol(prop$db))) prop$db[,i] <- ## d beta / d rho matrix
738c738
<   object$sp <- exp(lsp[1:n.sp]) 
---
>   object$sp <- exp(lsp[seq_len(n.sp)]) 
749c749
<     rV <- (ev$values*t(ev$vectors))[,1:M]
---
>     rV <- (ev$values*t(ev$vectors))[,seq_len(M)]
772,773c772,773
<   if (length(S)>0) for (i in 1:length(S)) {
<     ind <- off[i] - 1 + 1:ncol(S[[i]])
---
>   if (length(S)>0) for (i in seq_along(S)) {
>     ind <- off[i] - 1 + seq_len(ncol(S[[i]]))
854c854
<         warning("Too many cluster nodes to use all efficiently")
---
>         warning("too many cluster nodes to use all efficiently")
864c864
<       for (i in 1:n.threads) {
---
>       for (i in seq_len(n.threads)) {
871c871
<           stop <- (1:n.block)*chunk.size
---
>           stop <- seq_len(n.block)*chunk.size
901c901
<         stop <- (1:n.block)*chunk.size
---
>         stop <- seq_len(n.block)*chunk.size
920c920
<     for (iter in 1L:control$maxit) { ## main fitting loop
---
>     for (iter in seq_len(control$maxit)) { ## main fitting loop
928c928
<            for (b in 1:n.block) {
---
>            for (b in seq_len(n.block)) {
967c967
<           for (i in 1:length(arg)) {
---
>           for (i in seq_along(arg)) {
974c974
<           #for (i in 1:length(arg)) {
---
>           #for (i in seq_along(arg)) {
1001c1001
<             f <- qr.qty(qrx,f)[1:ncol(R)]
---
>             f <- qr.qty(qrx,f)[seq_len(ncol(R))]
1079c1079
< 	   theta <- theta[1:family$n.theta]
---
> 	   theta <- theta[seq_len(family$n.theta)]
1164c1164
<           warning(gettextf("non-finite coefficients at iteration %d",
---
>           warning(gettextf("Non-finite coefficients at iteration %d",
1196c1196
<        warning("algorithm did not converge")
---
>        warning("Algorithm did not converge")
1227c1227
<   for (i in 1:arg$n.block) {
---
>   for (i in seq_len(arg$n.block)) {
1233c1233
<        row <- c(1,rep(1:N,rep(2,N))[-c(1,2*N)])
---
>        row <- c(1,rep(seq_len(N),rep(2,N))[-c(1,2*N)])
1235c1235
<        stop <- c(1,1:(N-1)*2+1)
---
>        stop <- c(1,seq_len(N-1)*2+1)
1314c1314
<     for (i in 1:n.threads) { 
---
>     for (i in seq_len(n.threads)) { 
1380c1380
<          warning("Too many cluster nodes to use all efficiently")
---
>          warning("too many cluster nodes to use all efficiently")
1393c1393
<        for (i in 1:n.threads) { 
---
>        for (i in seq_len(n.threads)) { 
1440c1440
<        for (i in 1:n.block) {
---
>        for (i in seq_len(n.block)) {
1445c1445
<            row <- c(1,rep(1:N,rep(2,N))[-c(1,2*N)])
---
>            row <- c(1,rep(seq_len(N),rep(2,N))[-c(1,2*N)])
1447c1447
<            stop <- c(1,1:(N-1)*2+1) 
---
>            stop <- c(1,seq_len(N-1)*2+1) 
1487c1487
<        # for (i in 1:length(arg)) {
---
>        # for (i in seq_len(length(arg))) {
1508,1509c1508,1509
<          f <- qr.qty(qrx,f)[1:ncol(R)]
<          rp <- qrx$pivot;rp[rp] <- 1:ncol(R) # reverse pivot
---
>          f <- qr.qty(qrx,f)[seq_len(ncol(R))]
>          rp <- qrx$pivot;rp[rp] <- seq_len(ncol(R)) # reverse pivot
1519c1519
<        row <- c(1,rep(1:n,rep(2,n))[-c(1,2*n)])
---
>        row <- c(1,rep(seq_len(n),rep(2,n))[-c(1,2*n)])
1521c1521
<        stop <- c(1,1:(n-1)*2+1)
---
>        stop <- c(1,seq_len(n-1)*2+1)
1657c1657
<     warning("iterms reset to terms")
---
>     warning("type 'iterms' reset to type 'terms'")
1660c1660
<   if (!is.null(exclude)) warning("exclude ignored by discrete prediction at present")
---
>   if (!is.null(exclude)) warning("'exclude' argument ignored by discrete prediction at present")
1682,1683c1682,1683
<     object$coefficients <-  object$coefficients[1:object$nsdf]
<     object$Vp <- object$V[1:object$nsdf,1:object$nsdf]
---
>     object$coefficients <-  object$coefficients[seq_len(object$nsdf)]
>     object$Vp <- object$V[seq_len(object$nsdf),seq_len(object$nsdf)]
1707c1707
<      kd <- cbind(1:nrow(newdata),dk$k) ## add index for parametric part to index list
---
>      kd <- cbind(seq_len(nrow(newdata)),dk$k) ## add index for parametric part to index list
1721c1721
<   for (i in 1:length(object$smooth)) { ## work through the smooth list
---
>   for (i in seq_len(length(object$smooth))) { ## work through the smooth list
1724c1724
<       by.var <- dk$mf[[object$smooth[[i]]$by]][1:dk$nr[k]]
---
>       by.var <- dk$mf[[object$smooth[[i]]$by]][seq_len(dk$nr[k])]
1743c1743
<       for (j in 1:nmar) {
---
>       for (j in seq_len(nmar)) {
1774c1774
<     for (i in 1:length(object$smooth)) {
---
>     for (i in seq_len(length(object$smooth))) {
1819c1819
<   for (i in 1:ns) if (sm$margin[[i]]$bs.dim>=maxd) {
---
>   for (i in seq_len(ns)) if (sm$margin[[i]]$bs.dim>=maxd) {
1823c1823
<     ind <- 1:ns;ind[maxi] <- ns;ind[ns] <- maxi
---
>     ind <- seq_len(ns);ind[maxi] <- ns;ind[ns] <- maxi
1828c1828
<     for (i in 1:ns) sm$term <- c(sm$term,sm$margin[[i]]$term)
---
>     for (i in seq_len(ns)) sm$term <- c(sm$term,sm$margin[[i]]$term)
1841c1841
<   ar.row <- c(1,rep(1:N,rep(2,N))[-c(1,2*N)]) ## index of rows to reweight
---
>   ar.row <- c(1,rep(seq_len(N),rep(2,N))[-c(1,2*N)]) ## index of rows to reweight
1843c1843
<   ar.stop <- c(1,1:(N-1)*2+1)    ## (stop[i-1]+1):stop[i] are the rows to reweight to get ith row
---
>   ar.stop <- c(1,seq_len(N-1)*2+1)    ## (stop[i-1]+1):stop[i] are the rows to reweight to get ith row
1883,1884c1883
<     if (!method%in%c("fREML","GCV.Cp","REML",
<                     "ML","P-REML","P-ML")) stop("un-supported smoothness selection method")
---
>     if (!method%in%c("fREML","GCV.Cp","REML", "ML","P-REML","P-ML")) stop("unsupported smoothness selection method")
1917c1916
<       if (length(gp$smooth.spec)>0) for (i in 1:length(gp$smooth.spec)) { 
---
>       if (length(gp$smooth.spec)>0) for (i in seq_len(length(gp$smooth.spec))) { 
1926c1925
<           for (j in 1:gp$smooth.spec[[i]]$dim) gp$smooth.spec[[i]]$margin[[j]] <- list(term=gp$smooth.spec[[i]]$term[j])
---
>           for (j in seq_len(gp$smooth.spec[[i]]$dim)) gp$smooth.spec[[i]]$margin[[j]] <- list(term=gp$smooth.spec[[i]]$term[j])
1956c1955
<     if (rho!=0&&!is.null(mf$"(AR.start)")) if (!is.logical(mf$"(AR.start)")) stop("AR.start must be logical")
---
>     if (rho!=0&&!is.null(mf$"(AR.start)")) if (!is.logical(mf$"(AR.start)")) stop("'AR.start' argument must be logical")
2034c2033
<         G$kd <- cbind(1:nrow(mf),dk$k) ## add index for parametric part to index list
---
>         G$kd <- cbind(seq_len(nrow(mf)),dk$k) ## add index for parametric part to index list
2048c2047
<       for (i in 1:length(G$smooth)) {
---
>       for (i in seq_len(length(G$smooth))) {
2053c2052
<           by.var <- dk$mf[[G$smooth[[i]]$by]][1:dk$nr[k]]
---
>           by.var <- dk$mf[[G$smooth[[i]]$by]][seq_len(dk$nr[k])]
2076,2077c2075,2076
<           for (j in 1:nmar) {
<             G$Xd[[k]] <- G$smooth[[i]]$margin[[j]]$X[1:dk$nr[k],,drop=FALSE]
---
>           for (j in seq_len(nmar)) {
>             G$Xd[[k]] <- G$smooth[[i]]$margin[[j]]$X[seq_len(dk$nr[k]),,drop=FALSE]
2099c2098
<           G$Xd[[k]] <- G$X[1:dk$nr[k],G$smooth[[i]]$first.para:G$smooth[[i]]$last.para]
---
>           G$Xd[[k]] <- G$X[seq_len(dk$nr[k]),G$smooth[[i]]$first.para:G$smooth[[i]]$last.para]
2143c2142
<     if (G$m) for (i in 1:G$m) G$min.edf<-G$min.edf+G$smooth[[i]]$null.space.dim
---
>     if (G$m) for (i in seq_len(G$m)) G$min.edf<-G$min.edf+G$smooth[[i]]$null.space.dim
2175c2174
<   if (control$trace) cat("Setup complete. Calling fit\n")
---
>   if (control$trace) cat(gettext("Setup complete. Calling fit", domain = "R-mgcv"), "\n", sep = "")
2191,2192c2190,2191
<       ind <- sample(1:nrow(mf),ceiling(nrow(mf)*samfrac))
<       if (length(ind)<2*ncol(G$X)) warning("samfrac too small - ignored") else {
---
>       ind <- sample(seq_len(nrow(mf)),ceiling(nrow(mf)*samfrac))
>       if (length(ind)<2*ncol(G$X)) warning("value of 'samfrac' argument is too small - ignored") else {
2214c2213
<   if (control$trace) cat("Fit complete. Finishing gam object.\n")
---
>   if (control$trace) cat(gettext("Fit complete. Finishing gam object.", domain = "R-mgcv"), "\n", sep = "")
2244c2243
<   if (G$nsdf>0) names(object$coefficients)[1:G$nsdf] <- colnamesX[1:G$nsdf]
---
>   if (G$nsdf>0) names(object$coefficients)[seq_len(G$nsdf)] <- colnamesX[seq_len(G$nsdf)]
2372c2371
<     row <- c(1,rep(1:m,rep(2,m))[-c(1,2*m)])
---
>     row <- c(1,rep(seq_len(m),rep(2,m))[-c(1,2*m)])
2374c2373
<     stop <- c(1,1:(m-1)*2+1)
---
>     stop <- c(1,seq_len(m-1)*2+1)
diff -rEZbwB '--exclude=*.[lo,d,pdf,mo,po,tgz,gz,save]*' '--exclude=MD5' '--exclude=Makefile*' '--exclude=all.R' '--exclude=Changes' R-recommended/mgcv/R/coxph.r Recommended/mgcv/R/coxph.r
18c18
<         else stop(linktemp, " link not available for coxph family; available link is \"identity\" ")
---
>         else stop(gettextf("\"%s\" link not available for coxph family; available link is \"identity\"", linktemp))
83c83
< 	nt <- 0;for (i in 1:ns) nt <- nt + length(unique(y[strat==strat.lev[i]]))
---
> 	nt <- 0;for (i in seq_len(ns)) nt <- nt + length(unique(y[strat==strat.lev[i]]))
86c86
<         for (i in 1:ns) {
---
>         for (i in seq_len(ns)) {
106c106
< 	return(list(tr=tr,h=oo$h,q=oo$q,a=matrix(oo$A[1:(p*nt)],p,nt),nt=nt,r=r,km=oo$km))
---
> 	return(list(tr=tr,h=oo$h,q=oo$q,a=matrix(oo$A[seq_len(p*nt)],p,nt),nt=nt,r=r,km=oo$km))
110c110
<         for (i in 1:ns) { ## loop over strata
---
>         for (i in seq_len(ns)) { ## loop over strata
208c208
<       if (!is.null(offset)&&sum(offset!=0)) stop("cox.ph does not yet handle offsets")
---
>       if (!is.null(offset)&&sum(offset!=0)) stop("'cox.ph()' function does not yet handle offsets")
238,239c238,239
<       for (j in 1:ns) { ## loop over strata
<         ind <- if (ns==1) 1:length(y) else which(strat==strat.lev[j]) ## index for points in this strata
---
>       for (j in seq_len(ns)) { ## loop over strata
>         ind <- if (ns==1) seq_along(y) else which(strat==strat.lev[j]) ## index for points in this strata
260c260
<           ind <- 1:(p^2)
---
>           ind <- seq_len(p^2)
262c262
<           for (i in 1:M) { 
---
>           for (i in seq_len(M)) { 
diff -rEZbwB '--exclude=*.[lo,d,pdf,mo,po,tgz,gz,save]*' '--exclude=MD5' '--exclude=Makefile*' '--exclude=all.R' '--exclude=Changes' R-recommended/mgcv/R/efam.r Recommended/mgcv/R/efam.r
29c29
<       ind <- 1:length(g)
---
>       ind <- seq_along(g)
37c37
<       for (i in 1:nth) for (j in i:nth) {
---
>       for (i in seq_len(nth)) for (j in i:nth) {
140c140
<     } else stop(linktemp, " link not available for ordered categorical family; available links are \"identity\"")
---
>     } else stop(gettextf("\"%s\" link not available for ordered categorical family; available links are \"identity\"", linktemp))
177c177,178
<     paste("Ordered Categorical(",paste(round(family$getTheta(TRUE),2),collapse=","),")",sep="")
---
>     gettextf("Ordered Categorical(%s)", paste(round(family$getTheta(TRUE),2), collapse = ","), domain = "R-mgcv")
>     #paste("Ordered Categorical(",paste(round(family$getTheta(TRUE),2),collapse=","),")",sep="")
346c347
<       for (k in 1:(R-2)) { 
---
>       for (k in seq_len(R-2)) { 
395c396
<       for (j in 1:(R-2)) for (k in j:(R-2)) { 
---
>       for (j in seq_len(R-2)) for (k in j:(R-2)) { 
493c494
<     for (j in 1:(R-2)) for (k in j:(R-2)) { 
---
>     for (j in seq_len(R-2)) for (k in j:(R-2)) { 
512c513
<       for (i in 1:(R-2)) for (j in i:(R-2)) { 
---
>       for (i in seq_len(R-2)) for (j in i:(R-2)) { 
528c529
<       y <- c(1:R,y) ## make sure there is *something* in each class
---
>       y <- c(seq_len(R),y) ## make sure there is *something* in each class
575c576
<        for (i in 1:(R+1)) {
---
>        for (i in seq_len(R+1)) {
607c608
<       for (i in 1:R) {
---
>       for (i in seq_len(R)) {
636c637
<       for (i in 1:(R+1)) {
---
>       for (i in seq_len(R+1)) {
659c660
<     for (i in 1:R) {
---
>     for (i in seq_len(R)) {
695c696
<         else stop(linktemp, " link not available for negative binomial family; available links are \"identity\", \"log\" and \"sqrt\"")
---
>         else stop(gettextf("\"%s\" link not available for negative binomial family; available links are \"identity\", \"log\" and \"sqrt\"", linktemp))
796c797,798
<       paste("Negative Binomial(",round(family$getTheta(TRUE),3),")",sep="")
---
>       gettextf("Negative Binomial(%s)", paste(round(family$getTheta(TRUE),3), sep = ", ", collapse = ""), domain = "R-mgcv")
>       #paste("Negative Binomial(",round(family$getTheta(TRUE),3),")",sep="")
846,847c848
<         else  stop(gettextf("link \"%s\" not available for Tweedie family.", 
<                 linktemp, collapse = ""), domain = NA)
---
>         else  stop(gettextf("link \"%s\" is not available for Tweedie family",  linktemp, collapse = ""), domain = "R-mgcv")
971c972
<       paste("Tweedie(p=",round(family$getTheta(TRUE),3),")",sep="")
---
>       gettextf("Tweedie(p=%s)", round(family$getTheta(TRUE),3), domain = "R-mgcv")
1018c1019
<         else stop(linktemp, " link not available for beta regression; available links are  \"logit\", \"probit\", \"cloglog\" and \"cauchit\"")
---
>         else stop(gettextf("\"%s\" link not available for beta regression; available links are  \"logit\", \"probit\", \"cloglog\" and \"cauchit\"", linktemp))
1165c1166
<       mu <- LS <- ii <- 1:length(y)
---
>       mu <- LS <- ii <- seq_len(length(y))
1223c1224
<       paste("Beta regression(",round(theta,3),")",sep="")
---
>       gettextf("Beta regression(%s)",round(theta,3), domain = "R-mgcv")
1307c1308
<         else stop(linktemp, " link not available for scaled t distribution; available links are \"identity\", \"log\",  and \"inverse\"")
---
>         else stop(gettextf("\"%s\" link not available for scaled t distribution; available links are \"identity\", \"log\",  and \"inverse\"", linktemp))
1474c1475
<       paste("Scaled t(",paste(round(family$getTheta(TRUE),3),collapse=","),")",sep="")
---
>       gettextf("Scaled t(%s)",paste(round(family$getTheta(TRUE),3), collapse=","), domain = "R-mgcv")
1584c1585
<   } else  stop(linktemp, " link not available for zero inflated; available link for `lambda' is only  \"loga\"")
---
>   } else  stop(gettextf("\"%s\" link not available for zero inflated; available link for `lambda' is only  \"loga\"", linktemp))
1708c1709
<       paste("Zero inflated Poisson(",paste(round(family$getTheta(TRUE),3),collapse=","),")",sep="")
---
>       gettextf("Zero inflated Poisson(%s)",paste(round(family$getTheta(TRUE),3),collapse=","), domain = "R-mgcv")
diff -rEZbwB '--exclude=*.[lo,d,pdf,mo,po,tgz,gz,save]*' '--exclude=MD5' '--exclude=Makefile*' '--exclude=all.R' '--exclude=Changes' R-recommended/mgcv/R/fast-REML.r Recommended/mgcv/R/fast-REML.r
34,36c34,36
<     off <- unique(G$off[1:G$n.paraPen]) ## unique offset lists relating to paraPen
<     for (i in 1:length(off)) { ## loop over blocks
<       ind <- (1:G$n.paraPen)[G$off[1:G$n.paraPen]%in%off[i]] ## terms in same block
---
>     off <- unique(G$off[seq_len(G$n.paraPen)]) ## unique offset lists relating to paraPen
>     for (i in seq_along(off)) { ## loop over blocks
>       ind <- seq_len(G$n.paraPen)[G$off[seq_len(G$n.paraPen)]%in%off[i]] ## terms in same block
38c38
<         nr <- 0;for (k in 1:length(ind)) nr <- max(nr,nrow(G$S[[ind[k]]])) ## get block size
---
>         nr <- 0;for (k in seq_along(ind)) nr <- max(nr,nrow(G$S[[ind[k]]])) ## get block size
43c43
<         for (k in 1:length(ind)) { ## work through all penalties for this block
---
>         for (k in seq_along(ind)) { ## work through all penalties for this block
47c47
<             Sl[[b]]$S[[k]][1:nk,1:nk] <- G$S[[ind[k]]]
---
>             Sl[[b]]$S[[k]][seq_len(nk),seq_len(nk)] <- G$S[[ind[k]]]
65c65
<   if (length(G$smooth)) for (i in 1:length(G$smooth)) {
---
>   if (length(G$smooth)) for (i in seq_along(G$smooth)) {
96c96
<       for (j in 1:m) { ## get block range for each S[[j]]
---
>       for (j in seq_len(m)) { ## get block range for each S[[j]]
98c98
<         ir <- range((1:nb)[rowSums(abs(Sl[[b]]$S[[j]]))>0])
---
>         ir <- range(seq_len(nb)[rowSums(abs(Sl[[b]]$S[[j]]))>0])
102c102
<       for (j in 1:m) { ## test for overlap
---
>       for (j in seq_len(m)) { ## test for overlap
105c105
<           for (k in 1:m) if (j!=k) itot[diag(Sl[[b]]$S[[k]])!=0] <- TRUE
---
>           for (k in seq_len(m)) if (j!=k) itot[diag(Sl[[b]]$S[[k]])!=0] <- TRUE
110c110
<           for (k in 1:m) if (j!=k) itot[sbStart[k]:sbStop[k]] <- TRUE
---
>           for (k in seq_len(m)) if (j!=k) itot[sbStart[k]:sbStop[k]] <- TRUE
117c117
<         for (j in 1:m) {
---
>         for (j in seq_len(m)) {
149c149
<   for (b in 1:length(Sl)) { ## once more into the blocks, dear friends...
---
>   for (b in seq_along(Sl)) { ## once more into the blocks, dear friends...
166c166
<         ind[1:Sl[[b]]$rank] <- TRUE ## index penalized elements
---
>         ind[seq_len(Sl[[b]]$rank)] <- TRUE ## index penalized elements
197,198c197,198
<       ind <- 1:Sl[[b]]$rank
<       for (j in 1:length(Sl[[b]]$S)) { ## project penalties into range space of total penalty
---
>       ind <- seq_len(Sl[[b]]$rank)
>       for (j in seq_along(Sl[[b]]$S)) { ## project penalties into range space of total penalty
237c237
<   for (b in 1:length(Sl)) {
---
>   for (b in seq_along(Sl)) {
243c243
<       for (j in 1:length(Sl[[b]]$S)) {
---
>       for (j in seq_along(Sl[[b]]$S)) {
264c264
<         for (b in 1:length(Sl)) if (Sl[[b]]$repara) { 
---
>         for (b in seq_along(Sl)) if (Sl[[b]]$repara) { 
277c277
<          for (b in 1:length(Sl)) if (Sl[[b]]$repara) { 
---
>          for (b in seq_along(Sl)) if (Sl[[b]]$repara) { 
293c293
<       for (b in 1:length(Sl)) if (Sl[[b]]$repara) { 
---
>       for (b in seq_along(Sl)) if (Sl[[b]]$repara) { 
299c299
<   } else for (b in 1:length(Sl)) if (Sl[[b]]$repara) { ## model matrix re-para
---
>   } else for (b in seq_along(Sl)) if (Sl[[b]]$repara) { ## model matrix re-para
346c346
<     rp <- piv;rp[rp] <- 1:p ## reverse pivot
---
>     rp <- piv;rp[rp] <- seq_len(p) ## reverse pivot
350,351c350,351
<     R <- R[1:r,1:r]
<     piv <- piv[1:r]
---
>     R <- R[seq_len(r),seq_len(r)]
>     piv <- piv[seq_len(r)]
355c355
<   for (i in 1:m) {
---
>   for (i in seq_len(m)) {
361c361
<       for (j in 1:i) {
---
>       for (j in seq_len(i)) {
388c388
<   for (b in 1:length(Sl)) { ## work through blocks
---
>   for (b in seq_along(Sl)) { ## work through blocks
401c401
<           D <- Sl[[b]]$Di[1:Sl[[b]]$rank,]
---
>           D <- Sl[[b]]$Di[seq_len(Sl[[b]]$rank),]
432c432
<         for (i in 1:m) {
---
>         for (i in seq_len(m)) {
473c473
<   for (b in 1:length(Sl)) {
---
>   for (b in seq_along(Sl)) {
481c481
<       for (j in 1:length(Sl[[b]]$S)) {
---
>       for (j in seq_alongh(Sl[[b]]$S)) {
497c497
<   for (b in 1:length(Sl)) {
---
>   for (b in seq_along(Sl)) {
503c503
<       for (j in 1:length(Sl[[b]]$S)) {
---
>       for (j in seq_along(Sl[[b]]$S)) {
521c521
<       for (i in 1:nr) if (rp[[i]]$repara) {
---
>       for (i in seq_len(nr)) if (rp[[i]]$repara) {
528c528
<      for (i in 1:nr) if (rp[[i]]$repara) X[rp[[i]]$ind]  <- rp[[i]]$Qs %*% X[rp[[i]]$ind]
---
>      for (i in seq_len(nr)) if (rp[[i]]$repara) X[rp[[i]]$ind]  <- rp[[i]]$Qs %*% X[rp[[i]]$ind]
532c532
<       for (i in 1:nr) if (rp[[i]]$repara) X[,rp[[i]]$ind]  <- X[,rp[[i]]$ind]%*%rp[[i]]$Qs
---
>       for (i in seq_len(nr)) if (rp[[i]]$repara) X[,rp[[i]]$ind]  <- X[,rp[[i]]$ind]%*%rp[[i]]$Qs
534c534
<       for (i in 1:nr) if (rp[[i]]$repara) X[rp[[i]]$ind]  <- t(rp[[i]]$Qs) %*% X[rp[[i]]$ind]
---
>       for (i in seq_len(nr)) if (rp[[i]]$repara) X[rp[[i]]$ind]  <- t(rp[[i]]$Qs) %*% X[rp[[i]]$ind]
550c550
<     for (b in 1:nb) { ## block loop
---
>     for (b in seq_len(nb)) { ## block loop
570,571c570,571
<     for (b in 1:nb) { ## block loop
<       for (i in 1:length(Sl[[b]]$S)) { ## S loop within blocks
---
>     for (b in seq_len(nb)) { ## block loop
>       for (i in seq_along(Sl[[b]]$S)) { ## S loop within blocks
638c638
<   for (b in 1:nb) { ## block loop
---
>   for (b in seq_len(nb)) { ## block loop
668c668
<       for (i in 1:length(Sl[[b]]$S)) { ## work through S terms
---
>       for (i in seq_along(Sl[[b]]$S)) { ## work through S terms
710c710
<   for (i in 1:nd) { 
---
>   for (i in seq_len(nd)) { 
737c737
<   for (i in 1:nd) { ## compute the first derivatives
---
>   for (i in seq_len(nd)) { ## compute the first derivatives
747c747
<   for (k in 1:nd) { ## second derivative loop 
---
>   for (k in seq_len(nd)) { ## second derivative loop 
838,839c838,839
<     R <- R[1:r,1:r]
<     piv <- piv[1:r]
---
>     R <- R[seq_len(r),seq_len(r)]
>     piv <- piv[seq_len(r)]
868c868
<     reml2 <- rbind(cbind(reml2,d[1:n]),d) 
---
>     reml2 <- rbind(cbind(reml2,d[seq_len(n)]),d) 
916c916
<   rp <- qrx$pivot;rp[rp] <- 1:np ## reverse pivot vector
---
>   rp <- qrx$pivot;rp[rp] <- seq_len(np) ## reverse pivot vector
920,921c920,921
<   beta <- backsolve(R,Qty0)[1:np]
<   rss.bSb <- sum(Qty0[-(1:np)]^2) + rss.extra
---
>   beta <- backsolve(R,Qty0)[seq_len(np)]
>   rss.bSb <- sum(Qty0[-seq_len(np)]^2) + rss.extra
946c946
<     reml2 <- rbind(cbind(reml2,d[1:n]),d)
---
>     reml2 <- rbind(cbind(reml2,d[seq_len(n)]),d)
973c973
<     rp[rp] <- 1:np
---
>     rp[rp] <- seq_len(np)
976,977c976,977
<     rss.extra <- rss.extra + sum(y[-(1:np)]^2)
<     y <- y[1:np]
---
>     rss.extra <- rss.extra + sum(y[-seq_len(np)]^2)
>     y <- y[seq_len(np)]
1017c1017
<   for (iter in 1:200) { ## the Newton loop
---
>   for (iter in seq_len(200)) { ## the Newton loop
1041c1041
<     trial <- Sl.fit(Sl,X,y,rho1[1:nr],fixed,log.phi,phi.fixed,rss.extra,nobs,Mp,nt=nt)
---
>     trial <- Sl.fit(Sl,X,y,rho1[seq_len(nr)],fixed,log.phi,phi.fixed,rss.extra,nobs,Mp,nt=nt)
1055c1055
<       trial <- Sl.fit(Sl,X,y,rho1[1:nr],fixed,log.phi,phi.fixed,rss.extra,nobs,Mp,nt=nt)
---
>       trial <- Sl.fit(Sl,X,y,rho1[seq_len(nr)],fixed,log.phi,phi.fixed,rss.extra,nobs,Mp,nt=nt)
1084,1086c1084,1086
<   if (step.failed) best$conv <- "step failed" else
<   if (iter==200) best$conv <- "no convergence in 200 iterations" else
<   best$conv <- "full convergence"
---
>   if (step.failed) best$conv <- gettext("step failed", domain = "R-mgcv") else
>   if (iter==200) best$conv <- gettext("no convergence in 200 iterations", domain = "R-mgcv") else
>   best$conv <- gettext("full convergence", domain = "R-mgcv")
1108,1109c1108,1109
<   drop <- qrx$pivot[-(1:rank)] ## index of un-identifiable coefs
<   undrop <- 1:ncol(X) 
---
>   drop <- qrx$pivot[-seq_len(rank)] ## index of un-identifiable coefs
>   undrop <- seq_len(ncol(X))
1132c1132
<   for (b in 1:length(Sl)) {
---
>   for (b in seq_along(Sl)) {
1152c1152
<       for (i in 1:length(Sl[[b]]$S)) {
---
>       for (i in seq_along(Sl[[b]]$S)) {
1162c1162
<     for (i in 1:length(Sl)) {
---
>     for (i in seq_along(Sl)) {
1185c1185
<   for (b in 1:length(Sl)) rank <- rank + Sl[[b]]$rank ## the total penalty rank
---
>   for (b in seq_along(Sl)) rank <- rank + Sl[[b]]$rank ## the total penalty rank
1205c1205
<     for (i in 1:ncol(d1b)) d1b[,i] <- 
---
>     for (i in seq_len(ncol(d1b))) d1b[,i] <- 
1228c1228
<     rV <- (ev$values*t(ev$vectors))[,1:M]
---
>     rV <- (ev$values*t(ev$vectors))[,seq_len(M)]
diff -rEZbwB '--exclude=*.[lo,d,pdf,mo,po,tgz,gz,save]*' '--exclude=MD5' '--exclude=Makefile*' '--exclude=all.R' '--exclude=Changes' R-recommended/mgcv/R/gamlss.r Recommended/mgcv/R/gamlss.r
35c35
<   for (i in 1:K) for (j in i:K) for (k in j:K) for (l in k:K) {
---
>   for (i in seq_len(K)) for (j in i:K) for (k in j:K) for (l in k:K) {
49c49
<   for (j in 1:K) for (k in j:K) for (l in k:K) {
---
>   for (j in seq_len(K)) for (k in j:K) for (l in k:K) {
57c57
<   for (k in 1:K) for (l in k:K) {
---
>   for (k in seq_len(K)) for (l in k:K) {
78c78
<   for (i in 1:K) { ## first derivative loop
---
>   for (i in seq_len(K)) { ## first derivative loop
86c86
<   for (i in 1:K) for (j in i:K) {
---
>   for (i in seq_len(K)) for (j in i:K) {
103c103
<   if (deriv>0) for (i in 1:K) for (j in i:K) for (l in j:K) {
---
>   if (deriv>0) for (i in seq_len(K)) for (j in i:K) for (l in j:K) {
130c130
<   if (deriv>2) for (i in 1:K) for (j in i:K) for (l in j:K) for (m in l:K) {
---
>   if (deriv>2) for (i in seq_len(K)) for (j in i:K) for (l in j:K) for (m in l:K) {
198c198
<   for (i in 1:K) { ## first derivative loop
---
>   for (i in seq_len(K)) { ## first derivative loop
204c204
<   for (i in 1:K) for (j in i:K) {
---
>   for (i in seq_len(K)) for (j in i:K) {
216,217c216,217
<     ind <- 1:n
<     for (i in 1:K) { 
---
>     ind <- seq_len(n)
>     for (i in seq_len(K)) { 
225,228c225,228
<     for (l in 1:m) {
<       for (i in 1:K) {
<         v <- rep(0,n);ind <- 1:n
<         for (q in 1:K) { 
---
>     for (l in seq_len(m)) {
>       for (i in seq_len(K)) {
>         v <- rep(0,n);ind <- seq_len(n)
>         for (q in seq_len(K)) { 
239c239
<     for (l in 1:m) {
---
>     for (l in seq_len(m)) {
241,243c241,243
<       for (i in 1:K) for (j in i:K) {
<         v <- rep(0,n);ind <- 1:n
<         for (q in 1:K) { 
---
>       for (i in seq_len(K)) for (j in i:K) {
>         v <- rep(0,n);ind <- seq_len(n)
>         for (q in seq_len(K)) { 
258,259c258,259
<     ind <- 1:n 
<     for (i in 1:K) { 
---
>     ind <- seq_len(n) 
>     for (i in seq_len(K)) { 
268c268
<        ipiv <- piv <- attr(fh,"pivot");ipiv[piv] <- 1:p
---
>        ipiv <- piv <- attr(fh,"pivot");ipiv[piv] <- seq_len(p)
273,274c273,274
<     ind <- 1:n
<     for (i in 1:K) { 
---
>     ind <- seq_len(n)
>     for (i in seq_len(K)) { 
280c280
<     for (k in 1:m) for (l in k:m) { ## looping over smoothing parameters...
---
>     for (k in seq_len(m)) for (l in k:m) { ## looping over smoothing parameters...
282,284c282,284
<       for (i in 1:K) for (j in 1:K) {
<         v <- rep(0,n);ind <- 1:n
<         for (q in 1:K) { ## accumulate the diagonal matrix for X_i'diag(v)X_j
---
>       for (i in seq_len(K)) for (j in seq_len(K)) {
>         v <- rep(0,n);ind <- seq_len(n)
>         for (q in seq_len(K)) { ## accumulate the diagonal matrix for X_i'diag(v)X_j
286,287c286,287
<           ins <- 1:n
<           for (s in 1:K) { 
---
>           ins <- seq_len(n)
>           for (s in seq_len(K)) { 
294c294
<           rind <- 1:n + (i-1)*n
---
>           rind <- seq_len(n) + (i-1)*n
297,298c297,298
<           rind1 <- 1:n + (i-1)*n
<           rind2 <- 1:n + (j-1)*n
---
>           rind1 <- seq_len(n) + (i-1)*n
>           rind2 <- seq_len(n) + (j-1)*n
336c336
<   for (i in 1:K) { ## first derivative loop
---
>   for (i in seq_len(K)) { ## first derivative loop
342c342
<   for (i in 1:K) for (j in i:K) {
---
>   for (i in seq_len(K)) for (j in i:K) {
356,357c356,357
<     ind <- 1:n
<     for (i in 1:K) { 
---
>     ind <- seq_len(n)
>     for (i in seq_len(K)) { 
365,368c365,368
<     for (l in 1:m) {
<       for (i in 1:K) {
<         v <- rep(0,n);ind <- 1:n
<         for (q in 1:K) { 
---
>     for (l in seq_len(m)) {
>       for (i in seq_len(K)) {
>         v <- rep(0,n);ind <- seq_len(n)
>         for (q in seq_len(K)) { 
379c379
<     for (l in 1:m) {
---
>     for (l in seq_len(m)) {
381,383c381,383
<       for (i in 1:K) for (j in i:K) {
<         v <- rep(0,n);ind <- 1:n
<         for (q in 1:K) { 
---
>       for (i in seq_len(K)) for (j in i:K) {
>         v <- rep(0,n);ind <- seq_len(n)
>         for (q in seq_len(K)) { 
400,401c400,401
<     ind <- 1:n 
<     for (i in 1:K) { 
---
>     ind <- seq_len(n) 
>     for (i in seq_len(K)) { 
410c410
<        ipiv <- piv <- attr(fh,"pivot");ipiv[piv] <- 1:p
---
>        ipiv <- piv <- attr(fh,"pivot");ipiv[piv] <- seq_len(p)
415,416c415,416
<     ind <- 1:n
<     for (i in 1:K) { 
---
>     ind <- seq_len(n)
>     for (i in seq_len(K)) { 
422c422
<     for (k in 1:m) for (l in k:m) { ## looping over smoothing parameters...
---
>     for (k in seq_len(m)) for (l in k:m) { ## looping over smoothing parameters...
424,426c424,426
<       for (i in 1:K) for (j in 1:K) {
<         v <- rep(0,n);ind <- 1:n
<         for (q in 1:K) { ## accumulate the diagonal matrix for X_i'diag(v)X_j
---
>       for (i in seq_len(K)) for (j in seq_len(K)) {
>         v <- rep(0,n);ind <- seq_len(n)
>         for (q in seq_len(K)) { ## accumulate the diagonal matrix for X_i'diag(v)X_j
428,429c428,429
<           ins <- 1:n
<           for (s in 1:K) { 
---
>           ins <- seq_len(n)
>           for (s in seq_len(K)) { 
436c436
<           rind <- 1:n + (i-1)*n
---
>           rind <- seq_len(n) + (i-1)*n
439,440c439,440
<           rind1 <- 1:n + (i-1)*n
<           rind2 <- 1:n + (j-1)*n
---
>           rind1 <- seq_len(n) + (i-1)*n
>           rind2 <- seq_len(n) + (j-1)*n
459c459
<   lpi <- list(); for (i in 1:nlp) lpi[[i]] <- i
---
>   lpi <- list(); for (i in seq_len(nlp)) lpi[[i]] <- i
485c485
<   if (!is.null(offset)) for (i in 1:nlp) if (!is.null(offset[[i]])) eta[,i] <- eta[,i] + offset[[i]] 
---
>   if (!is.null(offset)) for (i in seq_len(nlp)) if (!is.null(offset[[i]])) eta[,i] <- eta[,i] + offset[[i]] 
505c505
<   if (length(link)!=2) stop("gaulss requires 2 links specified as character strings")
---
>   if (length(link)!=2) stop(gettextf("'%s' function requires 2 links specified as character strings", "gaulss()"))
509c509
<   stop(link[[1]]," link not available for mu parameter of gaulss")
---
>   stop(gettextf("\"%s\" link not available for mu parameter of gaulss", link[[1]]))
531c531
<   } else stop(link[[2]]," link not available for precision parameter of gaulss")
---
>   } else stop(gettextf("\"%s\" link not available for precision parameter of gaulss", link[[2]]))
696c696
<   for (i in 1:K) {
---
>   for (i in seq_len(K)) {
719c719
<       sgn*sqrt(-2*log(pmax(.Machine$double.eps,p[1:n + object$y*n]))) 
---
>       sgn*sqrt(-2*log(pmax(.Machine$double.eps,p[seq_len(n) + object$y*n]))) 
734c734
<         lpi <- list(1:ncol(X))
---
>         lpi <- list(seq_len(ncol(X)))
742c742
<       for (i in 1:K) { 
---
>       for (i in seq_len(K)) { 
763c763
<       for (j in 1:(K+1)) {
---
>       for (j in seq_len(K+1)) {
772c772
<         for (i in 1:K) if (i<K) for (k in (i+1):K) {
---
>         for (i in seq_len(K)) if (i<K) for (k in (i+1):K) {
816,817c816,817
<       for (i in 1:K) if (is.null(offset[[i]])) offset[[i]] <- 0
<       for (i in 1:K) eta[,i+1] <- X[,jj[[i]],drop=FALSE]%*%coef[jj[[i]]] + offset[[i]]
---
>       for (i in seq_len(K)) if (is.null(offset[[i]])) offset[[i]] <- 0
>       for (i in seq_len(K)) eta[,i+1] <- X[,jj[[i]],drop=FALSE]%*%coef[jj[[i]]] + offset[[i]]
827c827
<     l0 <- eta[1:n+y*n] - alpha ## log likelihood
---
>     l0 <- eta[seq_len(n)+y*n] - alpha ## log likelihood
833c833
<       for (i in 1:K) l1[,i] <- ee[,i]/beta ## alpha1
---
>       for (i in seq_len(K)) l1[,i] <- ee[,i]/beta ## alpha1
839c839
<       for (i in 1:K) for (j in i:K) {
---
>       for (i in seq_len(K)) for (j in i:K) {
845c845
<       for (i in 1:K) l1[,i] <- as.numeric(y==i) - l1[,i] 
---
>       for (i in seq_len(K)) l1[,i] <- as.numeric(y==i) - l1[,i] 
855c855
<       for (i in 1:K) for (j in i:K) for (k in j:K) {
---
>       for (i in seq_len(K)) for (j in i:K) for (k in j:K) {
871c871
<       for (i in 1:K) for (j in i:K) for (k in j:K) for (l in k:K) {
---
>       for (i in seq_len(K)) for (j in i:K) for (k in j:K) for (l in k:K) {
919c919
<         for (k in 1:length(jj)) { ## loop over the linear predictors      
---
>         for (k in seq_len(length(jj))) { ## loop over the linear predictors      
962c962
<   Qy <- qr.qty(qrx,y)[1:ncol(R)]  
---
>   Qy <- qr.qty(qrx,y)[seq_len(ncol(R))]  
967c967
<   edf <- sum(qr.Q(qrr)[1:r,]^2) 
---
>   edf <- sum(qr.Q(qrr)[seq_len(r),]^2) 
971c971
<     edf <- sum(qr.Q(qrr)[1:r,]^2)
---
>     edf <- sum(qr.Q(qrr)[seq_len(r),]^2)
976c976
<     edf <- sum(qr.Q(qrr)[1:r,]^2)
---
>     edf <- sum(qr.Q(qrr)[seq_len(r),]^2)
1175c1175
<   if (length(link)!=2) stop("ziplss requires 2 links specified as character strings")
---
>   if (length(link)!=2) stop(gettextf("'%s' function requires 2 links specified as character strings", "ziplss()"))
1181c1181
<     stop(link[[i]]," link not available for ",param.names[i]," parameter of ziplss")
---
>     stop(gettextf("\"%s\" link not available for parameter of ziplss %s", param.names[i], link[[i]]))
1416c1416
<         p <- drop(x1[1:nobs,,drop=FALSE] %*% startji) ## probability of presence
---
>         p <- drop(x1[seq_len(nobs),,drop=FALSE] %*% startji) ## probability of presence
1464c1464
<     stop(link[[i]]," link not available for mu parameter of gaulss")
---
>     stop(gettextf("'%s' link not available for mu parameter of gaulss", link[[i]]))
diff -rEZbwB '--exclude=*.[lo,d,pdf,mo,po,tgz,gz,save]*' '--exclude=MD5' '--exclude=Makefile*' '--exclude=all.R' '--exclude=Changes' R-recommended/mgcv/R/gamm.r Recommended/mgcv/R/gamm.r
134c134
<   if (sum(is.na(value))>0) warning("NA's in pdTens factor")
---
>   if (sum(is.na(value))>0) warning("NA values in factor of class \"pdTens\"")
157c157
<   if (sum(is.na(value))>0) warning("NA's in pdTens matrix")
---
>   if (sum(is.na(value))>0) warning("NA values in matrix of class \"pdTens\"")
173c173
<     names(val) <- paste("sp.",1:length(val), sep ="")
---
>     names(val) <- paste("sp.", seq_len(length(val)), sep ="")
179c179
<   function(object, structName = "Tensor product smooth term", ...)
---
>   function(object, structName = gettext("Tensor product smooth term", domain = "R-mgcv"), ...)
219c219
<     nm <- paste("V", 1:len, sep = "")
---
>     nm <- paste("V", seq_len(len), sep = "")
246,247c246
<     stop(paste("An object of length", length(val),
< 	       "does not match the required parameter size"))
---
>     stop(gettextf("An object of length %d does not match the required parameter size", length(val)))
250,251c249
<     stop(paste("Must give names when initializing pdIdnot from parameter.",
< 	       "without a formula"))
---
>     stop("Must give names when initializing pdIdnot from parameter without a formula")
273c271
<     stop(paste("Cannot extract the matrix with uninitialized dimensions"))
---
>     stop("Cannot extract the matrix with uninitialized dimensions")
331c329
<   function(object, structName = "Multiple of an Identity", ...)
---
>   function(object, structName = gettext("Multiple of an Identity", domain = "R-mgcv"), ...)
354c352
<   ind <- 1:colx 
---
>   ind <- seq_len(colx )
366c364
<   for (i in 1:length(object$S)) { ## work through penalties
---
>   for (i in seq_len(length(object$S))) { ## work through penalties
392c390
<       for (j in 1:n.lev) { ## assemble full sparse model matrix
---
>       for (j in seq_len(n.lev)) { ## assemble full sparse model matrix
405c403
<     ind <- 1:length(rind)
---
>     ind <- seq_along(rind)
443c441
<   ind <- 1:ncol(object$X)
---
>   ind <- seq_len(ncol(object$X))
446c444
<   for (i in 1:length(object$S)) { ## work through penalties
---
>   for (i in seq_along(object$S)) { ## work through penalties
476c474
<        rind=1:n.para,rinc=rep(n.para,n.para),pen.ind=pen.ind)
---
>        rind=seq_len(n.para),rinc=rep(n.para,n.para),pen.ind=pen.ind)
507c505
<   D <- c(ev$values[1:p.rank],rep(1,null.rank))
---
>   D <- c(ev$values[seq_len(p.rank)],rep(1,null.rank))
523c521
<     attr(random[[1]],"Xr") <- X[,1:p.rank,drop=FALSE]
---
>     attr(random[[1]],"Xr") <- X[, seq_len(p.rank), drop = FALSE]
525c523
<     random <- list(X[,1:p.rank,drop=FALSE]) 
---
>     random <- list(X[, seq_len(p.rank), drop = FALSE]) 
529c527
<   rind <- 1:p.rank
---
>   rind <- seq_len(p.rank)
584,586c582,583
<   D <- c(ev$values[1:p.rank],rep(1,null.rank))
<   if (sum(D<=0)) stop(
<   "Tensor product penalty rank appears to be too low: please email Simon.Wood@R-project.org with details.")
---
>   D <- c(ev$values[seq_len(p.rank)],rep(1,null.rank))
>   if (sum(D<=0)) stop("Tensor product penalty rank appears to be too low: please email Simon.Wood@R-project.org with details.")
593,594c590,591
<   for (l in 1:length(object$S)) {   # transform penalty explicitly
<     object$S[[l]] <- (t(U)%*%object$S[[l]]%*%U)[1:p.rank,1:p.rank]
---
>   for (l in seq_len(length(object$S))) {   # transform penalty explicitly
>     object$S[[l]] <- (t(U)%*%object$S[[l]]%*%U)[seq_len(p.rank), seq_len(p.rank)]
607,608c604,605
<   attr(random[[1]],"Xr") <- X[,1:p.rank,drop=FALSE] ## random effect model matrix
<   rind <- 1:p.rank
---
>   attr(random[[1]],"Xr") <- X[, seq_len(p.rank), drop = FALSE] ## random effect model matrix
>   rind <- seq_len(p.rank)
620c617
<                       data=stop("No data supplied to gamm.setup"),knots=NULL,
---
>                       data=stop(gettextf("No data supplied to '%s' function", "gamm.setup()")),knots=NULL,
644c641
<   if (!is.null(G$L)) stop("gamm can not handle linked smoothing parameters (probably from use of `id' or adaptive smooths)")
---
>   if (!is.null(G$L)) stop("gamm can not handle linked smoothing parameters (probably from use of 'id' or adaptive smooths)")
653c650
<   if (G$nsdf>0) ind <- 1:G$nsdf else ind <- rep(0,0)  
---
>   if (G$nsdf>0) ind <- seq_len(G$nsdf) else ind <- rep(0,0)  
662c659
<     pord <- 1:G$m
---
>     pord <- seq_len(G$m)
666c663
<     for (i in 1:G$m) if (is.null(G$smooth[[i]]$fac)) { 
---
>     for (i in seq_len(G$m)) if (is.null(G$smooth[[i]]$fac)) { 
673c670
<       if (!is.null(attr(G$smooth[[i]],"del.index"))) stop("side conditions not allowed for nested smooths")
---
>       if (!is.null(attr(G$smooth[[i]],"del.index"))) stop("side conditions are not allowed for nested smooths")
675c672
<     if (k < G$m) pord[(k+1):G$m] <- (1:G$m)[!done] 
---
>     if (k < G$m) pord[(k+1):G$m] <- seq_len(G$m)[!done] 
679c676
<   if (G$m) for (i in 1:G$m) { ## work through the smooths
---
>   if (G$m) for (i in seq_len(G$m)) { ## work through the smooths
696c693
<       for (k in 1:length(rasm$rand)) {
---
>       for (k in seq_len(length(rasm$rand))) {
718c715
<       for (j in 1:ncol(rasm$Xf)) {
---
>       for (j in seq_len(ncol(rasm$Xf))) {
801c798
< { if (!inherits(b,"lme")) stop("object does not appear to be of class lme")
---
> { if (!inherits(b,"lme")) stop(gettextf("'%s' argument is not an object of class %s", "b", dQuote("lme")))
842c839
<     rCind <- 1:n; rCind[Cind] <- 1:n
---
>     rCind <- seq_len(n); rCind[Cind] <- seq_len(n)
848c845
<     for (i in 1:n.cg) size.cg[i] <- sum(Cgrps==Clevel[i]) # size of each coarse group
---
>     for (i in seq_len(n.cg)) size.cg[i] <- sum(Cgrps==Clevel[i]) # size of each coarse group
851c848
<   } else {n.cg <- 1;Cind<-1:n}
---
>   } else {n.cg <- 1;Cind<-seq_len(n)}
874c871
<       for (i in 1:n.cg) { 
---
>       for (i in seq_len(n.cg)) { 
876c873
<         ind[[i]] <- 1:size.cg[i]
---
>         ind[[i]] <- seq_len(size.cg[i])
884,885c881,882
<       ii <- 1:n
<       for (i in 1:n.g) # work through innermost groups
---
>       ii <- seq_len(n)
>       for (i in seq_len(n.g)) # work through innermost groups
889c886
<         k <- (1:n.cg)[Clevel==Clev] # index of coarse group - i.e. update V[[k]] 
---
>         k <- seq_len(n.cg)[Clevel==Clev] # index of coarse group - i.e. update V[[k]] 
902c899
<       for (k in 1:n.cg) { # pasting correlations into right place in each matrix
---
>       for (k in seq_len(n.cg)) { # pasting correlations into right place in each matrix
909c906
<   { for (i in 1:n.cg)
---
>   { for (i in seq_len(n.cg))
932c929
<   { for (i in 1:(n.levels-start.level+1)) # work through the r.e. groupings inner to outer
---
>   { for (i in seq_len(n.levels-start.level+1)) # work through the r.e. groupings inner to outer
948c945
<     for (i in 1:(n.levels-start.level+1))
---
>     for (i in seq_len(n.levels-start.level+1))
950c947
<       for (j in 1:b$dims$ngrps[i]) 
---
>       for (j in seq_len(b$dims$ngrps[i])) 
969c966
<       for (i in 1:n.cg) {
---
>       for (i in seq_len(n.cg)) {
976c973
<         for (i in 1:n.cg) V[[i]] <- V[[i]]+Vz[[i]] 
---
>         for (i in seq_len(n.cg)) V[[i]] <- V[[i]]+Vz[[i]] 
979c976
<         for (i in 1:n.cg) {
---
>         for (i in seq_len(n.cg)) {
998c995
< { if (!inherits(b,"lme")) stop("object does not appear to be of class lme")
---
> { if (!inherits(b,"lme")) stop(gettextf("'%s' argument is not an object of class %s", "b", dQuote("lme")))
1023,1024c1020,1021
<       ind<-ii<-1:n
<       for (i in 1:n.g) 
---
>       ind<-ii<-seq_len(n)
>       for (i in seq_len(n.g)) 
1046c1043
<   { for (i in 1:(n.levels-start.level+1)) # work through the r.e. groupings inner to outer
---
>   { for (i in seq_len(n.levels-start.level+1)) # work through the r.e. groupings inner to outer
1062c1059
<     for (i in 1:(n.levels-start.level+1))
---
>     for (i in seq_len(n.levels-start.level+1))
1064c1061
<       for (j in 1:b$dims$ngrps[i]) 
---
>       for (j in seq_len(b$dims$ngrps[i])) 
1084c1081
<     for (i in 1:length(V$V))
---
>     for (i in seq_len(length(V$V)))
1142,1143c1139
<   eval(parse(text=paste("fit0 <- glm(formula = fixed, family = family, data = data,",
<                         "weights =",wts.name,",...)")))
---
>   eval(parse(text=paste("fit0 <- glm(formula = fixed, family = family, data = data,", "weights =",wts.name,",...)")))
1171c1167
<   for (i in 1:niter) {
---
>   for (i in seq_len(niter)) {
1187c1183
<   } ## end i in 1:niter
---
>   } ## end i in seq_len(niter)
1203c1199
< { if (inherits(family,"extended.family")) warning("family are not designed for use with gamm!")
---
> { if (inherits(family,"extended.family")) warning("family are not designed for use with 'gamm()' function!")
1217c1213
<       else stop("gamm() can only handle random effects defined as named lists")
---
>       else stop("'gamm()' can only handle random effects defined as named lists")
1232c1228
<         for (i in 1:length(weights)) {
---
>         for (i in seq_len(length(weights))) {
1321c1317
<       for (i in 1:r.m) rand[[n.sr+i]]<-random[[i]]   
---
>       for (i in seq_len(r.m)) rand[[n.sr+i]]<-random[[i]]   
1363c1359
<       if (verbosePQL) cat("\n Maximum number of PQL iterations: ",niterPQL,"\n")
---
>       if (verbosePQL) cat("\n ", gettext("Maximum number of PQL iterations: ", domain = "R-mgcv"), niterPQL, "\n", sep = "")
1401,1402c1397,1398
<     if (G$nsdf) p <- bf[1:G$nsdf] else p <- array(0,0)
<     if (G$m>0) for (i in 1:G$m)
---
>     if (G$nsdf) p <- bf[seq_len(G$nsdf)] else p <- array(0,0)
>     if (G$m>0) for (i in seq_len(G$m))
1412c1408
<           for (j in 1:length(flev)) {
---
>           for (j in seq_len(length(flev))) {
1432c1428
<     if (G$m>0) for (i in 1:G$m) # var.param in reverse term order, but forward order within terms!!
---
>     if (G$m>0) for (i in seq_len(G$m)) # var.param in reverse term order, but forward order within terms!!
1447c1443
<     if (length(spl)) for (i in 1:length(spl)) if (!is.null(spl[[i]])) object$sp <- c(object$sp,spl[[i]]) 
---
>     if (length(spl)) for (i in seq_len(length(spl))) if (!is.null(spl[[i]])) object$sp <- c(object$sp,spl[[i]]) 
1458,1459c1454,1455
<       Xf <- G$Xf[,1:G$nsdf,drop=FALSE] 
<       if (G$m>0) for (i in 1:G$m) {# Accumulate the total model matrix
---
>       Xf <- G$Xf[, seq_len(G$nsdf), drop = FALSE] 
>       if (G$m>0) for (i in seq_len(G$m)) {# Accumulate the total model matrix
1468c1464
<           for (k in 1:length(flev)) {
---
>           for (k in seq_len(length(flev))) {
1479c1475
<       if (G$m>0) for (i in 1:G$m) {
---
>       if (G$m>0) for (i in seq_len(G$m)) {
1494c1490
<     if (G$m>0) for (i in 1:G$m) {# Accumulate the total penalty matrix 
---
>     if (G$m>0) for (i in seq_len(G$m)) {# Accumulate the total penalty matrix 
1498c1494
<         if (ns) for (l in 1:ns) { 
---
>         if (ns) for (l in seq_len(ns)) { 
1507,1508c1503,1504
<         for (j in 1:length(flev)) {
<            if (ns) for (l in 1:ns) { 
---
>         for (j in seq_len(length(flev))) {
>            if (ns) for (l in seq_len(ns)) { 
1522c1518
<     if (G$m) for (i in 1:G$m) { 
---
>     if (G$m) for (i in seq_len(G$m)) { 
1561c1557
<     if (G$nsdf>0) term.names<-colnames(G$X)[1:G$nsdf] else term.names<-array("",0)
---
>     if (G$nsdf>0) term.names<-colnames(G$X)[seq_len(G$nsdf)] else term.names<-array("",0)
1564c1560
<       for (i in 1:n.smooth)
---
>       for (i in seq_len(n.smooth))
1613,1615c1609,1611
<     if (fit.cor<.999) { cat("FAILED: fit.cor = ",fit.cor,"\n");return()}
<     if (edf.diff>edf.tol) { cat("FAILED: edf.diff = ",edf.diff,"\n");return()}
<     cat("PASSED \n")
---
>     if (fit.cor<.999) { cat(gettextf("TEST FAILED: fit.cor = %s",fit.cor, domain = "R-mgcv"), "\n", sep = "");return()}
>     if (edf.diff>edf.tol) { cat(gettext("TEST FAILED: edf.diff = %s",edf.diff, domain = "R-mgcv"), "\n", sep = "");return()}
>     cat(gettext("TEST PASSED", domain = "R-mgcv"), "\n", sep = "")
1622c1618
<   cat("testing covariate scale invariance ... ")  
---
>   cat(gettext("testing covariate scale invariance ... ", domain = "R-mgcv"))
1628c1624
<   cat("testing invariance w.r.t. response ... ")
---
>   cat(gettext("testing invariance w.r.t. response ... ", domain = "R-mgcv"))
1633c1629
<   cat("testing equivalence of te(x) and s(x) ... ")
---
>   cat(gettext("testing equivalence of te(x) and s(x) ... ", domain = "R-mgcv"))
1638c1634
<   cat("testing equivalence of gam and gamm with same sp ... ")
---
>   cat(gettext("testing equivalence of gam and gamm with same sp ... ", domain = "R-mgcv"))
diff -rEZbwB '--exclude=*.[lo,d,pdf,mo,po,tgz,gz,save]*' '--exclude=MD5' '--exclude=Makefile*' '--exclude=all.R' '--exclude=Changes' R-recommended/mgcv/R/jagam.r Recommended/mgcv/R/jagam.r
26c26
<     cat("  for (i in 1:n) { mu[i] <- ",iltab[family$link],"} ## expected response\n",file=file,append=TRUE)
---
>     cat("  for (i in seq_len(n)) { mu[i] <- ",iltab[family$link],"} ## expected response\n",file=file,append=TRUE)
30c30
<   cat("  for (i in 1:n) { ",file=file,append=TRUE)
---
>   cat("  for (i in seq_len(n)) { ",file=file,append=TRUE)
50c50
<   } else stop("family not implemented yet")
---
>   } else stop("family not implemented yet") #IVORY
68c68
<   for (i in 1:length(uoff)) {
---
>   for (i in seq_len(length(uoff))) {
81c81
<   rp <- qrx$pivot;rp[rp] <- 1:ncol(X)
---
>   rp <- qrx$pivot;rp[rp] <- seq_len(ncol(X))
96c96
<   if (is.null(file)) stop("jagam requires a file for the JAGS model specification")
---
>   if (is.null(file)) stop("'jagam()' function requires a file for the JAGS model specification")
99c99
<     warning("smoothing parameter prior choise not recognised, reset to gamma")
---
>     warning("smoothing parameter prior choise not recognised, reset to 'gamma'")
177c177
<     ptau <- min(prior.tau[1:G$nsdf]) 
---
>     ptau <- min(prior.tau[seq_len(G$nsdf)]) 
179c179
<     cat("  for (i in 1:",G$nsdf,") { b[i] ~ dnorm(0,",ptau,") }\n",file=file,append=TRUE,sep="")
---
>     cat("  for (i in seq_len(",G$nsdf,")) { b[i] ~ dnorm(0,",ptau,") }\n",file=file,append=TRUE,sep="")
193c193
<   for (i in 1:length(G$smooth)) {
---
>   for (i in seq_len(length(G$smooth))) {
204c204
<       if (M>0) for (j in 1:M) {
---
>       if (M>0) for (j in seq_len(M)) {
216c216
<       } else for (j in 1:M) {
---
>       } else for (j in seq_len(M)) {
227c227
<       cat("  ",Kname," <- ",Sname,"[1:",p,",1:",p,"] * lambda[",n.sp+1,"] ",
---
>       cat("  ",Kname," <- ",Sname,"[seq_len(",p,"), seq_len(",p,")] * lambda[",n.sp+1,"] ",
230c230
<         for (j in 2:M) cat(" + ",Sname,"[1:",p,",",(j-1)*p+1,":",j*p,"] * lambda[",n.sp+j,"]",
---
>         for (j in 2:M) cat(" + ",Sname,"[seq_len(",p,"), ",(j-1)*p+1,":",j*p,"] * lambda[",n.sp+j,"]",
248c248
<       cat("  for (i in 1:",n.sp,") {\n",file=file,append=TRUE,sep="")
---
>       cat("  for (i in seq_len(",n.sp,")) {\n",file=file,append=TRUE,sep="")
254c254
<       cat("  for (i in 1:",n.sp,") {\n",file=file,append=TRUE,sep="")
---
>       cat("  for (i in seq_len(",n.sp,")) {\n",file=file,append=TRUE,sep="")
269c269
<       cat("  for (i in 1:",nr,") { rho0[i] ~ dunif(-12,12) }\n",file=file,append=TRUE,sep="")
---
>       cat("  for (i in seq_len(",nr,")) { rho0[i] ~ dunif(-12,12) }\n",file=file,append=TRUE,sep="")
272c272
<       cat("  for (i in 1:",n.sp,") { lambda[i] <- exp(rho[i]) }\n",file=file,append=TRUE,sep="")
---
>       cat("  for (i in seq_len(",n.sp,")) { lambda[i] <- exp(rho[i]) }\n",file=file,append=TRUE,sep="")
275c275
<       cat("  for (i in 1:",nr,") {\n",file=file,append=TRUE,sep="")
---
>       cat("  for (i in seq_len(",nr,")) {\n",file=file,append=TRUE,sep="")
281c281
<       cat("  for (i in 1:",n.sp,") { lambda[i] <- exp(rho[i]) }\n",file=file,append=TRUE,sep="")
---
>       cat("  for (i in seq_len(",n.sp,")) { lambda[i] <- exp(rho[i]) }\n",file=file,append=TRUE,sep="")
302c302
<       warning("burnin too large, reset")
---
>       warning(gettextf("'%s' argument is too large, reset", "burnin"))
329c329
<     warning("rho missing from simulation data edf.type reset to 2")
---
>     warning("'rho' slot for 'sam' argument is missing from simulation data, 'edf.type' argument reset to 2")
345c345
<     for (i in 1:length(lambda)) {
---
>     for (i in seq_len(length(lambda))) {
369,372c369,372
<     if ("residuals"%in% arg.names) stop("residuals argument not supported")
<     if ("unconditional"%in% arg.names) stop("unconditional argument not meaningful here")
<     if ("by.resids"%in% arg.names) stop("by.resids argument not supported")
<     if ("all.terms"%in% arg.names) stop("all.terms argument not supported")
---
>     if ("residuals"%in% arg.names) stop(gettextf("'%s' argument is not supported", "residuals"))
>     if ("unconditional"%in% arg.names) stop(gettextf("'%s' argument is not meaningful here", "unconfitional"))
>     if ("by.resids"%in% arg.names) stop(gettextf("'%s' argument is not supported", "by.resids"))
>     if ("all.terms"%in% arg.names) stop(gettextf("'%s' argument is not supported", "all.terms"))
388c388
<     if ("unconditional"%in% arg.names) warning("unconditional argument not meaningful here")
---
>     if ("unconditional"%in% arg.names) warning(gettextf("'%s' argument is not meaningful here", "unconditional"))
diff -rEZbwB '--exclude=*.[lo,d,pdf,mo,po,tgz,gz,save]*' '--exclude=MD5' '--exclude=Makefile*' '--exclude=all.R' '--exclude=Changes' R-recommended/mgcv/R/mgcv.r Recommended/mgcv/R/mgcv.r
32c32
<    if (k<0) stop("argument k must be positive.")
---
>    if (k<0) stop("argument 'k' must be positive")
36c36
<    if (n != ncol(A)) stop("A not square")
---
>    if (n != ncol(A)) stop("matrix 'A' is not square")
69c69
<   for (i in 1:length(na)) {
---
>   for (i in seq_len(length(na))) {
102,105c102,105
<   if (nrow(M$X)!=nar[1]) stop("nrow(M$X) != length(M$y)") 
<   if (ncol(M$X)!=nar[2]) stop("ncol(M$X) != length(M$p)")
<   if (length(M$w)!=nar[1]) stop("length(M$w) != length(M$y)")
<   if (nar[3]!=length(M$bin)) stop("nrow(M$Ain) != length(M$bin)")
---
>   if (nrow(M$X)!=nar[1]) stop("nrow(M$X) != length(M$y)", domain = NA)
>   if (ncol(M$X)!=nar[2]) stop("ncol(M$X) != length(M$p)", domain = NA)
>   if (length(M$w)!=nar[1]) stop("length(M$w) != length(M$y)", domain = NA)
>   if (nar[3]!=length(M$bin)) stop("nrow(M$Ain) != length(M$bin)", domain = NA)
107c107
<     if (ncol(M$Ain)!=nar[2]) stop("nrow(M$Ain) != length(M$p)") 
---
>     if (ncol(M$Ain)!=nar[2]) stop("nrow(M$Ain) != length(M$p)", domain = NA) 
112c112
<       warning("initial point very close to some inequality constraints")
---
>       warning("initial point is very close to some inequality constraints")
115c115
<       warning("initial parameters very close to inequality constraints")
---
>       warning("initial parameters are very close to inequality constraints")
118,120c118,120
<   if (nrow(M$C)>0) if (ncol(M$C)!=nar[2]) stop("ncol(M$C) != length(M$p)")  
<   if (length(M$S)!=length(M$off)) stop("M$S and M$off have different lengths")
<   if (length(M$S)!=length(M$sp)) stop("M$sp has different length to M$S and M$off")
---
>   if (nrow(M$C)>0) if (ncol(M$C)!=nar[2]) stop("ncol(M$C) != length(M$p)", domain = NA) 
>   if (length(M$S)!=length(M$off)) stop(gettextf("'%s' and '%s' components should have the same length", "M$S", "M$off"))
>   if (length(M$S)!=length(M$sp)) stop(gettextf("'%s', '%s' and '%s' components should have the same length", "M$sp", "M$S", "M$off"))
126c126
<   if (m>0) for (i in 1:m)
---
>   if (m>0) for (i in seq_len(m))
159c159
<   if ("[["%in%vn) stop("can't handle [[ in formula")
---
>   if ("[["%in%vn) stop("can't handle '[[' in formula")
168c168
<       vn1 <- c(vn1,paste(vn[ii[k]+1:n],collapse="$"))
---
>       vn1 <- c(vn1,paste(vn[ii[k]+seq_len(n)],collapse="$"))
212,213c212,213
<   if (length(sp)>0) for (i in 1:length(sp)) {
<     ind <- (1:nt)[as.logical(vtab[sp[i],])]
---
>   if (length(sp)>0) for (i in seq_along(sp)) {
>     ind <- seq_len(nt)[as.logical(vtab[sp[i],])]
216,217c216,217
<   if (length(tp)>0) for (i in 1:length(tp)) {
<     ind <- (1:nt)[as.logical(vtab[tp[i],])]
---
>   if (length(tp)>0) for (i in seq_along(tp)) {
>     ind <- seq_len(nt)[as.logical(vtab[tp[i],])]
220,221c220,221
<   if (length(tip)>0) for (i in 1:length(tip)) {
<     ind <- (1:nt)[as.logical(vtab[tip[i],])]
---
>   if (length(tip)>0) for (i in seq_along(tip)) {
>     ind <- seq_len(nt)[as.logical(vtab[tip[i],])]
224,225c224,225
<   if (length(t2p)>0) for (i in 1:length(t2p)) {
<     ind <- (1:nt)[as.logical(vtab[t2p[i],])]
---
>   if (length(t2p)>0) for (i in seq_along(t2p)) {
>     ind <- seq_len(nt)[as.logical(vtab[t2p[i],])]
228,229c228,229
<   if (length(zp)>0) for (i in 1:length(zp)) {
<     ind <- (1:nt)[as.logical(vtab[zp[i],])]
---
>   if (length(zp)>0) for (i in seq_along(zp)) {
>     ind <- seq_len(nt)[as.logical(vtab[zp[i],])]
243c243
<   if (nt) for (i in 1:nt) { # work through all terms
---
>   if (nt) for (i in seq_len(nt)) { # work through all terms
292c292
<   for (i in 1:length(smooth.spec)) {
---
>   for (i in seq_len(length(smooth.spec))) {
294c294
<     ff1 <- paste(smooth.spec[[i]]$term[1:nt],collapse="+")
---
>     ff1 <- paste(smooth.spec[[i]]$term[seq_len(nt)],collapse="+")
345c345
<     for (i in 1:d) {
---
>     for (i in seq_len(d)) {
373c373
<     for (i in 1:d) if (max(ret[[i]]$lpi)>nlp||min(ret[[i]]$lpi)<1) stop("linear predictor labels out of range")
---
>     for (i in seq_len(d)) if (max(ret[[i]]$lpi)>nlp||min(ret[[i]]$lpi)<1) stop("linear predictor labels out of range")
392c392
<     QtX2[-(1:r),] <- 0
---
>     QtX2[-seq_len(r),] <- 0
394,395c394,395
<     if (rank.def>0) ind <- (1:ncol(X2))[rank(mdiff) <= rank.def] else
<     ind <- (1:ncol(X2))[mdiff < R11*tol]
---
>     if (rank.def>0) ind <- seq_len(ncol(X2))[rank(mdiff) <= rank.def] else
>     ind <- seq_len(ncol(X2))[mdiff < R11*tol]
451c451
<   for (i in 1:m) { ## collect all term names and max smooth `dim'
---
>   for (i in seq_len(m)) { ## collect all term names and max smooth `dim'
480c480
<   for (i in 1:length(sm.id)) sm.id[[i]]<-array(0,0)
---
>   for (i in seq_len(length(sm.id))) sm.id[[i]]<-array(0,0)
482,484c482,484
<   for (d in 1:maxDim) {
<     for (i in 1:m) {
<       if (sm[[i]]$dim==d&&sm[[i]]$side.constrain) for (j in 1:d) { ## work through terms
---
>   for (d in seq_len(maxDim)) {
>     for (i in seq_len(m)) {
>       if (sm[[i]]$dim==d&&sm[[i]]$side.constrain) for (j in seq_len(d)) { ## work through terms
496c496
<   if (maxDim==1) warning("model has repeated 1-d smooths of same variable.")
---
>   if (maxDim==1) warning("model has repeated 1-d smooths of same variable")
502c502
<     for (i in 1:m) { ## create parameter indices for each term
---
>     for (i in seq_len(m)) { ## create parameter indices for each term
511,512c511,512
<   for (d in 1:maxDim) { ## work up through dimensions 
<     for (i in 1:m) { ## work through smooths
---
>   for (d in seq_len(maxDim)) { ## work up through dimensions 
>     for (i in seq_len(m)) { ## work through smooths
517c517
<         for (j in 1:d) { ## work through variables
---
>         for (j in seq_len(d)) { ## work through variables
519,520c519,520
<           k <- (1:length(b))[b==i] ## locate current smooth in list 
<           if (k>1) for (l in 1:(k-1)) if (!b[l] %in% X1comp) { ## collect X columns
---
>           k <- (seq_along(b))[b==i] ## locate current smooth in list 
>           if (k>1) for (l in seq_len(k-1)) if (!b[l] %in% X1comp) { ## collect X columns
555c555
<             if (mi>1) for (j in 1:mi) St <- St + 
---
>             if (mi>1) for (j in seq_len(mi)) St <- St + 
585c585
<     } ## end i in 1:m loop
---
>     } ## end i in seq_len(m) loop
587c587
<   if (with.pen) for (i in 1:m) { ## remove working variables that were added
---
>   if (with.pen) for (i in seq_len(m)) { ## remove working variables that were added
599c599
<  if (specb$dim!=spec$dim) stop("`id' linked smooths must have same number of arguments") 
---
>  if (specb$dim!=spec$dim) stop("'id' linked smooths must have same number of arguments") 
606c606
<     for (i in 1:length(specb$margin)) {
---
>     for (i in seq_len(length(specb$margin))) {
608c608
<          for (j in 1:length(specb$margin[[i]]$term)) {
---
>          for (j in seq_len(length(specb$margin[[i]]$term))) {
645c645
<   if (n.t>0) for (j in 1:n.t) if (tind[j]>0) {
---
>   if (n.t>0) for (j in seq_len(n.t)) if (tind[j]>0) {
649c649
<       ind <- (1:length(assign))[assign==tind[j]] ## index of coefs involved here
---
>       ind <- seq_len(length(assign))[assign==tind[j]] ## index of coefs involved here
656,657c656,657
<       if (!is.null(ranki)&&length(ranki)!=np) stop("`rank' has wrong length in `paraPen'") 
<       if (np) for (i in 1:np) { ## unpack penalty matrices, offsets and ranks
---
>       if (!is.null(ranki)&&length(ranki)!=np) stop("'rank' has wrong length in 'paraPen'") 
>       if (np) for (i in seq_len(np)) { ## unpack penalty matrices, offsets and ranks
670c670
<         if (nrow(Li)!=np) stop("L has wrong dimension in `paraPen'")
---
>         if (nrow(Li)!=np) stop("'L' has wrong dimension in 'paraPen'")
678c678
<           if (length(spi)!=ncol(Li)) stop("`sp' dimension wrong in `paraPen'")
---
>           if (length(spi)!=ncol(Li)) stop("'sp' dimension wrong in 'paraPen'")
692,693c692,693
<     if (length(sp0)<length(sp)) stop("`sp' too short")
<     sp0 <- sp0[1:length(sp)]
---
>     if (length(sp0)<length(sp)) stop("'sp' is too short")
>     sp0 <- sp0[seq_len(length(sp))]
742c742
<   ii <- 1:n
---
>   ii <- seq_len(n)
746c746
<   for (i in 1:nf) {
---
>   for (i in seq_len(nf)) {
749c749
<       ind <- pstart[i] + 1:nsdf[i] - 1
---
>       ind <- pstart[i] + seq_len(nsdf[i]) - 1
774c774
<       for (i in 1:nlp) { 
---
>       for (i in seq_len(nlp)) { 
788c788
<                     data=stop("No data supplied to gam.setup"),knots=NULL,sp=NULL,
---
>                     data=stop(gettextf("No data supplied to '%s' function", "gam.setup()")),knots=NULL,sp=NULL,
795,796c795,796
<   if (!is.null(paraPen)) stop("paraPen not supported for multi-formula models")
<   if (!absorb.cons) stop("absorb.cons must be TRUE for multi-formula models")
---
>   if (!is.null(paraPen)) stop("'paraPen' argument is not supported for multi-formula models")
>   if (!absorb.cons) stop("'absorb.cons' argument must be TRUE for multi-formula models")
799c799
<   if (length(drop.intercept) != d) stop("length(drop.intercept) should be equal to number of model formulas")
---
>   if (length(drop.intercept) != d) stop("'length(drop.intercept)' should be equal to number of model formulas")
813,814c813,814
<   if (!is.null(sp)&&used.sp>0) sp <- sp[-(1:used.sp)] ## need to strip off already used sp's
<   if (!is.null(min.sp)&&nrow(G$L)>0) min.sp <- min.sp[-(1:nrow(G$L))]  
---
>   if (!is.null(sp)&&used.sp>0) sp <- sp[-seq_len(used.sp)] ## need to strip off already used sp's
>   if (!is.null(min.sp)&&nrow(G$L)>0) min.sp <- min.sp[-seq_len(nrow(G$L))]  
819,820c819,820
<   for (i in 1:formula$nlp) lpi[[i]] <- rep(0,0)
<   lpi[[1]] <- 1:ncol(G$X) ## lpi[[j]] is index of cols for jth linear predictor 
---
>   for (i in seq_len(formula$nlp)) lpi[[i]] <- rep(0,0)
>   lpi[[1]] <- seq_len(ncol(G$X)) ## lpi[[j]] is index of cols for jth linear predictor 
838,839c838,839
<     if (!is.null(sp)&&used.sp>0) sp <- sp[-(1:used.sp)] ## need to strip off already used sp's
<     if (!is.null(min.sp)&&nrow(um$L)>0) min.sp <- min.sp[-(1:nrow(um$L))]  
---
>     if (!is.null(sp)&&used.sp>0) sp <- sp[-seq_len(used.sp)] ## need to strip off already used sp's
>     if (!is.null(min.sp)&&nrow(um$L)>0) min.sp <- min.sp[-seq_len(nrow(um$L))]  
843c843
<       lpi[[j]] <- c(lpi[[j]],pof + 1:ncol(um$X)) ## add these cols to lpi[[j]]
---
>       lpi[[j]] <- c(lpi[[j]],pof + seq_len(ncol(um$X))) ## add these cols to lpi[[j]]
848c848
<       stop("shared offsets not allowed")
---
>       stop("shared offsets are not allowed")
860c860
<     if (um$m) for (j in 1:um$m) {
---
>     if (um$m) for (j in seq_len(um$m)) {
877c877
<     if (M) for (j in 1:M) {
---
>     if (M) for (j in seq_len(M)) {
892c892
<     if (um$nsdf>0) um$term.names[1:um$nsdf] <- paste(um$term.names[1:um$nsdf],i-1,sep=".")
---
>     if (um$nsdf>0) um$term.names[seq_len(um$nsdf)] <- paste(um$term.names[seq_len(um$nsdf)],i-1,sep=".")
911c911
<       for (i in 1:length(G$smooth)) {
---
>       for (i in seq_len(length(G$smooth))) {
916c916
<       for (i in 1:length(G$off)) G$off[i] <- G$off[i] - sum(rt$dind < G$off[i])
---
>       for (i in seq_len(length(G$off))) G$off[i] <- G$off[i] - sum(rt$dind < G$off[i])
932c932
<                      data=stop("No data supplied to gam.setup"),knots=NULL,sp=NULL,
---
>                      data=stop(gettextf("No data supplied to '%s' function", "gam.setup()")),knots=NULL,sp=NULL,
1017c1017
<     ind <- 1:length(PP$sp)
---
>     ind <- seq_len(length(PP$sp))
1031c1031
<     if (m>0) for (i in 1:m) attr(split$smooth.spec[[i]],"gamm") <- TRUE
---
>     if (m>0) for (i in seq_len(m)) attr(split$smooth.spec[[i]],"gamm") <- TRUE
1036c1036
<     for (i in 1:m) if (!is.null(split$smooth.spec[[i]]$id)) {
---
>     for (i in seq_len(m)) if (!is.null(split$smooth.spec[[i]]$id)) {
1052c1052
<         for (j in 1:length(temp.term)) id.list[[id]]$data[[j]] <- cbind(id.list[[id]]$data[[j]],
---
>         for (j in seq_len(length(temp.term))) id.list[[id]]$data[[j]] <- cbind(id.list[[id]]$data[[j]],
1061c1061
<         for (j in 1:length(term)) id.list[[id]]$data[[j]] <- get.var(term[j],data,vecMat=FALSE)
---
>         for (j in seq_along(term)) id.list[[id]]$data[[j]] <- get.var(term[j],data,vecMat=FALSE)
1070c1070
<   if (m>0) for (i in 1:m) {
---
>   if (m>0) for (i in seq_len(m)) {
1087c1087
<     for (j in 1:length(sml)) {
---
>     for (j in seq_along(sml)) {
1099c1099
<     if (!apply.by) for (i in 1:length(sm)) { ## restore any by-free model matrices
---
>     if (!apply.by) for (i in seq_len(length(sm))) { ## restore any by-free model matrices
1113c1113
<   if (m>0) for (i in 1:m) {
---
>   if (m>0) for (i in seq_len(m)) {
1122c1122
<           if (is.null(Sname)) spn <- paste(sm[[i]]$label,1:length.S,sep="") else
---
>           if (is.null(Sname)) spn <- paste(sm[[i]]$label, seq_len(length.S),sep="") else
1142c1142
<         stop("Later terms sharing an `id' can not have more smoothing parameters than the first such term")
---
>         stop("Later terms sharing an 'id' can not have more smoothing parameters than the first such term")
1155c1155
<   if (m>0) for (i in 1:m) {
---
>   if (m>0) for (i in seq_len(m)) {
1193c1193
<     QtX <- qr.qty(qrx,X)[1:rank,]
---
>     QtX <- qr.qty(qrx,X)[seq_len(rank),]
1195c1195
<       R <- R[1:rank,]
---
>       R <- R[seq_len(rank),]
1207c1207
<   if (G$nsdf>0) G$cmX[-(1:G$nsdf)] <- 0 ## zero the smooth parts here 
---
>   if (G$nsdf>0) G$cmX[-seq_len(G$nsdf)] <- 0 ## zero the smooth parts here 
1227c1227
<       warning("Supplied smoothing parameter vector is too short - ignored.")
---
>       warning("Supplied smoothing parameter vector is too short - ignored")
1231c1231
<       warning("NA's in supplied smoothing parameter vector - ignoring.")
---
>       warning("NA values in supplied smoothing parameter vector - ignoring")
1244c1244
<   if (m>0) for (i in 1:m) {
---
>   if (m>0) for (i in seq_len(m)) {
1270,1271c1270,1271
<   if (length(idx)) for (i in 1:length(idx)) idx[[i]]$sp.done <- FALSE
<   if (m>0) for (i in 1:m) { ## work through all smooths
---
>   if (length(idx)) for (i in seq_along(idx)) idx[[i]]$sp.done <- FALSE
>   if (m>0) for (i in seq_len(m)) { ## work through all smooths
1291,1294c1291,1294
<     if (length(min.sp)<nrow(L)) stop("length of min.sp is wrong.")
<     min.sp <- min.sp[1:nrow(L)]
<     if (sum(is.na(min.sp))) stop("NA's in min.sp.")
<     if (sum(min.sp<0)) stop("elements of min.sp must be non negative.")
---
>     if (length(min.sp)<nrow(L)) stop(gettextf("'%s' argument is of the wrong length", "min.sp"))
>     min.sp <- min.sp[seq_len(nrow(L))]
>     if (sum(is.na(min.sp))) stop("NA values in 'min.sp' argument")
>     if (sum(min.sp<0)) stop("elements of 'min.sp' argument must be non negative")
1299c1299
<   if (m>0) for (i in 1:m) {
---
>   if (m>0) for (i in seq_len(m)) {
1302c1302
<     for (j in 1:length(sm$S)) {  # work through penalty matrices
---
>     for (j in seq_along(sm$S)) {  # work through penalty matrices
1328c1328
<       for (i in 1:length(PP$S)) {
---
>       for (i in seq_len(length(PP$S))) {
1344,1345c1344,1345
<     ef0 <- indi <- (1:length(ind))[ind]
<     if (length(indi)>0) for (i in 1:length(indi)) {
---
>     ef0 <- indi <- seq_len(length(ind))[ind]
>     if (length(indi)>0) for (i in seq_len(length(indi))) {
1368c1368
<       for (i in 1:m) {
---
>       for (i in seq_len(m)) {
1391c1391
<   if (G$nsdf > 0) term.names <- colnames(G$X)[1:G$nsdf] else term.names<-array("",0)
---
>   if (G$nsdf > 0) term.names <- colnames(G$X)[seq_len(G$nsdf)] else term.names<-array("",0)
1394c1394
<   for (i in 1:n.smooth) { ## create coef names, if smooth has any coefs!
---
>   for (i in seq_len(n.smooth)) { ## create coef names, if smooth has any coefs!
1433c1433
<   if (!optimizer[2]%in%c("newton","bfgs","nlm","optim","nlm.fd")) stop("unknown outer optimization method.")
---
>   if (!optimizer[2]%in%c("newton","bfgs","nlm","optim","nlm.fd")) stop("unknown outer optimization method")
1435c1435
<   if (optimizer[2]%in%c("nlm.fd")) .Deprecated(msg=paste("optimizer",optimizer[2],"is deprecated, please use newton or bfgs"))
---
>   if (optimizer[2]%in%c("nlm.fd")) .Deprecated(msg=gettextf("optimizer %s is deprecated, please use newton or bfgs", optimizer[2]))
1613c1613
<   if (length(G$S)>0) for (i in 1:length(G$S)) G$UrS[[i]] <- t(Ssp$Y)%*%G$rS[[i]] else i <- 0
---
>   if (length(G$S)>0) for (i in seq_len(length(G$S))) G$UrS[[i]] <- t(Ssp$Y)%*%G$rS[[i]] else i <- 0
1747c1747
<       ind <- 1:nlsp + nth ## only used if nlsp>0
---
>       ind <- seq_len(nlsp) + nth ## only used if nlsp>0
1771c1771
<     if (inherits(G$family,"extended.family")&&nth>0) object$sp <- object$sp[-(1:nth)] ## drop theta params
---
>     if (inherits(G$family,"extended.family")&&nth>0) object$sp <- object$sp[-seq_len(nth)] ## drop theta params
1838c1838
<    ## if (v.n) for (i in 1:v.n) if (length(dl[[i]])<n) dl[[i]] <- NULL 
---
>    ## if (v.n) for (i in seq_len(v.n)) if (length(dl[[i]])<n) dl[[i]] <- NULL 
1843c1843
<      for (i in 1:v.n) if (length(dl[[i]])>=n) { 
---
>      for (i in seq_len(v.n)) if (length(dl[[i]])>=n) { 
1847c1847
<      if (k>0) v.name <- v.name[1:k] else v.name <- rep("",k)
---
>      if (k>0) v.name <- v.name[seq_len(k)] else v.name <- rep("",k)
1854c1854
<    if (v.n>0) for (i in 1:v.n) {
---
>    if (v.n>0) for (i in seq_len(v.n)) {
1866c1866
<          ii <- min((1:length(lx))[freq==max(freq)])
---
>          ii <- min(seq_len(length(lx))[freq==max(freq)])
1938c1938
<       for (i in 1:length(formula)) {
---
>       for (i in seq_len(length(formula))) {
1997c1997
<     if (G$m) for (i in 1:G$m) G$min.edf<-G$min.edf+G$smooth[[i]]$null.space.dim
---
>     if (G$m) for (i in seq_len(G$m)) G$min.edf<-G$min.edf+G$smooth[[i]]$null.space.dim
2058c2058
<   if (is.list(x$formula)) for (i in 1:length(x$formula)) print(x$formula[[i]]) else
---
>   if (is.list(x$formula)) for (i in seq_len(length(x$formula))) print(x$formula[[i]]) else
2062c2062
<   cat("Total model degrees of freedom",sum(x$edf),"\n")
---
>   cat(gettextf("Total model degrees of freedom %s",sum(x$edf), domain = "R-mgcv"), "\n", sep = "")
2065,2066c2065,2066
<     cat("\nEstimated degrees of freedom:\n")
<     for (i in 1:n.smooth)
---
>     cat("\n", gettext("Estimated degrees of freedom:", domain = "R-mgcv"), "\n", sep = "")
>     for (i in seq_len(n.smooth))
2069c2069
<     for (i in 1:n.smooth) {   
---
>     for (i in seq_len(n.smooth)) {   
2073c2073
<     cat(" total =",round(sum(x$edf),digits=2),"\n")
---
>     cat(gettextf(" total df = %s",round(sum(x$edf),digits=2), domain = "R-mgcv"), "\n", sep = "")
2076,2077c2076,2077
<   cat("\n",x$method," score: ",x$gcv.ubre,"     ",sep="")
<   if (!is.null(x$rank) && x$rank< length(x$coefficients)) cat("rank: ",x$rank,"/",length(x$coefficients),sep="") 
---
>   cat("\n", gettextf("%s score = %s", sQuote(x$method), x$gcv.ubre, domain = "R-mgcv"), "     ", sep = "")
>   if (!is.null(x$rank) && x$rank< length(x$coefficients)) cat(gettextf("Rank: %s/%s", x$rank, length(x$coefficients), domain = "R-mgcv"), sep = "") 
2098,2101c2098,2100
<     if (!is.logical(edge.correct)&&(!is.numeric(edge.correct)||edge.correct<0)) stop(
<         "edge.correct must be logical or a positive number")
<     if (!is.numeric(nthreads) || nthreads <1) stop("nthreads must be a positive integer") 
<     if (!is.numeric(irls.reg) || irls.reg <0.0) stop("IRLS regularizing parameter must be a non-negative number.")
---
>     if (!is.logical(edge.correct)&&(!is.numeric(edge.correct)||edge.correct<0)) stop("edge.correct must be logical or a positive number")
>     if (!is.numeric(nthreads) || nthreads <1) stop("'nthreads' argument must be a positive integer") 
>     if (!is.numeric(irls.reg) || irls.reg <0.0) stop("IRLS regularizing parameter must be a non-negative number")
2108c2107
<       warning("silly value supplied for rank.tol: reset to square root of machine precision.")
---
>       warning("silly value supplied for rank.tol: reset to square root of machine precision")
2200c2199
<   for (i in 1:length(G$S))
---
>   for (i in seq_len(length(G$S)))
2232c2231
<     if (!olm)  .Deprecated(msg="performance iteration with gam is deprecated, use bam instead")
---
>     if (!olm)  .Deprecated(msg=gettext("performance iteration with gam is deprecated, use bam instead"))
2256c2255
<       for (i in 1:n.S) S.size[i]<-mean(abs(G$S[[i]])) 
---
>       for (i in seq_len(n.S)) S.size[i]<-mean(abs(G$S[[i]])) 
2268c2267
<         stop("illegal `family' argument")
---
>         stop("invalid 'family' argument")
2283c2282
<         stop("y must be univariate unless binomial")
---
>         stop("'y' must be univariate unless binomial")
2291c2290
<     stop(gettextf("Length of start should equal %d and correspond to initial coefs.",nvars)) 
---
>     stop(gettextf("Length of start should equal %d and correspond to initial coefs", nvars))
2311c2310
<     for (iter in 1:(control$maxit)) 
---
>     for (iter in seq_len(control$maxit)) 
2316c2315
<             stop("NAs in V(mu)")
---
>             stop("NA values in V(mu)")
2321c2320
<             stop("NAs in d(mu)/d(eta)")
---
>             stop("NA values in d(mu)/d(eta)")
2345c2344
<         stop("iterative weights or data non-finite in gam.fit - regularization may help. See ?gam.control.")
---
>         stop("iterative weights or data non-finite in gam.fit - regularization may help. See ?gam.control")
2383,2384c2382
<             stop("no valid set of coefficients has been found:please supply starting values",
<             call. = FALSE)
---
>             stop("no valid set of coefficients has been found:please supply starting values", call. = FALSE)
2389c2387
<                   stop("inner loop 1; can't correct step size")
---
>                   stop(gettextf("inner loop %d; can't correct step size", 1))
2399c2397
<                 cat("Step halved: new deviance =", dev, "\n")
---
>                 cat(gettextf("Step halved: new deviance = %g", dev, domain = "R-mgcv"), "\n", sep = "")
2402c2400
<             warning("Step size truncated: out of bounds.",call.=FALSE)
---
>             warning("Step size truncated: out of bounds",call. = FALSE)
2406c2404
<                   stop("inner loop 2; can't correct step size")
---
>                   stop(gettextf("inner loop %d; can't correct step size", 2))
2416c2414
<                 cat("Step halved: new deviance =", dev, "\n")
---
>                 cat(gettextf("Step halved: new deviance = %g", dev, domain = "R-mgcv"), "\n", sep = "")
2487c2485
< { if (!inherits(object,"gam")) stop("`object' is not of class \"gam\"")
---
> { if (!inherits(object,"gam")) stop(gettextf("'%s' argument is not an object of class %s", "object", dQuote("gam")))
2557c2555
<     warning("Unknown type, reset to terms.")
---
>     warning("Unknown type, reset to terms")
2590,2591c2588
<         if (sum(!(names(object$model)%in%names(newdata)))) stop(
<         "newdata is a model.frame: it should contain all required variables\n")
---
>         if (sum(!(names(object$model)%in%names(newdata)))) stop("newdata is a model.frame: it should contain all required variables\n")
2656c2653
<     for (i in 1:length(newdata)) 
---
>     for (i in seq_len(length(newdata))) 
2661c2658
<         msg <- paste(paste(levn[!levn%in%levm],collapse=", "),"not in original fit",collapse="")
---
>         msg <- gettextf("%s not in original fit", paste(levn[!levn%in%levm], collapse = ", "), domain = "R-mgcv")
2727c2724
<       warning("type iterms not available for multiple predictor cases")
---
>       warning("type 'iterms' is not available for multiple predictor cases")
2733c2730
<     for (i in 1:length(object$nsdf)) {
---
>     for (i in seq_len(length(object$nsdf))) {
2735c2732
<       if (object$nsdf[i]>0) pind <- c(pind,pstart[i]-1+1:object$nsdf[i])
---
>       if (object$nsdf[i]>0) pind <- c(pind,pstart[i]-1+seq_len(object$nsdf[i]))
2741c2738
<     pind <- 1:object$nsdf ## index of parameteric coefficients
---
>     pind <- seq_len(object$nsdf) ## index of parameteric coefficients
2772c2769
<   if (n.blocks > 0) for (b in 1:n.blocks) { # work through prediction blocks
---
>   if (n.blocks > 0) for (b in seq_len(n.blocks)) { # work through prediction blocks
2779c2776
<     for (i in 1:length(Terms)) { ## loop for parametric components (1 per lp)
---
>     for (i in seq_len(length(Terms))) { ## loop for parametric components (1 per lp)
2802c2799
<       if (object$nsdf[i]>0) X[,pstart[i]-1 + 1:object$nsdf[i]] <- Xp
---
>       if (object$nsdf[i]>0) X[,pstart[i]-1 + seq_len(object$nsdf[i])] <- Xp
2808c2805
<     if (n.smooth) for (k in 1:n.smooth) { ## loop through smooths
---
>     if (n.smooth) for (k in seq_len(n.smooth)) { ## loop through smooths
2833,2834c2830,2831
<       for (j in 1:length(lass)) if (length(lass[[j]])) { ## work through assign list
<         ind <- 1:length(lass[[j]]) ## index vector for coefs involved
---
>       for (j in seq_len(length(lass))) if (length(lass[[j]])) { ## work through assign list
>         ind <- seq_len(length(lass[[j]])) ## index vector for coefs involved
2836c2833
<         if (nptj>0) for (i in 1:nptj) { ## work through parametric part
---
>         if (nptj>0) for (i in seq_len(nptj)) { ## work through parametric part
2845c2842
<         for (k in 1:n.smooth) # work through the smooth terms 
---
>         for (k in seq_len(n.smooth)) # work through the smooth terms 
2890,2891c2887,2888
<           off.ind <- (1:n.smooth)[as.logical(colSums(abs(Xoff)))]
<           for (j in 1:nlp) { ## looping over the model formulae
---
>           off.ind <- seq_len(n.smooth)[as.logical(colSums(abs(Xoff)))]
>           for (j in seq_len(nlp)) { ## looping over the model formulae
3035c3032
<   if (!inherits(b,"gam")) stop("requires an object of class gam")
---
>   if (!inherits(b,"gam")) stop(gettextf("'%s' argument is not an object of class %s", "b", dQuote("gam")))
3044c3041
<   for (i in 1:m) { ## loop through smooths
---
>   for (i in seq_len(m)) { ## loop through smooths
3062c3059
<     for (i in 1:m) {
---
>     for (i in seq_len(m)) {
3066c3063
<       R <- qr.R(qr(cbind(Xi,Xj),LAPACK=FALSE,tol=0))[,-(1:r),drop=FALSE] ## No pivoting!!  
---
>       R <- qr.R(qr(cbind(Xi,Xj),LAPACK=FALSE,tol=0))[,-seq_len(r),drop=FALSE] ## No pivoting!!  
3070c3067
<       conc[1,i] <- svd(forwardsolve(t(Rt),t(R[1:r,,drop=FALSE])))$d[1]^2
---
>       conc[1,i] <- svd(forwardsolve(t(Rt),t(R[seq_len(r),,drop=FALSE])))$d[1]^2
3074c3071
<       conc[2,i] <- sum((R[1:r,,drop=FALSE]%*%beta)^2)/sum((Rt%*%beta)^2)
---
>       conc[2,i] <- sum((R[seq_len(r),,drop=FALSE]%*%beta)^2)/sum((Rt%*%beta)^2)
3077c3074
<       conc[3,i] <- sum(R[1:r,]^2)/sum(R^2)
---
>       conc[3,i] <- sum(R[seq_len(r),]^2)/sum(R^2)
3083,3084c3080,3081
<     for (i in 1:n.measures) conc[[i]] <- matrix(1,m,m) ## concurvity matrix
<     for (i in 1:m) { ## concurvity calculation loop
---
>     for (i in seq_len(n.measures)) conc[[i]] <- matrix(1,m,m) ## concurvity matrix
>     for (i in seq_len(m)) { ## concurvity calculation loop
3087c3084
<       for (j in 1:m) if (i!=j) { 
---
>       for (j in seq_len(m)) if (i!=j) { 
3089c3086
<         R <- qr.R(qr(cbind(Xi,Xj),LAPACK=FALSE,tol=0))[,-(1:r),drop=FALSE] ## No pivoting!!  
---
>         R <- qr.R(qr(cbind(Xi,Xj),LAPACK=FALSE,tol=0))[,-seq_len(r),drop=FALSE] ## No pivoting!!  
3093c3090
<         conc[[1]][i,j] <- svd(forwardsolve(t(Rt),t(R[1:r,,drop=FALSE])))$d[1]^2
---
>         conc[[1]][i,j] <- svd(forwardsolve(t(Rt),t(R[seq_len(r),,drop=FALSE])))$d[1]^2
3097c3094
<         conc[[2]][i,j] <- sum((R[1:r,,drop=FALSE]%*%beta)^2)/sum((Rt%*%beta)^2)
---
>         conc[[2]][i,j] <- sum((R[seq_len(r),,drop=FALSE]%*%beta)^2)/sum((Rt%*%beta)^2)
3100c3097
<         conc[[3]][i,j] <- sum(R[1:r,]^2)/sum(R^2)
---
>         conc[[3]][i,j] <- sum(R[seq_len(r),]^2)/sum(R^2)
3109c3106
<     for (i in 1:n.measures) rownames(conc[[i]]) <- colnames(conc[[i]]) <- lab
---
>     for (i in seq_len(n.measures)) rownames(conc[[i]]) <- colnames(conc[[i]]) <- lab
3143c3140
<       warning("Pearson residuals not available for this family - returning deviance residuals")
---
>       warning("Pearson residuals are not available for this family - returning deviance residuals")
3172c3169
< #    for (i in 1:length(x)) r[i] <- davies(x[i],lambda,h)$Qq
---
> #    for (i in seq_len(length(x))) r[i] <- davies(x[i],lambda,h)$Qq
3176c3173
<   if (length(h) != length(lambda)) stop("lambda and h should have the same length!")
---
>   if (length(h) != length(lambda)) stop(gettextf("'%s' and '%s' arguments should have the same length", "lambda", "h"))
3216c3213
<   p <- (1:nq-.5)/nq
---
>   p <- (seq_len(nq)-.5)/nq
3235c3232
<   if (!inherits(b,"gam")) stop("recov works with fitted gam objects only") 
---
>   if (!inherits(b,"gam")) stop(gettextf("'%s' argument is not an object of class %s", "b", dQuote("gam")))
3242c3239
<       for (i in 1:length(b$smooth)) { 
---
>       for (i in seq_len(length(b$smooth))) { 
3245c3242
<         if (ns>0) for (j in 1:ns) {
---
>         if (ns>0) for (j in seq_len(ns)) {
3261c3258
<   if (m%in%re) stop("m can't be in re")
---
>   if (m%in%re) stop("'m' argument  can't be in 're' argument")
3265c3262
<   for (i in 1:length(re)) {
---
>   for (i in seq_len(length(re))) {
3271,3272c3268,3269
<   map[rind] <- 1:p2 ## random
<   map[!rind] <- 1:p1 ## fixed
---
>   map[rind] <- seq_len(p2) ## random
>   map[!rind] <- seq_len(p1) ## fixed
3283c3280
<   for (i in 1:length(b$smooth)) { 
---
>   for (i in seq_len(length(b$smooth))) { 
3287c3284
<     if (ns>0) for (j in 1:ns) {
---
>     if (ns>0) for (j in seq_len(ns)) {
3346c3343
<   for (i in 1:length(b$smooth)) if (!is.null(b$smooth[[i]]$random)&&b$smooth[[i]]$random&&i!=m) rind <- c(rind,i)
---
>   for (i in seq_len(length(b$smooth))) if (!is.null(b$smooth[[i]]$random)&&b$smooth[[i]]$random&&i!=m) rind <- c(rind,i)
3404c3401
<   if (k1<ncol(vec)) vec <- vec[,1:k1,drop=FALSE]
---
>   if (k1<ncol(vec)) vec <- vec[,seq_len(k1),drop=FALSE]
3408c3405
<      if (k>1) vec[,1:(k-1)] <- t(t(vec[,1:(k-1)])/sqrt(ed$val[1:(k-1)]))
---
>      if (k>1) vec[,seq_len(k-1)] <- t(t(vec[,seq_len(k-1)])/sqrt(ed$val[seq_len(k-1)]))
3422c3419
<             t(t(vec)/sqrt(ed$val[1:k]))
---
>             t(t(vec)/sqrt(ed$val[seq_len(k)]))
3490c3487
<     warning("p-values for any terms that can be penalized to zero will be unreliable: refit model to fix this.")
---
>     warning("p-values for any terms that can be penalized to zero will be unreliable: refit model to fix this")
3517c3514
<       for (i in 1:length(object$nsdf)) if (object$nsdf[i]>0) ind <- 
---
>       for (i in seq_len(length(object$nsdf))) if (object$nsdf[i]>0) ind <- 
3519c3516
<     } else { pstart <- 1;ind <- 1:object$nsdf} ## only one lp
---
>     } else { pstart <- 1;ind <- seq_len(object$nsdf)} ## only one lp
3542c3539
<   for (j in 1:length(pterms)) {
---
>   for (j in seq_len(length(pterms))) {
3549c3546
<       ind <- pstart[j] - 1 + 1:np 
---
>       ind <- pstart[j] - 1 + seq_len(np)
3553c3550
<       for (i in 1:nt) { 
---
>       for (i in seq_len(nt)) { 
3614c3611
<     for (i in 1:m) { ## loop through smooths
---
>     for (i in seq_len(m)) { ## loop through smooths
3674c3671
<   cat("Formula:\n") 
---
>   cat(gettext("Formula:", domain = "R-mgcv"), "\n", sep = "")
3676c3673
<   if (is.list(x$formula)) for (i in 1:length(x$formula)) print(x$formula[[i]]) else
---
>   if (is.list(x$formula)) for (i in seq_len(length(x$formula))) print(x$formula[[i]]) else
3680c3677
<   { cat("\nParametric coefficients:\n")
---
>   { cat("\n", gettext("Parametric coefficients:", domain = "R-mgcv"), "\n", sep = "")
3685c3682
<   { cat("Approximate significance of smooth terms:\n")
---
>   { cat(gettext("Approximate significance of smooth terms:", domain = "R-mgcv"), "\n", sep = "")
3689,3691c3686,3688
<   if (!is.null(x$rank) && x$rank< x$np) cat("Rank: ",x$rank,"/",x$np,"\n",sep="") 
<   if (!is.null(x$r.sq)) cat("R-sq.(adj) = ",formatC(x$r.sq,digits=3,width=5),"  ")
<   if (length(x$dev.expl)>0) cat("Deviance explained = ",formatC(x$dev.expl*100,digits=3,width=4),"%",sep="")
---
>   if (!is.null(x$rank) && x$rank< x$np) cat(gettextf("Rank: %s/%s", x$rank, x$np, domain = "R-mgcv"), "\n", sep = "")
>   if (!is.null(x$r.sq)) cat(gettextf("R-sq.(adj) = %s", formatC(x$r.sq,digits=3,width=5), domain = "R-mgcv"), "  ", sep = "")
>   if (length(x$dev.expl)>0) cat(gettextf("Deviance explained = %s %%", formatC(x$dev.expl*100,digits=3,width=4), domain = "R-mgcv"), sep = "")
3696c3693
<   cat("  Scale est. = ",formatC(x$scale,digits=5,width=8,flag="-"),"  n = ",x$n,"\n",sep="")
---
>   cat(gettextf("  Scale est. = %s  n = %s", formatC(x$scale,digits=5,width=8,flag="-"), x$n, domain = "R-mgcv"), "\n", sep = "")
3709,3710c3706
<         warning("The following arguments to anova.glm(..) are invalid and dropped: ",
<             paste(deparse(dotargs[named]), collapse = ", "))
---
>         warning(gettext("The following arguments to anova.glm(..) are invalid and dropped: ", domain = "R-mgcv"), paste(deparse(dotargs[named]), collapse = ", "), domain = NA)
3729c3725
<       for (i in 1:length(dotargs)) {
---
>       for (i in seq_along(dotargs)) {
3740,3741c3736,3737
<     if (!is.null(test)) warning("test argument ignored")
<     if (!inherits(object,"gam")) stop("anova.gam called with non gam object")
---
>     if (!is.null(test)) warning("'test' argument ignored")
>     if (!inherits(object,"gam")) stop(gettextf("'%s' argument is not an object of class %s", "object", dQuote("gam")))
3752,3753c3748,3749
<   cat("Formula:\n") 
<   if (is.list(x$formula)) for (i in 1:length(x$formula)) print(x$formula[[i]]) else
---
>   cat(gettext("Formula:", domain = "R-mgcv"), "\n", sep = "")
>   if (is.list(x$formula)) for (i in seq_len(length(x$formula))) print(x$formula[[i]]) else
3756c3752
<   { cat("\nParametric Terms:\n")
---
>   { cat("\n", gettext("Parametric Terms:", domain = "R-mgcv"), "\n", sep = "")
3761c3757
<   { cat("Approximate significance of smooth terms:\n")
---
>   { cat(gettext("Approximate significance of smooth terms:", domain = "R-mgcv"), "\n", sep = "")
3775c3771
<   if (!inherits(x,"gam")) stop("not a gam object")
---
>   if (!inherits(x,"gam")) stop(gettextf("'%s' argument is not an object of class %s", "x", dQuote("gam")))
3780c3776
<   for (i in 1:length(x$smooth)) { ## work through smooths
---
>   for (i in seq_len(length(x$smooth))) { ## work through smooths
3784c3780
<       if (is.null(Snames)) Snames <- as.character(1:length(x$smooth[[i]]$S))
---
>       if (is.null(Snames)) Snames <- as.character(seq_len(length(x$smooth[[i]]$S)))
3786c3782
<       for (j in 1:length(x$smooth[[i]]$S)) {
---
>       for (j in seq_len(length(x$smooth[[i]]$S))) {
3812c3808
<   if (!inherits(x,"gam")) stop("argument is not a gam object")
---
>   if (!inherits(x,"gam")) stop(gettextf("'%s' argument is not an object of class %s", "x", dQuote("gam")))
3821c3817
<   if (!inherits(x,"gam")) stop("requires an object of class gam")
---
>   if (!inherits(x,"gam")) stop(gettextf("'%s' argument is not an object of class %s", "x", dQuote("gam")))
3835c3831
<     if (m>0) for (i in 1:m) { ## loop through all smooths
---
>     if (m>0) for (i in seq_len(m)) { ## loop through all smooths
3847,3848c3843,3844
<          warning("S.scale vector doesn't match S list - please report to maintainer")
<         for (j in 1:length(x$smooth[[i]]$S.scale)) {
---
>          warning("'S.scale' vector doesn't match S list - please report to maintainer")
>         for (j in seq_len(length(x$smooth[[i]]$S.scale))) {
3863c3859
<         for (j in 1:length(x$smooth[[ii]]$S.scale)) {
---
>         for (j in seq_len(length(x$smooth[[ii]]$S.scale))) {
3883c3879
<       ind <- 1:x$family$n.theta
---
>       ind <- seq_len(x$family$n.theta)
3915c3911
<     cat(paste("Standard deviations and",conf.lev,"confidence intervals:\n\n"))
---
>     cat(gettextf("Standard deviations and %s confidence intervals:", conf.lev, domain = "R-mgcv"), "\n\n", sep = "")
3917c3913
<     cat("\nRank: ");cat(rank);cat("/");cat(ncol(H));cat("\n")
---
>     cat("\n", gettextf("Rank: %s/%s", rank, ncol(H), domain = "R-mgcv"), "\n", sep = "")
3919c3915
<       cat("\nAll smooth components:\n")
---
>       cat("\n", gettext("All smooth components:", domain = "R-mgcv"), "\n", sep = "")
3994,3995c3990,3991
<     d<-um$d[1:rank]^0.5
<     return(t(t(um$u[,1:rank])*as.vector(d))) # note recycling rule used for efficiency
---
>     d<-um$d[seq_len(rank)]^0.5
>     return(t(t(um$u[,seq_len(rank)])*as.vector(d))) # note recycling rule used for efficiency
4007c4003
<     L <- L[,piv,drop=FALSE]; L <- t(L[1:rank,,drop=FALSE])
---
>     L <- L[,piv,drop=FALSE]; L <- t(L[seq_len(rank),,drop=FALSE])
4010c4006
<   stop("method not recognised.")
---
>   stop("method was not recognised")
4086c4082
<     for (i in 1:length(S)) {
---
>     for (i in seq_along(S)) {
4097c4093
<     for (i in 1:length(S)) {
---
>     for (i in seq_along(S)) {
4131c4127
<       for (i in 1:length(S)) {
---
>       for (i in seq_len(length(S))) {
4162c4158
<     for (i in 1:n.p) { # loop over penalties
---
>     for (i in seq_len(n.p)) { # loop over penalties
4176c4172
<       if (sizeS <= 0) stop(gettextf("S[[%d]] matrix is not +ve definite.", i)) 
---
>       if (sizeS <= 0) stop(gettextf("S[[%d]] matrix is not +ve definite", i))
4237,4239c4233,4235
<     if (!inherits(L,"matrix")) stop("L must be a matrix.")
<     if (nrow(L)<ncol(L)) stop("L must have at least as many rows as columns.")
<     if (nrow(L)!=n.p||ncol(L)!=length(sp)) stop("L has inconsistent dimensions.")
---
>     if (!inherits(L,"matrix")) stop("'L' argument must be a matrix")
>     if (nrow(L)<ncol(L)) stop("'L' argument must have at least as many rows as columns")
>     if (nrow(L)!=n.p||ncol(L)!=length(sp)) stop("'L' argument has inconsistent dimensions")
4246c4242
<   { for (i in 1:n.p) 
---
>   { for (i in seq_len(n.p)) 
4266c4262
<     if (n.p>0) for (i in 1:n.p) { 
---
>     if (n.p>0) for (i in seq_len(n.p)) { 
4283c4279
<     { if (dim(w)[1]!=dim(w)[2]||dim(w)[2]!=dim(X)[1]) stop("dimensions of supplied w wrong.")
---
>     { if (dim(w)[1]!=dim(w)[2]||dim(w)[2]!=dim(X)[1]) stop("dimensions of supplied 'w' argument is wrong")
4287c4283
<     { if (length(y)!=length(w)) stop("w different length from y!")
---
>     { if (length(y)!=length(w)) stop("'w' argument has different length from 'y' argument!")
4294c4290
<     if (n!=length(X)) stop("X lost dimensions in magic!!")
---
>     if (n!=length(X)) stop("'X' lost dimensions in magic!!")
4299c4295
<   if (n.p>0) for (i in 1:n.p) { 
---
>   if (n.p>0) for (i in seq_len(n.p)) { 
4327,4328c4323,4324
<   res$R <- matrix(um$X[1:q^2],q,q)
<   res$rV<-matrix(um$rV[1:(um$info[1]*q)],q,um$info[1])
---
>   res$R <- matrix(um$X[seq_len(q)^2],q,q)
>   res$rV<-matrix(um$rV[seq_len(um$info[1]*q)],q,um$info[1])
4340c4336
< } ## magic
---
> }
4348c4344
<   hello <- paste("This is mgcv ",version,". For overview type 'help(\"mgcv-package\")'.",sep="")
---
>   hello <- gettextf("This is mgcv %s. For overview type 'help(\"mgcv-package\")'", paste(version, collapse = ""), domain = "R-mgcv")
diff -rEZbwB '--exclude=*.[lo,d,pdf,mo,po,tgz,gz,save]*' '--exclude=MD5' '--exclude=Makefile*' '--exclude=all.R' '--exclude=Changes' R-recommended/mgcv/R/misc.r Recommended/mgcv/R/misc.r
11c11
<     if (ncol(mu)!=p||nrow(mu)!=n) stop("mu dimensions wrong")
---
>     if (ncol(mu)!=p||nrow(mu)!=n) stop("'mu' dimensions are wrong")
14c14
<     if (length(mu)!=p) stop("mu dimensions wrong")
---
>     if (length(mu)!=p) stop("'mu' dimensions are wrong")
27c27
<    i <- 1:n
---
>    i <- seq_len(n)
31c31
<    j <- 1:p
---
>    j <- seq_len(p)
33c33
<  if (length(i)>length(j)) i <- i[1:length(j)] else j <- j[1:length(i)]
---
>  if (length(i)>length(j)) i <- i[seq_len(length(j))] else j <- j[1:length(i)]
43c43
<    i <- 1:n
---
>    i <- seq_len(n)
47c47
<    j <- 1:p
---
>    j <- seq_len(p)
49c49
<  if (length(i)>length(j)) i <- i[1:length(j)] else j <- j[1:length(i)]
---
>  if (length(i)>length(j)) i <- i[seq_len(length(j))] else j <- j[seq_len(length(i))]
61c61
<     for (i in 1:n) {
---
>     for (i in seq_len(n)) {
65c65
<         A[i,1:length(b)] <- b
---
>         A[i,seq_len(length(b))] <- b
68c68
<     B <- A[1:k,]
---
>     B <- A[seq_len(k),]
72c72
<   if (oo$info>0) stop("not positive definite")
---
>   if (oo$info>0) stop("matrix is not positive definite")
76c76
<     for (i in 1:k) sdiag(A,i-1) <- B[i,1:(n-i+1)]
---
>     for (i in seq_len(k)) sdiag(A,i-1) <- B[i,seq_len(n-i+1)]
91c91
<   if (oo$info>0) stop("not positive definite")
---
>   if (oo$info>0) stop("matrix is not positive definite")
93c93
<   sd <- oo$sd*ld[1:(n-1)]
---
>   sd <- oo$sd*ld[seq_len(n-1)]
122,123c122,123
<     dH <- list();ind <- 1:(nb*nb)
<     for (i in 1:nsp) { 
---
>     dH <- list();ind <- seq_len(nb*nb)
>     for (i in seq_len(nsp)) { 
145c145
<   for (i in 1:nt) pt <- pt + prod(p[ts[i]:(ts[i]+dt[i]-1)]) - as.numeric(qc[i]>0) 
---
>   for (i in seq_len(nt)) pt <- pt + prod(p[ts[i]:(ts[i]+dt[i]-1)]) - as.numeric(qc[i]>0) 
159c159
<   for (i in 1:nt) pt <- pt + prod(p[ts[i]:(ts[i]+dt[i]-1)]) - as.numeric(qc[i]>0) 
---
>   for (i in seq_len(nt)) pt <- pt + prod(p[ts[i]:(ts[i]+dt[i]-1)]) - as.numeric(qc[i]>0) 
233c233
<     piv <- 1:ncol(X); piv[qrx$pivot] <- 1:ncol(X)
---
>     piv <- seq_len(ncol(X)); piv[qrx$pivot] <- seq_len(ncol(X))
235c235
<     d <- er$d*0;d[1:rr] <- 1/er$d[1:rr]
---
>     d <- er$d*0;d[seq_len(rr)] <- 1/er$d[seq_len(rr)]
239c239
<     Ri[1:rr,1:rr] <- backsolve(R[1:rr,1:rr],diag(rr))
---
>     Ri[seq_len(rr),seq_len(rr)] <- backsolve(R[seq_len(rr),seq_len(rr)],diag(rr))
368,369c368,369
<     if (is.matrix(a)) { if (nrow(a) != x$r) stop("a has wrong number of rows") }
<     else if (length(a) != x$r) stop("a has wrong number of rows")
---
>     if (is.matrix(a)) { if (nrow(a) != x$r) stop("'a' argument has wrong number of rows") }
>     else if (length(a) != x$r) stop("'a' argument has wrong number of rows")
371,372c371,372
<     if (is.matrix(a)) { if (nrow(a) != x$c) stop("a has wrong number of rows") }
<     else if (length(a) != x$c)  stop("a has wrong number of rows")
---
>     if (is.matrix(a)) { if (nrow(a) != x$c) stop("'a' argument has wrong number of rows") }
>     else if (length(a) != x$c)  stop("'a' argument has wrong number of rows")
377c377
<   if (tr) return(matrix(oo$a[1:(a.c*x$c)],x$c,a.c)) else
---
>   if (tr) return(matrix(oo$a[seq_len(a.c*x$c)],x$c,a.c)) else
diff -rEZbwB '--exclude=*.[lo,d,pdf,mo,po,tgz,gz,save]*' '--exclude=MD5' '--exclude=Makefile*' '--exclude=all.R' '--exclude=Changes' R-recommended/mgcv/R/mvam.r Recommended/mgcv/R/mvam.r
18,19c18,19
<   for (i in 1:length(lpi)) {
<     lpi[[i]] <- 1:length(lpi[[i]]) + k
---
>   for (i in seq_len(length(lpi))) {
>     lpi[[i]] <- seq_len(length(lpi[[i]])) + k
41c41
<       lpi[[length(lpi)+1]] <- 1:nt + max(ip)
---
>       lpi[[length(lpi)+1]] <- seq_len(nt) + max(ip)
50,51c50,51
<       for (i in 1:length(lpi)) { 
<         ii <- 1:length(lpi[[i]]) + k
---
>       for (i in seq_len(length(lpi))) { 
>         ii <- seq_len(length(lpi[[i]])) + k
60,61c60,61
<       for (i in 1:length(lpi)) { 
<         ii <- 1:length(lpi[[i]]) + k
---
>       for (i in seq_len(length(lpi))) { 
>         ii <- seq_len(length(lpi[[i]])) + k
68,69c68,69
<     for (i in 1:length(lpi)) {
<       ii <- 1:length(lpi[[i]]) + k
---
>     for (i in seq_len(length(lpi))) {
>       ii <- seq_len(length(lpi[[i]])) + k
79c79
<   if (d<2) stop("mvn requires 2 or more dimensional data")
---
>   if (d<2) stop(gettextf("'%s' function requires 2 or more dimensional data", "mvn()"))
81c81
<   for (i in 1:d) {
---
>   for (i in seq_len(d)) {
103c103
<       G$term.names <- c(G$term.names,paste("R",1:ntheta,sep="."))
---
>       G$term.names <- c(G$term.names,paste("R",seq_len(ntheta),sep="."))
112c112
<       for (k in 1:ydim) {
---
>       for (k in seq_len(ydim)) {
129c129
<       ind <- G$family$data$nbeta + 1:(ydim*(ydim+1)/2);
---
>       ind <- G$family$data$nbeta + seq_len(ydim*(ydim+1)/2);
131c131
<       k <- 1;for (i in 1:ydim) for (j in i:ydim) {
---
>       k <- 1;for (i in seq_len(ydim)) for (j in i:ydim) {
177c177
< 	for (i in 1:length(offset)) if (sum(offset[[i]]!=0)) stop("mvn does not yet handle offsets")
---
> 	for (i in seq_along(offset)) if (sum(offset[[i]]!=0)) stop("mvn does not yet handle offsets")
202c202
<       for (i in 1:(m-1)) lpstart[i] <- lpi[[i+1]][1]
---
>       for (i in seq_len(m-1)) lpstart[i] <- lpi[[i+1]][1]
226c226
<         for (i in 1:nsp) { 
---
>         for (i in seq_len(nsp)) { 
233,234c233,234
<         d1H <- list();ind <- 1:(nb*nb)
<         for (i in 1:nsp) { 
---
>         d1H <- list();ind <- seq_len(nb*nb)
>         for (i in seq_len(nsp)) { 
diff -rEZbwB '--exclude=*.[lo,d,pdf,mo,po,tgz,gz,save]*' '--exclude=MD5' '--exclude=Makefile*' '--exclude=all.R' '--exclude=Changes' R-recommended/mgcv/R/plots.r Recommended/mgcv/R/plots.r
26c26
<         stop("fam not a family object")
---
>         stop(gettextf("'%s' argument is not an object of class %s", "fam", dQuote("family")))
53c53
<         stop("fam not a family object")
---
>         stop(gettextf("'%s' argument is not an object of class %s", "fam", dQuote("family")))
90c90
<   } else stop("object is not a glm or gam")
---
>   } else stop("'object' argument is not an object of class \"glm\" or \"gam\"")
117c117
<       for (i in 1:rep) { 
---
>       for (i in seq_len(rep)) { 
126c126
<       Dq <- quantile(as.numeric(dm),(1:n - .5)/n) 
---
>       Dq <- quantile(as.numeric(dm),(seq_len(n) - .5)/n) 
142c142
<       for (i in 1:s.rep) { 
---
>       for (i in seq_len(s.rep)) { 
153c153
<   { qqplot(Dq,D,ylab=ylab,xlab="theoretical quantiles",ylim=range(c(lim,D)),
---
>   { qqplot(Dq,D,ylab=ylab,xlab=gettext("theoretical quantiles", domain = "R-mgcv"), ylim=range(c(lim,D)),
157c157
<       if (level>=1) for (i in 1:rep) lines(Dq,dm[,i],col=rep.col) else {
---
>       if (level>=1) for (i in seq_len(rep)) lines(Dq,dm[,i],col=rep.col) else {
182c182
<     ind <- sample(1:n,subsample)
---
>     ind <- sample(seq_len(n), subsample)
187c187
<   for (k in 1:m) { ## work through smooths
---
>   for (k in seq_len(m)) { ## work through smooths
198,199c198,199
<     if (ok && ncol(dat)>nc) dat <- dat[,1:nc,drop=FALSE] ## drop any by variables
<     for (j in 1:nc) if (is.factor(dat[[j]])) ok <- FALSE 
---
>     if (ok && ncol(dat)>nc) dat <- dat[, seq_len(nc), drop = FALSE] ## drop any by variables
>     for (j in seq_len(nc)) if (is.factor(dat[[j]])) ok <- FALSE 
206,207c206,207
<         for (i in 1:n.rep) {
<           e <- diff(rsd[sample(1:nr,nr)]) ## shuffle 
---
>         for (i in seq_len(n.rep)) {
>           e <- diff(rsd[sample(seq_len(nr), nr)]) ## shuffle 
218c218
<           for (i in 1:nc) {
---
>           for (i in seq_len(nc)) {
224c224
<           for (i in 1:nc) { ## rescale distances
---
>           for (i in seq_len(nc)) { ## rescale distances
234,235c234,235
<         for (i in 1:n.rep) {
<           rsdr <- rsd[sample(1:nr,nr)] ## shuffle
---
>         for (i in seq_len(n.rep)) {
>           rsdr <- rsd[sample(seq_len(nr), nr)] ## shuffle
269,271c269,271
<     plot(linpred, resid,main="Resids vs. linear pred.",
<          xlab="linear predictor",ylab="residuals",...)
<     hist(resid,xlab="Residuals",main="Histogram of residuals",...)
---
>     plot(linpred, resid,main=gettext("Resids vs. linear pred.", domain = "R-mgcv"),
>          xlab=gettext("linear predictor", domain = "R-mgcv"), ylab=gettext("Residuals", domain = "R-mgcv"),...)
>     hist(resid,xlab=gettext("Residuals", domain = "R-mgcv"), main=gettext("Histogram of residuals", domain = "R-mgcv"),...)
275c275
<          xlab="Fitted Values",ylab="Response",main="Response vs. Fitted Values",...)
---
>          xlab=gettext("Fitted Values", domain = "R-mgcv"), ylab=gettext("Response", domain = "R-mgcv"), main=gettext("Response vs. Fitted Values", domain = "R-mgcv"),...)
285c285
<       cat("\nChecks based on working residuals may be misleading.")
---
>       cat("\nChecks based on working residuals may be misleading.") #LUKI
287c287
<       cat("\nMethod:",b$method,"  Optimizer:",b$optimizer)
---
>       cat("\n", gettextf("Method: %s  Optimizer: %s", paste(b$method, collapse = ""), paste(b$optimizer, collapse = ""), domain = "R-mgcv"))
318c318
<         cat("Model rank = ",b$rank,"/",length(b$coefficients),"\n")
---
>         cat(gettextf("Model rank = %s/%s", b$rank, length(b$coefficients), domain = "R-mgcv"), "\n", sep = "")
325,326c325
<       cat("Basis dimension (k) checking results. Low p-value (k-index<1) may\n") 
<       cat("indicate that k is too low, especially if edf is close to k\'.\n\n")
---
>       cat(gettext("Basis dimension (k) checking results. Low p-value (k-index<1) may\nindicate that k is too low, especially if edf is close to k.", domain = "R-mgcv"), "\n\n", sep = "")
349,350c348,349
<       if (is.null(xlab)) xlabel<- "Gaussian quantiles" else xlabel <- xlab
<       if (is.null(ylab)) ylabel <- "effects" else ylabel <- ylab
---
>       if (is.null(xlab)) xlabel<- gettext("Gaussian quantiles", domain = "R-mgcv") else xlabel <- xlab
>       if (is.null(ylab)) ylabel <- gettext("effects", domain = "R-mgcv") else ylabel <- ylab
549c548
<   ind <- (1:nrow(x))[is.na(rowSums(x))] ## where are the splits?
---
>   ind <- seq_len(nrow(x))[is.na(rowSums(x))] ## where are the splits?
568c567
<   for (i in 1:length(pc)) {
---
>   for (i in seq_len(length(pc))) {
588c587
<      for (i in 1:length(pc)) { 
---
>      for (i in seq_len(length(pc))) { 
596c595
<       if (all.equal(sort(nz),sort(npc))!=TRUE) stop("names of z and pc must match")
---
>       if (all.equal(sort(nz),sort(npc))!=TRUE) stop("names of 'z' and 'pc' must match")
612c611
<     for (i in 1:length(pc)) pc[[i]][,2] <- zlim[1] + 
---
>     for (i in seq_len(length(pc))) pc[[i]][,2] <- zlim[1] + 
617c616
<     for (i in 1:length(pc)) {
---
>     for (i in seq_len(length(pc))) {
631c630
<     for (i in 1:n.col) {
---
>     for (i in seq_len(n.col)) {
686c685
<     ind <- 1:P$n
---
>     ind <- seq_len(P$n)
1048c1047
<     warn <- paste("scheme should be a single number, or a vector with",m,"elements")
---
>     warn <- gettextf("scheme should be a single number, or a vector with %d elements", m)
1087c1086
<   if (m>0) for (i in 1:m) { ## work through smooth terms
---
>   if (m>0) for (i in seq_len(m)) { ## work through smooth terms
1138c1137
<   if (m>0) for (i in 1:m) n.plots <- n.plots + as.numeric(pd[[i]]$plot.me) 
---
>   if (m>0) for (i in seq_len(m)) n.plots <- n.plots + as.numeric(pd[[i]]$plot.me) 
1179c1178
<     if (m>0) for (i in 1:m) if (pd[[i]]$plot.me&&pd[[i]]$scale) { ## loop through plot data 
---
>     if (m>0) for (i in seq_len(m)) if (pd[[i]]$plot.me&&pd[[i]]$scale) { ## loop through plot data 
1211c1210
<   if (m>0) for (i in 1:m) if (pd[[i]]$plot.me&&(is.null(select)||i==select)) {
---
>   if (m>0) for (i in seq_len(m)) if (pd[[i]]$plot.me&&(is.null(select)||i==select)) {
1285c1284
<     if (fn>gn) mf<-factor(levels(fac))[1:gn]
---
>     if (fn>gn) mf<-factor(levels(fac))[seq_len(gn)]
1289c1288
<       mf[1:(ln*fn)]<-rep(levels(fac),rep(ln,fn))
---
>       mf[seq_len(ln*fn)]<-rep(levels(fac),rep(ln,fn))
1310c1309
<     for (i in 1:length(v.names)) {
---
>     for (i in seq_len(length(v.names))) {
1327,1328c1326
< 
<     for (i in 1:2) 
---
>     for (i in seq_len(2)) 
1334c1332
<   for (i in 1:2) if (is.factor(x$var.summary[[view[i]]])) {
---
>   for (i in seq_len(2)) if (is.factor(x$var.summary[[view[i]]])) {
1354c1352
<   for (i in 1:length(x$var.summary)) { 
---
>   for (i in seq_len(length(x$var.summary))) { 
1367,1368c1365,1366
<   if (type=="link") zlab<-paste("linear predictor") ## ignore codetools
<   else if (type=="response") zlab<-type
---
>   if (type=="link") zlab<-gettext("linear predictor", domain = "R-mgcv") ## ignore codetools
>   else if (type=="response") zlab<-gettext("response", domain = "R-mgcv")
diff -rEZbwB '--exclude=*.[lo,d,pdf,mo,po,tgz,gz,save]*' '--exclude=MD5' '--exclude=Makefile*' '--exclude=all.R' '--exclude=Changes' R-recommended/mgcv/R/smooth.r Recommended/mgcv/R/smooth.r
43c43
<     E <- rep(1,ncol(X));E[1:rank] <- sqrt(er$value[1:rank])
---
>     E <- rep(1,ncol(X));E[seq_len(rank)] <- sqrt(er$value[seq_len(rank)])
48c48
<     av.norm <- mean(col.norm[1:rank])
---
>     av.norm <- mean(col.norm[seq_len(rank)])
73c73
<       ind <- 1:rank
---
>       ind <- seq_len(rank)
96c96
<   D <- er$values[1:rank] 
---
>   D <- er$values[seq_len(rank)]
111c111
<     ind <- 1:rank
---
>     ind <- seq_len(rank)
143c143
<   if (n<4) stop("At least three knots required in call to mono.con.")
---
>   if (n<4) stop("At least three knots required in call passed to 'mono.con()'")
146c146
<   if (lo*hi==1&&lower>=upper) stop("lower bound >= upper bound in call to mono.con()")
---
>   if (lo*hi==1&&lower>=upper) stop("lower bound >= upper bound in call passed to 'mono.con()'")
158c158
<   if (is.null(x)) stop("x is null")
---
>   if (is.null(x)) stop("'x' argument is null")
167c167
<     for (i in 1:length(x)) {
---
>     for (i in seq_along(x)) {
189c189
<     ## txt <- paste("paste0(",paste("x[,",1:ncol(x),"]",sep="",collapse=","),")",sep="")
---
>     ## txt <- paste("paste0(",paste("x[,",seq_len(ncol(x)),"]",sep="",collapse=","),")",sep="")
193c193
<     txt <- paste("paste0(",paste("x[,",1:ncol(x),"]",sep="",collapse=",\"*\","),")",sep="")
---
>     txt <- paste("paste0(",paste("x[,",seq_len(ncol(x)),"]",sep="",collapse=",\"*\","),")",sep="")
217c217
<     for (i in 1:ncol(xo)) {
---
>     for (i in seq_len(ncol(xo))) {
220,221c220,221
<         x[,i] <- if (is.ordered(xo[,i])) ordered(x[,i],levels=1:length(xoi),labels=xoi) else 
<                  factor(x[,i],levels=1:length(xoi),labels=xoi)
---
>         x[,i] <- if (is.ordered(xo[,i])) ordered(x[,i],levels=seq_along(xoi),labels=xoi) else 
>                  factor(x[,i],levels=seq_along(xoi),labels=xoi)
258c258
<     txt <- paste("paste0(",paste("x[,",1:ncol(x),"]",sep="",collapse=",\":\","),")",sep="")
---
>     txt <- paste("paste0(",paste("x[,",seq_len(ncol(x)),"]",sep="",collapse=",\":\","),")",sep="")
282c282
<     for (i in 1:ncol(xo)) if (is.factor(xo[,i])) { ## may need to reset factors to factors
---
>     for (i in seq_len(ncol(xo))) if (is.factor(xo[,i])) { ## may need to reset factors to factors
284,285c284,285
<       x[,i] <- if (is.ordered(xo[,i])) ordered(x[,i],levels=1:length(xoi),labels=xoi) else 
<                factor(x[,i],levels=1:length(xoi),labels=xoi)
---
>       x[,i] <- if (is.ordered(xo[,i])) ordered(x[,i],levels=seq_len(length(xoi)),labels=xoi) else 
>                factor(x[,i],levels=seq_along(xoi),labels=xoi)
301c301
<   if (min(x)<k1||max(x)>knots[nk]) stop("x out of range")
---
>   if (min(x)<k1||max(x)>knots[nk]) stop("'x' out of range")
380c380
<   for (i in 1:dim) term[i] <- attr(terms(reformulate(term[i])),"term.labels")
---
>   for (i in seq_len(dim)) term[i] <- attr(terms(reformulate(term[i])),"term.labels")
393c393
<     { warning("something wrong with argument d.")
---
>     { warning("something wrong with argument 'd'")
412c412
<   { warning("dimension of fx is wrong") 
---
>   { warning("dimension of 'fx' is wrong") 
418c418
<   if (is.null(xt)||length(xt)==1) for (i in 1:n.bases) xtra[[i]] <- xt else
---
>   if (is.null(xt)||length(xt)==1) for (i in seq_len(n.bases)) xtra[[i]] <- xt else
420c420
<   stop("xt argument is faulty.")
---
>   stop(gettextf("'%s' argument is faulty", "xt"))
424c424
<   if (length(bs)!=n.bases) {warning("bs wrong length and ignored.");bs<-rep("cr",n.bases)}
---
>   if (length(bs)!=n.bases) { warning(gettextf("'%s' argument is of the wrong length and ignored", "bs")); bs <- rep("cr",n.bases) }
430c430
<     warning("m wrong length and ignored.");
---
>     warning(gettextf("'%s' argument is of the wrong length and ignored", "m"));
440c440
<   for (i in 1:n.bases)
---
>   for (i in seq_len(n.bases))
459c459
<       warning("only first element of `id' used")
---
>       warning("only first element of 'id' used")
494c494
<   for (i in 1:dim) term[i] <- attr(terms(reformulate(term[i])),"term.labels")
---
>   for (i in seq_len(dim)) term[i] <- attr(terms(reformulate(term[i])),"term.labels")
507c507
<     { warning("something wrong with argument d.")
---
>     { warning("something wrong with argument 'd'")
526c526
<   if (is.null(xt)||length(xt)==1) for (i in 1:n.bases) xtra[[i]] <- xt else
---
>   if (is.null(xt)||length(xt)==1) for (i in seq_len(n.bases)) xtra[[i]] <- xt else
528c528
<   stop("xt argument is faulty.")
---
>   stop(gettextf("'%s' argument is faulty", "xt"))
532c532
<   if (length(bs)!=n.bases) {warning("bs wrong length and ignored.");bs<-rep("cr",n.bases)}
---
>   if (length(bs)!=n.bases) { warning(gettextf("'%s' argument is of the wrong length and ignored", "bs")); bs<-rep("cr",n.bases) }
538c538
<     warning("m wrong length and ignored.");
---
>     warning(gettextf("'%s' argument is of the wrong length and ignored", "m"));
548c548
<   for (i in 1:n.bases)
---
>   for (i in seq_len(n.bases))
562c562
<       warning("ord is wrong. reset to NULL.")
---
>       warning("ord is wrong. reset to NULL")
575c575
<       warning("only first element of `id' used")
---
>       warning("only first element of 'id' used")
608c608
<   if (by.var==".") stop("by=. not allowed")
---
>   if (by.var==".") stop("'by=.' is not allowed")
610c610
<   if (term[1]==".") stop("s(.) not supported.")
---
>   if (term[1]==".") stop("'s(.)' function is not yet supported")
614c614
<     if (term[i]==".") stop("s(.) not yet supported.")
---
>     if (term[i]==".") stop("'s(.)' function is not yet supported")
616c616
<   for (i in 1:d) term[i] <- attr(terms(reformulate(term[i])),"term.labels")
---
>   for (i in seq_len(d)) term[i] <- attr(terms(reformulate(term[i])),"term.labels")
620c620
<   if (all.equal(k.new,k)!=TRUE) {warning("argument k of s() should be integer and has been rounded")}
---
>   if (all.equal(k.new,k)!=TRUE) {warning("argument 'k' of 's()' function should be integer and has been rounded")}
631c631
<       warning("only first element of `id' used")
---
>       warning("only first element of 'id' used")
661c661
<     for (j in 1:ncol(X[[i]]))
---
>     for (j in seq_len(ncol(X[[i]])))
694c694
<   for (i in 1:m) { 
---
>   for (i in seq_len(m)) { 
700c700
<   for (i in 1:m) {
---
>   for (i in seq_len(m)) {
727c727
<   for (i in 1:m) { 
---
>   for (i in seq_len(m)) { 
731c731
<     for (j in 1:length(term)) { 
---
>     for (j in seq_len(length(term))) { 
745c745
<     stop("Sorry, tensor products of smooths with multiple penalties are not supported.")
---
>     stop("Sorry, tensor products of smooths with multiple penalties are not supported")
760,761c760,761
<     g <- list(); for (i in 1:length(km)) g[[i]] <- object$margin[[km[i]]]$g.index
<     for (i in 1:length(object$margin)) {
---
>     g <- list(); for (i in seq_along(km)) g[[i]] <- object$margin[[km[i]]]$g.index
>     for (i in seq_along(object$margin)) {
768c768
<   if (object$np) for (i in 1:m) { # reparameterize 
---
>   if (object$np) for (i in seq_len(m)) { # reparameterize
797c797
<   for (i in 1:m)  Sm[[i]] <- Sm[[i]]/eigen(Sm[[i]],symmetric=TRUE,only.values=TRUE)$values[1] 
---
>   for (i in seq_len(m))  Sm[[i]] <- Sm[[i]]/eigen(Sm[[i]],symmetric=TRUE,only.values=TRUE)$values[1] 
825c825
<     #for (i in 1:length(S)) {
---
>     #for (i in seq_along(S)) {
830c830
<     for (i in 1:m) { 
---
>     for (i in seq_len(m)) { 
837c837
<     for (i in 1:m) { 
---
>     for (i in seq_len(m)) { 
861c861
<   for (i in 1:m) { 
---
>   for (i in seq_len(m)) { 
864c864
<     for (j in 1:length(term)) dat[[term[j]]] <- data[[term[j]]]
---
>     for (j in seq_len(length(term))) dat[[term[j]]] <- data[[term[j]]]
870c870
<   for (i in 1:mxp) if (!is.null(object$XP[[i]])) X[[i]] <- X[[i]]%*%object$XP[[i]]
---
>   for (i in seq_len(mxp)) if (!is.null(object$XP[[i]])) X[[i]] <- X[[i]]%*%object$XP[[i]]
892c892
<   Zi <- Xm[[1]][,1:rank[1],drop=FALSE] ## range space basis for first margin
---
>   Zi <- Xm[[1]][,seq_len(rank)[1],drop=FALSE] ## range space basis for first margin
903c903
<       colnames(Xi) <- as.character(1:ncol(Xi)) 
---
>       colnames(Xi) <- as.character(seq_len(ncol(Xi))) 
914c914
<     Zi <- Xm[[i]][,1:rank[i],drop=FALSE]   ## margin i range space
---
>     Zi <- Xm[[i]][,seq_len(rank)[i],drop=FALSE]   ## margin i range space
918c918
<       if (full) colnames(Xi)  <- as.character(1:ncol(Xi))
---
>       if (full) colnames(Xi)  <- as.character(seq_len(ncol(Xi)))
925c925
<     for (ii in 1:length(X1)) { ## form products with Zi
---
>     for (ii in seq_len(length(X1))) { ## form products with Zi
928c928
<         for (j in 1:ncol(X1[[ii]])) A <- cbind(A,X1[[ii]][,j]*Zi)
---
>         for (j in seq_len(ncol(X1[[ii]]))) A <- cbind(A,X1[[ii]][,j]*Zi)
936c936
<         for (j in 1:ncol(X1[[ii]])) {
---
>         for (j in seq_len(ncol(X1[[ii]]))) {
947c947
<       for (ii in 1:length(X1)) { ## form products with Xi
---
>       for (ii in seq_len(length(X1))) { ## form products with Xi
954c954
<           for (j in 1:ncol(X1[[ii]])) { 
---
>           for (j in seq_len(ncol(X1[[ii]]))) { 
966c966
<            for (j in 1:ncol(Xi)) {
---
>            for (j in seq_len(ncol(Xi))) {
1010c1010
<   for (i in 1:m) { ## create marginal model matrices and penalties...
---
>   for (i in seq_len(m)) { ## create marginal model matrices and penalties...
1014c1014
<     for (j in 1:length(term)) { 
---
>     for (j in seq_len(length(term))) { 
1026c1026
<     stop("Sorry, tensor products of smooths with multiple penalties are not supported.")
---
>     stop("Sorry, tensor products of smooths with multiple penalties are not supported")
1037c1037
<     dS <- rep(0,ncol(Xm[[i]]));dS[1:r[i]] <- 1;
---
>     dS <- rep(0,ncol(Xm[[i]]));dS[seq_len(r[i])] <- 1;
1056c1056
<   if (nsc>0) for (j in 1:nsc) {
---
>   if (nsc>0) for (j in seq_len(nsc)) {
1078c1078
<   nup <- sum(sub.cols[1:nsc]) ## range space rank
---
>   nup <- sum(sub.cols[seq_len(nsc)]) ## range space rank
1084,1085c1084,1085
<     ##  X.shift <- colMeans(X[,1:nup])
<     ##  X[,1:nup] <- sweep(X[,1:nup],2,X.shift) ## make penalized columns orthog to constant col.
---
>     ##  X.shift <- colMeans(X[,seq_len(nup)])
>     ##  X[,seq_len(nup)] <- sweep(X[,seq_len(nup)],2,X.shift) ## make penalized columns orthog to constant col.
1100c1100
<   object$rank <- sub.cols[1:nsc] ## ranks of individual penalties
---
>   object$rank <- sub.cols[seq_len(nsc)] ## ranks of individual penalties
1112c1112
<   for (i in 1:m) { 
---
>   for (i in seq_len(m)) { 
1115c1115
<     for (j in 1:length(term)) dat[[term[j]]] <- data[[term[j]]]
---
>     for (j in seq_len(length(term))) dat[[term[j]]] <- data[[term[j]]]
1126c1126
<   ind <- 1:ncol(object$S[[1]])                   ## index of penalty columns 
---
>   ind <- seq_len(ncol(object$S[[1]]))                   ## index of penalty columns 
1131c1131
<   for (i in 1:length(object$S)) { ## work through penalties
---
>   for (i in seq_len(length(object$S))) { ## work through penalties
1171c1171
<   for (i in 1:m) if (inherits(sm[[i]],"t2.smooth")&&length(sm[[i]]$S)>1) { not.needed <- FALSE;break}
---
>   for (i in seq_len(m)) if (inherits(sm[[i]],"t2.smooth")&&length(sm[[i]]$S)>1) { not.needed <- FALSE;break}
1175c1175
<   for (i in 1:m) {
---
>   for (i in seq_len(m)) {
1179c1179
<       for (j in 1:length(smi)) {
---
>       for (j in seq_len(length(smi))) {
1197c1197
< { if (sum(d<0)) stop("d can not be negative in call to null.space.dimension().")
---
> { if (sum(d<0)) stop("'d' can not be negative in call passed to 'null.space.dimension()'")
1229c1229
<   for (i in 1:object$dim) 
---
>   for (i in seq_len(object$dim)) 
1241c1241
<     for (i in 1:object$dim) 
---
>     for (i in seq_len(object$dim)) 
1252c1252
<   warning("more knots than data in a tp term: knots ignored.")}
---
>   warning("more knots than data in a tp term: knots ignored")}
1267c1267
<       ind <- sample(1:nu,nk,replace=FALSE)  ## by sampling these rows from xu
---
>       ind <- sample(seq_len(nu),nk,replace=FALSE)  ## by sampling these rows from xu
1320c1320
<   object$UZ<-matrix(oo$UZ[1:UZ.len],oo$n.Xu+M,k)         # truncated basis matrix
---
>   object$UZ<-matrix(oo$UZ[seq_len(UZ.len)],oo$n.Xu+M,k)         # truncated basis matrix
1322c1322
<   object$Xu<-matrix(oo$Xu[1:Xu.len],oo$n.Xu,object$dim)  # unique covariate combinations
---
>   object$Xu<-matrix(oo$Xu[seq_len(Xu.len)],oo$n.Xu,object$dim)  # unique covariate combinations
1330c1330
<     ind <- 1:(k-M)
---
>     ind <- seq_len(k-M)
1363c1363
<   for (i in 1:object$dim) 
---
>   for (i in seq_len(object$dim)) 
1376c1376
<   ind <- 1:object$bs.dim
---
>   ind <- seq_len(object$bs.dim)
1435,1436c1435
<   { msg <- paste(object$term," has insufficient unique values to support ",
<                  nk," knots: reduce k.",sep="")
---
>   { msg <- gettextf("%s has insufficient unique values to support %d knots: reduce k", object$term, nk)
1537,1538c1536,1537
<   lbi<-floor(delta*1:(nk-2))+1 # lower interval bound index
<   frac<-delta*1:(nk-2)+1-lbi # left over proportion of interval  
---
>   lbi<-floor(delta*seq_len(nk-2))+1 # lower interval bound index
>   frac<-delta*seq_len(nk-2)+1-lbi # left over proportion of interval  
1554c1553
<     h<-x[2:n]-x[1:(n-1)]
---
>     h<-x[2:n]-x[seq_len(n-1)]
1630c1629
<     h<-knots[2:n]-knots[1:(n-1)]
---
>     h<-knots[2:n]-knots[seq_len(n-1)]
1682c1681
<     stop(paste("there should be ",nk," supplied knots"))
---
>     stop(gettextf("there should be %d knots supplied", nk))
1685c1684
<   if (length(k)!=nk) stop(paste("there should be",nk,"knots supplied"))
---
>   if (length(k)!=nk) stop(gettextf("there should be %d knots supplied", nk))
1700,1702c1699,1701
<     for (i in 1:p.ord) De <- diff(De)
<     D <- De[,-(1:p.ord)]
<     D[,(np-p.ord+1):np] <-  D[,(np-p.ord+1):np] + De[,1:p.ord]
---
>     for (i in seq_len(p.ord)) De <- diff(De)
>     D <- De[,-seq_len(p.ord)]
>     D[,(np-p.ord+1):np] <-  D[,(np-p.ord+1):np] + De[,seq_len(p.ord)]
1752c1751
<     stop(paste("there should be ",nk+2*m[1]+2," supplied knots"))
---
>     stop(gettextf("there should be %d knots supplied",nk+2*m[1]+2))
1764c1763
<     B <- matrix(as.numeric(rep(1:p,p)>=rep(1:p,each=p)),p,p) ## coef summation matrix
---
>     B <- matrix(as.numeric(rep(seq_len(p),p)>=rep(seq_len(p),each=p)),p,p) ## coef summation matrix
1875c1874
<     stop(paste("there should be ",nk+2*m[1]," supplied knots"))
---
>     stop(gettextf("there should be %d knots supplied", nk+2*m[1]))
1889c1888
<   k0 <- k[m[1]+1:nk] ## the interior knots
---
>   k0 <- k[m[1]+seq_len(nk)] ## the interior knots
1895c1894
<   if (pord==0) k1 <- (k0[2:nk]+k0[1:(nk-1)])/2 else {
---
>   if (pord==0) k1 <- (k0[2:nk]+k0[seq_len(nk-1)])/2 else {
1906c1905
<     i1 <- rep(1:(pord+1),pord+1)+rep(1:(pord+1),each=pord+1) ## i + j
---
>     i1 <- rep(seq_len(pord+1),pord+1)+rep(seq_len(pord+1),each=pord+1) ## i + j
1912c1911
<     i1 <- c(rep(1:pord,length(h)) + rep(0:(length(h)-1) * (pord+1),each=pord),length(ld0))
---
>     i1 <- c(rep(seq_len(pord),length(h)) + rep(0:(length(h)-1) * (pord+1),each=pord),length(ld0))
1914,1915c1913,1914
<     i0 <- 1:(length(h)-1)*pord+1
<     i2 <- 1:(length(h)-1)*(pord+1)
---
>     i0 <- seq_len(length(h)-1)*pord+1
>     i2 <- seq_len(length(h)-1)*(pord+1)
1919c1918
<     for (k in 1:pord) { ## create the other diagonals...
---
>     for (k in seq_len(pord)) { ## create the other diagonals...
1921c1920
<       ind <- 1:(length(ld)-k)
---
>       ind <- seq_len(length(ld)-k)
1928,1929c1927,1928
<     for (k in 1:pord) {
<       ind <- 1:(nrow(D)-k)
---
>     for (k in seq_len(pord)) {
>       ind <- seq_len(nrow(D)-k)
1975c1974
<   for (i in 1:length(object$term)) if (is.factor(data[[object$term[i]]])) { 
---
>   for (i in seq_len(length(object$term))) if (is.factor(data[[object$term[i]]])) { 
1999c1998
<   for (i in 1:object$dim) if (object$term[i]!=fterm) {
---
>   for (i in seq_len(object$dim)) if (object$term[i]!=fterm) {
2025c2024
<   for (i in 1:null.d) { ## create null space element penalties
---
>   for (i in seq_len(null.d)) { ## create null space element penalties
2038c2037
<   #for (i in 1:null.d) { ## null space penalties
---
>   #for (i in seq_len(null.d)) { ## null space penalties
2060c2059
<     for (i in 1:null.d) { ## null space penalties
---
>     for (i in seq_len(null.d)) { ## null space penalties
2114c2113
<   for (i in 1:length(object$flev)) {
---
>   for (i in seq_len(length(object$flev))) {
2126c2125
< ## sets M[i[k],j[k]] <- m[k] for all k in 1:length(m) without
---
> ## sets M[i[k],j[k]] <- m[k] for all k in seq_len(length(m)) without
2145,2147c2144,2146
<   Ind <- matrix(1:(ni*nj),ni,nj) ## the indexing matrix
<   rmt <- rep(1:ni,nj) ## the row index
<   cmt <- rep(1:nj,rep(ni,nj)) ## the column index
---
>   Ind <- matrix(seq_len(ni*nj),ni,nj) ## the indexing matrix
>   rmt <- rep(seq_len(ni),nj) ## the row index
>   cmt <- rep(seq_len(nj),rep(ni,nj)) ## the column index
2149c2148
<   ci <- Ind[2:(ni-1),1:nj] ## column index
---
>   ci <- Ind[2:(ni-1),seq_len(nj)] ## column index
2155,2159c2154,2158
<   Drr <- mfil(Drr,1:n.ci,ci,-2) ## central coefficient
<   ci <- Ind[1:(ni-2),1:nj] 
<   Drr <- mfil(Drr,1:n.ci,ci,1) ## back coefficient
<   ci <- Ind[3:ni,1:nj]
<   Drr <- mfil(Drr,1:n.ci,ci,1) ## forward coefficient
---
>   Drr <- mfil(Drr,seq_len(n.ci),ci,-2) ## central coefficient
>   ci <- Ind[seq_len(ni-2),seq_len(nj)] 
>   Drr <- mfil(Drr,seq_len(n.ci),ci,1) ## back coefficient
>   ci <- Ind[3:ni,seq_len(nj)]
>   Drr <- mfil(Drr,seq_len(n.ci),ci,1) ## forward coefficient
2162c2161
<   ci <- Ind[1:ni,2:(nj-1)] ## column index
---
>   ci <- Ind[seq_len(ni),2:(nj-1)] ## column index
2168,2172c2167,2171
<   Dcc <- mfil(Dcc,1:n.ci,ci,-2) ## central coefficient
<   ci <- Ind[1:ni,1:(nj-2)]
<   Dcc <- mfil(Dcc,1:n.ci,ci,1) ## back coefficient
<   ci <- Ind[1:ni,3:nj]
<   Dcc <- mfil(Dcc,1:n.ci,ci,1) ## forward coefficient
---
>   Dcc <- mfil(Dcc,seq_len(n.ci),ci,-2) ## central coefficient
>   ci <- Ind[seq_len(ni),seq_len(nj-2)]
>   Dcc <- mfil(Dcc,seq_len(n.ci),ci,1) ## back coefficient
>   ci <- Ind[seq_len(ni),3:nj]
>   Dcc <- mfil(Dcc,seq_len(n.ci),ci,1) ## forward coefficient
2181,2182c2180,2181
<   ci <- Ind[1:(ni-2),1:(nj-2)] 
<   Dcr <- mfil(Dcr,1:n.ci,ci,sqrt(0.125)) ## -- coefficient
---
>   ci <- Ind[seq_len(ni-2),seq_len(nj-2)] 
>   Dcr <- mfil(Dcr,seq_len(n.ci),ci,sqrt(0.125)) ## -- coefficient
2184,2188c2183,2187
<   Dcr <- mfil(Dcr,1:n.ci,ci,sqrt(0.125)) ## ++ coefficient
<   ci <- Ind[1:(ni-2),3:nj] 
<   Dcr <- mfil(Dcr,1:n.ci,ci,-sqrt(0.125)) ## -+ coefficient
<   ci <- Ind[3:ni,1:(nj-2)] 
<   Dcr <- mfil(Dcr,1:n.ci,ci,-sqrt(0.125)) ## +- coefficient
---
>   Dcr <- mfil(Dcr,seq_len(n.ci),ci,sqrt(0.125)) ## ++ coefficient
>   ci <- Ind[seq_len(ni-2),3:nj] 
>   Dcr <- mfil(Dcr,seq_len(n.ci),ci,-sqrt(0.125)) ## -+ coefficient
>   ci <- Ind[3:ni,seq_len(nj-2)] 
>   Dcr <- mfil(Dcr,seq_len(n.ci),ci,-sqrt(0.125)) ## +- coefficient
2206c2205
<   if (object$dim> 2 )  stop("the adaptive smooth class is limited to 1 or 2 covariates.")
---
>   if (object$dim> 2 )  stop("the adaptive smooth class is limited to 1 or 2 covariates")
2227c2226
<       x <- 1:(nk-2)/nk;m=2
---
>       x <- seq_len(nk-2)/nk;m=2
2239c2238
<      # for (i in 1:k) D[[i]] <- as.numeric(V[,i])*Db
---
>      # for (i in seq_len(k)) D[[i]] <- as.numeric(V[,i])*Db
2242c2241
<       for (i in 1:k) {
---
>       for (i in seq_len(k)) {
2258c2257
<       for (i in 1:2) {
---
>       for (i in seq_len(2)) {
2304c2303
<         for (i in 1:kp.tot) {
---
>         for (i in seq_len(kp.tot)) {
2337c2336
<   if (!is.null(object$id)) stop("random effects don't work with ids.")
---
>   if (!is.null(object$id)) stop("random effects don't work with ids")
2347c2346
<     for (i in 1:object$dim) {
---
>     for (i in seq_len(object$dim)) {
2357c2356
<       ind <- 1:ns;ind[maxi] <- ns ;ind[ns] <- maxi
---
>       ind <- seq_len(ns);ind[maxi] <- ns ;ind[ns] <- maxi
2360c2359
<       for (i in 1:ns) object$term <- c(object$term,object$margin[[i]]$term)
---
>       for (i in seq_len(ns)) object$term <- c(object$term,object$margin[[i]]$term)
2373,2374c2372,2373
<     for (i in 1:length(object$S)) { 
<       if (ncol(object$S[[i]])!=object$bs.dim||nrow(object$S[[i]])!=object$bs.dim) stop("supplied S matrices are wrong diminsion")
---
>     for (i in seq_len(length(object$S))) { 
>       if (ncol(object$S[[i]])!=object$bs.dim||nrow(object$S[[i]])!=object$bs.dim) stop("supplied S matrices are wrong dimension")
2430c2429
<   for (i in 1:n.poly) {
---
>   for (i in seq_len(n.poly)) {
2445c2444
<   for (i in 1:length(pc)) nb[[i]] <- rep(0,0)
---
>   for (i in seq_len(length(pc))) nb[[i]] <- rep(0,0)
2447c2446
<   for (k in 1:n.poly) { ## work through poly list looking for neighbours
---
>   for (k in seq_len(n.poly)) { ## work through poly list looking for neighbours
2453c2452
<     ind <- (1:n.poly)[ol] ## index of potential neighbours of poly k
---
>     ind <- seq_len(n.poly)[ol] ## index of potential neighbours of poly k
2456c2455
<     if (length(ind)>0) for (j in 1:length(ind)) {
---
>     if (length(ind)>0) for (j in seq_len(length(ind))) {
2465c2464
<   for (i in 1:length(pc)) nb[[i]] <- unique(nb[[i]])
---
>   for (i in seq_len(length(pc))) nb[[i]] <- unique(nb[[i]])
2522,2523c2521,2522
<       for (i in 1:length(d.name)) {
<         ind <- (1:length(a.name))[a.name==d.name[i]] ## index of duplicates 
---
>       for (i in seq_along(d.name)) {
>         ind <- seq_along(a.name)[a.name==d.name[i]] ## index of duplicates 
2528c2527
<       ind <- (1:length(a.name))[duplicated(a.name)]
---
>       ind <- seq_along(a.name)[duplicated(a.name)]
2549c2548
<     for (i in 1:np) {
---
>     for (i in seq_len(np)) {
2553c2552
<       if (lind>0) for (j in 1:lind) S[a.name[i],a.name[ind[j]]] <- -1
---
>       if (lind>0) for (j in seq_len(lind)) S[a.name[i],a.name[ind[j]]] <- -1
2582c2581
<       for (i in 1:length(mi)) object$X[i,mi[i]] <- 1
---
>       for (i in seq_len(length(mi))) object$X[i,mi[i]] <- 1
2588c2587
<     object$X <- if (length(mi)) rp$X[-(1:length(mi)),ind] else  rp$X[,ind] ## model matrix
---
>     object$X <- if (length(mi)) rp$X[-seq_len(length(mi)),ind] else  rp$X[,ind] ## model matrix
2735c2734
<   for (i in 1:2) {
---
>   for (i in seq_len(2)) {
2745c2744
<     for (i in 1:2) 
---
>     for (i in seq_len(2)) 
2757c2756
<     warning("more knots than data in an sos term: knots ignored.")
---
>     warning("more knots than data in an sos term: knots ignored")
2774c2773
<         ind <- sample(1:nu,nk,replace=FALSE)  ## by sampling these rows from xu
---
>         ind <- sample(seq_len(nu),nk,replace=FALSE)  ## by sampling these rows from xu
2793c2792
<   R <- makeR(la=knt[1:nk],lo=knt[-(1:nk)],lak=knt[1:nk],lok=knt[-(1:nk)],m=object$p.order)
---
>   R <- makeR(la=knt[seq_len(nk)],lo=knt[-seq_len(nk)],lak=knt[seq_len(nk)],lok=knt[-seq_len(nk)],m=object$p.order)
2795c2794
<   ind <- 1:ncol(T)
---
>   ind <- seq_len(ncol(T))
2848c2847
<   lak <- object$knt[1:nk];lok <- object$knt[-(1:nk)] ## knots
---
>   lak <- object$knt[seq_len(nk)];lok <- object$knt[-seq_len(nk)] ## knots
2852,2853c2851,2852
<     for (i in 1:n.chunk) { ## build predict matrix in chunks
<       ind <- 1:nk + (i-1)*nk
---
>     for (i in seq_len(n.chunk)) { ## build predict matrix in chunks
>       ind <- seq_len(nk) + (i-1)*nk
2901c2900
<   for (i in 1:M) {
---
>   for (i in seq_len(M)) {
2903c2902
<     for (j in 1:n) y <- y * x[,j]^p[i,j]
---
>     for (j in seq_len(n)) y <- y * x[,j]^p[i,j]
2911c2910
<   ind <- expand.grid(x=1:nrow(x),xk=1:nrow(xk))
---
>   ind <- expand.grid(x=seq_len(nrow(x)),xk=seq_len(nrow(xk)))
2942c2941
<   for (i in 1:object$dim) {
---
>   for (i in seq_len(object$dim)) {
2952c2951
<     for (i in 1:object$dim) 
---
>     for (i in seq_len(object$dim)) 
2964c2963
<     warning("more knots than data in a ds term: knots ignored.")
---
>     warning("more knots than data in a ds term: knots ignored")
2984c2983
<         ind <- sample(1:nu,nk,replace=FALSE)  ## by sampling these rows from xu
---
>         ind <- sample(seq_len(nu),nk,replace=FALSE)  ## by sampling these rows from xu
3038c3037
<   ind <- 1:ncol(T)
---
>   ind <- seq_len(ncol(T))
3092c3091
<   for (i in 1:object$dim) {
---
>   for (i in seq_len(object$dim)) {
3105,3106c3104,3105
<     for (i in 1:n.chunk) { ## build predict matrix in chunks
<       ind <- 1:nk + (i-1)*nk
---
>     for (i in seq_len(n.chunk)) { ## build predict matrix in chunks
>       ind <- seq_len(nk) + (i-1)*nk
3138c3137
<   ind <- expand.grid(x=1:nrow(x),xk=1:nrow(xk))
---
>   ind <- expand.grid(x=seq_len(nrow(x)),xk=seq_len(nrow(xk)))
3176c3175
<   for (i in 1:object$dim) {
---
>   for (i in seq_len(object$dim)) {
3186c3185
<     for (i in 1:object$dim) { 
---
>     for (i in seq_len(object$dim)) { 
3218c3217
<         ind <- sample(1:nu,nk,replace=FALSE)  ## by sampling these rows from xu
---
>         ind <- sample(seq_len(nu),nk,replace=FALSE)  ## by sampling these rows from xu
3257c3256
<     D[1:k,1:k] <- E  ## penalty
---
>     D[seq_len(k),seq_len(k)] <- E  ## penalty
3283c3282
<   for (i in 1:object$dim) {
---
>   for (i in seq_len(object$dim)) {
3296,3297c3295,3296
<     for (i in 1:n.chunk) { ## build predict matrix in chunks
<       ind <- 1:nk + (i-1)*nk
---
>     for (i in seq_len(n.chunk)) { ## build predict matrix in chunks
>       ind <- seq_len(nk) + (i-1)*nk
3402c3401
<    for (i in 1:length(object$term)) { 
---
>    for (i in seq_len(length(object$term))) { 
3414c3413
<          for (i in 1:m) dat[[i]] <- X[,i]     ## return only unique rows
---
>          for (i in seq_len(m)) dat[[i]] <- X[,i]     ## return only unique rows
3453c3452
<   if (!is.null(attr(sm,"qrc"))) warning("smooth objects should not have a qrc attribute.")
---
>   if (!is.null(attr(sm,"qrc"))) warning("smooth objects should not have a qrc attribute")
3489c3488
<         drop <- min((1:length(vcol))[vcol==min(vcol)])
---
>         drop <- min(seq_len(length(vcol))[vcol==min(vcol)])
3496c3495
<             sm$C <- ((1:length(xsd))[xsd==0])[1] ## index of coef to set to zero
---
>             sm$C <- (seq_len(length(xsd))[xsd==0])[1] ## index of coef to set to zero
3501c3500
<             sm$C <- ((1:length(xz))[xz==min(xz)])[1] ## index of coef to set to zero
---
>             sm$C <- (seq_len(length(xz))[xz==min(xz)])[1] ## index of coef to set to zero
3540c3539
<       for (i in 1:length(sm$S)) {
---
>       for (i in seq_len(length(sm$S))) {
3560c3559
<     if (!is.null(sm$by.done)) warning("handling `by' variables in smooth constructors may not work with the summation convention ")
---
>     if (!is.null(sm$by.done)) warning("handling 'by' variables in smooth constructors may not work with the summation convention")
3612c3611
<      for (l in 1:length(sm$S)) { # some smooths have > 1 penalty 
---
>      for (l in seq_len(length(sm$S))) { # some smooths have > 1 penalty 
3625c3624
<       if (matrixArg) stop("factor `by' variables can not be used with matrix arguments.")
---
>       if (matrixArg) stop("factor 'by' variables can not be used with matrix arguments")
3632c3631
<       for (j in 1:length(lev)) {
---
>       for (j in seq_len(length(lev))) {
3645c3644
<           (!is.null(sm$ind)&&length(by)!=length(sm$ind))) stop("`by' variable must be same dimension as smooth arguments")
---
>           (!is.null(sm$ind)&&length(by)!=length(sm$ind))) stop("'by' variable must be same dimension as smooth arguments")
3652c3651
<           ind <- 1:n 
---
>           ind <- seq_len(n)
3662c3661
<             ind <- 1:n 
---
>             ind <- seq_len(n)
3675c3674
<           for (i in 1:n) { ## in this case have to work down the rows
---
>           for (i in seq_len(n)) { ## in this case have to work down the rows
3710c3709
<       for (i in 1:length(sml)) { ## loop through smooth list
---
>       for (i in seq_len(length(sml))) { ## loop through smooth list
3715c3714
<           for (l in 1:length(sml[[i]]$S)) { # some smooths have > 1 penalty 
---
>           for (l in seq_len(length(sml[[i]]$S))) { # some smooths have > 1 penalty 
3726c3725
<         indi <- (1:ncol(sm$C))[colSums(sm$C)!=0] ## index of non-zero columns in C
---
>         indi <- seq_len(ncol(sm$C))[colSums(sm$C)!=0] ## index of non-zero columns in C
3732c3731
<           for (i in 1:length(sml)) { ## loop through smooth list
---
>           for (i in seq_len(length(sml))) { ## loop through smooth list
3734c3733
<             for (l in 1:length(sm$S)) # some smooths have > 1 penalty 
---
>             for (l in seq_len(length(sm$S))) # some smooths have > 1 penalty 
3736c3735
<               ZSZ[indi[1:nz],]<-qr.qty(qrc,sml[[i]]$S[[l]][indi,,drop=FALSE])[(nc+1):nx,] 
---
>               ZSZ[indi[seq_len(nz)],]<-qr.qty(qrc,sml[[i]]$S[[l]][indi,,drop=FALSE])[(nc+1):nx,] 
3738c3737
<               ZSZ[,indi[1:nz]]<-t(qr.qty(qrc,t(ZSZ[,indi,drop=FALSE]))[(nc+1):nx,])
---
>               ZSZ[,indi[seq_len(nz)]]<-t(qr.qty(qrc,t(ZSZ[,indi,drop=FALSE]))[(nc+1):nx,])
3744c3743
<             sml[[i]]$X[,indi[1:nz]]<-t(qr.qty(qrc,t(sml[[i]]$X[,indi,drop=FALSE]))[(nc+1):nx,])
---
>             sml[[i]]$X[,indi[seq_len(nz)]]<-t(qr.qty(qrc,t(sml[[i]]$X[,indi,drop=FALSE]))[(nc+1):nx,])
3760c3759
<         #    for (i in 1:length(sml)) { ## loop through smooth list
---
>         #    for (i in seq_along(sml)) { ## loop through smooth list
3765c3764
<         #      for (l in 1:length(sm$S)) { # some smooths have > 1 penalty 
---
>         #      for (l in seq_along(sm$S)) { # some smooths have > 1 penalty 
3772c3771
<             for (i in 1:length(sml)) { ## loop through smooth list
---
>             for (i in seq_len(length(sml))) { ## loop through smooth list
3774c3773
<               for (l in 1:length(sm$S)) { # some smooths have > 1 penalty 
---
>               for (l in seq_len(length(sm$S))) { # some smooths have > 1 penalty 
3784c3783
<           for (i in 1:length(sml)) { ## loop through smooth list
---
>           for (i in seq_len(length(sml))) { ## loop through smooth list
3794c3793
<         for (i in 1:length(sml)) {
---
>         for (i in seq_len(length(sml))) {
3800c3799
<        for (i in 1:length(sml)) { ## loop through smooth list
---
>        for (i in seq_len(length(sml))) { ## loop through smooth list
3802c3801
<           for (l in 1:length(sm$S)) { # some smooths have > 1 penalty 
---
>           for (l in seq_len(length(sm$S))) { # some smooths have > 1 penalty 
3815c3814
<        for (i in 1:length(sml)) { ## loop through smooth list
---
>        for (i in seq_len(length(sml))) { ## loop through smooth list
3817c3816
<           for (l in 1:length(sm$S)) { # some smooths have > 1 penalty 
---
>           for (l in seq_len(length(sm$S))) { # some smooths have > 1 penalty 
3833c3832
<       for (i in 1:length(sml)) { ## loop through smooth list
---
>       for (i in seq_len(length(sml))) { ## loop through smooth list
3840c3839
<   } else for (i in 1:length(sml)) attr(sml[[i]],"qrc") <-NULL ## no absorption
---
>   } else for (i in seq_len(length(sml))) attr(sml[[i]],"qrc") <-NULL ## no absorption
3881c3880
<         if (p>rank) for (i in 1:length(sml)) {
---
>         if (p>rank) for (i in seq_len(length(sml))) {
3892c3891
<       if (length(sml[[1]]$S)>1) for (i in 1:length(sml[[1]]$S)) St <- St + sml[[1]]$S[[i]]
---
>       if (length(sml[[1]]$S)>1) for (i in seq_len(length(sml[[1]]$S))) St <- St + sml[[1]]$S[[i]]
3899c3898
<         for (i in 1:length(sml)) {
---
>         for (i in seq_len(length(sml))) {
3909c3908
<   if (!apply.by) for (i in 1:length(sml)) {
---
>   if (!apply.by) for (i in seq_along(sml)) {
3930c3929
<     if (!deriv&&!is.null(object$margin)) for (i in 1:length(object$margin))
---
>     if (!deriv&&!is.null(object$margin)) for (i in seq_along(object$margin))
3947c3946
<     for (i in 1:n) { ## in this case have to work down the rows
---
>     for (i in seq_len(n)) { ## in this case have to work down the rows
3971c3970
<           if (length(by)!=nrow(X)) stop("`by' variable must be same dimension as smooth arguments")
---
>           if (length(by)!=nrow(X)) stop("'by' variable must be same dimension as smooth arguments")
3983c3982
<       ind <- 1:n 
---
>       ind <- seq_len(n)
4022c4021
<             X[ind,indi[1:nz]]<-t(qr.qty(qrc,t(X[ind,indi,drop=FALSE]))[(nc+1):nx,])
---
>             X[ind,indi[seq_len(nz)]]<-t(qr.qty(qrc,t(X[ind,indi,drop=FALSE]))[(nc+1):nx,])
4026c4025
<             X[,indi[1:nz]]<-t(qr.qty(qrc,t(X[,indi,drop=FALSE]))[(nc+1):nx,,drop=FALSE])
---
>             X[,indi[seq_len(nz)]]<-t(qr.qty(qrc,t(X[,indi,drop=FALSE]))[(nc+1):nx,,drop=FALSE])
diff -rEZbwB '--exclude=*.[lo,d,pdf,mo,po,tgz,gz,save]*' '--exclude=MD5' '--exclude=Makefile*' '--exclude=all.R' '--exclude=Changes' R-recommended/mgcv/R/soap.r Recommended/mgcv/R/soap.r
14c14
<     for (i in 1:length(beta.full)) {
---
>     for (i in seq_len(length(beta.full))) {
41c41
<           for (i in 1:length(beta.full)) {
---
>           for (i in seq_len(length(beta.full))) {
60c60
<         beta <- c(beta[1:(qrc[1]-1)],0,beta[qrc[1]:length(beta)])
---
>         beta <- c(beta[seq_len(qrc[1]-1)],0,beta[qrc[1]:length(beta)])
66c66
<         beta <- c(beta[1:(qrc-1)],0,beta[qrc:length(beta)])
---
>         beta <- c(beta[seq_len(qrc-1)],0,beta[qrc:length(beta)])
107c107
<   if (is.null(bnd.name)) for (i in 1:length(bnd)) { 
---
>   if (is.null(bnd.name)) for (i in seq_len(length(bnd))) { 
131c131
< { for (i in 1:length(bnd)) {
---
> { for (i in seq_len(length(bnd))) {
133c133
<     if (length(y)!=n) stop("x and y not same length")
---
>     if (length(y)!=n) stop("'x' and 'y' components of 'bnd' argument are not of same length")
142c142
<     len <- c(0,sqrt((x[1:(n-1)]-x[2:n])^2+(y[1:(n-1)]-y[2:n])^2)) ## seg lengths
---
>     len <- c(0,sqrt((x[seq_len(n-1)]-x[2:n])^2+(y[seq_len(n-1)]-y[2:n])^2)) ## seg lengths
157c157
<   for (k in 1:nk) {
---
>   for (k in seq_len(nk)) {
163c163
<         str <- paste("knot",k,"is on or outside boundary")
---
>         str <- gettextf("knot %d is on or outside boundary", k)
177c177
<   if (!inherits(bnd,"list")) stop("bnd must be a list.")
---
>   if (!inherits(bnd,"list")) stop("bnd must be a list")
181c181
<     else stop("lengths of k and bnd are not compatible.") 
---
>     else stop("lengths of 'k' and 'bnd' arguments are inconsistent") 
224c224
<   ind <- 1:o1$n
---
>   ind <- seq_len(o1$n)
239c239
<   for (i in 1:length(bnd)) {
---
>   for (i in seq_len(length(bnd))) {
255c255
<       bc[[i]] <- list(bsm=bsm,X=bsm$X[1:ret$nb[i],],S=bsm$S[[1]],free.bound=TRUE)
---
>       bc[[i]] <- list(bsm=bsm,X=bsm$X[seq_len(ret$nb[i]),],S=bsm$S[[1]],free.bound=TRUE)
292c292
<     for (i in 1:length(sd$bc)) { ## work through boundary loops
---
>     for (i in seq_len(length(sd$bc))) { ## work through boundary loops
318c318
<       gind[G[ind]] <- (1:length(G))[ind]
---
>       gind[G[ind]] <- seq_len(length(G))[ind]
350c350
<     for (i in 1:length(sd$bc)) { ## work through boundary loops
---
>     for (i in seq_len(length(sd$bc))) { ## work through boundary loops
360c360
<         for (j in 1:ncol(sd$bc[[i]]$X)) { ## loop over loop basis cols
---
>         for (j in seq_len(ncol(sd$bc[[i]]$X))) { ## loop over loop basis cols
384c384
<     for (i in 1:nc) g[sd$ki[i],i] <- 1
---
>     for (i in seq_len(nc)) g[sd$ki[i],i] <- 1
393c393
<     for (i in 1:nc) {
---
>     for (i in seq_len(nc)) {
433c433
<   for (i in 1:length(bnd)) { ## re-lable boundary
---
>   for (i in seq_len(length(bnd))) { ## re-lable boundary
446c446
<     stop("k and bnd lengths are inconsistent")
---
>     stop("lengths of 'bs.dim' and 'bnd' components of 'object' argument are inconsistent")
467c467
<   if (n>0) for (i in 1:n) if (sd$bc[[i]]$free.bound) 
---
>   if (n>0) for (i in seq_len(n)) if (sd$bc[[i]]$free.bound) 
471c471
<   for (i in 1:length(sd$bc)) 
---
>   for (i in seq_len(length(sd$bc))) 
478c478
<   for (i in  1:length(b$S)) {
---
>   for (i in  seq_len(length(b$S))) {
490c490
<     for (i in 1:length(b$S)) {
---
>     for (i in seq_len(length(b$S))) {
508c508
<   for (i in 1:length(sd$bc)) {
---
>   for (i in seq_len(length(sd$bc))) {
537c537
<   for (i in 1:length(bnd)) { ## re-lable boundary
---
>   for (i in seq_len(length(bnd))) { ## re-lable boundary
550c550
<     stop("k and bnd lengths are inconsistent")
---
>     stop("lengths of 'bs.dim' and 'bnd' components of 'object' argument are inconsistent")
572c572
<   if (n>0) for (i in 1:n) if (sd$bc[[i]]$free.bound) { 
---
>   if (n>0) for (i in seq_len(n)) if (sd$bc[[i]]$free.bound) { 
582c582
<   for (i in 1:length(sd$bc)) 
---
>   for (i in seq_len(length(sd$bc))) 
589c589
<   if (length(b$S)>0) for (i in  1:length(b$S)) {
---
>   if (length(b$S)>0) for (i in  seq_len(length(b$S))) {
601c601
<     if (length(b$S)>0) for (i in 1:length(b$S)) {
---
>     if (length(b$S)>0) for (i in seq_len(length(b$S))) {
614c614
<   for (i in 1:length(sd$bc)) {
---
>   for (i in seq_len(length(sd$bc))) {
642c642
<   for (i in 1:length(bnd)) { ## re-lable boundary
---
>   for (i in seq_len(length(bnd))) { ## re-lable boundary
655c655
<     stop("k and bnd lengths are inconsistent")
---
>     stop("lengths of 'bs.dim' and 'bnd' components of 'object' argument are inconsistent")
675c675
<   for (i in  1:length(b$S)) {
---
>   for (i in  seq_len(length(b$S))) {
686c686
<     for (i in 1:length(b$S)) {
---
>     for (i in seq_len(length(b$S))) {
703c703
<   for (i in 1:length(sd$bc)) {
---
>   for (i in seq_len(length(sd$bc))) {
766c766
<                 for (i in 1:length(P$bnd)) lines(P$bnd[[i]],lwd=2)
---
>                 for (i in seq_len(length(P$bnd))) lines(P$bnd[[i]],lwd=2)
802c802
<           for (i in 1:length(P$bnd)) lines(P$bnd[[i]],lwd=2)
---
>           for (i in seq_len(length(P$bnd))) lines(P$bnd[[i]],lwd=2)
diff -rEZbwB '--exclude=*.[lo,d,pdf,mo,po,tgz,gz,save]*' '--exclude=MD5' '--exclude=Makefile*' '--exclude=all.R' '--exclude=Changes' R-recommended/mgcv/R/sparse.r Recommended/mgcv/R/sparse.r
14c14
<   ## ni[1:off[1]] gives neighbours of point 1. 
---
>   ## ni[seq_len(off[1])] gives neighbours of point 1. 
16c16
<   return(list(ni = oo$T[1:oo$off[n]]+1,off=oo$off))
---
>   return(list(ni = oo$T[seq_len(oo$off[n])]+1,off=oo$off))
33,34c33,34
<   ii <- c(1:n,oo$ii[1:ni]+1) ## row index
<   jj <- c(1:n,oo$ni[1:ni]+1) ## col index
---
>   ii <- c(seq_len(n),oo$ii[seq_len(ni)]+1) ## row index
>   jj <- c(seq_len(n),oo$ni[seq_len(ni)]+1) ## col index
37,39c37,39
<   Kx <- sparseMatrix(i=ii,j=jj,x=oo$D[1:ni],dims=c(n,n))
<   Kz <- sparseMatrix(i=ii,j=jj,x=oo$D[1:ni+ni],dims=c(n,n))
<   Kxz <- sparseMatrix(i=ii,j=jj,x=oo$D[1:ni+2*ni],dims=c(n,n))
---
>   Kx <- sparseMatrix(i=ii,j=jj,x=oo$D[seq_len(ni)],dims=c(n,n))
>   Kz <- sparseMatrix(i=ii,j=jj,x=oo$D[seq_len(ni)+ni],dims=c(n,n))
>   Kxz <- sparseMatrix(i=ii,j=jj,x=oo$D[seq_len(ni)+2*ni],dims=c(n,n))
112c112
<   lo <- dd[,1:d];hi <- dd[,1:d+d]
---
>   lo <- dd[,seq_len(d)];hi <- dd[,seq_len(d)+d]
123c123
<   for (i in 1:nb) {
---
>   for (i in seq_len(nb)) {
144c144
<   } else { Xu <- X; ind <- 1:nrow(X)}
---
>   } else { Xu <- X; ind <- seq_len(nrow(X))}
150c150
<   if (get.a) a <- 1:n else a=1
---
>   if (get.a) a <- seq_len(n) else a=1
156,157c156,157
<   rind <- 1:nobs
<   rind[ind] <- 1:nobs
---
>   rind <- seq_len(nobs)
>   rind[ind] <- seq_len(nobs)
252c252
<   P <- sparseMatrix(i=1:n,j=ind,x=rep(1,n),dims=c(n,nrow(xu)))
---
>   P <- sparseMatrix(i=seq_len(n),j=ind,x=rep(1,n),dims=c(n,nrow(xu)))
292,293c292,293
<     for (i in 1:nb) {
<       ind[[i]] <- (1:n)[block==levels(block)[i]]
---
>     for (i in seq_len(nb)) {
>       ind[[i]] <- (seq_len(n))[block==levels(block)[i]]
298c298
<     ind[[1]] <- 1:n
---
>     ind[[1]] <- seq_len(n)
323c323
<   if (block==0) block <- 1:object$nblock
---
>   if (block==0) block <- seq_len(object$nblock)
361c361
<   } else for (i in 1:object$nblock) { ## work through all blocks 
---
>   } else for (i in seq_len(object$nblock)) { ## work through all blocks 
393,394c393,394
<     for (i in 1:nb) { 
<       ind[[i]] <- (1:n)[block==levels(block)[i]]
---
>     for (i in seq_len(nb)) { 
>       ind[[i]] <- (seq_len(n))[block==levels(block)[i]]
398c398
<     ind[[1]] <- 1:n
---
>     ind[[1]] <- seq_len(n)
Only in R-recommended/mgcv/inst/po: ko
diff -rEZbwB '--exclude=*.[lo,d,pdf,mo,po,tgz,gz,save]*' '--exclude=MD5' '--exclude=Makefile*' '--exclude=all.R' '--exclude=Changes' R-recommended/mgcv/src/general.h Recommended/mgcv/src/general.h
3,8d2
< #ifdef ENABLE_NLS
< #include <libintl.h>
< #define _(String) dgettext ("mgcv", String)
< #else
< #define _(String) (String)
< #endif
Only in Recommended/mgcv/src: localization.h
diff -rEZbwB '--exclude=*.[lo,d,pdf,mo,po,tgz,gz,save]*' '--exclude=MD5' '--exclude=Makefile*' '--exclude=all.R' '--exclude=Changes' R-recommended/mgcv/src/magic.c Recommended/mgcv/src/magic.c
27a28
> #include "localization.h"
diff -rEZbwB '--exclude=*.[lo,d,pdf,mo,po,tgz,gz,save]*' '--exclude=MD5' '--exclude=Makefile*' '--exclude=all.R' '--exclude=Changes' R-recommended/mgcv/src/mat.c Recommended/mgcv/src/mat.c
31a32
> #include "localization.h"
47c48
<     Rprintf("\nFailed to open file\n");
---
>     Rprintf(_("\nFailed to open file\n"));
69c70
<     Rprintf("\nFailed to open file\n");
---
>     Rprintf(_("\nFailed to open file\n"));
77c78
<    if (j!= *r * *c)  Rprintf("\nfile dim problem\n");
---
>    if (j != *r * *c)  Rprintf(_("\nfile dim problem\n"));
2690c2691
<     if (k) Rprintf("Non orthogonal eigenvectors %d %g\n",k,x/k);
---
>     if (k) Rprintf(_("Non orthogonal eigenvectors %d %g\n"), k, x / k);
2695c2696
<     if (k) Rprintf("Eigenvectors not normalized %d %g\n",k,x/k);
---
>     if (k) Rprintf(_("Eigenvectors not normalized %d %g\n"), k, x / k);
diff -rEZbwB '--exclude=*.[lo,d,pdf,mo,po,tgz,gz,save]*' '--exclude=MD5' '--exclude=Makefile*' '--exclude=all.R' '--exclude=Changes' R-recommended/mgcv/src/matrix.c Recommended/mgcv/src/matrix.c
32a33
> #include "localization.h"
diff -rEZbwB '--exclude=*.[lo,d,pdf,mo,po,tgz,gz,save]*' '--exclude=MD5' '--exclude=Makefile*' '--exclude=all.R' '--exclude=Changes' R-recommended/mgcv/src/mvn.c Recommended/mgcv/src/mvn.c
15,16c15,16
<             int *m,double *ll,double *lb,double *lbb,double *dbeta,
<             double *dH,int *deriv,int *nsp,int *nt) {
---
> int *m, double *ll, double *lb, double *lbb, double *dbeta, double *dH,
> 		int *deriv, int *nsp, int *nt) {
31,33c31,35
<   double *R,*theta,ldetR,*Xl,*bl,oned=1.0,zerod=0.0,*p,*p1,*p2,*p3,xx,zz,yy,*yty,
<     *mu,*Rymu,rip,*dtheta,*db,*deriv_theta,*yX,*yRX;
<   int i,j,k,l,pl,one=1,bt,ct,nb,*din,ntheta,ncoef,*rri,*rci,ri,rj,ril,rjl,rik,rjk,rij,rjj,q,r;
---
> 	double *R, *theta, ldetR, *Xl, *bl, oned = 1.0, zerod = 0.0, *p, *p1, *p2,
> 			*p3, xx, zz, yy, *yty, *mu, *Rymu, rip, *dtheta, *db, *deriv_theta,
> 			*yX, *yRX;
> 	int i, j, k, l, pl, one = 1, bt, ct, nb, *din, ntheta, ncoef, *rri, *rci,
> 			ri, rj, ril, rjl, rik, rjk, rij, rjj, q, r;
35c37,38
<   ntheta = *m * (*m+1)/2;ncoef = lpi[*m-1];
---
> 	ntheta = *m * (*m + 1) / 2;
> 	ncoef = lpi[*m - 1];
47,48c50,53
<     R[i + *m * i] = deriv_theta[k];ldetR += theta[k];
<     rri[k]=rci[k]=i;k++; 
---
> 		R[i + *m * i] = deriv_theta[k];
> 		ldetR += theta[k];
> 		rri[k] = rci[k] = i;
> 		k++;
52c57,59
<       rri[k]=i;rci[k]=j;k++;
---
> 			rri[k] = i;
> 			rci[k] = j;
> 			k++;
58,60c65,76
<     if (l==0) { Xl = X;pl = lpi[0];bl=beta;} /* Xl is lth model matrix with pl columns, coef vec bl */ 
<     else { Xl = X + *n * lpi[l-1];pl = lpi[l]-lpi[l-1];bl = beta + lpi[l-1];}   
<     F77_CALL(dgemv)(&not_trans,n,&pl,&oned,Xl,n, bl, &one,&zerod, mu, &one); /* BLAS call for mu = Xl bl */
---
> 		if (l == 0) {
> 			Xl = X;
> 			pl = lpi[0];
> 			bl = beta;
> 		} /* Xl is lth model matrix with pl columns, coef vec bl */
> 		else {
> 			Xl = X + *n * lpi[l - 1];
> 			pl = lpi[l] - lpi[l - 1];
> 			bl = beta + lpi[l - 1];
> 		}
> 		F77_CALL(dgemv)(&not_trans, n, &pl, &oned, Xl, n, bl, &one, &zerod, mu,
> 				&one); /* BLAS call for mu = Xl bl */
62c78,79
<     for (p=mu,p1= mu + *n,p2=y+l;p<p1;p++,p2 += *m) *p2 -= *p;
---
> 		for (p = mu, p1 = mu + *n, p2 = y + l; p < p1; p++, p2 += *m)
> 			*p2 -= *p;
69c86,88
<   bt=0;ct=0;mgcv_pmmult(Rymu,R,y,&bt,&ct,m,n,m,nt);  
---
> 	bt = 0;
> 	ct = 0;
> 	mgcv_pmmult(Rymu, R, y, &bt, &ct, m, n, m, nt);
71c90,91
<   for (*ll=0.0,p=Rymu,p1=p + *n * *m;p<p1;p++) *ll += *p * *p;
---
> 	for (*ll = 0.0, p = Rymu, p1 = p + *n * *m; p < p1; p++)
> 		*ll += *p * *p;
79,80c99,106
<     if (l==0) { Xl = X;pl = lpi[0];} /* Xl is lth model matrix with pl columns */ 
<     else { Xl = X + *n * lpi[l-1];pl = lpi[l]-lpi[l-1];} 
---
> 		if (l == 0) {
> 			Xl = X;
> 			pl = lpi[0];
> 		} /* Xl is lth model matrix with pl columns */
> 		else {
> 			Xl = X + *n * lpi[l - 1];
> 			pl = lpi[l] - lpi[l - 1];
> 		}
85c111,113
<         for (p1=R + l * *m,p2 = p1 + l,p3 = Rymu + *m *j;p1<=p2;p1++,p3++) *p += xx * *p1 * *p3; 
---
> 				for (p1 = R + l * *m, p2 = p1 + l, p3 = Rymu + *m * j; p1 <= p2;
> 						p1++, p3++)
> 					*p += xx * *p1 * *p3;
94c122,123
<     xx = deriv_theta[k]; /* the non-zero element of R_theta^i at i,i */;
---
> 		xx = deriv_theta[k]; /* the non-zero element of R_theta^i at i,i */
> 		;
98c127,129
<     for (zz=0.0,l=0,p1 = Rymu+i,p2=y+i;l<*n;l++,p1 += *m,p2 += *m) zz += *p1 * *p2 * xx;
---
> 		for (zz = 0.0, l = 0, p1 = Rymu + i, p2 = y + i; l < *n;
> 				l++, p1 += *m, p2 += *m)
> 			zz += *p1 * *p2 * xx;
103c134,136
<       for (zz=0.0,l=0,p1 = Rymu+i,p2=y+j;l<*n;l++,p1 += *m,p2 += *m) zz += *p1 * *p2;
---
> 			for (zz = 0.0, l = 0, p1 = Rymu + i, p2 = y + j; l < *n; l++, p1 +=
> 					*m, p2 += *m)
> 				zz += *p1 * *p2;
113c146,147
<     if (i==lpi[k]) k++; 
---
> 		if (i == lpi[k])
> 			k++;
117,118c151,154
<   for (i=0;i<ncoef;i++) for (j=0;j<=i;j++) {
<      l=din[i];k=din[j]; /* note l>=k */
---
> 	for (i = 0; i < ncoef; i++)
> 		for (j = 0; j <= i; j++) {
> 			l = din[i];
> 			k = din[j]; /* note l>=k */
120c156,158
<      for (p=R+l * *m,p1=R+k * *m,rip=0.0,p2=p1+k;p1<=p2;p++,p1++) rip += *p * *p1;
---
> 			for (p = R + l * *m, p1 = R + k * *m, rip = 0.0, p2 = p1 + k;
> 					p1 <= p2; p++, p1++)
> 				rip += *p * *p1;
124c162,163
<   for (i=0;i<ncoef;i++) for (j=0;j<ntheta;j++) {
---
> 	for (i = 0; i < ncoef; i++)
> 		for (j = 0; j < ntheta; j++) {
131c170,173
<      if (l==rj) for (p = X + i* *n,p1=Rymu+ri,p2=p + *n;p<p2;p++,p1 += *m) xx += *p * *p1;
---
> 			if (l == rj)
> 				for (p = X + i * *n, p1 = Rymu + ri, p2 = p + *n; p < p2;
> 						p++, p1 += *m)
> 					xx += *p * *p1;
135c177,179
<        for (yy=0.0,p = X + i* *n,p1=y+rj,p2=p + *n;p<p2;p++,p1 += *m) yy += *p * *p1;
---
> 				for (yy = 0.0, p = X + i * *n, p1 = y + rj, p2 = p + *n; p < p2;
> 						p++, p1 += *m)
> 					yy += *p * *p1;
141c185,186
<   for (k=0;k<ntheta;k++) for (l=0;l<=k;l++) {
---
> 	for (k = 0; k < ntheta; k++)
> 		for (l = 0; l <= k; l++) {
144c189,190
<         ri=rri[k];rj=rci[k];
---
> 				ri = rri[k];
> 				rj = rci[k];
147c193,195
<           for (zz=0.0,i=0,p=Rymu+ri,p2=y+ri;i<*n;i++,p += *m,p2+= *m) zz += *p * *p2;
---
> 					for (zz = 0.0, i = 0, p = Rymu + ri, p2 = y + ri; i < *n;
> 							i++, p += *m, p2 += *m)
> 						zz += *p * *p2;
152c200,201
<       ri=rri[k];rj=rci[k];
---
> 			ri = rri[k];
> 			rj = rci[k];
155,156c204,207
<       ril=rri[l];rjl=rci[l];
<       rik=rri[k];rjk=rci[k];
---
> 			ril = rri[l];
> 			rjl = rci[l];
> 			rik = rri[k];
> 			rjk = rci[k];
158c209,211
< 	for (yy=0.0,i=0,p=y+rjl,p1=y+rjk;i<*n;i++,p+= *m, p1+= *m) yy += *p * *p1;
---
> 				for (yy = 0.0, i = 0, p = y + rjl, p1 = y + rjk; i < *n;
> 						i++, p += *m, p1 += *m)
> 					yy += *p * *p1;
160c213,214
<         if (ril==rjl) yy *= deriv_theta[l];
---
> 				if (ril == rjl)
> 					yy *= deriv_theta[l];
163c217,218
<       lbb[k + ncoef + nb * (l+ncoef)] = lbb[l + ncoef + nb * (k+ncoef)] = xx;
---
> 			lbb[k + ncoef + nb * (l + ncoef)] =
> 					lbb[l + ncoef + nb * (k + ncoef)] = xx;
170c225,227
<     bt=0;ct=0;mgcv_pmmult(yX,y,X,&bt,&ct,m,&ncoef,n,nt); /* rows, dim, cols coef */   
---
> 		bt = 0;
> 		ct = 0;
> 		mgcv_pmmult(yX, y, X, &bt, &ct, m, &ncoef, n, nt); /* rows, dim, cols coef */
172c229,231
<     bt=0;ct=0;mgcv_pmmult(yRX,Rymu,X,&bt,&ct,m,&ncoef,n,nt); /* rows, dim, cols coef */  
---
> 		bt = 0;
> 		ct = 0;
> 		mgcv_pmmult(yRX, Rymu, X, &bt, &ct, m, &ncoef, n, nt); /* rows, dim, cols coef */
174c233,235
<     bt=0;ct=1;mgcv_pmmult(yty,y,y,&bt,&ct,m,m,n,nt); /* rows, cols dim */  
---
> 		bt = 0;
> 		ct = 1;
> 		mgcv_pmmult(yty, y, y, &bt, &ct, m, m, n, nt); /* rows, cols dim */
181,183c242,248
<       for (i=0;i<ncoef;i++) for (j=0;j<=i;j++) {
< 	l = din[i];k = din[j]; /* dimensions for these elements */
< 	xx=0.0;p=R+l* *m;p1=R+k* *m;
---
> 			for (i = 0; i < ncoef; i++)
> 				for (j = 0; j <= i; j++) {
> 					l = din[i];
> 					k = din[j]; /* dimensions for these elements */
> 					xx = 0.0;
> 					p = R + l * *m;
> 					p1 = R + k * *m;
185,187c250,255
<           ri=rri[q];rj=rci[q]; /* row and col of non zero element of deriv of R wrt theta_q */
<           if (rj==l) xx += p1[ri]*deriv_theta[q]*dtheta[q];
<           if (rj==k) xx += p[ri]*deriv_theta[q]*dtheta[q];
---
> 						ri = rri[q];
> 						rj = rci[q]; /* row and col of non zero element of deriv of R wrt theta_q */
> 						if (rj == l)
> 							xx += p1[ri] * deriv_theta[q] * dtheta[q];
> 						if (rj == k)
> 							xx += p[ri] * deriv_theta[q] * dtheta[q];
194c262,263
<       for (i=0;i<ncoef;i++) for (j=0;j<ntheta;j++) {  
---
> 			for (i = 0; i < ncoef; i++)
> 				for (j = 0; j < ntheta; j++) {
199c268,269
<           ri=rri[j];rj=rci[j]; /* row and col of non zero element of deriv of R wrt theta_j */
---
> 						ri = rri[j];
> 						rj = rci[j]; /* row and col of non zero element of deriv of R wrt theta_j */
201,202c271,276
<           if (rj==l) xx += -R[ri + *m * k]*zz*XX[i + ncoef * q] * db[q];
<           if (rj==k) xx += -R[ri + *m * l]*zz*XX[i + ncoef * q] * db[q];
---
> 						if (rj == l)
> 							xx += -R[ri + *m * k] * zz * XX[i + ncoef * q]
> 									* db[q];
> 						if (rj == k)
> 							xx += -R[ri + *m * l] * zz * XX[i + ncoef * q]
> 									* db[q];
205c279,280
<         rij=rri[j];rjj=rci[j]; /* row and col of non zero element of deriv of R wrt theta_j */
---
> 					rij = rri[j];
> 					rjj = rci[j]; /* row and col of non zero element of deriv of R wrt theta_j */
208c283,284
<           rik=rri[k];rjk=rci[k]; /* row and col of non zero element of deriv of R wrt theta_k */
---
> 						rik = rri[k];
> 						rjk = rci[k]; /* row and col of non zero element of deriv of R wrt theta_k */
210,211c286,291
<             if (l==rjj) zz +=  yX[rjk + i * *m] * deriv_theta[j] * deriv_theta[k];
<             if (l==rjk) zz +=  yX[rjj + i * *m] * deriv_theta[j] * deriv_theta[k];
---
> 							if (l == rjj)
> 								zz += yX[rjk + i * *m] * deriv_theta[j]
> 										* deriv_theta[k];
> 							if (l == rjk)
> 								zz += yX[rjj + i * *m] * deriv_theta[j]
> 										* deriv_theta[k];
217c297,299
<           if (k==j&&rik==rjk) xx += dtheta[k]* deriv_theta[k] * R[rjj + *m * l] * yX[rjj + *m * i];/* x_i^l'R'R_tt^jk(y-mu) */
---
> 						if (k == j && rik == rjk)
> 							xx += dtheta[k] * deriv_theta[k] * R[rjj + *m * l]
> 									* yX[rjj + *m * i];/* x_i^l'R'R_tt^jk(y-mu) */
223,224c305,310
<       for (j=0;j<ntheta;j++) for (k=j;k<ntheta;k++) {
<         rij=rri[j];rjj=rci[j];rik=rri[k];rjk=rci[k];
---
> 			for (j = 0; j < ntheta; j++)
> 				for (k = j; k < ntheta; k++) {
> 					rij = rri[j];
> 					rjj = rci[j];
> 					rik = rri[k];
> 					rjk = rci[k];
228c314,315
< 	  zz=0.0;l=din[i];
---
> 						zz = 0.0;
> 						l = din[i];
230,231c317,322
<             if (l==rjj) zz +=  yX[rjk + i * *m] * deriv_theta[j] * deriv_theta[k];
<             if (l==rjk) zz +=  yX[rjj + i * *m] * deriv_theta[j] * deriv_theta[k];
---
> 							if (l == rjj)
> 								zz += yX[rjk + i * *m] * deriv_theta[j]
> 										* deriv_theta[k];
> 							if (l == rjk)
> 								zz += yX[rjj + i * *m] * deriv_theta[j]
> 										* deriv_theta[k];
236c327,328
<               if (l==rjj) zz +=  deriv_theta[k] * yRX[rjj + *m * i];  /* x_i^l'R_tt^jk R(y-mu) */
---
> 								if (l == rjj)
> 									zz += deriv_theta[k] * yRX[rjj + *m * i]; /* x_i^l'R_tt^jk R(y-mu) */
240c332,334
<           if (k==j&&rij==rjj) xx +=  db[i]*deriv_theta[k] * R[rjj + *m * l] * yX[rjj + *m * i]; /* x_i^l'R'R_tt^jk(y-mu) */
---
> 						if (k == j && rij == rjj)
> 							xx += db[i] * deriv_theta[k] * R[rjj + *m * l]
> 									* yX[rjj + *m * i]; /* x_i^l'R'R_tt^jk(y-mu) */
243,246c337,348
< 	  ri = rri[i];rj=rci[i];zz=0.0;
<           if (j==k&&ri==rij&&rjk==rik) zz += deriv_theta[j]*deriv_theta[i]*yty[rj * *m + rjj];  /* row rjj, col rj */ 
<           if (i==k&&rik==rij&&rj==ri) zz += deriv_theta[j]*deriv_theta[i]*yty[rjk * *m + rjj];  /* row rjj, col rjk */ 
<           if (i==j&&rik==rij&&rj==ri) zz += deriv_theta[k]*deriv_theta[i]*yty[rjk * *m + rj];  /* row rjk, col rj */ 
---
> 						ri = rri[i];
> 						rj = rci[i];
> 						zz = 0.0;
> 						if (j == k && ri == rij && rjk == rik)
> 							zz += deriv_theta[j] * deriv_theta[i]
> 									* yty[rj * *m + rjj]; /* row rjj, col rj */
> 						if (i == k && rik == rij && rj == ri)
> 							zz += deriv_theta[j] * deriv_theta[i]
> 									* yty[rjk * *m + rjj]; /* row rjj, col rjk */
> 						if (i == j && rik == rij && rj == ri)
> 							zz += deriv_theta[k] * deriv_theta[i]
> 									* yty[rjk * *m + rj]; /* row rjk, col rj */
249c351,353
<             for (yy=0.0,p=Rymu+ri,p1=y+ri,q=0;q<*n;p+= *m,p1+= *m,q++) yy += *p * *p1;           
---
> 							for (yy = 0.0, p = Rymu + ri, p1 = y + ri, q = 0;
> 									q < *n; p += *m, p1 += *m, q++)
> 								yy += *p * *p1;
254c358,359
< 	dH[k + ncoef + (j+ncoef) * nb] = dH[j+ncoef + (k+ncoef) * nb] = xx;
---
> 					dH[k + ncoef + (j + ncoef) * nb] = dH[j + ncoef
> 							+ (k + ncoef) * nb] = xx;
259c364,366
<     FREE(yX);FREE(yRX);FREE(yty);
---
> 		FREE(yX);
> 		FREE(yRX);
> 		FREE(yty);
262,265c369,375
< 
<   FREE(din); FREE(rri); FREE(rci);
<   
<   FREE(R);FREE(Rymu);FREE(deriv_theta);
---
> 	FREE(din);
> 	FREE(rri);
> 	FREE(rci);
> 
> 	FREE(R);
> 	FREE(Rymu);
> 	FREE(deriv_theta);
diff -rEZbwB '--exclude=*.[lo,d,pdf,mo,po,tgz,gz,save]*' '--exclude=MD5' '--exclude=Makefile*' '--exclude=all.R' '--exclude=Changes' R-recommended/mgcv/src/qp.c Recommended/mgcv/src/qp.c
29a30,31
> #include "localization.h"
> #include <R_ext/Minmax.h>
32,35d33
< 
< 
< #define max(a,b)    (((a) > (b)) ? (a) : (b))
< #define min(a,b)    (((a) < (b)) ? (a) : (b))
diff -rEZbwB '--exclude=*.[lo,d,pdf,mo,po,tgz,gz,save]*' '--exclude=MD5' '--exclude=Makefile*' '--exclude=all.R' '--exclude=Changes' R-recommended/mgcv/src/sparse-smooth.c Recommended/mgcv/src/sparse-smooth.c
23a24
> #include "localization.h"
142c143
<     if (kd.box[i].p1-kd.box[i].p0>1) { Rprintf("More than 2 points in a box!!\n");ok=0;}
---
>     if (kd.box[i].p1-kd.box[i].p0>1) { Rprintf(_("More than 2 points in a box!!\n"));ok=0;}
147c148
<     if (count[i]!=1) { Rprintf("point %d in %d boxes!\n",i,count[i]);ok=0;}
---
>     if (count[i]!=1) { Rprintf(_("point %d in %d boxes!\n"),i,count[i]);ok=0;}
149c150
<   if (ok) Rprintf("kd tree sanity checks\n");
---
>   if (ok) Rprintf(_("kd tree sanity checks\n"));
309c310
<     if (bi>nb-1) Rprintf("too many boxes!!");
---
>     if (bi>nb-1) Rprintf(_("too many boxes!!"));
325c326
<     if (bi>nb-1) Rprintf("too many boxes!!");
---
>     if (bi>nb-1) Rprintf(_("too many boxes!!"));
341c342
<   if (bi!=nb-1) Rprintf("bi not equal to nb-1 %d %d\n",bi,nb-1);
---
>   if (bi!=nb-1) Rprintf(_("bi not equal to nb-1 %d %d\n"),bi,nb-1);
638c639
<       if (!check) Rprintf("indexing error in p_area!\n");
---
>       if (!check) Rprintf(_("indexing error in p_area!\n"));
diff -rEZbwB '--exclude=*.[lo,d,pdf,mo,po,tgz,gz,save]*' '--exclude=MD5' '--exclude=Makefile*' '--exclude=all.R' '--exclude=Changes' R-recommended/mgcv/src/tprs.c Recommended/mgcv/src/tprs.c
25a26
> #include "localization.h"
39,40c38,41
<   d2 = d/2;m2 = 2*m;
<   if (m2 <= d) error(_("You must have 2m>d for a thin plate spline."));
---
> 	d2 = d / 2;
> 	m2 = 2 * m;
> 	if (m2 <= d)
> 		error(_("You must have 2m>d for a thin plate spline."));
42,46c43,55
<   { if ((m+1+d2)%2) f= -1.0; else f=1.0; /* finding (-1)^{m+1+d/2} */
<     for (i=0;i<m2-1;i++) f/=2;  /* dividing by 2^{2m-1} */
<     for (i=0;i<d2;i++) f/=pi;  /* dividing by pi^{d/2} */
<     for (i=2;i<m;i++) f/=i; /* dividing by (m-1)! */
<     for (i=2;i<=m-d2;i++) f/=i; /* dividing by (m-d/2)! */
---
> 	{
> 		if ((m + 1 + d2) % 2)
> 			f = -1.0;
> 		else
> 			f = 1.0; /* finding (-1)^{m+1+d/2} */
> 		for (i = 0; i < m2 - 1; i++)
> 			f /= 2; /* dividing by 2^{2m-1} */
> 		for (i = 0; i < d2; i++)
> 			f /= pi; /* dividing by pi^{d/2} */
> 		for (i = 2; i < m; i++)
> 			f /= i; /* dividing by (m-1)! */
> 		for (i = 2; i <= m - d2; i++)
> 			f /= i; /* dividing by (m-d/2)! */
48c57,58
<   { f=Ghalf;
---
> 	{
> 		f = Ghalf;
50,52c60,65
<     for (i=0;i<k;i++) f/= -0.5-i; /* f = gamma function of d/2-m */
<     for (i=0;i<m;i++) f/= 4; /* divide by 2^{2m} */
<     for (i=0;i<d2;i++) f/=pi;
---
> 		for (i = 0; i < k; i++)
> 			f /= -0.5 - i; /* f = gamma function of d/2-m */
> 		for (i = 0; i < m; i++)
> 			f /= 4; /* divide by 2^{2m} */
> 		for (i = 0; i < d2; i++)
> 			f /= pi;
54c67,68
<     for (i=2;i<m;i++) f/=i;  /* divide by (m-1)! */
---
> 		for (i = 2; i < m; i++)
> 			f /= i; /* divide by (m-1)! */
63c77,78
<   if (r<=0.0) return(0.0); /* this is safe: even if eta() gets inlined so that r comes in in an fp register! */
---
> 	if (r <= 0.0)
> 		return (0.0); /* this is safe: even if eta() gets inlined so that r comes in in an fp register! */
66c81,82
<     for (i=0;i<m-d2;i++) f *= r; /* r^2m-d (noting r is really r^2) */
---
> 		for (i = 0; i < m - d2; i++)
> 			f *= r; /* r^2m-d (noting r is really r^2) */
68c84,85
<     for (i=0;i<m-d2-1 ;i++) f *= r; /* note r really r^2 */
---
> 		for (i = 0; i < m - d2 - 1; i++)
> 			f *= r; /* note r really r^2 */
79c96,97
< { int i,j,k,Xr,Xc;
---
> {
> 	int i, j, k, Xr, Xc;
84,86c102,107
<   XMi = X->M;Xr = X->r;Xc = X->c;
<   for (i=0;i<Xr;i++,XMi++) for (XMj = X->M,j=0;j<i;j++,XMj++)
<   { r=0.0;
---
> 	XMi = X->M;
> 	Xr = X->r;
> 	Xc = X->c;
> 	for (i = 0; i < Xr; i++, XMi++)
> 		for (XMj = X->M, j = 0; j < i; j++, XMj++) {
> 			r = 0.0;
107c127,128
< { int *index,i,j,sum;
---
> {
> 	int *index, i, j, sum;
109,110c130
<   for (i=0;i < *M;i++)
<   { /* copy index to pi */
---
> 	for (i = 0; i < *M; i++) { /* copy index to pi */
112c132,133
<     for (j=0;j< *d;j++) pi[i + *M * j]=index[j];
---
> 		for (j = 0; j < *d; j++)
> 			pi[i + *M * j] = index[j];
114c135,137
<     sum=0;for (j=0;j< *d;j++) sum += index[j];
---
> 		sum = 0;
> 		for (j = 0; j < *d; j++)
> 			sum += index[j];
118c141,142
<     { sum -= index[0];
---
> 		{
> 			sum -= index[0];
120,123c144,151
<       for (j=1;j< *d;j++)
<       { index[j]++;sum++;
<         if (sum== *m) { sum-=index[j];index[j]=0;}
<         else break; /* problem resolved! */
---
> 			for (j = 1; j < *d; j++) {
> 				index[j]++;
> 				sum++;
> 				if (sum == *m) {
> 					sum -= index[j];
> 					index[j] = 0;
> 				} else
> 					break; /* problem resolved! */
138c165,166
< { int M,i,j,k,*pin,z;
---
> {
> 	int M, i, j, k, *pin, z;
141,142c169,172
<   for (i=0;i<d;i++) M*=d+m-1-i;
<   for (i=2;i<=d;i++) M/=i;     /* M = (m+d+1)!/(d!(m-d!) */
---
> 	for (i = 0; i < d; i++)
> 		M *= d + m - 1 - i;
> 	for (i = 2; i <= d; i++)
> 		M /= i; /* M = (m+d+1)!/(d!(m-d!) */
152,154c182,186
<   for (j=0;j<M;j++)
<   { x=1.0;/* for (k=0;k<d;k++) for (z=0;z<pin[j][k];z++) x *= X->M[i][k]; */
<     for (k=0;k<d;k++) for (z=0;z<pin[j + M * k];z++) x *= X->M[i][k];
---
> 		for (j = 0; j < M; j++) {
> 			x = 1.0;/* for (k=0;k<d;k++) for (z=0;z<pin[j][k];z++) x *= X->M[i][k]; */
> 			for (k = 0; k < d; k++)
> 				for (z = 0; z < pin[j + M * k]; z++)
> 					x *= X->M[i][k];
169,170c200,206
< { int M,i;
<   if (2*m<=d) {m=1;while (2*m<d+2) m++;} 
---
> {
> 	int M, i;
> 	if (2 * m <= d) {
> 		m = 1;
> 		while (2 * m < d + 2)
> 			m++;
> 	}
172,173c208,211
<   for (i=0;i<d;i++) M*=d+m-1-i;/* get (m+d-1)!/(m-1)! = (m+d-1)*(m+d-2) ... *(m) -- d terms */ 
<   for (i=2;i<=d;i++) M/=i;     /* M = (m+d-1)!/(d!(m-1)!) */
---
> 	for (i = 0; i < d; i++)
> 		M *= d + m - 1 - i;/* get (m+d-1)!/(m-1)! = (m+d-1)*(m+d-2) ... *(m) -- d terms */
> 	for (i = 2; i <= d; i++)
> 		M /= i; /* M = (m+d-1)!/(d!(m-1)!) */
177,178c215,216
< 
< double tps_g(matrix *X,matrix *p,double *x,int d,int m,double *b,int constant)
---
> double tps_g(matrix *X, matrix *p, double *x, int d, int m, double *b,
> 		int constant)
200c238,239
< { static int sd=0,sm=0,*pin,M;
---
> {
> 	static int sd = 0, sm = 0, *pin, M;
204,205c243,249
<   if (sd==0&&d==0) return(0.0); /* There is nothing to clear up and nothing to calculate */
<   if (2*m<=d&&d>0) { m=0;while (2*m<d+2) m++;} 
---
> 	if (sd == 0 && d == 0)
> 		return (0.0); /* There is nothing to clear up and nothing to calculate */
> 	if (2 * m <= d && d > 0) {
> 		m = 0;
> 		while (2 * m < d + 2)
> 			m++;
> 	}
207,209c251,256
<   { if (sd>0&&sm>0) 
<     { /*for (i=0;i<M;i++) FREE(pin[i]);*/ FREE(pin);}
<     sd=d;sm=m;
---
> 	{
> 		if (sd > 0 && sm > 0) { /*for (i=0;i<M;i++) FREE(pin[i]);*/
> 			FREE(pin);
> 		}
> 		sd = d;
> 		sm = m;
211,213c258,263
<     { M=1;     /* dimension of penalty null space */
<       for (i=0;i<d;i++) M*=d+m-1-i;
<       for (i=2;i<=d;i++) M/=i;     /* M = (m+d+1)!/(d!(m-d!) */
---
> 		{
> 			M = 1; /* dimension of penalty null space */
> 			for (i = 0; i < d; i++)
> 				M *= d + m - 1 - i;
> 			for (i = 2; i <= d; i++)
> 				M /= i; /* M = (m+d+1)!/(d!(m-d!) */
219c269,270
<     } else return(0.0);
---
> 		} else
> 			return (0.0);
221,224c272,282
<   g=0.0;XM=X->M;n = X->r;
<   for (pb=b,i=0;i<n;i++,pb++)
<   { r=0.0;XMi=XM[i];
<     for (dum=x;dum<x+d;dum++) { z= *XMi - *dum;XMi++;r+=z*z;}
---
> 	g = 0.0;
> 	XM = X->M;
> 	n = X->r;
> 	for (pb = b, i = 0; i < n; i++, pb++) {
> 		r = 0.0;
> 		XMi = XM[i];
> 		for (dum = x; dum < x + d; dum++) {
> 			z = *XMi - *dum;
> 			XMi++;
> 			r += z * z;
> 		}
227c285,286
<     if (p->r) g += *pb *p->V[i];
---
> 		if (p->r)
> 			g += *pb * p->V[i];
231c290,291
<   { r=1.0;
---
> 	{
> 		r = 1.0;
234c294,296
<     for (j=0;j<d;j++) for (k=0;k<pin[i+M*j];k++)  r*=x[j];
---
> 		for (j = 0; j < d; j++)
> 			for (k = 0; k < pin[i + M * j]; k++)
> 				r *= x[j];
236c298,299
<     if (p->r) g+=p->V[i+n-off]*r;
---
> 		if (p->r)
> 			g += p->V[i + n - off] * r;
245,246c308,312
< { int i;
<   for (i=0;i<k;i++) if (a[i]!=b[i]) return(0);
---
> {
> 	int i;
> 	for (i = 0; i < k; i++)
> 		if (a[i] != b[i])
> 			return (0);
267c333,334
< { int *yxindex,start,stop,ok,i;
---
> {
> 	int *yxindex, start, stop, ok, i;
272,276c339,343
<   start=stop=0;ok=1;
<   while(ok)
<   { /* look for start of run of equal rows ..... */
<     while(start<Xd->r-1&&!Xd_row_comp(Xd->M[start],Xd->M[start+1],Xd->c-1)) 
<     { /* Xd->M[start] not tied with anything, nothing to erase.... */
---
> 	start = stop = 0;
> 	ok = 1;
> 	while (ok) { /* look for start of run of equal rows ..... */
> 		while (start < Xd->r - 1
> 				&& !Xd_row_comp(Xd->M[start], Xd->M[start + 1], Xd->c - 1)) { /* Xd->M[start] not tied with anything, nothing to erase.... */
281,282c348,349
<     if (start==Xd->r-1) 
<     { ok=0; /* reached end with no more ties */
---
> 		if (start == Xd->r - 1) {
> 			ok = 0; /* reached end with no more ties */
287,288c354,358
<     { stop=start+1;
<       while(stop<Xd->r-1&&Xd_row_comp(Xd->M[stop],Xd->M[stop+1],Xd->c-1)) stop++;
---
> 		{
> 			stop = start + 1;
> 			while (stop < Xd->r - 1
> 					&& Xd_row_comp(Xd->M[stop], Xd->M[stop + 1], Xd->c - 1))
> 				stop++;
290c360,361
<       { xi=Xd->M[i][Xd->c-1];
---
> 			{
> 				xi = Xd->M[i][Xd->c - 1];
294,295c365,367
<       for (i=stop+1;i<Xd->r;i++)
<       { Xd->M[i-stop+start]=Xd->M[i];}
---
> 			for (i = stop + 1; i < Xd->r; i++) {
> 				Xd->M[i - stop + start] = Xd->M[i];
> 			}
297,298c369,371
<       for (i=1;i<=stop-start;i++)
<       { Xd->M[Xd->r-1+i]=dum[i];}
---
> 			for (i = 1; i <= stop - start; i++) {
> 				Xd->M[Xd->r - 1 + i] = dum[i];
> 			}
305,306c378,379
< void tprs_setup(double **x,double **knt,int m,int d,int n,int k,int constant,matrix *X,matrix *S,
<                 matrix *UZ,matrix *Xu,int n_knots)
---
> void tprs_setup(double **x, double **knt, int m, int d, int n, int k,
> 		int constant, matrix *X, matrix *S, matrix *UZ, matrix *Xu, int n_knots)
355c428,429
< { matrix X1,E,U,v,TU,T,Z,p;
---
> {
> 	matrix X1, E, U, v, TU, T, Z, p;
358c432,433
<   double w,*xc,*XMi,*Ea,*Ua,tol=DOUBLE_EPS,*b,*a,*uz,alpha=1.0,beta=0.0,*p0,*p1;
---
> 	double w, *xc, *XMi, *Ea, *Ua, tol = DOUBLE_EPS, *b, *a, *uz, alpha = 1.0,
> 			beta = 0.0, *p0, *p1;
362,363c437,443
<   { *Xu=initmat(n,d+1);
<     for (i=0;i<n;i++) { for (j=0;j<d;j++) Xu->M[i][j]=x[j][i];Xu->M[i][d]=(double)i;}
---
> 	{
> 		*Xu = initmat(n, d + 1);
> 		for (i = 0; i < n; i++) {
> 			for (j = 0; j < d; j++)
> 				Xu->M[i][j] = x[j][i];
> 			Xu->M[i][d] = (double) i;
> 		}
365,366c445,451
<   { *Xu=initmat(n_knots,d+1);
<     for (i=0;i<n_knots;i++) { for (j=0;j<d;j++) Xu->M[i][j]=knt[j][i];Xu->M[i][d]=(double)i;}
---
> 	{
> 		*Xu = initmat(n_knots, d + 1);
> 		for (i = 0; i < n_knots; i++) {
> 			for (j = 0; j < d; j++)
> 				Xu->M[i][j] = knt[j][i];
> 			Xu->M[i][d] = (double) i;
> 		}
375,376c459,466
<   error(_("A term has fewer unique covariate combinations than specified maximum degrees of freedom"));
<   if (2*m<=d) { m=0;while (2*m<d+2) m++;} 
---
> 		error(
> 				_(
> 						"A term has fewer unique covariate combinations than specified maximum degrees of freedom"));
> 	if (2 * m <= d) {
> 		m = 0;
> 		while (2 * m < d + 2)
> 			m++;
> 	}
382,383c472,477
<   {  k=M+1;
<      if (Xu->r<k) error(_("A term has fewer unique covariate combinations than specified maximum degrees of freedom"));
---
> 	{
> 		k = M + 1;
> 		if (Xu->r < k)
> 			error(
> 					_(
> 							"A term has fewer unique covariate combinations than specified maximum degrees of freedom"));
385c479,480
<   if (Xu->r==k) pure_knot=1; /* basis dimension is number of knots - don't need eigen step */
---
> 	if (Xu->r == k)
> 		pure_knot = 1; /* basis dimension is number of knots - don't need eigen step */
388c483,484
<   { *UZ=initmat(T.r+M-1+constant,T.r);
---
> 	{
> 		*UZ = initmat(T.r + M - 1 + constant, T.r);
391c487,489
<     for (i=0;i<T.r;i++) for (j=0;j<T.c;j++) TU.M[j][i]=T.M[i][j];
---
> 		for (i = 0; i < T.r; i++)
> 			for (j = 0; j < T.c; j++)
> 				TU.M[j][i] = T.M[i][j];
393c491,493
<     for (i=0;i<T.r;i++) for (j=0;j<T.c;j++) TU.M[j][i]=T.M[i][j];
---
> 		for (i = 0; i < T.r; i++)
> 			for (j = 0; j < T.c; j++)
> 				TU.M[j][i] = T.M[i][j];
396,398c496,497
<   } else
<   { v=initmat(k,1);    /* eigen-value matrix for E */
< 
---
> 	} else {
> 		v = initmat(k, 1); /* eigen-value matrix for E */
404c503,504
<       minus = -1;kk=k; 
---
> 		minus = -1;
> 		kk = k;
408,409c508,510
<       U = Rmatrix(Ua,E.r,k);FREE(Ea);FREE(Ua);
<     
---
> 		U = Rmatrix(Ua, E.r, k);
> 		FREE(Ea);
> 		FREE(Ua);
419c520,521
<     *UZ=initmat(U.r+M-1+constant,U.c);UZ->r=U.r;
---
> 		*UZ = initmat(U.r + M - 1 + constant, U.c);
> 		UZ->r = U.r;
421c523,524
<     HQmult(*UZ,Z,0,0);UZ->c -= M;      /* Now UZ multiplied by truncated delta gives full delta */
---
> 		HQmult(*UZ, Z, 0, 0);
> 		UZ->c -= M; /* Now UZ multiplied by truncated delta gives full delta */
426,427c529,533
<   for (i=0;i<E.r;i++) for (j=k-M;j<UZ->c;j++) UZ->M[i][j]=0.0;
<   for (i=0;i<M-1+constant;i++) UZ->M[UZ->r-i-1][UZ->c-i-1]=1.0;
---
> 	for (i = 0; i < E.r; i++)
> 		for (j = k - M; j < UZ->c; j++)
> 			UZ->M[i][j] = 0.0;
> 	for (i = 0; i < M - 1 + constant; i++)
> 		UZ->M[UZ->r - i - 1][UZ->c - i - 1] = 1.0;
431c537,538
<   { X1=initmat(U.r,k);
---
> 	{
> 		X1 = initmat(U.r, k);
433c540,542
<     for (i=0;i<X1.r;i++) for (j=0;j<X1.c;j++) X1.M[i][j]*=v.V[j];
---
> 		for (i = 0; i < X1.r; i++)
> 			for (j = 0; j < X1.c; j++)
> 				X1.M[i][j] *= v.V[j];
435c544,546
<     for (i=0;i<X1.r;i++) for (j=X1.c-M;j<X1.c;j++) X1.M[i][j]=0.0;
---
> 		for (i = 0; i < X1.r; i++)
> 			for (j = X1.c - M; j < X1.c; j++)
> 				X1.M[i][j] = 0.0;
438,440c549,557
<     for (i=0;i<X1.r;i++) for (j=0;j<T.c;j++) X1.M[i][X1.c-M+j]=T.M[i][j];
<     else 
<     { for (i=0;i<X1.r;i++) for (j=1;j<T.c;j++) X1.M[i][X1.c-M+j-1]=T.M[i][j];X1.c--;}
---
> 			for (i = 0; i < X1.r; i++)
> 				for (j = 0; j < T.c; j++)
> 					X1.M[i][X1.c - M + j] = T.M[i][j];
> 		else {
> 			for (i = 0; i < X1.r; i++)
> 				for (j = 1; j < T.c; j++)
> 					X1.M[i][X1.c - M + j - 1] = T.M[i][j];
> 			X1.c--;
> 		}
444,446c561,564
<     for (i=0;i<n;i++)
<     { l=yxindex[i];
<       for (j=0;j<X1.c;j++) X->M[i][j]=X1.M[l][j];
---
> 		for (i = 0; i < n; i++) {
> 			l = yxindex[i];
> 			for (j = 0; j < X1.c; j++)
> 				X->M[i][j] = X1.M[l][j];
450c568,569
<   { p.r=0; /* don't want a value from tps_g() */
---
> 	{
> 		p.r = 0; /* don't want a value from tps_g() */
461c580,581
<       for (j=0;j<d;j++) xc[j]=x[j][i];
---
> 			for (j = 0; j < d; j++)
> 				xc[j] = x[j][i];
466c586,587
<       F77_CALL(dgemv)(&trans,&kk,&k,&alpha,uz,&kk, b, &one,&beta, a, &one); /* BLAS call for (UZ)'b */
---
> 			F77_CALL(dgemv)(&trans, &kk, &k, &alpha, uz, &kk, b, &one, &beta, a,
> 					&one); /* BLAS call for (UZ)'b */
468c589,590
<       for (p0=a,p1=a+k;p0<p1;p0++,XMi++) *XMi = *p0;
---
> 			for (p0 = a, p1 = a + k; p0 < p1; p0++, XMi++)
> 				*XMi = *p0;
477c599,602
<     FREE(xc);FREE(b);FREE(a);FREE(uz);
---
> 		FREE(xc);
> 		FREE(b);
> 		FREE(a);
> 		FREE(uz);
481,485c606,619
<   if (pure_knot) mcopy(&E,S);
<   else for (i=0;i<v.r;i++) S->M[i][i]=v.V[i];
<   HQmult(*S,Z,0,0);HQmult(*S,Z,1,1);
<   for (i=0;i<S->r;i++) for (j=S->r-M;j<S->r;j++) S->M[i][j]=S->M[j][i]=0.0;
<   if (!constant) {S->r--;S->c--;}
---
> 	if (pure_knot)
> 		mcopy(&E, S);
> 	else
> 		for (i = 0; i < v.r; i++)
> 			S->M[i][i] = v.V[i];
> 	HQmult(*S, Z, 0, 0);
> 	HQmult(*S, Z, 1, 1);
> 	for (i = 0; i < S->r; i++)
> 		for (j = S->r - M; j < S->r; j++)
> 			S->M[i][j] = S->M[j][i] = 0.0;
> 	if (!constant) {
> 		S->r--;
> 		S->c--;
> 	}
491,496c625,646
<   for (i=0;i<X->c;i++)
<   { w=0; for (j=0;j<X->r;j++) w+=X->M[j][i]*X->M[j][i]; w=sqrt(w/X->r);
<     for (j=0;j<X->r;j++) X->M[j][i]/=w;
<     for (j=0;j<UZ->r;j++) UZ->M[j][i]/=w;
<     for (j=0;j<S->r;j++) S->M[i][j]/=w;
<     for (j=0;j<S->r;j++) S->M[j][i]/=w;
---
> 	for (i = 0; i < X->c; i++) {
> 		w = 0;
> 		for (j = 0; j < X->r; j++)
> 			w += X->M[j][i] * X->M[j][i];
> 		w = sqrt(w / X->r);
> 		for (j = 0; j < X->r; j++)
> 			X->M[j][i] /= w;
> 		for (j = 0; j < UZ->r; j++)
> 			UZ->M[j][i] /= w;
> 		for (j = 0; j < S->r; j++)
> 			S->M[i][j] /= w;
> 		for (j = 0; j < S->r; j++)
> 			S->M[j][i] /= w;
> 	}
> 	FREE(yxindex);
> 	freemat(Z);
> 	freemat(TU);
> 	freemat(E);
> 	freemat(T);
> 	if (!pure_knot) {
> 		freemat(U);
> 		freemat(v);
498,499d647
<   FREE(yxindex);freemat(Z);freemat(TU);freemat(E);freemat(T);
<   if (!pure_knot) {freemat(U);freemat(v);}
502,504c650,652
< 
< void construct_tprs(double *x,int *d,int *n,double *knt,int *nk,int *m,int *k,double *X,double *S,
<                     double *UZ,double *Xu,int *nXu,double *C)
---
> void construct_tprs(double *x, int *d, int *n, double *knt, int *nk, int *m,
> 		int *k, double *X, double *S, double *UZ, double *Xu, int *nXu,
> 		double *C)
520c668,669
< { double **xx,**kk=NULL,*dum,**XM;
---
> {
> 	double **xx, **kk = NULL, *dum, **XM;
524,527c673,678
<   for (i=0;i<*d;i++) xx[i]=x + i * *n;
<   if (*nk)
<   { kk=(double **)CALLOC((size_t)(*d),sizeof(double*));
<     for (i=0;i<*d;i++) kk[i]=knt + i * *nk;
---
> 	for (i = 0; i < *d; i++)
> 		xx[i] = x + i * *n;
> 	if (*nk) {
> 		kk = (double **) CALLOC((size_t) (*d), sizeof(double*));
> 		for (i = 0; i < *d; i++)
> 			kk[i] = knt + i * *nk;
536,539c687,693
<   dum=C;XM=Xm.M;Xr=Xm.r;
<   for (i=0;i< *k;i++)
<   { *dum = 0.0;
<     for (j=0;j<Xr;j++) *dum += XM[j][i];
---
> 	dum = C;
> 	XM = Xm.M;
> 	Xr = Xm.r;
> 	for (i = 0; i < *k; i++) {
> 		*dum = 0.0;
> 		for (j = 0; j < Xr; j++)
> 			*dum += XM[j][i];
542,543c696,702
<   freemat(Xm);freemat(Sm);freemat(UZm);freemat(Xum);
<   FREE(xx);if(*nk) FREE(kk);
---
> 	freemat(Xm);
> 	freemat(Sm);
> 	freemat(UZm);
> 	freemat(Xum);
> 	FREE(xx);
> 	if (*nk)
> 		FREE(kk);
546,547c705,706
< void predict_tprs(double *x, int *d,int *n,int *m,int *k,int *M,double *Xu,int *nXu,
<                   double *UZ,double *by,int *by_exists,double *X)
---
> void predict_tprs(double *x, int *d, int *n, int *m, int *k, int *M, double *Xu,
> 		int *nXu, double *UZ, double *by, int *by_exists, double *X)
558,559c717,719
< { double *b,by_mult,*xx,*a,*xp,*xxp,*xxp1,*xp1,*Xp,alpha=1.0,beta=0.0,*Xup,*Xup1,r,z,*pb,
<          eta0;
---
> {
> 	double *b, by_mult, *xx, *a, *xp, *xxp, *xxp1, *xp1, *Xp, alpha = 1.0,
> 			beta = 0.0, *Xup, *Xup1, r, z, *pb, eta0;
563c723,727
<   if (2 * *m <= *d && *d > 0) { *m = 0;while ( 2 * *m < *d+2) (*m)++;} 
---
> 	if (2 * *m <= *d && *d > 0) {
> 		*m = 0;
> 		while (2 * *m < *d + 2)
> 			(*m)++;
> 	}
576,577c740,744
<   for (Xp=X,xp=x,i=0;i< *n;i++,xp++,Xp++) 
<   { if (*by_exists) by_mult=by[i]; else by_mult=1.0;
---
> 	for (Xp = X, xp = x, i = 0; i < *n; i++, xp++, Xp++) {
> 		if (*by_exists)
> 			by_mult = by[i];
> 		else
> 			by_mult = 1.0;
580c747,748
<       for (xxp=Xp,j=0;j < *k;j++,xxp+= *n) *xxp = 0.0; 
---
> 			for (xxp = Xp, j = 0; j < *k; j++, xxp += *n)
> 				*xxp = 0.0;
582c750,752
<       for (xxp=xx,xxp1=xx + *d,xp1=xp;xxp < xxp1;xxp++,xp1 += *n) *xxp = *xp1; /*xx[j]=x[j * *n + i];*/
---
> 			for (xxp = xx, xxp1 = xx + *d, xp1 = xp; xxp < xxp1; xxp++, xp1 +=
> 					*n)
> 				*xxp = *xp1; /*xx[j]=x[j * *n + i];*/
586c756,760
<         for (xxp=xx,xxp1=xx + *d,xp1=Xup;xxp<xxp1;xxp++,xp1+= *nXu) { z = *xp1 - *xxp;r += z*z;}
---
> 				for (xxp = xx, xxp1 = xx + *d, xp1 = Xup; xxp < xxp1;
> 						xxp++, xp1 += *nXu) {
> 					z = *xp1 - *xxp;
> 					r += z * z;
> 				}
593c767,769
<         for (j=0;j<*d;j++) for (kk=0;kk<pin[l + *M * j];kk++)  r *= xx[j];
---
> 				for (j = 0; j < *d; j++)
> 					for (kk = 0; kk < pin[l + *M * j]; kk++)
> 						r *= xx[j];
599c775,776
<       F77_CALL(dgemv)(&trans,&nobsM,k,&alpha,UZ,&nobsM, b, &one,&beta, a, &one); /* BLAS call for (UZ)'b */
---
> 			F77_CALL(dgemv)(&trans, &nobsM, k, &alpha, UZ, &nobsM, b, &one,
> 					&beta, a, &one); /* BLAS call for (UZ)'b */
601c778,780
<       for (xp1=Xp,xxp=a,xxp1=a + *k;xxp<xxp1;xxp++,xp1+= *n) *xp1 = *xxp * by_mult; 
---
> 				for (xp1 = Xp, xxp = a, xxp1 = a + *k; xxp < xxp1; xxp++, xp1 +=
> 						*n)
> 					*xp1 = *xxp * by_mult;
603c782,784
<       for (xp1=Xp,xxp=a,xxp1=a + *k;xxp<xxp1;xxp++,xp1+= *n) *xp1 = *xxp;
---
> 				for (xp1 = Xp, xxp = a, xxp1 = a + *k; xxp < xxp1; xxp++, xp1 +=
> 						*n)
> 					*xp1 = *xxp;
617,618c798,801
<   FREE(b);FREE(a);
<   FREE(xx);FREE(pin);
---
> 	FREE(b);
> 	FREE(a);
> 	FREE(xx);
> 	FREE(pin);
diff -rEZbwB '--exclude=*.[lo,d,pdf,mo,po,tgz,gz,save]*' '--exclude=MD5' '--exclude=Makefile*' '--exclude=all.R' '--exclude=Changes' R-recommended/mgcv/src/tprs.h Recommended/mgcv/src/tprs.h
10,12c10,14
< double tps_g(matrix *X,matrix *p,double *x,int d,int m,double *b,int constant);
< void tprs_setup(double **x,double **knt,int m,int d,int n,int k,int constant,matrix *X,matrix *S,
<                 matrix *UZ,matrix *Xu,int n_knots);
---
> double tps_g(matrix *X, matrix *p, double *x, int d, int m, double *b,
> 		int constant);
> void tprs_setup(double **x, double **knt, int m, int d, int n, int k,
> 		int constant, matrix *X, matrix *S, matrix *UZ, matrix *Xu,
> 		int n_knots);
18,21c20,22
< void tprs_setup(double **x,double **knt,int m,int d,int n,int k,int constant,matrix *X,matrix *S,
<                 matrix *UZ,matrix *Xu,int n_knots);
< 
< 
---
> void tprs_setup(double **x, double **knt, int m, int d, int n, int k,
> 		int constant, matrix *X, matrix *S, matrix *UZ, matrix *Xu,
> 		int n_knots);
