diff -rEZbwB '--exclude=*.[lo,d,pdf,mo,po,tgz,gz,save]*' '--exclude=MD5' '--exclude=Makefile*' '--exclude=all.R' '--exclude=Changes' R-recommended/mgcv/R/bam.r Recommended/mgcv/R/bam.r
13c13
<  for (i in 1:n) sz[i] <- object.size(x[[i]])
---
>  for (i in seq_len(n)) sz[i] <- object.size(x[[i]])
38,39c38,39
<   ipiv <- piv <- attr(R,"pivot");ipiv[piv] <- 1:p
<   rank <- attr(R,"rank");ind <- 1:rank
---
>   ipiv <- piv <- attr(R,"pivot");ipiv[piv] <- seq_len(p)
>   rank <- attr(R,"rank");ind <- seq_len(rank)
71,72c71,72
<     fn <- qr.qty(qrx,yn)[1:p]
<     rp <- qrx$pivot;rp[rp] <- 1:p # reverse pivot
---
>     fn <- qr.qty(qrx,yn)[seq_len(p)]
>     rp <- qrx$pivot;rp[rp] <- seq_len(p) # reverse pivot
83c83
<   for (b in 1:arg$n.block) {
---
>   for (b in seq_len(arg$n.block)) {
121c121
<   for (i in 1:d) if (is.factor(dat[,i])) {  
---
>   for (i in seq_len(d)) if (is.factor(dat[,i])) {  
134c134
<     for (i in 1:d) if (!is.factor(dat[,i])) { ## round the metric variables
---
>     for (i in seq_len(d)) if (!is.factor(dat[,i])) { ## round the metric variables
158c158
<   ii <- sample(1:nrow(xu),nrow(xu),replace=FALSE) ## shuffling index
---
>   ii <- sample(seq_len(nrow(xu)),nrow(xu),replace=FALSE) ## shuffling index
223c223
<   for (i in 1:length(gp$smooth.spec)) nk <- nk + as.numeric(gp$smooth.spec[[i]]$by!="NA") +
---
>   for (i in seq_len(length(gp$smooth.spec))) nk <- nk + as.numeric(gp$smooth.spec[[i]]$by!="NA") +
226c226
<   k.start <- 1:(nk+1) ## record last column for each term
---
>   k.start <- seq_len(nk+1) ## record last column for each term
234c234
<   for (i in 1:length(gp$smooth.spec)) {
---
>   for (i in seq_len(length(gp$smooth.spec))) {
240c240
<     for (jj in 1:maxj) { ## loop through marginals
---
>     for (jj in seq_len(maxj)) { ## loop through marginals
290c290
<     for (i in 1:length(mf0)) {
---
>     for (i in seq_len(length(mf0))) {
304c304
<     mf <- mf[sample(1:nrow(mf),maxr,replace=TRUE),]
---
>     mf <- mf[sample(seq_len(nrow(mf)),maxr,replace=TRUE),]
327c327
<           ii0 <- if (ik>1) 1:(ik-1) else rep(0,0) ## earlier
---
>           ii0 <- if (ik>1) seq_len(ik-1) else rep(0,0) ## earlier
331c331
<           kk0 <- if (ik>1) 1:(k.start[ik]-1) else rep(0,0) ## earlier
---
>           kk0 <- if (ik>1) seq_len(k.start[ik]-1) else rep(0,0) ## earlier
352c352
<   for (j in 1:length(mf)) mn <- mn + if (is.factor(mf[[j]])) length(levels(mf[[j]])) else 2
---
>   for (j in seq_len(length(mf))) mn <- mn + if (is.factor(mf[[j]])) length(levels(mf[[j]])) else 2
366c366
<   ind <- sample(1:n,chunk.size)
---
>   ind <- sample(seq_len(n),chunk.size)
374c374
<   ind <- sample(1:n,n,replace=FALSE) ## randomized index for stratified sampling w.r.t. factor levels
---
>   ind <- sample(seq_len(n),n,replace=FALSE) ## randomized index for stratified sampling w.r.t. factor levels
377c377
<   for (j in 1:length(mf)) if (is.numeric(mf0[[j]])) {
---
>   for (j in seq_len(length(mf))) if (is.numeric(mf0[[j]])) {
379,380c379,380
<       j.min <- min((1:n)[as.logical(rowSums(mf[[j]]==min(mf[[j]])))])
<       j.max <- min((1:n)[as.logical(rowSums(mf[[j]]==max(mf[[j]])))])
---
>       j.min <- min((seq_len(n))[as.logical(rowSums(mf[[j]]==min(mf[[j]])))])
>       j.max <- min((seq_len(n))[as.logical(rowSums(mf[[j]]==max(mf[[j]])))])
427c427
<       ar.row <- c(1,rep(1:N,rep(2,N))[-c(1,2*N)]) ## index of rows to reweight
---
>       ar.row <- c(1,rep(seq_len(N),rep(2,N))[-c(1,2*N)]) ## index of rows to reweight
429c429
<       ar.stop <- c(1,1:(N-1)*2+1)    ## (stop[i-1]+1):stop[i] are the rows to reweight to get ith row
---
>       ar.stop <- c(1,seq_len(N-1)*2+1)    ## (stop[i-1]+1):stop[i] are the rows to reweight to get ith row
486c486
<     for (b in 1:length(Sl)) rank <- rank + Sl[[b]]$rank
---
>     for (b in seq_len(length(Sl))) rank <- rank + Sl[[b]]$rank
489c489
<     for (iter in 1L:control$maxit) { ## main fitting loop 
---
>     for (iter in seq_len(control$maxit)) { ## main fitting loop 
561c561
<         prop <- Sl.fitChol(Sl,qrx$XX,qrx$Xy,rho=lsp[1:n.sp],yy=qrx$y.norm2,L=G$L,rho0=G$lsp0,log.phi=log.phi,
---
>         prop <- Sl.fitChol(Sl,qrx$XX,qrx$Xy,rho=lsp[seq_len(n.sp)],yy=qrx$y.norm2,L=G$L,rho0=G$lsp0,log.phi=log.phi,
577c577
<           warning(gettextf("non-finite coefficients at iteration %d",
---
>           warning(gettextf("Non-finite coefficients at iteration %d",
584c584
<        warning("algorithm did not converge")
---
>        warning("Algorithm did not converge")
596c596
<   if (length(G$smooth)>1) for (i in 1:length(G$smooth)) Mp <- Mp + G$smooth[[i]]$null.space.dim
---
>   if (length(G$smooth)>1) for (i in seq_len(length(G$smooth))) Mp <- Mp + G$smooth[[i]]$null.space.dim
604c604
<   for (i in 1:ncol(prop$db)) prop$db[,i] <- ## d beta / d rho matrix
---
>   for (i in seq_len(ncol(prop$db))) prop$db[,i] <- ## d beta / d rho matrix
618c618
<   object$sp <- exp(lsp[1:n.sp]) 
---
>   object$sp <- exp(lsp[seq_len(n.sp)]) 
629c629
<     rV <- (ev$values*t(ev$vectors))[,1:M]
---
>     rV <- (ev$values*t(ev$vectors))[,seq_len(M)]
710c710
<         warning("Too many cluster nodes to use all efficiently")
---
>         warning("too many cluster nodes to use all efficiently")
720c720
<       for (i in 1:n.threads) {
---
>       for (i in seq_len(n.threads)) {
727c727
<           stop <- (1:n.block)*chunk.size
---
>           stop <- seq_len(n.block)*chunk.size
751c751
<         stop <- (1:n.block)*chunk.size
---
>         stop <- seq_len(n.block)*chunk.size
768c768
<     for (iter in 1L:control$maxit) { ## main fitting loop
---
>     for (iter in seq_len(control$maxit)) { ## main fitting loop
774c774
<          for (b in 1:n.block) {
---
>          for (b in seq_len(n.block)) {
800c800
<          for (i in 1:length(arg)) arg[[i]]$coef <- coef
---
>          for (i in seq_len(length(arg))) arg[[i]]$coef <- coef
804c804
<          #for (i in 1:length(arg)) {
---
>          #for (i in seq_len(length(arg))) {
828,829c828,829
<           f <- qr.qty(qrx,f)[1:ncol(R)]
<           rp <- qrx$pivot;rp[rp] <- 1:ncol(R) # reverse pivot
---
>           f <- qr.qty(qrx,f)[seq_len(ncol(R))]
>           rp <- qrx$pivot;rp[rp] <- seq_len(ncol(R)) # reverse pivot
936c936
<           warning(gettextf("non-finite coefficients at iteration %d",
---
>           warning(gettextf("Non-finite coefficients at iteration %d",
955c955
<        warning("algorithm did not converge")
---
>        warning("Algorithm did not converge")
986c986
<   for (i in 1:arg$n.block) {
---
>   for (i in seq_len(arg$n.block)) {
992c992
<        row <- c(1,rep(1:N,rep(2,N))[-c(1,2*N)])
---
>        row <- c(1,rep(seq_len(N),rep(2,N))[-c(1,2*N)])
994c994
<        stop <- c(1,1:(N-1)*2+1)
---
>        stop <- c(1,seq_len(N-1)*2+1)
1073c1073
<     for (i in 1:n.threads) { 
---
>     for (i in seq_len(n.threads)) { 
1139c1139
<          warning("Too many cluster nodes to use all efficiently")
---
>          warning("too many cluster nodes to use all efficiently")
1152c1152
<        for (i in 1:n.threads) { 
---
>        for (i in seq_len(n.threads)) { 
1199c1199
<        for (i in 1:n.block) {
---
>        for (i in seq_len(n.block)) {
1204c1204
<            row <- c(1,rep(1:N,rep(2,N))[-c(1,2*N)])
---
>            row <- c(1,rep(seq_len(N),rep(2,N))[-c(1,2*N)])
1206c1206
<            stop <- c(1,1:(N-1)*2+1) 
---
>            stop <- c(1,seq_len(N-1)*2+1) 
1246c1246
<        # for (i in 1:length(arg)) {
---
>        # for (i in seq_len(length(arg))) {
1267,1268c1267,1268
<          f <- qr.qty(qrx,f)[1:ncol(R)]
<          rp <- qrx$pivot;rp[rp] <- 1:ncol(R) # reverse pivot
---
>          f <- qr.qty(qrx,f)[seq_len(ncol(R))]
>          rp <- qrx$pivot;rp[rp] <- seq_len(ncol(R)) # reverse pivot
1278c1278
<        row <- c(1,rep(1:n,rep(2,n))[-c(1,2*n)])
---
>        row <- c(1,rep(seq_len(n),rep(2,n))[-c(1,2*n)])
1280c1280
<        stop <- c(1,1:(n-1)*2+1)
---
>        stop <- c(1,seq_len(n-1)*2+1)
1415c1415
<     warning("iterms reset to terms")
---
>     warning("type 'iterms' reset to type 'terms'")
1418c1418
<   if (!is.null(exclude)) warning("exclude ignored by discrete prediction at present")
---
>   if (!is.null(exclude)) warning("'exclude' argument ignored by discrete prediction at present")
1433,1434c1433,1434
<     object$coefficients <-  object$coefficients[1:object$nsdf]
<     object$Vp <- object$V[1:object$nsdf,1:object$nsdf]
---
>     object$coefficients <-  object$coefficients[seq_len(object$nsdf)]
>     object$Vp <- object$V[seq_len(object$nsdf),seq_len(object$nsdf)]
1458c1458
<      kd <- cbind(1:nrow(newdata),dk$k) ## add index for parametric part to index list
---
>      kd <- cbind(seq_len(nrow(newdata)),dk$k) ## add index for parametric part to index list
1472c1472
<   for (i in 1:length(object$smooth)) { ## work through the smooth list
---
>   for (i in seq_len(length(object$smooth))) { ## work through the smooth list
1475c1475
<       by.var <- dk$mf[[object$smooth[[i]]$by]][1:dk$nr[k]]
---
>       by.var <- dk$mf[[object$smooth[[i]]$by]][seq_len(dk$nr[k])]
1494c1494
<       for (j in 1:nmar) {
---
>       for (j in seq_len(nmar)) {
1525c1525
<     for (i in 1:length(object$smooth)) {
---
>     for (i in seq_len(length(object$smooth))) {
1572c1572
<   for (i in 1:ns) if (sm$margin[[i]]$bs.dim>=maxd) {
---
>   for (i in seq_len(ns)) if (sm$margin[[i]]$bs.dim>=maxd) {
1576c1576
<     ind <- 1:ns;ind[maxi] <- ns;ind[ns] <- maxi
---
>     ind <- seq_len(ns);ind[maxi] <- ns;ind[ns] <- maxi
1580c1580
<     for (i in 1:ns) sm$term <- c(sm$term,sm$margin[[i]]$term)
---
>     for (i in seq_len(ns)) sm$term <- c(sm$term,sm$margin[[i]]$term)
1593c1593
<   ar.row <- c(1,rep(1:N,rep(2,N))[-c(1,2*N)]) ## index of rows to reweight
---
>   ar.row <- c(1,rep(seq_len(N),rep(2,N))[-c(1,2*N)]) ## index of rows to reweight
1595c1595
<   ar.stop <- c(1,1:(N-1)*2+1)    ## (stop[i-1]+1):stop[i] are the rows to reweight to get ith row
---
>   ar.stop <- c(1,seq_len(N-1)*2+1)    ## (stop[i-1]+1):stop[i] are the rows to reweight to get ith row
1630c1630
<     if (inherits(family,"extended.family")) stop("extended families not supported by bam")
---
>     if (inherits(family,"extended.family")) stop("extended families are not supported by 'bam()' function")
1634,1635c1634
<     if (!method%in%c("fREML","GCV.Cp","REML",
<                     "ML","P-REML","P-ML")) stop("un-supported smoothness selection method")
---
>     if (!method%in%c("fREML","GCV.Cp","REML", "ML","P-REML","P-ML")) stop("unsupported smoothness selection method")
1660c1659
<       if (length(gp$smooth.spec)>0) for (i in 1:length(gp$smooth.spec)) { 
---
>       if (length(gp$smooth.spec)>0) for (i in seq_len(length(gp$smooth.spec))) { 
1669c1668
<           for (j in 1:gp$smooth.spec[[i]]$dim) gp$smooth.spec[[i]]$margin[[j]] <- list(term=gp$smooth.spec[[i]]$term[j])
---
>           for (j in seq_len(gp$smooth.spec[[i]]$dim)) gp$smooth.spec[[i]]$margin[[j]] <- list(term=gp$smooth.spec[[i]]$term[j])
1699c1698
<     if (rho!=0&&!is.null(mf$"(AR.start)")) if (!is.logical(mf$"(AR.start)")) stop("AR.start must be logical")
---
>     if (rho!=0&&!is.null(mf$"(AR.start)")) if (!is.logical(mf$"(AR.start)")) stop("'AR.start' argument must be logical")
1777c1776
<         G$kd <- cbind(1:nrow(mf),dk$k) ## add index for parametric part to index list
---
>         G$kd <- cbind(seq_len(nrow(mf)),dk$k) ## add index for parametric part to index list
1791c1790
<       for (i in 1:length(G$smooth)) {
---
>       for (i in seq_len(length(G$smooth))) {
1796c1795
<           by.var <- dk$mf[[G$smooth[[i]]$by]][1:dk$nr[k]]
---
>           by.var <- dk$mf[[G$smooth[[i]]$by]][seq_len(dk$nr[k])]
1819,1820c1818,1819
<           for (j in 1:nmar) {
<             G$Xd[[k]] <- G$smooth[[i]]$margin[[j]]$X[1:dk$nr[k],,drop=FALSE]
---
>           for (j in seq_len(nmar)) {
>             G$Xd[[k]] <- G$smooth[[i]]$margin[[j]]$X[seq_len(dk$nr[k]),,drop=FALSE]
1842c1841
<           G$Xd[[k]] <- G$X[1:dk$nr[k],G$smooth[[i]]$first.para:G$smooth[[i]]$last.para]
---
>           G$Xd[[k]] <- G$X[seq_len(dk$nr[k]),G$smooth[[i]]$first.para:G$smooth[[i]]$last.para]
1886c1885
<     if (G$m) for (i in 1:G$m) G$min.edf<-G$min.edf+G$smooth[[i]]$null.space.dim
---
>     if (G$m) for (i in seq_len(G$m)) G$min.edf<-G$min.edf+G$smooth[[i]]$null.space.dim
1916c1915
<   if (control$trace) cat("Setup complete. Calling fit\n")
---
>   if (control$trace) cat(gettext("Setup complete. Calling fit", domain = "R-mgcv"), "\n", sep = "")
1932,1933c1931,1932
<       ind <- sample(1:nrow(mf),ceiling(nrow(mf)*samfrac))
<       if (length(ind)<2*ncol(G$X)) warning("samfrac too small - ignored") else {
---
>       ind <- sample(seq_len(nrow(mf)),ceiling(nrow(mf)*samfrac))
>       if (length(ind)<2*ncol(G$X)) warning("value of 'samfrac' argument is too small - ignored") else {
1955c1954
<   if (control$trace) cat("Fit complete. Finishing gam object.\n")
---
>   if (control$trace) cat(gettext("Fit complete. Finishing gam object.", domain = "R-mgcv"), "\n", sep = "")
1985c1984
<   if (G$nsdf>0) names(object$coefficients)[1:G$nsdf] <- colnamesX[1:G$nsdf]
---
>   if (G$nsdf>0) names(object$coefficients)[seq_len(G$nsdf)] <- colnamesX[seq_len(G$nsdf)]
2106c2105
<     row <- c(1,rep(1:m,rep(2,m))[-c(1,2*m)])
---
>     row <- c(1,rep(seq_len(m),rep(2,m))[-c(1,2*m)])
2108c2107
<     stop <- c(1,1:(m-1)*2+1)
---
>     stop <- c(1,seq_len(m-1)*2+1)
diff -rEZbwB '--exclude=*.[lo,d,pdf,mo,po,tgz,gz,save]*' '--exclude=MD5' '--exclude=Makefile*' '--exclude=all.R' '--exclude=Changes' R-recommended/mgcv/R/coxph.r Recommended/mgcv/R/coxph.r
18c18
<         else stop(linktemp, " link not available for coxph family; available link is \"identity\" ")
---
>         else stop(gettextf("\"%s\" link not available for coxph family; available link is \"identity\"", linktemp))
80c80
<       list(tr=tr,h=oo$h,q=oo$q,a=matrix(oo$A[1:(p*nt)],p,nt),nt=nt,r=r,km=oo$km)
---
>       list(tr=tr,h=oo$h,q=oo$q,a=matrix(oo$A[seq_len(p*nt)],p,nt),nt=nt,r=r,km=oo$km)
128c128
<       if (!is.null(offset)&&sum(offset!=0)) stop("cox.ph does not yet handle offsets")
---
>       if (!is.null(offset)&&sum(offset!=0)) stop("'cox.ph()' function does not yet handle offsets")
160c160
<         ind <- 1:(p^2)
---
>         ind <- seq_len(p^2)
162c162
<         for (i in 1:M) { 
---
>         for (i in seq_len(M)) { 
diff -rEZbwB '--exclude=*.[lo,d,pdf,mo,po,tgz,gz,save]*' '--exclude=MD5' '--exclude=Makefile*' '--exclude=all.R' '--exclude=Changes' R-recommended/mgcv/R/efam.r Recommended/mgcv/R/efam.r
57c57
<     } else stop(linktemp, " link not available for ordered categorical family; available links are \"identity\"")
---
>     } else stop(gettextf("\"%s\" link not available for ordered categorical family; available links are \"identity\"", linktemp))
93c93,94
<     paste("Ordered Categorical(",paste(round(object$family$getTheta(TRUE),2),collapse=","),")",sep="")
---
>     gettextf("Ordered Categorical(%s)", paste(round(object$family$getTheta(TRUE),2), collapse = ","), domain = "R-mgcv")
>     #paste("Ordered Categorical(",paste(round(object$family$getTheta(TRUE),2),collapse=","),")",sep="")
261c262
<       for (k in 1:(R-2)) { 
---
>       for (k in seq_len(R-2)) { 
310c311
<       for (j in 1:(R-2)) for (k in j:(R-2)) { 
---
>       for (j in seq_len(R-2)) for (k in j:(R-2)) { 
408c409
<     for (j in 1:(R-2)) for (k in j:(R-2)) { 
---
>     for (j in seq_len(R-2)) for (k in j:(R-2)) { 
427c428
<       for (i in 1:(R-2)) for (j in i:(R-2)) { 
---
>       for (i in seq_len(R-2)) for (j in i:(R-2)) { 
443c444
<       y <- c(1:R,y) ## make sure there is *something* in each class
---
>       y <- c(seq_len(R),y) ## make sure there is *something* in each class
490c491
<        for (i in 1:(R+1)) {
---
>        for (i in seq_len(R+1)) {
522c523
<       for (i in 1:R) {
---
>       for (i in seq_len(R)) {
551c552
<       for (i in 1:(R+1)) {
---
>       for (i in seq_len(R+1)) {
574c575
<     for (i in 1:R) {
---
>     for (i in seq_len(R)) {
610c611
<         else stop(linktemp, " link not available for negative binomial family; available links are \"identity\", \"log\" and \"sqrt\"")
---
>         else stop(gettextf("\"%s\" link not available for negative binomial family; available links are \"identity\", \"log\" and \"sqrt\"", linktemp))
710c711,712
<       paste("Negative Binomial(",round(object$family$getTheta(TRUE),3),")",sep="")
---
>       gettextf("Negative Binomial(%s)", paste(round(object$family$getTheta(TRUE),3), sep = ", ", collapse = ""), domain = "R-mgcv")
>       #paste("Negative Binomial(",round(object$family$getTheta(TRUE),3),")",sep="")
759,760c761
<         else  stop(gettextf("link \"%s\" not available for Tweedie family.", 
<                 linktemp, collapse = ""), domain = NA)
---
>         else  stop(gettextf("link \"%s\" is not available for Tweedie family",  linktemp, collapse = ""), domain = "R-mgcv")
882c883
<       paste("Tweedie(p=",round(object$family$getTheta(TRUE),3),")",sep="")
---
>       gettextf("Tweedie(p=%s)", round(object$family$getTheta(TRUE),3), domain = "R-mgcv")
928c929
<         else stop(linktemp, " link not available for beta regression; available links are  \"logit\", \"probit\", \"cloglog\" and \"cauchit\"")
---
>         else stop(gettextf("\"%s\" link not available for beta regression; available links are  \"logit\", \"probit\", \"cloglog\" and \"cauchit\"", linktemp))
1069c1070
<       mu <- LS <- ii <- 1:length(y)
---
>       mu <- LS <- ii <- seq_len(length(y))
1123c1124
<       paste("Beta regression(",round(theta,3),")",sep="")
---
>       gettextf("Beta regression(%s)",round(theta,3), domain = "R-mgcv")
1209c1210
<         else stop(linktemp, " link not available for scaled t distribution; available links are \"identity\", \"log\",  and \"inverse\"")
---
>         else stop(gettextf("\"%s\" link not available for scaled t distribution; available links are \"identity\", \"log\",  and \"inverse\"", linktemp))
1363c1364
<       paste("Scaled t(",paste(round(object$family$getTheta(TRUE),3),collapse=","),")",sep="")
---
>       gettextf("Scaled t(%s)",paste(round(object$family$getTheta(TRUE),3), collapse=","), domain = "R-mgcv")
1471c1472
<   } else  stop(linktemp, " link not available for zero inflated; available link for `lambda' is only  \"loga\"")
---
>   } else  stop(gettextf("\"%s\" link not available for zero inflated; available link for `lambda' is only  \"loga\"", linktemp))
diff -rEZbwB '--exclude=*.[lo,d,pdf,mo,po,tgz,gz,save]*' '--exclude=MD5' '--exclude=Makefile*' '--exclude=all.R' '--exclude=Changes' R-recommended/mgcv/R/fast-REML.r Recommended/mgcv/R/fast-REML.r
34,36c34,36
<     off <- unique(G$off[1:G$n.paraPen]) ## unique offset lists relating to paraPen
<     for (i in 1:length(off)) { ## loop over blocks
<       ind <- (1:G$n.paraPen)[G$off[1:G$n.paraPen]%in%off[i]] ## terms in same block
---
>     off <- unique(G$off[seq_len(G$n.paraPen)]) ## unique offset lists relating to paraPen
>     for (i in seq_along(off)) { ## loop over blocks
>       ind <- seq_len(G$n.paraPen)[G$off[seq_len(G$n.paraPen)]%in%off[i]] ## terms in same block
38c38
<         nr <- 0;for (k in 1:length(ind)) nr <- max(nr,nrow(G$S[[ind[k]]])) ## get block size
---
>         nr <- 0;for (k in seq_along(ind)) nr <- max(nr,nrow(G$S[[ind[k]]])) ## get block size
43c43
<         for (k in 1:length(ind)) { ## work through all penalties for this block
---
>         for (k in seq_along(ind)) { ## work through all penalties for this block
47c47
<             Sl[[b]]$S[[k]][1:nk,1:nk] <- G$S[[ind[k]]]
---
>             Sl[[b]]$S[[k]][seq_len(nk),seq_len(nk)] <- G$S[[ind[k]]]
65c65
<   if (length(G$smooth)) for (i in 1:length(G$smooth)) {
---
>   if (length(G$smooth)) for (i in seq_along(G$smooth)) {
96c96
<       for (j in 1:m) { ## get block range for each S[[j]]
---
>       for (j in seq_len(m)) { ## get block range for each S[[j]]
98c98
<         ir <- range((1:nb)[rowSums(abs(Sl[[b]]$S[[j]]))>0])
---
>         ir <- range(seq_len(nb)[rowSums(abs(Sl[[b]]$S[[j]]))>0])
102c102
<       for (j in 1:m) { ## test for overlap
---
>       for (j in seq_len(m)) { ## test for overlap
105c105
<           for (k in 1:m) if (j!=k) itot[diag(Sl[[b]]$S[[k]])!=0] <- TRUE
---
>           for (k in seq_len(m)) if (j!=k) itot[diag(Sl[[b]]$S[[k]])!=0] <- TRUE
110c110
<           for (k in 1:m) if (j!=k) itot[sbStart[k]:sbStop[k]] <- TRUE
---
>           for (k in seq_len(m)) if (j!=k) itot[sbStart[k]:sbStop[k]] <- TRUE
117c117
<         for (j in 1:m) {
---
>         for (j in seq_len(m)) {
149c149
<   for (b in 1:length(Sl)) { ## once more into the blocks, dear friends...
---
>   for (b in seq_along(Sl)) { ## once more into the blocks, dear friends...
166c166
<         ind[1:Sl[[b]]$rank] <- TRUE ## index penalized elements
---
>         ind[seq_len(Sl[[b]]$rank)] <- TRUE ## index penalized elements
197,198c197,198
<       ind <- 1:Sl[[b]]$rank
<       for (j in 1:length(Sl[[b]]$S)) { ## project penalties into range space of total penalty
---
>       ind <- seq_len(Sl[[b]]$rank)
>       for (j in seq_along(Sl[[b]]$S)) { ## project penalties into range space of total penalty
242c242
<         for (b in 1:length(Sl)) if (Sl[[b]]$repara) { 
---
>         for (b in seq_along(Sl)) if (Sl[[b]]$repara) { 
255c255
<          for (b in 1:length(Sl)) if (Sl[[b]]$repara) { 
---
>          for (b in seq_along(Sl)) if (Sl[[b]]$repara) { 
271c271
<       for (b in 1:length(Sl)) if (Sl[[b]]$repara) { 
---
>       for (b in seq_along(Sl)) if (Sl[[b]]$repara) { 
277c277
<   } else for (b in 1:length(Sl)) if (Sl[[b]]$repara) { ## model matrix re-para
---
>   } else for (b in seq_along(Sl)) if (Sl[[b]]$repara) { ## model matrix re-para
324c324
<     rp <- piv;rp[rp] <- 1:p ## reverse pivot
---
>     rp <- piv;rp[rp] <- seq_len(p) ## reverse pivot
328,329c328,329
<     R <- R[1:r,1:r]
<     piv <- piv[1:r]
---
>     R <- R[seq_len(r),seq_len(r)]
>     piv <- piv[seq_len(r)]
333c333
<   for (i in 1:m) {
---
>   for (i in seq_len(m)) {
339c339
<       for (j in 1:i) {
---
>       for (j in seq_len(i)) {
366c366
<   for (b in 1:length(Sl)) { ## work through blocks
---
>   for (b in seq_along(Sl)) { ## work through blocks
379c379
<           D <- Sl[[b]]$Di[1:Sl[[b]]$rank,]
---
>           D <- Sl[[b]]$Di[seq_len(Sl[[b]]$rank),]
410c410
<         for (i in 1:m) {
---
>         for (i in seq_len(m)) {
451c451
<   for (b in 1:length(Sl)) {
---
>   for (b in seq_along(Sl)) {
457c457
<       for (j in 1:length(Sl[[b]]$S)) {
---
>       for (j in seq_along(Sl[[b]]$S)) {
475c475
<       for (i in 1:nr) if (rp[[i]]$repara) {
---
>       for (i in seq_len(nr)) if (rp[[i]]$repara) {
482c482
<      for (i in 1:nr) if (rp[[i]]$repara) X[rp[[i]]$ind]  <- rp[[i]]$Qs %*% X[rp[[i]]$ind]
---
>      for (i in seq_len(nr)) if (rp[[i]]$repara) X[rp[[i]]$ind]  <- rp[[i]]$Qs %*% X[rp[[i]]$ind]
486c486
<       for (i in 1:nr) if (rp[[i]]$repara) X[,rp[[i]]$ind]  <- X[,rp[[i]]$ind]%*%rp[[i]]$Qs
---
>       for (i in seq_len(nr)) if (rp[[i]]$repara) X[,rp[[i]]$ind]  <- X[,rp[[i]]$ind]%*%rp[[i]]$Qs
488c488
<       for (i in 1:nr) if (rp[[i]]$repara) X[rp[[i]]$ind]  <- t(rp[[i]]$Qs) %*% X[rp[[i]]$ind]
---
>       for (i in seq_len(nr)) if (rp[[i]]$repara) X[rp[[i]]$ind]  <- t(rp[[i]]$Qs) %*% X[rp[[i]]$ind]
504c504
<     for (b in 1:nb) { ## block loop
---
>     for (b in seq_len(nb)) { ## block loop
524,525c524,525
<     for (b in 1:nb) { ## block loop
<       for (i in 1:length(Sl[[b]]$S)) { ## S loop within blocks
---
>     for (b in seq_len(nb)) { ## block loop
>       for (i in seq_along(Sl[[b]]$S)) { ## S loop within blocks
592c592
<   for (b in 1:nb) { ## block loop
---
>   for (b in seq_len(nb)) { ## block loop
622c622
<       for (i in 1:length(Sl[[b]]$S)) { ## work through S terms
---
>       for (i in seq_along(Sl[[b]]$S)) { ## work through S terms
664c664
<   for (i in 1:nd) { 
---
>   for (i in seq_len(nd)) { 
691c691
<   for (i in 1:nd) { ## compute the first derivatives
---
>   for (i in seq_len(nd)) { ## compute the first derivatives
701c701
<   for (k in 1:nd) { ## second derivative loop 
---
>   for (k in seq_len(nd)) { ## second derivative loop 
725c725
<   for (i in 1:nd) { ## compute the first derivatives
---
>   for (i in seq_len(nd)) { ## compute the first derivatives
736c736
<   for (k in 1:nd) { ## second derivative loop 
---
>   for (k in seq_len(nd)) { ## second derivative loop 
773,774c773,774
<     R <- R[1:r,1:r]
<     piv <- piv[1:r]
---
>     R <- R[seq_len(r),seq_len(r)]
>     piv <- piv[seq_len(r)]
803c803
<     reml2 <- rbind(cbind(reml2,d[1:n]),d) 
---
>     reml2 <- rbind(cbind(reml2,d[seq_len(n)]),d) 
851c851
<   rp <- qrx$pivot;rp[rp] <- 1:np ## reverse pivot vector
---
>   rp <- qrx$pivot;rp[rp] <- seq_len(np) ## reverse pivot vector
855,856c855,856
<   beta <- backsolve(R,Qty0)[1:np]
<   rss.bSb <- sum(Qty0[-(1:np)]^2) + rss.extra
---
>   beta <- backsolve(R,Qty0)[seq_len(np)]
>   rss.bSb <- sum(Qty0[-seq_len(np)]^2) + rss.extra
881c881
<     reml2 <- rbind(cbind(reml2,d[1:n]),d)
---
>     reml2 <- rbind(cbind(reml2,d[seq_len(n)]),d)
908c908
<     rp[rp] <- 1:np
---
>     rp[rp] <- seq_len(np)
911,912c911,912
<     rss.extra <- rss.extra + sum(y[-(1:np)]^2)
<     y <- y[1:np]
---
>     rss.extra <- rss.extra + sum(y[-seq_len(np)]^2)
>     y <- y[seq_len(np)]
952c952
<   for (iter in 1:200) { ## the Newton loop
---
>   for (iter in seq_len(200)) { ## the Newton loop
976c976
<     trial <- Sl.fit(Sl,X,y,rho1[1:nr],fixed,log.phi,phi.fixed,rss.extra,nobs,Mp,nt=nt)
---
>     trial <- Sl.fit(Sl,X,y,rho1[seq_len(nr)],fixed,log.phi,phi.fixed,rss.extra,nobs,Mp,nt=nt)
981c981
<       trial <- Sl.fit(Sl,X,y,rho1[1:nr],fixed,log.phi,phi.fixed,rss.extra,nobs,Mp,nt=nt)
---
>       trial <- Sl.fit(Sl,X,y,rho1[seq_len(nr)],fixed,log.phi,phi.fixed,rss.extra,nobs,Mp,nt=nt)
1009,1011c1009,1011
<   if (step.failed) best$conv <- "step failed" else
<   if (iter==200) best$conv <- "no convergence in 200 iterations" else
<   best$conv <- "full convergence"
---
>   if (step.failed) best$conv <- gettext("step failed", domain = "R-mgcv") else
>   if (iter==200) best$conv <- gettext("no convergence in 200 iterations", domain = "R-mgcv") else
>   best$conv <- gettext("full convergence", domain = "R-mgcv")
1033,1034c1033,1034
<   drop <- qrx$pivot[-(1:rank)] ## index of un-identifiable coefs
<   undrop <- 1:ncol(X) 
---
>   drop <- qrx$pivot[-seq_len(rank)] ## index of un-identifiable coefs
>   undrop <- seq_len(ncol(X))
1057c1057
<   for (b in 1:length(Sl)) {
---
>   for (b in seq_along(Sl)) {
1077c1077
<       for (i in 1:length(Sl[[b]]$S)) {
---
>       for (i in seq_along(Sl[[b]]$S)) {
1087c1087
<     for (i in 1:length(Sl)) {
---
>     for (i in seq_along(Sl)) {
1110c1110
<   for (b in 1:length(Sl)) rank <- rank + Sl[[b]]$rank ## the total penalty rank
---
>   for (b in seq_along(Sl)) rank <- rank + Sl[[b]]$rank ## the total penalty rank
1130c1130
<     for (i in 1:ncol(d1b)) d1b[,i] <- 
---
>     for (i in seq_len(ncol(d1b))) d1b[,i] <- 
1153c1153
<     rV <- (ev$values*t(ev$vectors))[,1:M]
---
>     rV <- (ev$values*t(ev$vectors))[,seq_len(M)]
diff -rEZbwB '--exclude=*.[lo,d,pdf,mo,po,tgz,gz,save]*' '--exclude=MD5' '--exclude=Makefile*' '--exclude=all.R' '--exclude=Changes' R-recommended/mgcv/R/gamlss.r Recommended/mgcv/R/gamlss.r
35c35
<   for (i in 1:K) for (j in i:K) for (k in j:K) for (l in k:K) {
---
>   for (i in seq_len(K)) for (j in i:K) for (k in j:K) for (l in k:K) {
49c49
<   for (j in 1:K) for (k in j:K) for (l in k:K) {
---
>   for (j in seq_len(K)) for (k in j:K) for (l in k:K) {
57c57
<   for (k in 1:K) for (l in k:K) {
---
>   for (k in seq_len(K)) for (l in k:K) {
78c78
<   for (i in 1:K) { ## first derivative loop
---
>   for (i in seq_len(K)) { ## first derivative loop
86c86
<   for (i in 1:K) for (j in i:K) {
---
>   for (i in seq_len(K)) for (j in i:K) {
103c103
<   if (deriv>0) for (i in 1:K) for (j in i:K) for (l in j:K) {
---
>   if (deriv>0) for (i in seq_len(K)) for (j in i:K) for (l in j:K) {
130c130
<   if (deriv>2) for (i in 1:K) for (j in i:K) for (l in j:K) for (m in l:K) {
---
>   if (deriv>2) for (i in seq_len(K)) for (j in i:K) for (l in j:K) for (m in l:K) {
198c198
<   for (i in 1:K) { ## first derivative loop
---
>   for (i in seq_len(K)) { ## first derivative loop
204c204
<   for (i in 1:K) for (j in i:K) {
---
>   for (i in seq_len(K)) for (j in i:K) {
216,217c216,217
<     ind <- 1:n
<     for (i in 1:K) { 
---
>     ind <- seq_len(n)
>     for (i in seq_len(K)) { 
225,228c225,228
<     for (l in 1:m) {
<       for (i in 1:K) {
<         v <- rep(0,n);ind <- 1:n
<         for (q in 1:K) { 
---
>     for (l in seq_len(m)) {
>       for (i in seq_len(K)) {
>         v <- rep(0,n);ind <- seq_len(n)
>         for (q in seq_len(K)) { 
239c239
<     for (l in 1:m) {
---
>     for (l in seq_len(m)) {
241,243c241,243
<       for (i in 1:K) for (j in i:K) {
<         v <- rep(0,n);ind <- 1:n
<         for (q in 1:K) { 
---
>       for (i in seq_len(K)) for (j in i:K) {
>         v <- rep(0,n);ind <- seq_len(n)
>         for (q in seq_len(K)) { 
258,259c258,259
<     ind <- 1:n 
<     for (i in 1:K) { 
---
>     ind <- seq_len(n) 
>     for (i in seq_len(K)) { 
268c268
<        ipiv <- piv <- attr(fh,"pivot");ipiv[piv] <- 1:p
---
>        ipiv <- piv <- attr(fh,"pivot");ipiv[piv] <- seq_len(p)
273,274c273,274
<     ind <- 1:n
<     for (i in 1:K) { 
---
>     ind <- seq_len(n)
>     for (i in seq_len(K)) { 
280c280
<     for (k in 1:m) for (l in k:m) { ## looping over smoothing parameters...
---
>     for (k in seq_len(m)) for (l in k:m) { ## looping over smoothing parameters...
282,284c282,284
<       for (i in 1:K) for (j in 1:K) {
<         v <- rep(0,n);ind <- 1:n
<         for (q in 1:K) { ## accumulate the diagonal matrix for X_i'diag(v)X_j
---
>       for (i in seq_len(K)) for (j in seq_len(K)) {
>         v <- rep(0,n);ind <- seq_len(n)
>         for (q in seq_len(K)) { ## accumulate the diagonal matrix for X_i'diag(v)X_j
286,287c286,287
<           ins <- 1:n
<           for (s in 1:K) { 
---
>           ins <- seq_len(n)
>           for (s in seq_len(K)) { 
294c294
<           rind <- 1:n + (i-1)*n
---
>           rind <- seq_len(n) + (i-1)*n
297,298c297,298
<           rind1 <- 1:n + (i-1)*n
<           rind2 <- 1:n + (j-1)*n
---
>           rind1 <- seq_len(n) + (i-1)*n
>           rind2 <- seq_len(n) + (j-1)*n
336c336
<   for (i in 1:K) { ## first derivative loop
---
>   for (i in seq_len(K)) { ## first derivative loop
342c342
<   for (i in 1:K) for (j in i:K) {
---
>   for (i in seq_len(K)) for (j in i:K) {
356,357c356,357
<     ind <- 1:n
<     for (i in 1:K) { 
---
>     ind <- seq_len(n)
>     for (i in seq_len(K)) { 
365,368c365,368
<     for (l in 1:m) {
<       for (i in 1:K) {
<         v <- rep(0,n);ind <- 1:n
<         for (q in 1:K) { 
---
>     for (l in seq_len(m)) {
>       for (i in seq_len(K)) {
>         v <- rep(0,n);ind <- seq_len(n)
>         for (q in seq_len(K)) { 
379c379
<     for (l in 1:m) {
---
>     for (l in seq_len(m)) {
381,383c381,383
<       for (i in 1:K) for (j in i:K) {
<         v <- rep(0,n);ind <- 1:n
<         for (q in 1:K) { 
---
>       for (i in seq_len(K)) for (j in i:K) {
>         v <- rep(0,n);ind <- seq_len(n)
>         for (q in seq_len(K)) { 
400,401c400,401
<     ind <- 1:n 
<     for (i in 1:K) { 
---
>     ind <- seq_len(n) 
>     for (i in seq_len(K)) { 
410c410
<        ipiv <- piv <- attr(fh,"pivot");ipiv[piv] <- 1:p
---
>        ipiv <- piv <- attr(fh,"pivot");ipiv[piv] <- seq_len(p)
415,416c415,416
<     ind <- 1:n
<     for (i in 1:K) { 
---
>     ind <- seq_len(n)
>     for (i in seq_len(K)) { 
422c422
<     for (k in 1:m) for (l in k:m) { ## looping over smoothing parameters...
---
>     for (k in seq_len(m)) for (l in k:m) { ## looping over smoothing parameters...
424,426c424,426
<       for (i in 1:K) for (j in 1:K) {
<         v <- rep(0,n);ind <- 1:n
<         for (q in 1:K) { ## accumulate the diagonal matrix for X_i'diag(v)X_j
---
>       for (i in seq_len(K)) for (j in seq_len(K)) {
>         v <- rep(0,n);ind <- seq_len(n)
>         for (q in seq_len(K)) { ## accumulate the diagonal matrix for X_i'diag(v)X_j
428,429c428,429
<           ins <- 1:n
<           for (s in 1:K) { 
---
>           ins <- seq_len(n)
>           for (s in seq_len(K)) { 
436c436
<           rind <- 1:n + (i-1)*n
---
>           rind <- seq_len(n) + (i-1)*n
439,440c439,440
<           rind1 <- 1:n + (i-1)*n
<           rind2 <- 1:n + (j-1)*n
---
>           rind1 <- seq_len(n) + (i-1)*n
>           rind2 <- seq_len(n) + (j-1)*n
459c459
<   lpi <- list(); for (i in 1:nlp) lpi[[i]] <- i
---
>   lpi <- list(); for (i in seq_len(nlp)) lpi[[i]] <- i
485c485
<   if (!is.null(offset)) for (i in 1:nlp) if (!is.null(offset[[i]])) eta[,i] <- eta[,i] + offset[[i]] 
---
>   if (!is.null(offset)) for (i in seq_len(nlp)) if (!is.null(offset[[i]])) eta[,i] <- eta[,i] + offset[[i]] 
505c505
<   if (length(link)!=2) stop("gaulss requires 2 links specified as character strings")
---
>   if (length(link)!=2) stop(gettextf("'%s' function requires 2 links specified as character strings", "gaulss()"))
509c509
<   stop(link[[1]]," link not available for mu parameter of gaulss")
---
>   stop(gettextf("\"%s\" link not available for mu parameter of gaulss", link[[1]]))
531c531
<   } else stop(link[[2]]," link not available for precision parameter of gaulss")
---
>   } else stop(gettextf("\"%s\" link not available for precision parameter of gaulss", link[[2]]))
696c696
<   for (i in 1:K) {
---
>   for (i in seq_len(K)) {
719c719
<       sgn*sqrt(-2*log(pmax(.Machine$double.eps,p[1:n + object$y*n]))) 
---
>       sgn*sqrt(-2*log(pmax(.Machine$double.eps,p[seq_len(n) + object$y*n]))) 
734c734
<         lpi <- list(1:ncol(X))
---
>         lpi <- list(seq_len(ncol(X)))
742c742
<       for (i in 1:K) { 
---
>       for (i in seq_len(K)) { 
763c763
<       for (j in 1:(K+1)) {
---
>       for (j in seq_len(K+1)) {
772c772
<         for (i in 1:K) if (i<K) for (k in (i+1):K) {
---
>         for (i in seq_len(K)) if (i<K) for (k in (i+1):K) {
816,817c816,817
<       for (i in 1:K) if (is.null(offset[[i]])) offset[[i]] <- 0
<       for (i in 1:K) eta[,i+1] <- X[,jj[[i]],drop=FALSE]%*%coef[jj[[i]]] + offset[[i]]
---
>       for (i in seq_len(K)) if (is.null(offset[[i]])) offset[[i]] <- 0
>       for (i in seq_len(K)) eta[,i+1] <- X[,jj[[i]],drop=FALSE]%*%coef[jj[[i]]] + offset[[i]]
827c827
<     l0 <- eta[1:n+y*n] - alpha ## log likelihood
---
>     l0 <- eta[seq_len(n)+y*n] - alpha ## log likelihood
833c833
<       for (i in 1:K) l1[,i] <- ee[,i]/beta ## alpha1
---
>       for (i in seq_len(K)) l1[,i] <- ee[,i]/beta ## alpha1
839c839
<       for (i in 1:K) for (j in i:K) {
---
>       for (i in seq_len(K)) for (j in i:K) {
845c845
<       for (i in 1:K) l1[,i] <- as.numeric(y==i) - l1[,i] 
---
>       for (i in seq_len(K)) l1[,i] <- as.numeric(y==i) - l1[,i] 
855c855
<       for (i in 1:K) for (j in i:K) for (k in j:K) {
---
>       for (i in seq_len(K)) for (j in i:K) for (k in j:K) {
871c871
<       for (i in 1:K) for (j in i:K) for (k in j:K) for (l in k:K) {
---
>       for (i in seq_len(K)) for (j in i:K) for (k in j:K) for (l in k:K) {
919c919
<         for (k in 1:length(jj)) { ## loop over the linear predictors      
---
>         for (k in seq_len(length(jj))) { ## loop over the linear predictors      
962c962
<   Qy <- qr.qty(qrx,y)[1:ncol(R)]  
---
>   Qy <- qr.qty(qrx,y)[seq_len(ncol(R))]  
967c967
<   edf <- sum(qr.Q(qrr)[1:r,]^2) 
---
>   edf <- sum(qr.Q(qrr)[seq_len(r),]^2) 
971c971
<     edf <- sum(qr.Q(qrr)[1:r,]^2)
---
>     edf <- sum(qr.Q(qrr)[seq_len(r),]^2)
976c976
<     edf <- sum(qr.Q(qrr)[1:r,]^2)
---
>     edf <- sum(qr.Q(qrr)[seq_len(r),]^2)
1175c1175
<   if (length(link)!=2) stop("ziplss requires 2 links specified as character strings")
---
>   if (length(link)!=2) stop(gettextf("'%s' function requires 2 links specified as character strings", "ziplss()"))
1181c1181
<     stop(link[[i]]," link not available for ",param.names[i]," parameter of ziplss")
---
>     stop(gettextf("\"%s\" link not available for parameter of ziplss %s", param.names[i], link[[i]]))
1416c1416
<         p <- drop(x1[1:nobs,,drop=FALSE] %*% startji) ## probability of presence
---
>         p <- drop(x1[seq_len(nobs),,drop=FALSE] %*% startji) ## probability of presence
1464c1464
<     stop(link[[i]]," link not available for mu parameter of gaulss")
---
>     stop(gettextf("'%s' link not available for mu parameter of gaulss", link[[i]]))
diff -rEZbwB '--exclude=*.[lo,d,pdf,mo,po,tgz,gz,save]*' '--exclude=MD5' '--exclude=Makefile*' '--exclude=all.R' '--exclude=Changes' R-recommended/mgcv/R/gamm.r Recommended/mgcv/R/gamm.r
134c134
<   if (sum(is.na(value))>0) warning("NA's in pdTens factor")
---
>   if (sum(is.na(value))>0) warning("NA values in factor of class \"pdTens\"")
157c157
<   if (sum(is.na(value))>0) warning("NA's in pdTens matrix")
---
>   if (sum(is.na(value))>0) warning("NA values in matrix of class \"pdTens\"")
173c173
<     names(val) <- paste("sp.",1:length(val), sep ="")
---
>     names(val) <- paste("sp.", seq_len(length(val)), sep ="")
179c179
<   function(object, structName = "Tensor product smooth term", ...)
---
>   function(object, structName = gettext("Tensor product smooth term", domain = "R-mgcv"), ...)
219c219
<     nm <- paste("V", 1:len, sep = "")
---
>     nm <- paste("V", seq_len(len), sep = "")
246,247c246
<     stop(paste("An object of length", length(val),
< 	       "does not match the required parameter size"))
---
>     stop(gettextf("An object of length %d does not match the required parameter size", length(val)))
250,251c249
<     stop(paste("Must give names when initializing pdIdnot from parameter.",
< 	       "without a formula"))
---
>     stop("Must give names when initializing pdIdnot from parameter without a formula")
273c271
<     stop(paste("Cannot extract the matrix with uninitialized dimensions"))
---
>     stop("Cannot extract the matrix with uninitialized dimensions")
331c329
<   function(object, structName = "Multiple of an Identity", ...)
---
>   function(object, structName = gettext("Multiple of an Identity", domain = "R-mgcv"), ...)
354c352
<   ind <- 1:colx 
---
>   ind <- seq_len(colx )
366c364
<   for (i in 1:length(object$S)) { ## work through penalties
---
>   for (i in seq_len(length(object$S))) { ## work through penalties
392c390
<       for (j in 1:n.lev) { ## assemble full sparse model matrix
---
>       for (j in seq_len(n.lev)) { ## assemble full sparse model matrix
405c403
<     ind <- 1:length(rind)
---
>     ind <- seq_along(rind)
443c441
<   ind <- 1:ncol(object$X)
---
>   ind <- seq_len(ncol(object$X))
446c444
<   for (i in 1:length(object$S)) { ## work through penalties
---
>   for (i in seq_along(object$S)) { ## work through penalties
476c474
<        rind=1:n.para,rinc=rep(n.para,n.para),pen.ind=pen.ind)
---
>        rind=seq_len(n.para),rinc=rep(n.para,n.para),pen.ind=pen.ind)
507c505
<   D <- c(ev$values[1:p.rank],rep(1,null.rank))
---
>   D <- c(ev$values[seq_len(p.rank)],rep(1,null.rank))
523c521
<     attr(random[[1]],"Xr") <- X[,1:p.rank,drop=FALSE]
---
>     attr(random[[1]],"Xr") <- X[, seq_len(p.rank), drop = FALSE]
525c523
<     random <- list(X[,1:p.rank,drop=FALSE]) 
---
>     random <- list(X[, seq_len(p.rank), drop = FALSE]) 
529c527
<   rind <- 1:p.rank
---
>   rind <- seq_len(p.rank)
584,586c582,583
<   D <- c(ev$values[1:p.rank],rep(1,null.rank))
<   if (sum(D<=0)) stop(
<   "Tensor product penalty rank appears to be too low: please email Simon.Wood@R-project.org with details.")
---
>   D <- c(ev$values[seq_len(p.rank)],rep(1,null.rank))
>   if (sum(D<=0)) stop("Tensor product penalty rank appears to be too low: please email Simon.Wood@R-project.org with details.")
593,594c590,591
<   for (l in 1:length(object$S)) {   # transform penalty explicitly
<     object$S[[l]] <- (t(U)%*%object$S[[l]]%*%U)[1:p.rank,1:p.rank]
---
>   for (l in seq_len(length(object$S))) {   # transform penalty explicitly
>     object$S[[l]] <- (t(U)%*%object$S[[l]]%*%U)[seq_len(p.rank), seq_len(p.rank)]
607,608c604,605
<   attr(random[[1]],"Xr") <- X[,1:p.rank,drop=FALSE] ## random effect model matrix
<   rind <- 1:p.rank
---
>   attr(random[[1]],"Xr") <- X[, seq_len(p.rank), drop = FALSE] ## random effect model matrix
>   rind <- seq_len(p.rank)
620c617
<                       data=stop("No data supplied to gamm.setup"),knots=NULL,
---
>                       data=stop(gettextf("No data supplied to '%s' function", "gamm.setup()")),knots=NULL,
644c641
<   if (!is.null(G$L)) stop("gamm can not handle linked smoothing parameters (probably from use of `id' or adaptive smooths)")
---
>   if (!is.null(G$L)) stop("gamm can not handle linked smoothing parameters (probably from use of 'id' or adaptive smooths)")
653c650
<   if (G$nsdf>0) ind <- 1:G$nsdf else ind <- rep(0,0)  
---
>   if (G$nsdf>0) ind <- seq_len(G$nsdf) else ind <- rep(0,0)  
662c659
<     pord <- 1:G$m
---
>     pord <- seq_len(G$m)
666c663
<     for (i in 1:G$m) if (is.null(G$smooth[[i]]$fac)) { 
---
>     for (i in seq_len(G$m)) if (is.null(G$smooth[[i]]$fac)) { 
673c670
<       if (!is.null(attr(G$smooth[[i]],"del.index"))) stop("side conditions not allowed for nested smooths")
---
>       if (!is.null(attr(G$smooth[[i]],"del.index"))) stop("side conditions are not allowed for nested smooths")
675c672
<     if (k < G$m) pord[(k+1):G$m] <- (1:G$m)[!done] 
---
>     if (k < G$m) pord[(k+1):G$m] <- seq_len(G$m)[!done] 
679c676
<   if (G$m) for (i in 1:G$m) { ## work through the smooths
---
>   if (G$m) for (i in seq_len(G$m)) { ## work through the smooths
696c693
<       for (k in 1:length(rasm$rand)) {
---
>       for (k in seq_len(length(rasm$rand))) {
718c715
<       for (j in 1:ncol(rasm$Xf)) {
---
>       for (j in seq_len(ncol(rasm$Xf))) {
801c798
< { if (!inherits(b,"lme")) stop("object does not appear to be of class lme")
---
> { if (!inherits(b,"lme")) stop(gettextf("'%s' argument is not an object of class %s", "b", dQuote("lme")))
842c839
<     rCind <- 1:n; rCind[Cind] <- 1:n
---
>     rCind <- seq_len(n); rCind[Cind] <- seq_len(n)
848c845
<     for (i in 1:n.cg) size.cg[i] <- sum(Cgrps==Clevel[i]) # size of each coarse group
---
>     for (i in seq_len(n.cg)) size.cg[i] <- sum(Cgrps==Clevel[i]) # size of each coarse group
851c848
<   } else {n.cg <- 1;Cind<-1:n}
---
>   } else {n.cg <- 1;Cind<-seq_len(n)}
874c871
<       for (i in 1:n.cg) { 
---
>       for (i in seq_len(n.cg)) { 
876c873
<         ind[[i]] <- 1:size.cg[i]
---
>         ind[[i]] <- seq_len(size.cg[i])
884,885c881,882
<       ii <- 1:n
<       for (i in 1:n.g) # work through innermost groups
---
>       ii <- seq_len(n)
>       for (i in seq_len(n.g)) # work through innermost groups
889c886
<         k <- (1:n.cg)[Clevel==Clev] # index of coarse group - i.e. update V[[k]] 
---
>         k <- seq_len(n.cg)[Clevel==Clev] # index of coarse group - i.e. update V[[k]] 
902c899
<       for (k in 1:n.cg) { # pasting correlations into right place in each matrix
---
>       for (k in seq_len(n.cg)) { # pasting correlations into right place in each matrix
909c906
<   { for (i in 1:n.cg)
---
>   { for (i in seq_len(n.cg))
932c929
<   { for (i in 1:(n.levels-start.level+1)) # work through the r.e. groupings inner to outer
---
>   { for (i in seq_len(n.levels-start.level+1)) # work through the r.e. groupings inner to outer
948c945
<     for (i in 1:(n.levels-start.level+1))
---
>     for (i in seq_len(n.levels-start.level+1))
950c947
<       for (j in 1:b$dims$ngrps[i]) 
---
>       for (j in seq_len(b$dims$ngrps[i])) 
969c966
<       for (i in 1:n.cg) {
---
>       for (i in seq_len(n.cg)) {
976c973
<         for (i in 1:n.cg) V[[i]] <- V[[i]]+Vz[[i]] 
---
>         for (i in seq_len(n.cg)) V[[i]] <- V[[i]]+Vz[[i]] 
979c976
<         for (i in 1:n.cg) {
---
>         for (i in seq_len(n.cg)) {
998c995
< { if (!inherits(b,"lme")) stop("object does not appear to be of class lme")
---
> { if (!inherits(b,"lme")) stop(gettextf("'%s' argument is not an object of class %s", "b", dQuote("lme")))
1023,1024c1020,1021
<       ind<-ii<-1:n
<       for (i in 1:n.g) 
---
>       ind<-ii<-seq_len(n)
>       for (i in seq_len(n.g)) 
1046c1043
<   { for (i in 1:(n.levels-start.level+1)) # work through the r.e. groupings inner to outer
---
>   { for (i in seq_len(n.levels-start.level+1)) # work through the r.e. groupings inner to outer
1062c1059
<     for (i in 1:(n.levels-start.level+1))
---
>     for (i in seq_len(n.levels-start.level+1))
1064c1061
<       for (j in 1:b$dims$ngrps[i]) 
---
>       for (j in seq_len(b$dims$ngrps[i])) 
1084c1081
<     for (i in 1:length(V$V))
---
>     for (i in seq_len(length(V$V)))
1142,1143c1139
<   eval(parse(text=paste("fit0 <- glm(formula = fixed, family = family, data = data,",
<                         "weights =",wts.name,",...)")))
---
>   eval(parse(text=paste("fit0 <- glm(formula = fixed, family = family, data = data,", "weights =",wts.name,",...)")))
1171c1167
<   for (i in 1:niter) {
---
>   for (i in seq_len(niter)) {
1187c1183
<   } ## end i in 1:niter
---
>   } ## end i in seq_len(niter)
1203c1199
< { if (inherits(family,"extended.family")) warning("family are not designed for use with gamm!")
---
> { if (inherits(family,"extended.family")) warning("family are not designed for use with 'gamm()' function!")
1216c1212
<       else stop("gamm() can only handle random effects defined as named lists")
---
>       else stop("'gamm()' can only handle random effects defined as named lists")
1231c1227
<         for (i in 1:length(weights)) {
---
>         for (i in seq_len(length(weights))) {
1320c1316
<       for (i in 1:r.m) rand[[n.sr+i]]<-random[[i]]   
---
>       for (i in seq_len(r.m)) rand[[n.sr+i]]<-random[[i]]   
1362c1358
<       if (verbosePQL) cat("\n Maximum number of PQL iterations: ",niterPQL,"\n")
---
>       if (verbosePQL) cat("\n ", gettext("Maximum number of PQL iterations: ", domain = "R-mgcv"), niterPQL, "\n", sep = "")
1400,1401c1396,1397
<     if (G$nsdf) p <- bf[1:G$nsdf] else p <- array(0,0)
<     if (G$m>0) for (i in 1:G$m)
---
>     if (G$nsdf) p <- bf[seq_len(G$nsdf)] else p <- array(0,0)
>     if (G$m>0) for (i in seq_len(G$m))
1411c1407
<           for (j in 1:length(flev)) {
---
>           for (j in seq_len(length(flev))) {
1431c1427
<     if (G$m>0) for (i in 1:G$m) # var.param in reverse term order, but forward order within terms!!
---
>     if (G$m>0) for (i in seq_len(G$m)) # var.param in reverse term order, but forward order within terms!!
1446c1442
<     if (length(spl)) for (i in 1:length(spl)) if (!is.null(spl[[i]])) object$sp <- c(object$sp,spl[[i]]) 
---
>     if (length(spl)) for (i in seq_len(length(spl))) if (!is.null(spl[[i]])) object$sp <- c(object$sp,spl[[i]]) 
1457,1458c1453,1454
<       Xf <- G$Xf[,1:G$nsdf,drop=FALSE] 
<       if (G$m>0) for (i in 1:G$m) {# Accumulate the total model matrix
---
>       Xf <- G$Xf[, seq_len(G$nsdf), drop = FALSE] 
>       if (G$m>0) for (i in seq_len(G$m)) {# Accumulate the total model matrix
1467c1463
<           for (k in 1:length(flev)) {
---
>           for (k in seq_len(length(flev))) {
1478c1474
<       if (G$m>0) for (i in 1:G$m) {
---
>       if (G$m>0) for (i in seq_len(G$m)) {
1493c1489
<     if (G$m>0) for (i in 1:G$m) {# Accumulate the total penalty matrix 
---
>     if (G$m>0) for (i in seq_len(G$m)) {# Accumulate the total penalty matrix 
1497c1493
<         if (ns) for (l in 1:ns) { 
---
>         if (ns) for (l in seq_len(ns)) { 
1506,1507c1502,1503
<         for (j in 1:length(flev)) {
<            if (ns) for (l in 1:ns) { 
---
>         for (j in seq_len(length(flev))) {
>            if (ns) for (l in seq_len(ns)) { 
1521c1517
<     if (G$m) for (i in 1:G$m) { 
---
>     if (G$m) for (i in seq_len(G$m)) { 
1560c1556
<     if (G$nsdf>0) term.names<-colnames(G$X)[1:G$nsdf] else term.names<-array("",0)
---
>     if (G$nsdf>0) term.names<-colnames(G$X)[seq_len(G$nsdf)] else term.names<-array("",0)
1563c1559
<       for (i in 1:n.smooth)
---
>       for (i in seq_len(n.smooth))
1612,1614c1608,1610
<     if (fit.cor<.999) { cat("FAILED: fit.cor = ",fit.cor,"\n");return()}
<     if (edf.diff>edf.tol) { cat("FAILED: edf.diff = ",edf.diff,"\n");return()}
<     cat("PASSED \n")
---
>     if (fit.cor<.999) { cat(gettextf("TEST FAILED: fit.cor = %s",fit.cor, domain = "R-mgcv"), "\n", sep = "");return()}
>     if (edf.diff>edf.tol) { cat(gettext("TEST FAILED: edf.diff = %s",edf.diff, domain = "R-mgcv"), "\n", sep = "");return()}
>     cat(gettext("TEST PASSED", domain = "R-mgcv"), "\n", sep = "")
1621c1617
<   cat("testing covariate scale invariance ... ")  
---
>   cat(gettext("testing covariate scale invariance ... ", domain = "R-mgcv"))
1627c1623
<   cat("testing invariance w.r.t. response ... ")
---
>   cat(gettext("testing invariance w.r.t. response ... ", domain = "R-mgcv"))
1632c1628
<   cat("testing equivalence of te(x) and s(x) ... ")
---
>   cat(gettext("testing equivalence of te(x) and s(x) ... ", domain = "R-mgcv"))
1637c1633
<   cat("testing equivalence of gam and gamm with same sp ... ")
---
>   cat(gettext("testing equivalence of gam and gamm with same sp ... ", domain = "R-mgcv"))
diff -rEZbwB '--exclude=*.[lo,d,pdf,mo,po,tgz,gz,save]*' '--exclude=MD5' '--exclude=Makefile*' '--exclude=all.R' '--exclude=Changes' R-recommended/mgcv/R/jagam.r Recommended/mgcv/R/jagam.r
26c26
<     cat("  for (i in 1:n) { mu[i] <- ",iltab[family$link],"} ## expected response\n",file=file,append=TRUE)
---
>     cat("  for (i in seq_len(n)) { mu[i] <- ",iltab[family$link],"} ## expected response\n",file=file,append=TRUE)
30c30
<   cat("  for (i in 1:n) { ",file=file,append=TRUE)
---
>   cat("  for (i in seq_len(n)) { ",file=file,append=TRUE)
50c50
<   } else stop("family not implemented yet")
---
>   } else stop("family not implemented yet") #IVORY
68c68
<   for (i in 1:length(uoff)) {
---
>   for (i in seq_len(length(uoff))) {
81c81
<   rp <- qrx$pivot;rp[rp] <- 1:ncol(X)
---
>   rp <- qrx$pivot;rp[rp] <- seq_len(ncol(X))
96c96
<   if (is.null(file)) stop("jagam requires a file for the JAGS model specification")
---
>   if (is.null(file)) stop("'jagam()' function requires a file for the JAGS model specification")
99c99
<     warning("smoothing parameter prior choise not recognised, reset to gamma")
---
>     warning("smoothing parameter prior choise not recognised, reset to 'gamma'")
177c177
<     ptau <- min(prior.tau[1:G$nsdf]) 
---
>     ptau <- min(prior.tau[seq_len(G$nsdf)]) 
179c179
<     cat("  for (i in 1:",G$nsdf,") { b[i] ~ dnorm(0,",ptau,") }\n",file=file,append=TRUE,sep="")
---
>     cat("  for (i in seq_len(",G$nsdf,")) { b[i] ~ dnorm(0,",ptau,") }\n",file=file,append=TRUE,sep="")
193c193
<   for (i in 1:length(G$smooth)) {
---
>   for (i in seq_len(length(G$smooth))) {
204c204
<       if (M>0) for (j in 1:M) {
---
>       if (M>0) for (j in seq_len(M)) {
216c216
<       } else for (j in 1:M) {
---
>       } else for (j in seq_len(M)) {
227c227
<       cat("  ",Kname," <- ",Sname,"[1:",p,",1:",p,"] * lambda[",n.sp+1,"] ",
---
>       cat("  ",Kname," <- ",Sname,"[seq_len(",p,"), seq_len(",p,")] * lambda[",n.sp+1,"] ",
230c230
<         for (j in 2:M) cat(" + ",Sname,"[1:",p,",",(j-1)*p+1,":",j*p,"] * lambda[",n.sp+j,"]",
---
>         for (j in 2:M) cat(" + ",Sname,"[seq_len(",p,"), ",(j-1)*p+1,":",j*p,"] * lambda[",n.sp+j,"]",
248c248
<       cat("  for (i in 1:",n.sp,") {\n",file=file,append=TRUE,sep="")
---
>       cat("  for (i in seq_len(",n.sp,")) {\n",file=file,append=TRUE,sep="")
254c254
<       cat("  for (i in 1:",n.sp,") {\n",file=file,append=TRUE,sep="")
---
>       cat("  for (i in seq_len(",n.sp,")) {\n",file=file,append=TRUE,sep="")
269c269
<       cat("  for (i in 1:",nr,") { rho0[i] ~ dunif(-12,12) }\n",file=file,append=TRUE,sep="")
---
>       cat("  for (i in seq_len(",nr,")) { rho0[i] ~ dunif(-12,12) }\n",file=file,append=TRUE,sep="")
272c272
<       cat("  for (i in 1:",n.sp,") { lambda[i] <- exp(rho[i]) }\n",file=file,append=TRUE,sep="")
---
>       cat("  for (i in seq_len(",n.sp,")) { lambda[i] <- exp(rho[i]) }\n",file=file,append=TRUE,sep="")
275c275
<       cat("  for (i in 1:",nr,") {\n",file=file,append=TRUE,sep="")
---
>       cat("  for (i in seq_len(",nr,")) {\n",file=file,append=TRUE,sep="")
281c281
<       cat("  for (i in 1:",n.sp,") { lambda[i] <- exp(rho[i]) }\n",file=file,append=TRUE,sep="")
---
>       cat("  for (i in seq_len(",n.sp,")) { lambda[i] <- exp(rho[i]) }\n",file=file,append=TRUE,sep="")
302c302
<       warning("burnin too large, reset")
---
>       warning(gettextf("'%s' argument is too large, reset", "burnin"))
329c329
<     warning("rho missing from simulation data edf.type reset to 2")
---
>     warning("'rho' slot for 'sam' argument is missing from simulation data, 'edf.type' argument reset to 2")
345c345
<     for (i in 1:length(lambda)) {
---
>     for (i in seq_len(length(lambda))) {
369,372c369,372
<     if ("residuals"%in% arg.names) stop("residuals argument not supported")
<     if ("unconditional"%in% arg.names) stop("unconditional argument not meaningful here")
<     if ("by.resids"%in% arg.names) stop("by.resids argument not supported")
<     if ("all.terms"%in% arg.names) stop("all.terms argument not supported")
---
>     if ("residuals"%in% arg.names) stop(gettextf("'%s' argument is not supported", "residuals"))
>     if ("unconditional"%in% arg.names) stop(gettextf("'%s' argument is not meaningful here", "unconfitional"))
>     if ("by.resids"%in% arg.names) stop(gettextf("'%s' argument is not supported", "by.resids"))
>     if ("all.terms"%in% arg.names) stop(gettextf("'%s' argument is not supported", "all.terms"))
388c388
<     if ("unconditional"%in% arg.names) warning("unconditional argument not meaningful here")
---
>     if ("unconditional"%in% arg.names) warning(gettextf("'%s' argument is not meaningful here", "unconditional"))
diff -rEZbwB '--exclude=*.[lo,d,pdf,mo,po,tgz,gz,save]*' '--exclude=MD5' '--exclude=Makefile*' '--exclude=all.R' '--exclude=Changes' R-recommended/mgcv/R/mgcv.r Recommended/mgcv/R/mgcv.r
32c32
<    if (k<0) stop("argument k must be positive.")
---
>    if (k<0) stop("argument 'k' must be positive")
36c36
<    if (n != ncol(A)) stop("A not square")
---
>    if (n != ncol(A)) stop("matrix 'A' is not square")
69c69
<   for (i in 1:length(na)) {
---
>   for (i in seq_len(length(na))) {
103,106c103,106
<   if (nrow(M$X)!=nar[1]) stop("nrow(M$X) != length(M$y)") 
<   if (ncol(M$X)!=nar[2]) stop("ncol(M$X) != length(M$p)")
<   if (length(M$w)!=nar[1]) stop("length(M$w) != length(M$y)")
<   if (nar[3]!=length(M$bin)) stop("nrow(M$Ain) != length(M$bin)")
---
>   if (nrow(M$X)!=nar[1]) stop("nrow(M$X) != length(M$y)", domain = NA)
>   if (ncol(M$X)!=nar[2]) stop("ncol(M$X) != length(M$p)", domain = NA)
>   if (length(M$w)!=nar[1]) stop("length(M$w) != length(M$y)", domain = NA)
>   if (nar[3]!=length(M$bin)) stop("nrow(M$Ain) != length(M$bin)", domain = NA)
108c108
<     if (ncol(M$Ain)!=nar[2]) stop("nrow(M$Ain) != length(M$p)") 
---
>     if (ncol(M$Ain)!=nar[2]) stop("nrow(M$Ain) != length(M$p)", domain = NA) 
113c113
<       warning("initial point very close to some inequality constraints")
---
>       warning("initial point is very close to some inequality constraints")
116c116
<       warning("initial parameters very close to inequality constraints")
---
>       warning("initial parameters are very close to inequality constraints")
119,121c119,121
<   if (nrow(M$C)>0) if (ncol(M$C)!=nar[2]) stop("ncol(M$C) != length(M$p)")  
<   if (length(M$S)!=length(M$off)) stop("M$S and M$off have different lengths")
<   if (length(M$S)!=length(M$sp)) stop("M$sp has different length to M$S and M$off")
---
>   if (nrow(M$C)>0) if (ncol(M$C)!=nar[2]) stop("ncol(M$C) != length(M$p)", domain = NA) 
>   if (length(M$S)!=length(M$off)) stop(gettextf("'%s' and '%s' components should have the same length", "M$S", "M$off"))
>   if (length(M$S)!=length(M$sp)) stop(gettextf("'%s', '%s' and '%s' components should have the same length", "M$sp", "M$S", "M$off"))
127c127
<   if (m>0) for (i in 1:m)
---
>   if (m>0) for (i in seq_len(m))
161c161
<   if ("[["%in%vn) stop("can't handle [[ in formula")
---
>   if ("[["%in%vn) stop("can't handle '[[' in formula")
170c170
<       vn1 <- c(vn1,paste(vn[ii[k]+1:n],collapse="$"))
---
>       vn1 <- c(vn1,paste(vn[ii[k]+seq_len(n)],collapse="$"))
211,212c211,212
<   if (length(sp)>0) for (i in 1:length(sp)) {
<     ind <- (1:nt)[as.logical(vtab[sp[i],])]
---
>   if (length(sp)>0) for (i in seq_len(length(sp))) {
>     ind <- seq_len(nt)[as.logical(vtab[sp[i],])]
215,216c215,216
<   if (length(tp)>0) for (i in 1:length(tp)) {
<     ind <- (1:nt)[as.logical(vtab[tp[i],])]
---
>   if (length(tp)>0) for (i in seq_len(length(tp))) {
>     ind <- seq_len(nt)[as.logical(vtab[tp[i],])]
219,220c219,220
<   if (length(tip)>0) for (i in 1:length(tip)) {
<     ind <- (1:nt)[as.logical(vtab[tip[i],])]
---
>   if (length(tip)>0) for (i in seq_len(length(tip))) {
>     ind <- seq_len(nt)[as.logical(vtab[tip[i],])]
223,224c223,224
<    if (length(t2p)>0) for (i in 1:length(t2p)) {
<     ind <- (1:nt)[as.logical(vtab[t2p[i],])]
---
>    if (length(t2p)>0) for (i in seq_len(length(t2p))) {
>     ind <- seq_len(nt)[as.logical(vtab[t2p[i],])]
237c237
<   if (nt) for (i in 1:nt) { # work through all terms
---
>   if (nt) for (i in seq_len(nt)) { # work through all terms
285c285
<   for (i in 1:length(smooth.spec)) {
---
>   for (i in seq_len(length(smooth.spec))) {
287c287
<     ff1 <- paste(smooth.spec[[i]]$term[1:nt],collapse="+")
---
>     ff1 <- paste(smooth.spec[[i]]$term[seq_len(nt)],collapse="+")
338c338
<     for (i in 1:d) {
---
>     for (i in seq_len(d)) {
366c366
<     for (i in 1:d) if (max(ret[[i]]$lpi)>nlp||min(ret[[i]]$lpi)<1) stop("linear predictor labels out of range")
---
>     for (i in seq_len(d)) if (max(ret[[i]]$lpi)>nlp||min(ret[[i]]$lpi)<1) stop("linear predictor labels out of range")
385c385
<     QtX2[-(1:r),] <- 0
---
>     QtX2[-seq_len(r),] <- 0
387,388c387,388
<     if (rank.def>0) ind <- (1:ncol(X2))[rank(mdiff) <= rank.def] else
<     ind <- (1:ncol(X2))[mdiff < R11*tol]
---
>     if (rank.def>0) ind <- seq_len(ncol(X2))[rank(mdiff) <= rank.def] else
>     ind <- seq_len(ncol(X2))[mdiff < R11*tol]
444c444
<   for (i in 1:m) { ## collect all term names and max smooth `dim'
---
>   for (i in seq_len(m)) { ## collect all term names and max smooth `dim'
473c473
<   for (i in 1:length(sm.id)) sm.id[[i]]<-array(0,0)
---
>   for (i in seq_len(length(sm.id))) sm.id[[i]]<-array(0,0)
475,477c475,477
<   for (d in 1:maxDim) {
<     for (i in 1:m) {
<       if (sm[[i]]$dim==d&&sm[[i]]$side.constrain) for (j in 1:d) { ## work through terms
---
>   for (d in seq_len(maxDim)) {
>     for (i in seq_len(m)) {
>       if (sm[[i]]$dim==d&&sm[[i]]$side.constrain) for (j in seq_len(d)) { ## work through terms
489c489
<   if (maxDim==1) warning("model has repeated 1-d smooths of same variable.")
---
>   if (maxDim==1) warning("model has repeated 1-d smooths of same variable")
495c495
<     for (i in 1:m) { ## create parameter indices for each term
---
>     for (i in seq_len(m)) { ## create parameter indices for each term
504,505c504,505
<   for (d in 1:maxDim) { ## work up through dimensions 
<     for (i in 1:m) { ## work through smooths
---
>   for (d in seq_len(maxDim)) { ## work up through dimensions 
>     for (i in seq_len(m)) { ## work through smooths
510c510
<         for (j in 1:d) { ## work through variables
---
>         for (j in seq_len(d)) { ## work through variables
512,513c512,513
<           k <- (1:length(b))[b==i] ## locate current smooth in list 
<           if (k>1) for (l in 1:(k-1)) if (!b[l] %in% X1comp) { ## collect X columns
---
>           k <- (seq_along(b))[b==i] ## locate current smooth in list 
>           if (k>1) for (l in seq_len(k-1)) if (!b[l] %in% X1comp) { ## collect X columns
548c548
<             if (mi>1) for (j in 1:mi) St <- St + 
---
>             if (mi>1) for (j in seq_len(mi)) St <- St + 
578c578
<     } ## end i in 1:m loop
---
>     } ## end i in seq_len(m) loop
580c580
<   if (with.pen) for (i in 1:m) { ## remove working variables that were added
---
>   if (with.pen) for (i in seq_len(m)) { ## remove working variables that were added
592c592
<  if (specb$dim!=spec$dim) stop("`id' linked smooths must have same number of arguments") 
---
>  if (specb$dim!=spec$dim) stop("'id' linked smooths must have same number of arguments") 
599c599
<     for (i in 1:length(specb$margin)) {
---
>     for (i in seq_len(length(specb$margin))) {
601c601
<          for (j in 1:length(specb$margin[[i]]$term)) {
---
>          for (j in seq_len(length(specb$margin[[i]]$term))) {
638c638
<   if (n.t>0) for (j in 1:n.t) if (tind[j]>0) {
---
>   if (n.t>0) for (j in seq_len(n.t)) if (tind[j]>0) {
642c642
<       ind <- (1:length(assign))[assign==tind[j]] ## index of coefs involved here
---
>       ind <- seq_len(length(assign))[assign==tind[j]] ## index of coefs involved here
649,650c649,650
<       if (!is.null(ranki)&&length(ranki)!=np) stop("`rank' has wrong length in `paraPen'") 
<       if (np) for (i in 1:np) { ## unpack penalty matrices, offsets and ranks
---
>       if (!is.null(ranki)&&length(ranki)!=np) stop("'rank' has wrong length in 'paraPen'") 
>       if (np) for (i in seq_len(np)) { ## unpack penalty matrices, offsets and ranks
663c663
<         if (nrow(Li)!=np) stop("L has wrong dimension in `paraPen'")
---
>         if (nrow(Li)!=np) stop("'L' has wrong dimension in 'paraPen'")
671c671
<           if (length(spi)!=ncol(Li)) stop("`sp' dimension wrong in `paraPen'")
---
>           if (length(spi)!=ncol(Li)) stop("'sp' dimension wrong in 'paraPen'")
685,686c685,686
<     if (length(sp0)<length(sp)) stop("`sp' too short")
<     sp0 <- sp0[1:length(sp)]
---
>     if (length(sp0)<length(sp)) stop("'sp' is too short")
>     sp0 <- sp0[seq_len(length(sp))]
735c735
<   ii <- 1:n
---
>   ii <- seq_len(n)
739c739
<   for (i in 1:nf) {
---
>   for (i in seq_len(nf)) {
742c742
<       ind <- pstart[i] + 1:nsdf[i] - 1
---
>       ind <- pstart[i] + seq_len(nsdf[i]) - 1
767c767
<       for (i in 1:nlp) { 
---
>       for (i in seq_len(nlp)) { 
781c781
<                     data=stop("No data supplied to gam.setup"),knots=NULL,sp=NULL,
---
>                     data=stop(gettextf("No data supplied to '%s' function", "gam.setup()")),knots=NULL,sp=NULL,
788,789c788,789
<   if (!is.null(paraPen)) stop("paraPen not supported for multi-formula models")
<   if (!absorb.cons) stop("absorb.cons must be TRUE for multi-formula models")
---
>   if (!is.null(paraPen)) stop("'paraPen' argument is not supported for multi-formula models")
>   if (!absorb.cons) stop("'absorb.cons' argument must be TRUE for multi-formula models")
792c792
<   if (length(drop.intercept) != d) stop("length(drop.intercept) should be equal to number of model formulas")
---
>   if (length(drop.intercept) != d) stop("'length(drop.intercept)' should be equal to number of model formulas")
806,807c806,807
<   if (!is.null(sp)&&used.sp>0) sp <- sp[-(1:used.sp)] ## need to strip off already used sp's
<   if (!is.null(min.sp)&&nrow(G$L)>0) min.sp <- min.sp[-(1:nrow(G$L))]  
---
>   if (!is.null(sp)&&used.sp>0) sp <- sp[-seq_len(used.sp)] ## need to strip off already used sp's
>   if (!is.null(min.sp)&&nrow(G$L)>0) min.sp <- min.sp[-seq_len(nrow(G$L))]  
812,813c812,813
<   for (i in 1:formula$nlp) lpi[[i]] <- rep(0,0)
<   lpi[[1]] <- 1:ncol(G$X) ## lpi[[j]] is index of cols for jth linear predictor 
---
>   for (i in seq_len(formula$nlp)) lpi[[i]] <- rep(0,0)
>   lpi[[1]] <- seq_len(ncol(G$X)) ## lpi[[j]] is index of cols for jth linear predictor 
831,832c831,832
<     if (!is.null(sp)&&used.sp>0) sp <- sp[-(1:used.sp)] ## need to strip off already used sp's
<     if (!is.null(min.sp)&&nrow(um$L)>0) min.sp <- min.sp[-(1:nrow(um$L))]  
---
>     if (!is.null(sp)&&used.sp>0) sp <- sp[-seq_len(used.sp)] ## need to strip off already used sp's
>     if (!is.null(min.sp)&&nrow(um$L)>0) min.sp <- min.sp[-seq_len(nrow(um$L))]  
836c836
<       lpi[[j]] <- c(lpi[[j]],pof + 1:ncol(um$X)) ## add these cols to lpi[[j]]
---
>       lpi[[j]] <- c(lpi[[j]],pof + seq_len(ncol(um$X))) ## add these cols to lpi[[j]]
841c841
<       stop("shared offsets not allowed")
---
>       stop("shared offsets are not allowed")
853c853
<     if (um$m) for (j in 1:um$m) {
---
>     if (um$m) for (j in seq_len(um$m)) {
870c870
<     if (M) for (j in 1:M) {
---
>     if (M) for (j in seq_len(M)) {
885c885
<     if (um$nsdf>0) um$term.names[1:um$nsdf] <- paste(um$term.names[1:um$nsdf],i-1,sep=".")
---
>     if (um$nsdf>0) um$term.names[seq_len(um$nsdf)] <- paste(um$term.names[seq_len(um$nsdf)],i-1,sep=".")
904c904
<       for (i in 1:length(G$smooth)) {
---
>       for (i in seq_len(length(G$smooth))) {
909c909
<       for (i in 1:length(G$off)) G$off[i] <- G$off[i] - sum(rt$dind < G$off[i])
---
>       for (i in seq_len(length(G$off))) G$off[i] <- G$off[i] - sum(rt$dind < G$off[i])
925c925
<                      data=stop("No data supplied to gam.setup"),knots=NULL,sp=NULL,
---
>                      data=stop(gettextf("No data supplied to '%s' function", "gam.setup()")),knots=NULL,sp=NULL,
1010c1010
<     ind <- 1:length(PP$sp)
---
>     ind <- seq_len(length(PP$sp))
1024c1024
<     if (m>0) for (i in 1:m) attr(split$smooth.spec[[i]],"gamm") <- TRUE
---
>     if (m>0) for (i in seq_len(m)) attr(split$smooth.spec[[i]],"gamm") <- TRUE
1029c1029
<     for (i in 1:m) if (!is.null(split$smooth.spec[[i]]$id)) {
---
>     for (i in seq_len(m)) if (!is.null(split$smooth.spec[[i]]$id)) {
1045c1045
<         for (j in 1:length(temp.term)) id.list[[id]]$data[[j]] <- cbind(id.list[[id]]$data[[j]],
---
>         for (j in seq_len(length(temp.term))) id.list[[id]]$data[[j]] <- cbind(id.list[[id]]$data[[j]],
1054c1054
<         for (j in 1:length(term)) id.list[[id]]$data[[j]] <- get.var(term[j],data,vecMat=FALSE)
---
>         for (j in seq_along(term)) id.list[[id]]$data[[j]] <- get.var(term[j],data,vecMat=FALSE)
1063c1063
<   if (m>0) for (i in 1:m) {
---
>   if (m>0) for (i in seq_len(m)) {
1080c1080
<     for (j in 1:length(sml)) {
---
>     for (j in seq_along(sml)) {
1092c1092
<     if (!apply.by) for (i in 1:length(sm)) { ## restore any by-free model matrices
---
>     if (!apply.by) for (i in seq_len(length(sm))) { ## restore any by-free model matrices
1106c1106
<   if (m>0) for (i in 1:m) {
---
>   if (m>0) for (i in seq_len(m)) {
1115c1115
<           if (is.null(Sname)) spn <- paste(sm[[i]]$label,1:length.S,sep="") else
---
>           if (is.null(Sname)) spn <- paste(sm[[i]]$label, seq_len(length.S),sep="") else
1135c1135
<         stop("Later terms sharing an `id' can not have more smoothing parameters than the first such term")
---
>         stop("Later terms sharing an 'id' can not have more smoothing parameters than the first such term")
1148c1148
<   if (m>0) for (i in 1:m) {
---
>   if (m>0) for (i in seq_len(m)) {
1186c1186
<     QtX <- qr.qty(qrx,X)[1:rank,]
---
>     QtX <- qr.qty(qrx,X)[seq_len(rank),]
1188c1188
<       R <- R[1:rank,]
---
>       R <- R[seq_len(rank),]
1200c1200
<   if (G$nsdf>0) G$cmX[-(1:G$nsdf)] <- 0 ## zero the smooth parts here 
---
>   if (G$nsdf>0) G$cmX[-seq_len(G$nsdf)] <- 0 ## zero the smooth parts here 
1220c1220
<       warning("Supplied smoothing parameter vector is too short - ignored.")
---
>       warning("Supplied smoothing parameter vector is too short - ignored")
1224c1224
<       warning("NA's in supplied smoothing parameter vector - ignoring.")
---
>       warning("NA values in supplied smoothing parameter vector - ignoring")
1237c1237
<   if (m>0) for (i in 1:m) {
---
>   if (m>0) for (i in seq_len(m)) {
1263,1264c1263,1264
<   if (length(idx)) for (i in 1:length(idx)) idx[[i]]$sp.done <- FALSE
<   if (m>0) for (i in 1:m) { ## work through all smooths
---
>   if (length(idx)) for (i in seq_along(idx)) idx[[i]]$sp.done <- FALSE
>   if (m>0) for (i in seq_len(m)) { ## work through all smooths
1284,1287c1284,1287
<     if (length(min.sp)<nrow(L)) stop("length of min.sp is wrong.")
<     min.sp <- min.sp[1:nrow(L)]
<     if (sum(is.na(min.sp))) stop("NA's in min.sp.")
<     if (sum(min.sp<0)) stop("elements of min.sp must be non negative.")
---
>     if (length(min.sp)<nrow(L)) stop(gettextf("'%s' argument is of the wrong length", "min.sp"))
>     min.sp <- min.sp[seq_len(nrow(L))]
>     if (sum(is.na(min.sp))) stop("NA values in 'min.sp' argument")
>     if (sum(min.sp<0)) stop("elements of 'min.sp' argument must be non negative")
1292c1292
<   if (m>0) for (i in 1:m) {
---
>   if (m>0) for (i in seq_len(m)) {
1295c1295
<     for (j in 1:length(sm$S)) {  # work through penalty matrices
---
>     for (j in seq_along(sm$S)) {  # work through penalty matrices
1321c1321
<       for (i in 1:length(PP$S)) {
---
>       for (i in seq_len(length(PP$S))) {
1337,1338c1337,1338
<     ef0 <- indi <- (1:length(ind))[ind]
<     if (length(indi)>0) for (i in 1:length(indi)) {
---
>     ef0 <- indi <- seq_len(length(ind))[ind]
>     if (length(indi)>0) for (i in seq_len(length(indi))) {
1361c1361
<       for (i in 1:m) {
---
>       for (i in seq_len(m)) {
1384c1384
<   if (G$nsdf > 0) term.names <- colnames(G$X)[1:G$nsdf] else term.names<-array("",0)
---
>   if (G$nsdf > 0) term.names <- colnames(G$X)[seq_len(G$nsdf)] else term.names<-array("",0)
1387c1387
<   for (i in 1:n.smooth) { ## create coef names, if smooth has any coefs!
---
>   for (i in seq_len(n.smooth)) { ## create coef names, if smooth has any coefs!
1426c1426
<   if (!optimizer[2]%in%c("newton","bfgs","nlm","optim","nlm.fd")) stop("unknown outer optimization method.")
---
>   if (!optimizer[2]%in%c("newton","bfgs","nlm","optim","nlm.fd")) stop("unknown outer optimization method")
1573c1573
<        #if (!is.null(G$offset)) if (is.list(G$offset)) { for (i in 1:length(G$offset)) 
---
>        #if (!is.null(G$offset)) if (is.list(G$offset)) { for (i in seq_len(length(G$offset)))
1616c1616
<   if (length(G$S)>0) for (i in 1:length(G$S)) G$UrS[[i]] <- t(Ssp$Y)%*%G$rS[[i]] else i <- 0
---
>   if (length(G$S)>0) for (i in seq_len(length(G$S))) G$UrS[[i]] <- t(Ssp$Y)%*%G$rS[[i]] else i <- 0
1739c1739
<       ind <- 1:nlsp + nth ## only used if nlsp>0
---
>       ind <- seq_len(nlsp) + nth ## only used if nlsp>0
1763c1763
<     if (inherits(G$family,"extended.family")&&nth>0) object$sp <- object$sp[-(1:nth)] ## drop theta params
---
>     if (inherits(G$family,"extended.family")&&nth>0) object$sp <- object$sp[-seq_len(nth)] ## drop theta params
1821c1821
<    ## if (v.n) for (i in 1:v.n) if (length(dl[[i]])<n) dl[[i]] <- NULL 
---
>    ## if (v.n) for (i in seq_len(v.n)) if (length(dl[[i]])<n) dl[[i]] <- NULL 
1826c1826
<      for (i in 1:v.n) if (length(dl[[i]])>=n) { 
---
>      for (i in seq_len(v.n)) if (length(dl[[i]])>=n) { 
1830c1830
<      if (k>0) v.name <- v.name[1:k] else v.name <- rep("",k)
---
>      if (k>0) v.name <- v.name[seq_len(k)] else v.name <- rep("",k)
1837c1837
<    if (v.n>0) for (i in 1:v.n) {
---
>    if (v.n>0) for (i in seq_len(v.n)) {
1849c1849
<          ii <- min((1:length(lx))[freq==max(freq)])
---
>          ii <- min(seq_len(length(lx))[freq==max(freq)])
1921c1921
<       for (i in 1:length(formula)) {
---
>       for (i in seq_len(length(formula))) {
1980c1980
<     if (G$m) for (i in 1:G$m) G$min.edf<-G$min.edf+G$smooth[[i]]$null.space.dim
---
>     if (G$m) for (i in seq_len(G$m)) G$min.edf<-G$min.edf+G$smooth[[i]]$null.space.dim
2041c2041
<   if (is.list(x$formula)) for (i in 1:length(x$formula)) print(x$formula[[i]]) else
---
>   if (is.list(x$formula)) for (i in seq_len(length(x$formula))) print(x$formula[[i]]) else
2045c2045
<   cat("Total model degrees of freedom",sum(x$edf),"\n")
---
>   cat(gettextf("Total model degrees of freedom %s",sum(x$edf), domain = "R-mgcv"), "\n", sep = "")
2048,2049c2048,2049
<     cat("\nEstimated degrees of freedom:\n")
<     for (i in 1:n.smooth)
---
>     cat("\n", gettext("Estimated degrees of freedom:", domain = "R-mgcv"), "\n", sep = "")
>     for (i in seq_len(n.smooth))
2052c2052
<     for (i in 1:n.smooth) {   
---
>     for (i in seq_len(n.smooth)) {   
2056c2056
<     cat(" total =",round(sum(x$edf),digits=2),"\n")
---
>     cat(gettextf(" total df = %s",round(sum(x$edf),digits=2), domain = "R-mgcv"), "\n", sep = "")
2059,2060c2059,2060
<   cat("\n",x$method," score: ",x$gcv.ubre,"     ",sep="")
<   if (!is.null(x$rank) && x$rank< length(x$coefficients)) cat("rank: ",x$rank,"/",length(x$coefficients),sep="") 
---
>   cat("\n", gettextf("%s score = %s", sQuote(x$method), x$gcv.ubre, domain = "R-mgcv"), "     ", sep = "")
>   if (!is.null(x$rank) && x$rank< length(x$coefficients)) cat(gettextf("Rank: %s/%s", x$rank, length(x$coefficients), domain = "R-mgcv"), sep = "") 
2081,2084c2081,2083
<     if (!is.logical(edge.correct)&&(!is.numeric(edge.correct)||edge.correct<0)) stop(
<         "edge.correct must be logical or a positive number")
<     if (!is.numeric(nthreads) || nthreads <1) stop("nthreads must be a positive integer") 
<     if (!is.numeric(irls.reg) || irls.reg <0.0) stop("IRLS regularizing parameter must be a non-negative number.")
---
>     if (!is.logical(edge.correct)&&(!is.numeric(edge.correct)||edge.correct<0)) stop("edge.correct must be logical or a positive number")
>     if (!is.numeric(nthreads) || nthreads <1) stop("'nthreads' argument must be a positive integer") 
>     if (!is.numeric(irls.reg) || irls.reg <0.0) stop("IRLS regularizing parameter must be a non-negative number")
2091c2090
<       warning("silly value supplied for rank.tol: reset to square root of machine precision.")
---
>       warning("silly value supplied for rank.tol: reset to square root of machine precision")
2183c2182
<   for (i in 1:length(G$S))
---
>   for (i in seq_len(length(G$S)))
2238c2237
<       for (i in 1:n.S) S.size[i]<-mean(abs(G$S[[i]])) 
---
>       for (i in seq_len(n.S)) S.size[i]<-mean(abs(G$S[[i]])) 
2250c2249
<         stop("illegal `family' argument")
---
>         stop("invalid 'family' argument")
2265c2264
<         stop("y must be univariate unless binomial")
---
>         stop("'y' must be univariate unless binomial")
2273c2272
<     stop(gettextf("Length of start should equal %d and correspond to initial coefs.",nvars)) 
---
>     stop(gettextf("Length of start should equal %d and correspond to initial coefs", nvars))
2293c2292
<     for (iter in 1:(control$maxit)) 
---
>     for (iter in seq_len(control$maxit)) 
2298c2297
<             stop("NAs in V(mu)")
---
>             stop("NA values in V(mu)")
2303c2302
<             stop("NAs in d(mu)/d(eta)")
---
>             stop("NA values in d(mu)/d(eta)")
2327c2326
<         stop("iterative weights or data non-finite in gam.fit - regularization may help. See ?gam.control.")
---
>         stop("iterative weights or data non-finite in gam.fit - regularization may help. See ?gam.control")
2365,2366c2364
<             stop("no valid set of coefficients has been found:please supply starting values",
<             call. = FALSE)
---
>             stop("no valid set of coefficients has been found:please supply starting values", call. = FALSE)
2371c2369
<                   stop("inner loop 1; can't correct step size")
---
>                   stop(gettextf("inner loop %d; can't correct step size", 1))
2381c2379
<                 cat("Step halved: new deviance =", dev, "\n")
---
>                 cat(gettextf("Step halved: new deviance = %g", dev, domain = "R-mgcv"), "\n", sep = "")
2384c2382
<             warning("Step size truncated: out of bounds.",call.=FALSE)
---
>             warning("Step size truncated: out of bounds",call. = FALSE)
2388c2386
<                   stop("inner loop 2; can't correct step size")
---
>                   stop(gettextf("inner loop %d; can't correct step size", 2))
2398c2396
<                 cat("Step halved: new deviance =", dev, "\n")
---
>                 cat(gettextf("Step halved: new deviance = %g", dev, domain = "R-mgcv"), "\n", sep = "")
2469c2467
< { if (!inherits(object,"gam")) stop("`object' is not of class \"gam\"")
---
> { if (!inherits(object,"gam")) stop(gettextf("'%s' argument is not an object of class %s", "object", dQuote("gam")))
2539c2537
<     warning("Unknown type, reset to terms.")
---
>     warning("Unknown type, reset to terms")
2571,2572c2569
<         if (sum(!(names(object$model)%in%names(newdata)))) stop(
<         "newdata is a model.frame: it should contain all required variables\n")
---
>         if (sum(!(names(object$model)%in%names(newdata)))) stop("newdata is a model.frame: it should contain all required variables\n")
2629c2626
<     for (i in 1:length(newdata)) 
---
>     for (i in seq_len(length(newdata))) 
2634c2631
<         msg <- paste(paste(levn[!levn%in%levm],collapse=", "),"not in original fit",collapse="")
---
>         msg <- gettextf("%s not in original fit", paste(levn[!levn%in%levm], collapse = ", "), domain = "R-mgcv")
2698c2695
<       warning("type iterms not available for multiple predictor cases")
---
>       warning("type 'iterms' is not available for multiple predictor cases")
2704c2701
<     for (i in 1:length(object$nsdf)) {
---
>     for (i in seq_len(length(object$nsdf))) {
2706c2703
<       if (object$nsdf[i]>0) pind <- c(pind,pstart[i]-1+1:object$nsdf[i])
---
>       if (object$nsdf[i]>0) pind <- c(pind,pstart[i]-1+seq_len(object$nsdf[i]))
2712c2709
<     pind <- 1:object$nsdf ## index of parameteric coefficients
---
>     pind <- seq_len(object$nsdf) ## index of parameteric coefficients
2743c2740
<   if (n.blocks > 0) for (b in 1:n.blocks) { # work through prediction blocks
---
>   if (n.blocks > 0) for (b in seq_len(n.blocks)) { # work through prediction blocks
2750c2747
<     for (i in 1:length(Terms)) { ## loop for parametric components (1 per lp)
---
>     for (i in seq_len(length(Terms))) { ## loop for parametric components (1 per lp)
2773c2770
<       if (object$nsdf[i]>0) X[,pstart[i]-1 + 1:object$nsdf[i]] <- Xp
---
>       if (object$nsdf[i]>0) X[,pstart[i]-1 + seq_len(object$nsdf[i])] <- Xp
2779c2776
<     if (n.smooth) for (k in 1:n.smooth) { ## loop through smooths
---
>     if (n.smooth) for (k in seq_len(n.smooth)) { ## loop through smooths
2804,2805c2801,2802
<       for (j in 1:length(lass)) if (length(lass[[j]])) { ## work through assign list
<         ind <- 1:length(lass[[j]]) ## index vector for coefs involved
---
>       for (j in seq_len(length(lass))) if (length(lass[[j]])) { ## work through assign list
>         ind <- seq_len(length(lass[[j]])) ## index vector for coefs involved
2807c2804
<         if (nptj>0) for (i in 1:nptj) { ## work through parametric part
---
>         if (nptj>0) for (i in seq_len(nptj)) { ## work through parametric part
2816c2813
<         for (k in 1:n.smooth) # work through the smooth terms 
---
>         for (k in seq_len(n.smooth)) # work through the smooth terms 
2861,2862c2858,2859
<           off.ind <- (1:n.smooth)[as.logical(colSums(abs(Xoff)))]
<           for (j in 1:nlp) { ## looping over the model formulae
---
>           off.ind <- seq_len(n.smooth)[as.logical(colSums(abs(Xoff)))]
>           for (j in seq_len(nlp)) { ## looping over the model formulae
3006c3003
<   if (!inherits(b,"gam")) stop("requires an object of class gam")
---
>   if (!inherits(b,"gam")) stop(gettextf("'%s' argument is not an object of class %s", "b", dQuote("gam")))
3015c3012
<   for (i in 1:m) { ## loop through smooths
---
>   for (i in seq_len(m)) { ## loop through smooths
3033c3030
<     for (i in 1:m) {
---
>     for (i in seq_len(m)) {
3037c3034
<       R <- qr.R(qr(cbind(Xi,Xj),LAPACK=FALSE,tol=0))[,-(1:r),drop=FALSE] ## No pivoting!!  
---
>       R <- qr.R(qr(cbind(Xi,Xj),LAPACK=FALSE,tol=0))[,-seq_len(r),drop=FALSE] ## No pivoting!!  
3041c3038
<       conc[1,i] <- svd(forwardsolve(t(Rt),t(R[1:r,,drop=FALSE])))$d[1]^2
---
>       conc[1,i] <- svd(forwardsolve(t(Rt),t(R[seq_len(r),,drop=FALSE])))$d[1]^2
3045c3042
<       conc[2,i] <- sum((R[1:r,,drop=FALSE]%*%beta)^2)/sum((Rt%*%beta)^2)
---
>       conc[2,i] <- sum((R[seq_len(r),,drop=FALSE]%*%beta)^2)/sum((Rt%*%beta)^2)
3048c3045
<       conc[3,i] <- sum(R[1:r,]^2)/sum(R^2)
---
>       conc[3,i] <- sum(R[seq_len(r),]^2)/sum(R^2)
3054,3055c3051,3052
<     for (i in 1:n.measures) conc[[i]] <- matrix(1,m,m) ## concurvity matrix
<     for (i in 1:m) { ## concurvity calculation loop
---
>     for (i in seq_len(n.measures)) conc[[i]] <- matrix(1,m,m) ## concurvity matrix
>     for (i in seq_len(m)) { ## concurvity calculation loop
3058c3055
<       for (j in 1:m) if (i!=j) { 
---
>       for (j in seq_len(m)) if (i!=j) { 
3060c3057
<         R <- qr.R(qr(cbind(Xi,Xj),LAPACK=FALSE,tol=0))[,-(1:r),drop=FALSE] ## No pivoting!!  
---
>         R <- qr.R(qr(cbind(Xi,Xj),LAPACK=FALSE,tol=0))[,-seq_len(r),drop=FALSE] ## No pivoting!!  
3064c3061
<         conc[[1]][i,j] <- svd(forwardsolve(t(Rt),t(R[1:r,,drop=FALSE])))$d[1]^2
---
>         conc[[1]][i,j] <- svd(forwardsolve(t(Rt),t(R[seq_len(r),,drop=FALSE])))$d[1]^2
3068c3065
<         conc[[2]][i,j] <- sum((R[1:r,,drop=FALSE]%*%beta)^2)/sum((Rt%*%beta)^2)
---
>         conc[[2]][i,j] <- sum((R[seq_len(r),,drop=FALSE]%*%beta)^2)/sum((Rt%*%beta)^2)
3071c3068
<         conc[[3]][i,j] <- sum(R[1:r,]^2)/sum(R^2)
---
>         conc[[3]][i,j] <- sum(R[seq_len(r),]^2)/sum(R^2)
3080c3077
<     for (i in 1:n.measures) rownames(conc[[i]]) <- colnames(conc[[i]]) <- lab
---
>     for (i in seq_len(n.measures)) rownames(conc[[i]]) <- colnames(conc[[i]]) <- lab
3114c3111
<       warning("Pearson residuals not available for this family - returning deviance residuals")
---
>       warning("Pearson residuals are not available for this family - returning deviance residuals")
3141c3138
<   f <- t(ed$vectors[,1:k])%*%R%*%b
---
>   f <- t(ed$vectors[,seq_len(k)])%*%R%*%b
3144c3141
<   lambda <- as.numeric(ed$values[1:k])
---
>   lambda <- as.numeric(ed$values[seq_len(k)])
3164c3161
< #    for (i in 1:length(x)) r[i] <- davies(x[i],lambda,h)$Qq
---
> #    for (i in seq_len(length(x))) r[i] <- davies(x[i],lambda,h)$Qq
3168c3165
<   if (length(h) != length(lambda)) stop("lambda and h should have the same length!")
---
>   if (length(h) != length(lambda)) stop(gettextf("'%s' and '%s' arguments should have the same length", "lambda", "h"))
3208c3205
<   p <- (1:nq-.5)/nq
---
>   p <- (seq_len(nq)-.5)/nq
3227c3224
<   if (!inherits(b,"gam")) stop("recov works with fitted gam objects only") 
---
>   if (!inherits(b,"gam")) stop(gettextf("'%s' argument is not an object of class %s", "b", dQuote("gam")))
3234c3231
<       for (i in 1:length(b$smooth)) { 
---
>       for (i in seq_len(length(b$smooth))) { 
3237c3234
<         if (ns>0) for (j in 1:ns) {
---
>         if (ns>0) for (j in seq_len(ns)) {
3253c3250
<   if (m%in%re) stop("m can't be in re")
---
>   if (m%in%re) stop("'m' argument  can't be in 're' argument")
3257c3254
<   for (i in 1:length(re)) {
---
>   for (i in seq_len(length(re))) {
3263,3264c3260,3261
<   map[rind] <- 1:p2 ## random
<   map[!rind] <- 1:p1 ## fixed
---
>   map[rind] <- seq_len(p2) ## random
>   map[!rind] <- seq_len(p1) ## fixed
3275c3272
<   for (i in 1:length(b$smooth)) { 
---
>   for (i in seq_len(length(b$smooth))) { 
3279c3276
<     if (ns>0) for (j in 1:ns) {
---
>     if (ns>0) for (j in seq_len(ns)) {
3338c3335
<   for (i in 1:length(b$smooth)) if (!is.null(b$smooth[[i]]$random)&&b$smooth[[i]]$random&&i!=m) rind <- c(rind,i)
---
>   for (i in seq_len(length(b$smooth))) if (!is.null(b$smooth[[i]]$random)&&b$smooth[[i]]$random&&i!=m) rind <- c(rind,i)
3413c3410
<   if (k1<ncol(vec)) vec <- vec[,1:k1,drop=FALSE]
---
>   if (k1<ncol(vec)) vec <- vec[,seq_len(k1),drop=FALSE]
3417c3414
<      if (k>1) vec[,1:(k-1)] <- t(t(vec[,1:(k-1)])/sqrt(ed$val[1:(k-1)]))
---
>      if (k>1) vec[,seq_len(k-1)] <- t(t(vec[,seq_len(k-1)])/sqrt(ed$val[seq_len(k-1)]))
3431c3428
<             t(t(vec)/sqrt(ed$val[1:k]))
---
>             t(t(vec)/sqrt(ed$val[seq_len(k)]))
3508c3505
<     warning("p-values for any terms that can be penalized to zero will be unreliable: refit model to fix this.")
---
>     warning("p-values for any terms that can be penalized to zero will be unreliable: refit model to fix this")
3514c3511
<   if (p.type!=0) warning("p.type!=0 is deprecated, and liable to be removed in future")
---
>   if (p.type!=0) warning("'p.type != 0' is deprecated, and liable to be removed in future")
3539c3536
<       for (i in 1:length(object$nsdf)) if (object$nsdf[i]>0) ind <- 
---
>       for (i in seq_len(length(object$nsdf))) if (object$nsdf[i]>0) ind <- 
3541c3538
<     } else { pstart <- 1;ind <- 1:object$nsdf} ## only one lp
---
>     } else { pstart <- 1;ind <- seq_len(object$nsdf)} ## only one lp
3564c3561
<   for (j in 1:length(pterms)) {
---
>   for (j in seq_len(length(pterms))) {
3572c3569
<       ind <- pstart[j] - 1 + 1:np 
---
>       ind <- pstart[j] - 1 + seq_len(np)
3578c3575
<       for (i in 1:nt) { 
---
>       for (i in seq_len(nt)) { 
3617c3614
<     for (i in 1:m) { 
---
>     for (i in seq_len(m)) { 
3639c3636
<           ind <- sample(1:nrow(object$model),sub.samp,replace=FALSE)  ## sample these rows from X
---
>           ind <- sample(seq_len(nrow(object$model)),sub.samp,replace=FALSE)  ## sample these rows from X
3650c3647
<     for (i in 1:m) { ## loop through smooths
---
>     for (i in seq_len(m)) { ## loop through smooths
3737c3734
<   cat("Formula:\n") 
---
>   cat(gettext("Formula:", domain = "R-mgcv"), "\n", sep = "")
3739c3736
<   if (is.list(x$formula)) for (i in 1:length(x$formula)) print(x$formula[[i]]) else
---
>   if (is.list(x$formula)) for (i in seq_len(length(x$formula))) print(x$formula[[i]]) else
3743c3740
<   { cat("\nParametric coefficients:\n")
---
>   { cat("\n", gettext("Parametric coefficients:", domain = "R-mgcv"), "\n", sep = "")
3748c3745
<   { cat("Approximate significance of smooth terms:\n")
---
>   { cat(gettext("Approximate significance of smooth terms:", domain = "R-mgcv"), "\n", sep = "")
3752,3754c3749,3751
<   if (!is.null(x$rank) && x$rank< x$np) cat("Rank: ",x$rank,"/",x$np,"\n",sep="") 
<   if (!is.null(x$r.sq)) cat("R-sq.(adj) = ",formatC(x$r.sq,digits=3,width=5),"  ")
<   if (length(x$dev.expl)>0) cat("Deviance explained = ",formatC(x$dev.expl*100,digits=3,width=4),"%",sep="")
---
>   if (!is.null(x$rank) && x$rank< x$np) cat(gettextf("Rank: %s/%s", x$rank, x$np, domain = "R-mgcv"), "\n", sep = "")
>   if (!is.null(x$r.sq)) cat(gettextf("R-sq.(adj) = %s", formatC(x$r.sq,digits=3,width=5), domain = "R-mgcv"), "  ", sep = "")
>   if (length(x$dev.expl)>0) cat(gettextf("Deviance explained = %s %%", formatC(x$dev.expl*100,digits=3,width=4), domain = "R-mgcv"), sep = "")
3759c3756
<   cat("  Scale est. = ",formatC(x$scale,digits=5,width=8,flag="-"),"  n = ",x$n,"\n",sep="")
---
>   cat(gettextf("  Scale est. = %s  n = %s", formatC(x$scale,digits=5,width=8,flag="-"), x$n, domain = "R-mgcv"), "\n", sep = "")
3772,3773c3769
<         warning("The following arguments to anova.glm(..) are invalid and dropped: ",
<             paste(deparse(dotargs[named]), collapse = ", "))
---
>         warning(gettext("The following arguments to anova.glm(..) are invalid and dropped: ", domain = "R-mgcv"), paste(deparse(dotargs[named]), collapse = ", "), domain = NA)
3792c3788
<       for (i in 1:length(dotargs)) {
---
>       for (i in seq_along(dotargs)) {
3803,3804c3799,3800
<     if (!is.null(test)) warning("test argument ignored")
<     if (!inherits(object,"gam")) stop("anova.gam called with non gam object")
---
>     if (!is.null(test)) warning("'test' argument ignored")
>     if (!inherits(object,"gam")) stop(gettextf("'%s' argument is not an object of class %s", "object", dQuote("gam")))
3815,3816c3811,3812
<   cat("Formula:\n") 
<   if (is.list(x$formula)) for (i in 1:length(x$formula)) print(x$formula[[i]]) else
---
>   cat(gettext("Formula:", domain = "R-mgcv"), "\n", sep = "")
>   if (is.list(x$formula)) for (i in seq_len(length(x$formula))) print(x$formula[[i]]) else
3819c3815
<   { cat("\nParametric Terms:\n")
---
>   { cat("\n", gettext("Parametric Terms:", domain = "R-mgcv"), "\n", sep = "")
3824c3820
<   { cat("Approximate significance of smooth terms:\n")
---
>   { cat(gettext("Approximate significance of smooth terms:", domain = "R-mgcv"), "\n", sep = "")
3838c3834
<   if (!inherits(x,"gam")) stop("not a gam object")
---
>   if (!inherits(x,"gam")) stop(gettextf("'%s' argument is not an object of class %s", "x", dQuote("gam")))
3843c3839
<   for (i in 1:length(x$smooth)) { ## work through smooths
---
>   for (i in seq_len(length(x$smooth))) { ## work through smooths
3847c3843
<       if (is.null(Snames)) Snames <- as.character(1:length(x$smooth[[i]]$S))
---
>       if (is.null(Snames)) Snames <- as.character(seq_len(length(x$smooth[[i]]$S)))
3849c3845
<       for (j in 1:length(x$smooth[[i]]$S)) {
---
>       for (j in seq_len(length(x$smooth[[i]]$S))) {
3875c3871
<   if (!inherits(x,"gam")) stop("argument is not a gam object")
---
>   if (!inherits(x,"gam")) stop(gettextf("'%s' argument is not an object of class %s", "x", dQuote("gam")))
3884c3880
<   if (!inherits(x,"gam")) stop("requires an object of class gam")
---
>   if (!inherits(x,"gam")) stop(gettextf("'%s' argument is not an object of class %s", "x", dQuote("gam")))
3898c3894
<     if (m>0) for (i in 1:m) { ## loop through all smooths
---
>     if (m>0) for (i in seq_len(m)) { ## loop through all smooths
3910,3911c3906,3907
<          warning("S.scale vector doesn't match S list - please report to maintainer")
<         for (j in 1:length(x$smooth[[i]]$S.scale)) {
---
>          warning("'S.scale' vector doesn't match S list - please report to maintainer")
>         for (j in seq_len(length(x$smooth[[i]]$S.scale))) {
3926c3922
<         for (j in 1:length(x$smooth[[ii]]$S.scale)) {
---
>         for (j in seq_len(length(x$smooth[[ii]]$S.scale))) {
3946c3942
<       ind <- 1:x$family$n.theta
---
>       ind <- seq_len(x$family$n.theta)
3978c3974
<     cat(paste("Standard deviations and",conf.lev,"confidence intervals:\n\n"))
---
>     cat(gettextf("Standard deviations and %s confidence intervals:", conf.lev, domain = "R-mgcv"), "\n\n", sep = "")
3980c3976
<     cat("\nRank: ");cat(rank);cat("/");cat(ncol(H));cat("\n")
---
>     cat("\n", gettextf("Rank: %s/%s", rank, ncol(H), domain = "R-mgcv"), "\n", sep = "")
3982c3978
<       cat("\nAll smooth components:\n")
---
>       cat("\n", gettext("All smooth components:", domain = "R-mgcv"), "\n", sep = "")
4057,4058c4053,4054
<     d<-um$d[1:rank]^0.5
<     return(t(t(um$u[,1:rank])*as.vector(d))) # note recycling rule used for efficiency
---
>     d<-um$d[seq_len(rank)]^0.5
>     return(t(t(um$u[,seq_len(rank)])*as.vector(d))) # note recycling rule used for efficiency
4070c4066
<     L <- L[,piv,drop=FALSE]; L <- t(L[1:rank,,drop=FALSE])
---
>     L <- L[,piv,drop=FALSE]; L <- t(L[seq_len(rank),,drop=FALSE])
4073c4069
<   stop("method not recognised.")
---
>   stop("method was not recognised")
4149c4145
<     for (i in 1:length(S)) {
---
>     for (i in seq_along(S)) {
4160c4156
<     for (i in 1:length(S)) {
---
>     for (i in seq_along(S)) {
4194c4190
<       for (i in 1:length(S)) {
---
>       for (i in seq_len(length(S))) {
4225c4221
<     for (i in 1:n.p) { # loop over penalties
---
>     for (i in seq_len(n.p)) { # loop over penalties
4239c4235
<       if (sizeS <= 0) stop(gettextf("S[[%d]] matrix is not +ve definite.", i)) 
---
>       if (sizeS <= 0) stop(gettextf("S[[%d]] matrix is not +ve definite", i))
4300,4302c4296,4298
<     if (!inherits(L,"matrix")) stop("L must be a matrix.")
<     if (nrow(L)<ncol(L)) stop("L must have at least as many rows as columns.")
<     if (nrow(L)!=n.p||ncol(L)!=length(sp)) stop("L has inconsistent dimensions.")
---
>     if (!inherits(L,"matrix")) stop("'L' argument must be a matrix")
>     if (nrow(L)<ncol(L)) stop("'L' argument must have at least as many rows as columns")
>     if (nrow(L)!=n.p||ncol(L)!=length(sp)) stop("'L' argument has inconsistent dimensions")
4309c4305
<   { for (i in 1:n.p) 
---
>   { for (i in seq_len(n.p)) 
4329c4325
<     if (n.p>0) for (i in 1:n.p) { 
---
>     if (n.p>0) for (i in seq_len(n.p)) { 
4346c4342
<     { if (dim(w)[1]!=dim(w)[2]||dim(w)[2]!=dim(X)[1]) stop("dimensions of supplied w wrong.")
---
>     { if (dim(w)[1]!=dim(w)[2]||dim(w)[2]!=dim(X)[1]) stop("dimensions of supplied 'w' argument is wrong")
4350c4346
<     { if (length(y)!=length(w)) stop("w different length from y!")
---
>     { if (length(y)!=length(w)) stop("'w' argument has different length from 'y' argument!")
4357c4353
<     if (n!=length(X)) stop("X lost dimensions in magic!!")
---
>     if (n!=length(X)) stop("'X' lost dimensions in magic!!")
4362c4358
<   if (n.p>0) for (i in 1:n.p) { 
---
>   if (n.p>0) for (i in seq_len(n.p)) { 
4390,4391c4386,4387
<   res$R <- matrix(um$X[1:q^2],q,q)
<   res$rV<-matrix(um$rV[1:(um$info[1]*q)],q,um$info[1])
---
>   res$R <- matrix(um$X[seq_len(q)^2],q,q)
>   res$rV<-matrix(um$rV[seq_len(um$info[1]*q)],q,um$info[1])
4403c4399
< } ## magic
---
> }
4411c4407
<   hello <- paste("This is mgcv ",version,". For overview type 'help(\"mgcv-package\")'.",sep="")
---
>   hello <- gettextf("This is mgcv %s. For overview type 'help(\"mgcv-package\")'", paste(version, collapse = ""), domain = "R-mgcv")
diff -rEZbwB '--exclude=*.[lo,d,pdf,mo,po,tgz,gz,save]*' '--exclude=MD5' '--exclude=Makefile*' '--exclude=all.R' '--exclude=Changes' R-recommended/mgcv/R/misc.r Recommended/mgcv/R/misc.r
11c11
<     if (ncol(mu)!=p||nrow(mu)!=n) stop("mu dimensions wrong")
---
>     if (ncol(mu)!=p||nrow(mu)!=n) stop("'mu' dimensions are wrong")
14c14
<     if (length(mu)!=p) stop("mu dimensions wrong")
---
>     if (length(mu)!=p) stop("'mu' dimensions are wrong")
27c27
<    i <- 1:n
---
>    i <- seq_len(n)
31c31
<    j <- 1:p
---
>    j <- seq_len(p)
33c33
<  if (length(i)>length(j)) i <- i[1:length(j)] else j <- j[1:length(i)]
---
>  if (length(i)>length(j)) i <- i[seq_len(length(j))] else j <- j[1:length(i)]
43c43
<    i <- 1:n
---
>    i <- seq_len(n)
47c47
<    j <- 1:p
---
>    j <- seq_len(p)
49c49
<  if (length(i)>length(j)) i <- i[1:length(j)] else j <- j[1:length(i)]
---
>  if (length(i)>length(j)) i <- i[seq_len(length(j))] else j <- j[seq_len(length(i))]
61c61
<     for (i in 1:n) {
---
>     for (i in seq_len(n)) {
65c65
<         A[i,1:length(b)] <- b
---
>         A[i,seq_len(length(b))] <- b
68c68
<     B <- A[1:k,]
---
>     B <- A[seq_len(k),]
72c72
<   if (oo$info>0) stop("not positive definite")
---
>   if (oo$info>0) stop("matrix is not positive definite")
76c76
<     for (i in 1:k) sdiag(A,i-1) <- B[i,1:(n-i+1)]
---
>     for (i in seq_len(k)) sdiag(A,i-1) <- B[i,seq_len(n-i+1)]
91c91
<   if (oo$info>0) stop("not positive definite")
---
>   if (oo$info>0) stop("matrix is not positive definite")
93c93
<   sd <- oo$sd*ld[1:(n-1)]
---
>   sd <- oo$sd*ld[seq_len(n-1)]
122,123c122,123
<     dH <- list();ind <- 1:(nb*nb)
<     for (i in 1:nsp) { 
---
>     dH <- list();ind <- seq_len(nb*nb)
>     for (i in seq_len(nsp)) { 
145c145
<   for (i in 1:nt) pt <- pt + prod(p[ts[i]:(ts[i]+dt[i]-1)]) - as.numeric(qc[i]>0) 
---
>   for (i in seq_len(nt)) pt <- pt + prod(p[ts[i]:(ts[i]+dt[i]-1)]) - as.numeric(qc[i]>0) 
159c159
<   for (i in 1:nt) pt <- pt + prod(p[ts[i]:(ts[i]+dt[i]-1)]) - as.numeric(qc[i]>0) 
---
>   for (i in seq_len(nt)) pt <- pt + prod(p[ts[i]:(ts[i]+dt[i]-1)]) - as.numeric(qc[i]>0) 
233c233
<     piv <- 1:ncol(X); piv[qrx$pivot] <- 1:ncol(X)
---
>     piv <- seq_len(ncol(X)); piv[qrx$pivot] <- seq_len(ncol(X))
235c235
<     d <- er$d*0;d[1:rr] <- 1/er$d[1:rr]
---
>     d <- er$d*0;d[seq_len(rr)] <- 1/er$d[seq_len(rr)]
239c239
<     Ri[1:rr,1:rr] <- backsolve(R[1:rr,1:rr],diag(rr))
---
>     Ri[seq_len(rr),seq_len(rr)] <- backsolve(R[seq_len(rr),seq_len(rr)],diag(rr))
368,369c368,369
<     if (is.matrix(a)) { if (nrow(a) != x$r) stop("a has wrong number of rows") }
<     else if (length(a) != x$r) stop("a has wrong number of rows")
---
>     if (is.matrix(a)) { if (nrow(a) != x$r) stop("'a' argument has wrong number of rows") }
>     else if (length(a) != x$r) stop("'a' argument has wrong number of rows")
371,372c371,372
<     if (is.matrix(a)) { if (nrow(a) != x$c) stop("a has wrong number of rows") }
<     else if (length(a) != x$c)  stop("a has wrong number of rows")
---
>     if (is.matrix(a)) { if (nrow(a) != x$c) stop("'a' argument has wrong number of rows") }
>     else if (length(a) != x$c)  stop("'a' argument has wrong number of rows")
377c377
<   if (tr) return(matrix(oo$a[1:(a.c*x$c)],x$c,a.c)) else
---
>   if (tr) return(matrix(oo$a[seq_len(a.c*x$c)],x$c,a.c)) else
diff -rEZbwB '--exclude=*.[lo,d,pdf,mo,po,tgz,gz,save]*' '--exclude=MD5' '--exclude=Makefile*' '--exclude=all.R' '--exclude=Changes' R-recommended/mgcv/R/mvam.r Recommended/mgcv/R/mvam.r
18,19c18,19
<   for (i in 1:length(lpi)) {
<     lpi[[i]] <- 1:length(lpi[[i]]) + k
---
>   for (i in seq_len(length(lpi))) {
>     lpi[[i]] <- seq_len(length(lpi[[i]])) + k
41c41
<       lpi[[length(lpi)+1]] <- 1:nt + max(ip)
---
>       lpi[[length(lpi)+1]] <- seq_len(nt) + max(ip)
50,51c50,51
<       for (i in 1:length(lpi)) { 
<         ii <- 1:length(lpi[[i]]) + k
---
>       for (i in seq_len(length(lpi))) { 
>         ii <- seq_len(length(lpi[[i]])) + k
60,61c60,61
<       for (i in 1:length(lpi)) { 
<         ii <- 1:length(lpi[[i]]) + k
---
>       for (i in seq_len(length(lpi))) { 
>         ii <- seq_len(length(lpi[[i]])) + k
68,69c68,69
<     for (i in 1:length(lpi)) {
<       ii <- 1:length(lpi[[i]]) + k
---
>     for (i in seq_len(length(lpi))) {
>       ii <- seq_len(length(lpi[[i]])) + k
79c79
<   if (d<2) stop("mvn requires 2 or more dimensional data")
---
>   if (d<2) stop(gettextf("'%s' function requires 2 or more dimensional data", "mvn()"))
81c81
<   for (i in 1:d) {
---
>   for (i in seq_len(d)) {
103c103
<       G$term.names <- c(G$term.names,paste("R",1:ntheta,sep="."))
---
>       G$term.names <- c(G$term.names,paste("R",seq_len(ntheta),sep="."))
112c112
<       for (k in 1:ydim) {
---
>       for (k in seq_len(ydim)) {
129c129
<       ind <- G$family$data$nbeta + 1:(ydim*(ydim+1)/2);
---
>       ind <- G$family$data$nbeta + seq_len(ydim*(ydim+1)/2);
131c131
<       k <- 1;for (i in 1:ydim) for (j in i:ydim) {
---
>       k <- 1;for (i in seq_len(ydim)) for (j in i:ydim) {
177c177
< 	for (i in 1:length(offset)) if (sum(offset[[i]]!=0)) stop("mvn does not yet handle offsets")
---
> 	for (i in seq_along(offset)) if (sum(offset[[i]]!=0)) stop("mvn does not yet handle offsets")
202c202
<       for (i in 1:(m-1)) lpstart[i] <- lpi[[i+1]][1]
---
>       for (i in seq_len(m-1)) lpstart[i] <- lpi[[i+1]][1]
226c226
<         for (i in 1:nsp) { 
---
>         for (i in seq_len(nsp)) { 
233,234c233,234
<         d1H <- list();ind <- 1:(nb*nb)
<         for (i in 1:nsp) { 
---
>         d1H <- list();ind <- seq_len(nb*nb)
>         for (i in seq_len(nsp)) { 
diff -rEZbwB '--exclude=*.[lo,d,pdf,mo,po,tgz,gz,save]*' '--exclude=MD5' '--exclude=Makefile*' '--exclude=all.R' '--exclude=Changes' R-recommended/mgcv/R/plots.r Recommended/mgcv/R/plots.r
26c26
<         stop("fam not a family object")
---
>         stop(gettextf("'%s' argument is not an object of class %s", "fam", dQuote("family")))
53c53
<         stop("fam not a family object")
---
>         stop(gettextf("'%s' argument is not an object of class %s", "fam", dQuote("family")))
90c90
<   } else stop("object is not a glm or gam")
---
>   } else stop("'object' argument is not an object of class \"glm\" or \"gam\"")
117c117
<       for (i in 1:rep) { 
---
>       for (i in seq_len(rep)) { 
126c126
<       Dq <- quantile(as.numeric(dm),(1:n - .5)/n) 
---
>       Dq <- quantile(as.numeric(dm),(seq_len(n) - .5)/n) 
141c141
<       for (i in 1:s.rep) { 
---
>       for (i in seq_len(s.rep)) { 
159c159
<   { qqplot(Dq,D,ylab=ylab,xlab="theoretical quantiles",ylim=range(c(lim,D)),
---
>   { qqplot(Dq,D,ylab=ylab,xlab=gettext("theoretical quantiles", domain = "R-mgcv"), ylim=range(c(lim,D)),
163c163
<       if (level>=1) for (i in 1:rep) lines(Dq,dm[,i],col=rep.col) else {
---
>       if (level>=1) for (i in seq_len(rep)) lines(Dq,dm[,i],col=rep.col) else {
188c188
<     ind <- sample(1:n,subsample)
---
>     ind <- sample(seq_len(n), subsample)
193c193
<   for (k in 1:m) { ## work through smooths
---
>   for (k in seq_len(m)) { ## work through smooths
204,205c204,205
<     if (ok && ncol(dat)>nc) dat <- dat[,1:nc,drop=FALSE] ## drop any by variables
<     for (j in 1:nc) if (is.factor(dat[[j]])) ok <- FALSE 
---
>     if (ok && ncol(dat)>nc) dat <- dat[, seq_len(nc), drop = FALSE] ## drop any by variables
>     for (j in seq_len(nc)) if (is.factor(dat[[j]])) ok <- FALSE 
212,213c212,213
<         for (i in 1:n.rep) {
<           e <- diff(rsd[sample(1:nr,nr)]) ## shuffle 
---
>         for (i in seq_len(n.rep)) {
>           e <- diff(rsd[sample(seq_len(nr), nr)]) ## shuffle 
224c224
<           for (i in 1:nc) {
---
>           for (i in seq_len(nc)) {
230c230
<           for (i in 1:nc) { ## rescale distances
---
>           for (i in seq_len(nc)) { ## rescale distances
240,241c240,241
<         for (i in 1:n.rep) {
<           rsdr <- rsd[sample(1:nr,nr)] ## shuffle
---
>         for (i in seq_len(n.rep)) {
>           rsdr <- rsd[sample(seq_len(nr), nr)] ## shuffle
275,277c275,277
<     plot(linpred, resid,main="Resids vs. linear pred.",
<          xlab="linear predictor",ylab="residuals",...)
<     hist(resid,xlab="Residuals",main="Histogram of residuals",...)
---
>     plot(linpred, resid,main=gettext("Resids vs. linear pred.", domain = "R-mgcv"),
>          xlab=gettext("linear predictor", domain = "R-mgcv"), ylab=gettext("Residuals", domain = "R-mgcv"),...)
>     hist(resid,xlab=gettext("Residuals", domain = "R-mgcv"), main=gettext("Histogram of residuals", domain = "R-mgcv"),...)
281c281
<          xlab="Fitted Values",ylab="Response",main="Response vs. Fitted Values",...)
---
>          xlab=gettext("Fitted Values", domain = "R-mgcv"), ylab=gettext("Response", domain = "R-mgcv"), main=gettext("Response vs. Fitted Values", domain = "R-mgcv"),...)
287c287
<     cat("\nMethod:",b$method,"  Optimizer:",b$optimizer)
---
>     cat("\n", gettextf("Method: %s  Optimizer: %s", paste(b$method, collapse = ""), paste(b$optimizer, collapse = ""), domain = "R-mgcv"))
291,294c291,293
<         cat("\n",boi$conv," after ",boi$iter," iteration",sep="")
<         if (boi$iter==1) cat(".") else cat("s.")
<         cat("\nGradient range [",min(boi$grad),",",max(boi$grad),"]",sep="")
<         cat("\n(score ",b$gcv.ubre," & scale ",b$sig2,").",sep="")
---
>         cat("\n", sprintf(ngettext(boi$iter, "%s after %d iteration.", "%s after %d iterations.", domain = "R-mgcv"), boi$conv, boi$iter), sep = "")
>         cat("\n", gettextf("Gradient range [%s, %s]", min(boi$grad), max(boi$grad), domain = "R-mgcv"), sep = "")
>         cat("\n", gettextf("(score %s & scale %s).", b$gcv.ubre, b$sig2, domain = "R-mgcv"), sep = "")
296,297c295,296
<         if (min(ev)>0) cat("\nHessian positive definite, ") else cat("\n")
<         cat("eigenvalue range [",min(ev),",",max(ev),"].\n",sep="")
---
>         if (min(ev)>0) cat("\n", gettext("Hessian positive definite, eigenvalue range [%s, %s].", domain = "R-mgcv"), "\n", sep = "")
> 	 else cat("\n", gettextf("eigenvalue range [%s, %s].", min(ev), max(ev), domain = "R-mgcv"), "\n", sep = "")
303c302
<         cat("\nModel required no smoothing parameter selection")
---
>         cat("\n", gettext("Model required no smoothing parameter selection", domain = "R-mgcv"), "\n", sep = "")
305,310c304,312
<         cat("\nSmoothing parameter selection converged after",b$mgcv.conv$iter,"iteration")       
<         if (b$mgcv.conv$iter>1) cat("s")
<          
<         if (!b$mgcv.conv$fully.converged)
<         cat(" by steepest\ndescent step failure.\n") else cat(".\n")
<         cat("The RMS",b$method,"score gradient at convergence was",b$mgcv.conv$rms.grad,".\n")
---
>      if (!b$mgcv.conv$fully.converged) {
>         cat("\n", sprintf(ngettext(b$mgcv.conv$iter, "Smoothing parameter selection converged after %d iteration by steepest descent step failure.",
> 				"Smoothing parameter selection converged after %d iterations by steepest descent step failure.",
> 				 domain = "R-mgcv"), b$mgcv.conv$iter), "\n", sep = "")
>      } else {
>         cat("\n", sprintf(ngettext(b$mgcv.conv$iter, "Smoothing parameter selection converged after %d iteration.",
> 				"Smoothing parameter selection converged after %d iterations.", domain = "R-mgcv"), b$mgcv.conv$iter), sep = "")       
>     }
>         cat(gettextf("The RMS %s score gradient at convergence was %s.", b$method, b$mgcv.conv$rms.grad, domain = "R-mgcv"),"\n", sep = "")
312,314c314,315
<         cat("The Hessian was positive definite.\n") else cat("The Hessian was not positive definite.\n")
<         #cat("The estimated model rank was ",b$mgcv.conv$rank,
<         #           " (maximum possible: ",b$mgcv.conv$full.rank,")\n",sep="")
---
>         cat(gettext("The Hessian was positive definite.", domain = "R-mgcv"), "\n", sep = "") else cat(gettext("The Hessian was not positive definite.", domain = "R-mgcv"), "\n", sep = "")
>         #cat(gettextf("The estimated model rank was %s (maximum possible: %s)", b$mgcv.conv$rank, b$mgcv.conv$full.rank, domain = "R-mgcv"), "\n", sep = "")
318c319
<       cat("Model rank = ",b$rank,"/",length(b$coefficients),"\n")
---
>       cat(gettextf("Model rank = %s/%s", b$rank, length(b$coefficients), domain = "R-mgcv"), "\n", sep = "")
325,326c326
<       cat("Basis dimension (k) checking results. Low p-value (k-index<1) may\n") 
<       cat("indicate that k is too low, especially if edf is close to k\'.\n\n")
---
>       cat(gettext("Basis dimension (k) checking results. Low p-value (k-index<1) may\nindicate that k is too low, especially if edf is close to k.", domain = "R-mgcv"), "\n\n", sep = "")
349,350c349,350
<       if (is.null(xlab)) xlabel<- "Gaussian quantiles" else xlabel <- xlab
<       if (is.null(ylab)) ylabel <- "effects" else ylabel <- ylab
---
>       if (is.null(xlab)) xlabel<- gettext("Gaussian quantiles", domain = "R-mgcv") else xlabel <- xlab
>       if (is.null(ylab)) ylabel <- gettext("effects", domain = "R-mgcv") else ylabel <- ylab
548c548
<   ind <- (1:nrow(x))[is.na(rowSums(x))] ## where are the splits?
---
>   ind <- seq_len(nrow(x))[is.na(rowSums(x))] ## where are the splits?
567c567
<   for (i in 1:length(pc)) {
---
>   for (i in seq_len(length(pc))) {
587c587
<      for (i in 1:length(pc)) { 
---
>      for (i in seq_len(length(pc))) { 
595c595
<       if (all.equal(sort(nz),sort(npc))!=TRUE) stop("names of z and pc must match")
---
>       if (all.equal(sort(nz),sort(npc))!=TRUE) stop("names of 'z' and 'pc' must match")
611c611
<     for (i in 1:length(pc)) pc[[i]][,2] <- zlim[1] + 
---
>     for (i in seq_len(length(pc))) pc[[i]][,2] <- zlim[1] + 
616c616
<     for (i in 1:length(pc)) {
---
>     for (i in seq_len(length(pc))) {
630c630
<     for (i in 1:n.col) {
---
>     for (i in seq_len(n.col)) {
684c684
<     ind <- 1:P$n
---
>     ind <- seq_len(P$n)
1043c1043
<     warn <- paste("scheme should be a single number, or a vector with",m,"elements")
---
>     warn <- gettextf("scheme should be a single number, or a vector with %d elements", m)
1082c1082
<   if (m>0) for (i in 1:m) { ## work through smooth terms
---
>   if (m>0) for (i in seq_len(m)) { ## work through smooth terms
1133c1133
<   if (m>0) for (i in 1:m) n.plots <- n.plots + as.numeric(pd[[i]]$plot.me) 
---
>   if (m>0) for (i in seq_len(m)) n.plots <- n.plots + as.numeric(pd[[i]]$plot.me) 
1174c1174
<     if (m>0) for (i in 1:m) if (pd[[i]]$plot.me&&pd[[i]]$scale) { ## loop through plot data 
---
>     if (m>0) for (i in seq_len(m)) if (pd[[i]]$plot.me&&pd[[i]]$scale) { ## loop through plot data 
1206c1206
<   if (m>0) for (i in 1:m) if (pd[[i]]$plot.me&&(is.null(select)||i==select)) {
---
>   if (m>0) for (i in seq_len(m)) if (pd[[i]]$plot.me&&(is.null(select)||i==select)) {
1280c1280
<     if (fn>gn) mf<-factor(levels(fac))[1:gn]
---
>     if (fn>gn) mf<-factor(levels(fac))[seq_len(gn)]
1284c1284
<       mf[1:(ln*fn)]<-rep(levels(fac),rep(ln,fn))
---
>       mf[seq_len(ln*fn)]<-rep(levels(fac),rep(ln,fn))
1305c1305
<     for (i in 1:length(v.names)) {
---
>     for (i in seq_len(length(v.names))) {
1322,1323c1322
< 
<     for (i in 1:2) 
---
>     for (i in seq_len(2)) 
1329c1328
<   for (i in 1:2) if (is.factor(x$var.summary[[view[i]]])) {
---
>   for (i in seq_len(2)) if (is.factor(x$var.summary[[view[i]]])) {
1349c1348
<   for (i in 1:length(x$var.summary)) { 
---
>   for (i in seq_len(length(x$var.summary))) { 
1362,1363c1361,1362
<   if (type=="link") zlab<-paste("linear predictor") ## ignore codetools
<   else if (type=="response") zlab<-type
---
>   if (type=="link") zlab<-gettext("linear predictor", domain = "R-mgcv") ## ignore codetools
>   else if (type=="response") zlab<-gettext("response", domain = "R-mgcv")
diff -rEZbwB '--exclude=*.[lo,d,pdf,mo,po,tgz,gz,save]*' '--exclude=MD5' '--exclude=Makefile*' '--exclude=all.R' '--exclude=Changes' R-recommended/mgcv/R/smooth.r Recommended/mgcv/R/smooth.r
43c43
<     E <- rep(1,ncol(X));E[1:rank] <- sqrt(er$value[1:rank])
---
>     E <- rep(1,ncol(X));E[seq_len(rank)] <- sqrt(er$value[seq_len(rank)])
48c48
<     av.norm <- mean(col.norm[1:rank])
---
>     av.norm <- mean(col.norm[seq_len(rank)])
73c73
<       ind <- 1:rank
---
>       ind <- seq_len(rank)
96c96
<   D <- er$values[1:rank] 
---
>   D <- er$values[seq_len(rank)]
111c111
<     ind <- 1:rank
---
>     ind <- seq_len(rank)
143c143
<   if (n<4) stop("At least three knots required in call to mono.con.")
---
>   if (n<4) stop("At least three knots required in call passed to 'mono.con()'")
146c146
<   if (lo*hi==1&&lower>=upper) stop("lower bound >= upper bound in call to mono.con()")
---
>   if (lo*hi==1&&lower>=upper) stop("lower bound >= upper bound in call passed to 'mono.con()'")
158c158
<   if (is.null(x)) stop("x is null")
---
>   if (is.null(x)) stop("'x' argument is null")
167c167
<     for (i in 1:length(x)) {
---
>     for (i in seq_along(x)) {
189c189
<     ## txt <- paste("paste0(",paste("x[,",1:ncol(x),"]",sep="",collapse=","),")",sep="")
---
>     ## txt <- paste("paste0(",paste("x[,",seq_len(ncol(x)),"]",sep="",collapse=","),")",sep="")
193c193
<     txt <- paste("paste0(",paste("x[,",1:ncol(x),"]",sep="",collapse=",\"*\","),")",sep="")
---
>     txt <- paste("paste0(",paste("x[,",seq_len(ncol(x)),"]",sep="",collapse=",\"*\","),")",sep="")
217c217
<     for (i in 1:ncol(xo)) {
---
>     for (i in seq_len(ncol(xo))) {
220,221c220,221
<         x[,i] <- if (is.ordered(xo[,i])) ordered(x[,i],levels=1:length(xoi),labels=xoi) else 
<                  factor(x[,i],levels=1:length(xoi),labels=xoi)
---
>         x[,i] <- if (is.ordered(xo[,i])) ordered(x[,i],levels=seq_along(xoi),labels=xoi) else 
>                  factor(x[,i],levels=seq_along(xoi),labels=xoi)
258c258
<     txt <- paste("paste0(",paste("x[,",1:ncol(x),"]",sep="",collapse=",\":\","),")",sep="")
---
>     txt <- paste("paste0(",paste("x[,",seq_len(ncol(x)),"]",sep="",collapse=",\":\","),")",sep="")
282c282
<     for (i in 1:ncol(xo)) if (is.factor(xo[,i])) { ## may need to reset factors to factors
---
>     for (i in seq_len(ncol(xo))) if (is.factor(xo[,i])) { ## may need to reset factors to factors
284,285c284,285
<       x[,i] <- if (is.ordered(xo[,i])) ordered(x[,i],levels=1:length(xoi),labels=xoi) else 
<                factor(x[,i],levels=1:length(xoi),labels=xoi)
---
>       x[,i] <- if (is.ordered(xo[,i])) ordered(x[,i],levels=seq_len(length(xoi)),labels=xoi) else 
>                factor(x[,i],levels=seq_along(xoi),labels=xoi)
301c301
<   if (min(x)<k1||max(x)>knots[nk]) stop("x out of range")
---
>   if (min(x)<k1||max(x)>knots[nk]) stop("'x' out of range")
381c381
<   for (i in 1:dim) term[i] <- attr(terms(reformulate(term[i])),"term.labels")
---
>   for (i in seq_len(dim)) term[i] <- attr(terms(reformulate(term[i])),"term.labels")
394c394
<     { warning("something wrong with argument d.")
---
>     { warning("something wrong with argument 'd'")
413c413
<   { warning("dimension of fx is wrong") 
---
>   { warning("dimension of 'fx' is wrong") 
419c419
<   if (is.null(xt)||length(xt)==1) for (i in 1:n.bases) xtra[[i]] <- xt else
---
>   if (is.null(xt)||length(xt)==1) for (i in seq_len(n.bases)) xtra[[i]] <- xt else
421c421
<   stop("xt argument is faulty.")
---
>   stop(gettextf("'%s' argument is faulty", "xt"))
425c425
<   if (length(bs)!=n.bases) {warning("bs wrong length and ignored.");bs<-rep("cr",n.bases)}
---
>   if (length(bs)!=n.bases) { warning(gettextf("'%s' argument is of the wrong length and ignored", "bs")); bs <- rep("cr",n.bases) }
431c431
<     warning("m wrong length and ignored.");
---
>     warning(gettextf("'%s' argument is of the wrong length and ignored", "m"));
441c441
<   for (i in 1:n.bases)
---
>   for (i in seq_len(n.bases))
460c460
<       warning("only first element of `id' used")
---
>       warning("only first element of 'id' used")
495c495
<   for (i in 1:dim) term[i] <- attr(terms(reformulate(term[i])),"term.labels")
---
>   for (i in seq_len(dim)) term[i] <- attr(terms(reformulate(term[i])),"term.labels")
508c508
<     { warning("something wrong with argument d.")
---
>     { warning("something wrong with argument 'd'")
527c527
<   if (is.null(xt)||length(xt)==1) for (i in 1:n.bases) xtra[[i]] <- xt else
---
>   if (is.null(xt)||length(xt)==1) for (i in seq_len(n.bases)) xtra[[i]] <- xt else
529c529
<   stop("xt argument is faulty.")
---
>   stop(gettextf("'%s' argument is faulty", "xt"))
533c533
<   if (length(bs)!=n.bases) {warning("bs wrong length and ignored.");bs<-rep("cr",n.bases)}
---
>   if (length(bs)!=n.bases) { warning(gettextf("'%s' argument is of the wrong length and ignored", "bs")); bs<-rep("cr",n.bases) }
539c539
<     warning("m wrong length and ignored.");
---
>     warning(gettextf("'%s' argument is of the wrong length and ignored", "m"));
549c549
<   for (i in 1:n.bases)
---
>   for (i in seq_len(n.bases))
563c563
<       warning("ord is wrong. reset to NULL.")
---
>       warning("ord is wrong. reset to NULL")
576c576
<       warning("only first element of `id' used")
---
>       warning("only first element of 'id' used")
609c609
<   if (by.var==".") stop("by=. not allowed")
---
>   if (by.var==".") stop("'by=.' is not allowed")
611c611
<   if (term[1]==".") stop("s(.) not yet supported.")
---
>   if (term[1]==".") stop("'s(.)' function is not yet supported")
615c615
<     if (term[i]==".") stop("s(.) not yet supported.")
---
>     if (term[i]==".") stop("'s(.)' function is not yet supported")
617c617
<   for (i in 1:d) term[i] <- attr(terms(reformulate(term[i])),"term.labels")
---
>   for (i in seq_len(d)) term[i] <- attr(terms(reformulate(term[i])),"term.labels")
621c621
<   if (all.equal(k.new,k)!=TRUE) {warning("argument k of s() should be integer and has been rounded")}
---
>   if (all.equal(k.new,k)!=TRUE) {warning("argument 'k' of 's()' function should be integer and has been rounded")}
632c632
<       warning("only first element of `id' used")
---
>       warning("only first element of 'id' used")
662c662
<     for (j in 1:ncol(X[[i]]))
---
>     for (j in seq_len(ncol(X[[i]])))
695c695
<   for (i in 1:m) { 
---
>   for (i in seq_len(m)) { 
701c701
<   for (i in 1:m) {
---
>   for (i in seq_len(m)) {
728c728
<   for (i in 1:m) { 
---
>   for (i in seq_len(m)) { 
732c732
<     for (j in 1:length(term)) { 
---
>     for (j in seq_len(length(term))) { 
746c746
<     stop("Sorry, tensor products of smooths with multiple penalties are not supported.")
---
>     stop("Sorry, tensor products of smooths with multiple penalties are not supported")
761,762c761,762
<     g <- list(); for (i in 1:length(km)) g[[i]] <- object$margin[[km[i]]]$g.index
<     for (i in 1:length(object$margin)) {
---
>     g <- list(); for (i in seq_along(km)) g[[i]] <- object$margin[[km[i]]]$g.index
>     for (i in seq_along(object$margin)) {
769c769
<   if (object$np) for (i in 1:m) { # reparameterize 
---
>   if (object$np) for (i in seq_len(m)) { # reparameterize
798c798
<   for (i in 1:m)  Sm[[i]] <- Sm[[i]]/eigen(Sm[[i]],symmetric=TRUE,only.values=TRUE)$values[1] 
---
>   for (i in seq_len(m))  Sm[[i]] <- Sm[[i]]/eigen(Sm[[i]],symmetric=TRUE,only.values=TRUE)$values[1] 
826c826
<     #for (i in 1:length(S)) {
---
>     #for (i in seq_along(S)) {
831c831
<     for (i in 1:m) { 
---
>     for (i in seq_len(m)) { 
838c838
<     for (i in 1:m) { 
---
>     for (i in seq_len(m)) { 
862c862
<   for (i in 1:m) { 
---
>   for (i in seq_len(m)) { 
865c865
<     for (j in 1:length(term)) dat[[term[j]]] <- data[[term[j]]]
---
>     for (j in seq_len(length(term))) dat[[term[j]]] <- data[[term[j]]]
871c871
<   for (i in 1:mxp) if (!is.null(object$XP[[i]])) X[[i]] <- X[[i]]%*%object$XP[[i]]
---
>   for (i in seq_len(mxp)) if (!is.null(object$XP[[i]])) X[[i]] <- X[[i]]%*%object$XP[[i]]
893c893
<   Zi <- Xm[[1]][,1:rank[1],drop=FALSE] ## range space basis for first margin
---
>   Zi <- Xm[[1]][,seq_len(rank)[1],drop=FALSE] ## range space basis for first margin
904c904
<       colnames(Xi) <- as.character(1:ncol(Xi)) 
---
>       colnames(Xi) <- as.character(seq_len(ncol(Xi))) 
915c915
<     Zi <- Xm[[i]][,1:rank[i],drop=FALSE]   ## margin i range space
---
>     Zi <- Xm[[i]][,seq_len(rank)[i],drop=FALSE]   ## margin i range space
919c919
<       if (full) colnames(Xi)  <- as.character(1:ncol(Xi))
---
>       if (full) colnames(Xi)  <- as.character(seq_len(ncol(Xi)))
926c926
<     for (ii in 1:length(X1)) { ## form products with Zi
---
>     for (ii in seq_len(length(X1))) { ## form products with Zi
929c929
<         for (j in 1:ncol(X1[[ii]])) A <- cbind(A,X1[[ii]][,j]*Zi)
---
>         for (j in seq_len(ncol(X1[[ii]]))) A <- cbind(A,X1[[ii]][,j]*Zi)
937c937
<         for (j in 1:ncol(X1[[ii]])) {
---
>         for (j in seq_len(ncol(X1[[ii]]))) {
948c948
<       for (ii in 1:length(X1)) { ## form products with Xi
---
>       for (ii in seq_len(length(X1))) { ## form products with Xi
955c955
<           for (j in 1:ncol(X1[[ii]])) { 
---
>           for (j in seq_len(ncol(X1[[ii]]))) { 
967c967
<            for (j in 1:ncol(Xi)) {
---
>            for (j in seq_len(ncol(Xi))) {
1011c1011
<   for (i in 1:m) { ## create marginal model matrices and penalties...
---
>   for (i in seq_len(m)) { ## create marginal model matrices and penalties...
1015c1015
<     for (j in 1:length(term)) { 
---
>     for (j in seq_len(length(term))) { 
1027c1027
<     stop("Sorry, tensor products of smooths with multiple penalties are not supported.")
---
>     stop("Sorry, tensor products of smooths with multiple penalties are not supported")
1038c1038
<     dS <- rep(0,ncol(Xm[[i]]));dS[1:r[i]] <- 1;
---
>     dS <- rep(0,ncol(Xm[[i]]));dS[seq_len(r[i])] <- 1;
1057c1057
<   if (nsc>0) for (j in 1:nsc) {
---
>   if (nsc>0) for (j in seq_len(nsc)) {
1079c1079
<   nup <- sum(sub.cols[1:nsc]) ## range space rank
---
>   nup <- sum(sub.cols[seq_len(nsc)]) ## range space rank
1085,1086c1085,1086
<     ##  X.shift <- colMeans(X[,1:nup])
<     ##  X[,1:nup] <- sweep(X[,1:nup],2,X.shift) ## make penalized columns orthog to constant col.
---
>     ##  X.shift <- colMeans(X[,seq_len(nup)])
>     ##  X[,seq_len(nup)] <- sweep(X[,seq_len(nup)],2,X.shift) ## make penalized columns orthog to constant col.
1101c1101
<   object$rank <- sub.cols[1:nsc] ## ranks of individual penalties
---
>   object$rank <- sub.cols[seq_len(nsc)] ## ranks of individual penalties
1113c1113
<   for (i in 1:m) { 
---
>   for (i in seq_len(m)) { 
1116c1116
<     for (j in 1:length(term)) dat[[term[j]]] <- data[[term[j]]]
---
>     for (j in seq_len(length(term))) dat[[term[j]]] <- data[[term[j]]]
1127c1127
<   ind <- 1:ncol(object$S[[1]])                   ## index of penalty columns 
---
>   ind <- seq_len(ncol(object$S[[1]]))                   ## index of penalty columns 
1132c1132
<   for (i in 1:length(object$S)) { ## work through penalties
---
>   for (i in seq_len(length(object$S))) { ## work through penalties
1172c1172
<   for (i in 1:m) if (inherits(sm[[i]],"t2.smooth")&&length(sm[[i]]$S)>1) { not.needed <- FALSE;break}
---
>   for (i in seq_len(m)) if (inherits(sm[[i]],"t2.smooth")&&length(sm[[i]]$S)>1) { not.needed <- FALSE;break}
1176c1176
<   for (i in 1:m) {
---
>   for (i in seq_len(m)) {
1180c1180
<       for (j in 1:length(smi)) {
---
>       for (j in seq_len(length(smi))) {
1198c1198
< { if (sum(d<0)) stop("d can not be negative in call to null.space.dimension().")
---
> { if (sum(d<0)) stop("'d' can not be negative in call passed to 'null.space.dimension()'")
1230c1230
<   for (i in 1:object$dim) 
---
>   for (i in seq_len(object$dim)) 
1242c1242
<     for (i in 1:object$dim) 
---
>     for (i in seq_len(object$dim)) 
1253c1253
<   warning("more knots than data in a tp term: knots ignored.")}
---
>   warning("more knots than data in a tp term: knots ignored")}
1268c1268
<       ind <- sample(1:nu,nk,replace=FALSE)  ## by sampling these rows from xu
---
>       ind <- sample(seq_len(nu),nk,replace=FALSE)  ## by sampling these rows from xu
1321c1321
<   object$UZ<-matrix(oo$UZ[1:UZ.len],oo$n.Xu+M,k)         # truncated basis matrix
---
>   object$UZ<-matrix(oo$UZ[seq_len(UZ.len)],oo$n.Xu+M,k)         # truncated basis matrix
1323c1323
<   object$Xu<-matrix(oo$Xu[1:Xu.len],oo$n.Xu,object$dim)  # unique covariate combinations
---
>   object$Xu<-matrix(oo$Xu[seq_len(Xu.len)],oo$n.Xu,object$dim)  # unique covariate combinations
1331c1331
<     ind <- 1:(k-M)
---
>     ind <- seq_len(k-M)
1364c1364
<   for (i in 1:object$dim) 
---
>   for (i in seq_len(object$dim)) 
1377c1377
<   ind <- 1:object$bs.dim
---
>   ind <- seq_len(object$bs.dim)
1436,1437c1436
<   { msg <- paste(object$term," has insufficient unique values to support ",
<                  nk," knots: reduce k.",sep="")
---
>   { msg <- gettextf("%s has insufficient unique values to support %d knots: reduce k", object$term, nk)
1538,1539c1537,1538
<   lbi<-floor(delta*1:(nk-2))+1 # lower interval bound index
<   frac<-delta*1:(nk-2)+1-lbi # left over proportion of interval  
---
>   lbi<-floor(delta*seq_len(nk-2))+1 # lower interval bound index
>   frac<-delta*seq_len(nk-2)+1-lbi # left over proportion of interval  
1555c1554
<     h<-x[2:n]-x[1:(n-1)]
---
>     h<-x[2:n]-x[seq_len(n-1)]
1631c1630
<     h<-knots[2:n]-knots[1:(n-1)]
---
>     h<-knots[2:n]-knots[seq_len(n-1)]
1683c1682
<     stop(paste("there should be ",nk," supplied knots"))
---
>     stop(gettextf("there should be %d knots supplied", nk))
1686c1685
<   if (length(k)!=nk) stop(paste("there should be",nk,"knots supplied"))
---
>   if (length(k)!=nk) stop(gettextf("there should be %d knots supplied", nk))
1701,1703c1700,1702
<     for (i in 1:p.ord) De <- diff(De)
<     D <- De[,-(1:p.ord)]
<     D[,(np-p.ord+1):np] <-  D[,(np-p.ord+1):np] + De[,1:p.ord]
---
>     for (i in seq_len(p.ord)) De <- diff(De)
>     D <- De[,-seq_len(p.ord)]
>     D[,(np-p.ord+1):np] <-  D[,(np-p.ord+1):np] + De[,seq_len(p.ord)]
1753c1752
<     stop(paste("there should be ",nk+2*m[1]+2," supplied knots"))
---
>     stop(gettextf("there should be %d knots supplied",nk+2*m[1]+2))
1765c1764
<     B <- matrix(as.numeric(rep(1:p,p)>=rep(1:p,each=p)),p,p) ## coef summation matrix
---
>     B <- matrix(as.numeric(rep(seq_len(p),p)>=rep(seq_len(p),each=p)),p,p) ## coef summation matrix
1876c1875
<     stop(paste("there should be ",nk+2*m[1]," supplied knots"))
---
>     stop(gettextf("there should be %d knots supplied", nk+2*m[1]))
1890c1889
<   k0 <- k[m[1]+1:nk] ## the interior knots
---
>   k0 <- k[m[1]+seq_len(nk)] ## the interior knots
1896c1895
<   if (pord==0) k1 <- (k0[2:nk]+k0[1:(nk-1)])/2 else {
---
>   if (pord==0) k1 <- (k0[2:nk]+k0[seq_len(nk-1)])/2 else {
1907c1906
<     i1 <- rep(1:(pord+1),pord+1)+rep(1:(pord+1),each=pord+1) ## i + j
---
>     i1 <- rep(seq_len(pord+1),pord+1)+rep(seq_len(pord+1),each=pord+1) ## i + j
1913c1912
<     i1 <- c(rep(1:pord,length(h)) + rep(0:(length(h)-1) * (pord+1),each=pord),length(ld0))
---
>     i1 <- c(rep(seq_len(pord),length(h)) + rep(0:(length(h)-1) * (pord+1),each=pord),length(ld0))
1915,1916c1914,1915
<     i0 <- 1:(length(h)-1)*pord+1
<     i2 <- 1:(length(h)-1)*(pord+1)
---
>     i0 <- seq_len(length(h)-1)*pord+1
>     i2 <- seq_len(length(h)-1)*(pord+1)
1920c1919
<     for (k in 1:pord) { ## create the other diagonals...
---
>     for (k in seq_len(pord)) { ## create the other diagonals...
1922c1921
<       ind <- 1:(length(ld)-k)
---
>       ind <- seq_len(length(ld)-k)
1929,1930c1928,1929
<     for (k in 1:pord) {
<       ind <- 1:(nrow(D)-k)
---
>     for (k in seq_len(pord)) {
>       ind <- seq_len(nrow(D)-k)
1976c1975
<   for (i in 1:length(object$term)) if (is.factor(data[[object$term[i]]])) { 
---
>   for (i in seq_len(length(object$term))) if (is.factor(data[[object$term[i]]])) { 
2000c1999
<   for (i in 1:object$dim) if (object$term[i]!=fterm) {
---
>   for (i in seq_len(object$dim)) if (object$term[i]!=fterm) {
2026c2025
<   for (i in 1:null.d) { ## create null space element penalties
---
>   for (i in seq_len(null.d)) { ## create null space element penalties
2039c2038
<   #for (i in 1:null.d) { ## null space penalties
---
>   #for (i in seq_len(null.d)) { ## null space penalties
2061c2060
<     for (i in 1:null.d) { ## null space penalties
---
>     for (i in seq_len(null.d)) { ## null space penalties
2115c2114
<   for (i in 1:length(object$flev)) {
---
>   for (i in seq_len(length(object$flev))) {
2127c2126
< ## sets M[i[k],j[k]] <- m[k] for all k in 1:length(m) without
---
> ## sets M[i[k],j[k]] <- m[k] for all k in seq_len(length(m)) without
2146,2148c2145,2147
<   Ind <- matrix(1:(ni*nj),ni,nj) ## the indexing matrix
<   rmt <- rep(1:ni,nj) ## the row index
<   cmt <- rep(1:nj,rep(ni,nj)) ## the column index
---
>   Ind <- matrix(seq_len(ni*nj),ni,nj) ## the indexing matrix
>   rmt <- rep(seq_len(ni),nj) ## the row index
>   cmt <- rep(seq_len(nj),rep(ni,nj)) ## the column index
2150c2149
<   ci <- Ind[2:(ni-1),1:nj] ## column index
---
>   ci <- Ind[2:(ni-1),seq_len(nj)] ## column index
2156,2160c2155,2159
<   Drr <- mfil(Drr,1:n.ci,ci,-2) ## central coefficient
<   ci <- Ind[1:(ni-2),1:nj] 
<   Drr <- mfil(Drr,1:n.ci,ci,1) ## back coefficient
<   ci <- Ind[3:ni,1:nj]
<   Drr <- mfil(Drr,1:n.ci,ci,1) ## forward coefficient
---
>   Drr <- mfil(Drr,seq_len(n.ci),ci,-2) ## central coefficient
>   ci <- Ind[seq_len(ni-2),seq_len(nj)] 
>   Drr <- mfil(Drr,seq_len(n.ci),ci,1) ## back coefficient
>   ci <- Ind[3:ni,seq_len(nj)]
>   Drr <- mfil(Drr,seq_len(n.ci),ci,1) ## forward coefficient
2163c2162
<   ci <- Ind[1:ni,2:(nj-1)] ## column index
---
>   ci <- Ind[seq_len(ni),2:(nj-1)] ## column index
2169,2173c2168,2172
<   Dcc <- mfil(Dcc,1:n.ci,ci,-2) ## central coefficient
<   ci <- Ind[1:ni,1:(nj-2)]
<   Dcc <- mfil(Dcc,1:n.ci,ci,1) ## back coefficient
<   ci <- Ind[1:ni,3:nj]
<   Dcc <- mfil(Dcc,1:n.ci,ci,1) ## forward coefficient
---
>   Dcc <- mfil(Dcc,seq_len(n.ci),ci,-2) ## central coefficient
>   ci <- Ind[seq_len(ni),seq_len(nj-2)]
>   Dcc <- mfil(Dcc,seq_len(n.ci),ci,1) ## back coefficient
>   ci <- Ind[seq_len(ni),3:nj]
>   Dcc <- mfil(Dcc,seq_len(n.ci),ci,1) ## forward coefficient
2182,2183c2181,2182
<   ci <- Ind[1:(ni-2),1:(nj-2)] 
<   Dcr <- mfil(Dcr,1:n.ci,ci,sqrt(0.125)) ## -- coefficient
---
>   ci <- Ind[seq_len(ni-2),seq_len(nj-2)] 
>   Dcr <- mfil(Dcr,seq_len(n.ci),ci,sqrt(0.125)) ## -- coefficient
2185,2189c2184,2188
<   Dcr <- mfil(Dcr,1:n.ci,ci,sqrt(0.125)) ## ++ coefficient
<   ci <- Ind[1:(ni-2),3:nj] 
<   Dcr <- mfil(Dcr,1:n.ci,ci,-sqrt(0.125)) ## -+ coefficient
<   ci <- Ind[3:ni,1:(nj-2)] 
<   Dcr <- mfil(Dcr,1:n.ci,ci,-sqrt(0.125)) ## +- coefficient
---
>   Dcr <- mfil(Dcr,seq_len(n.ci),ci,sqrt(0.125)) ## ++ coefficient
>   ci <- Ind[seq_len(ni-2),3:nj] 
>   Dcr <- mfil(Dcr,seq_len(n.ci),ci,-sqrt(0.125)) ## -+ coefficient
>   ci <- Ind[3:ni,seq_len(nj-2)] 
>   Dcr <- mfil(Dcr,seq_len(n.ci),ci,-sqrt(0.125)) ## +- coefficient
2207c2206
<   if (object$dim> 2 )  stop("the adaptive smooth class is limited to 1 or 2 covariates.")
---
>   if (object$dim> 2 )  stop("the adaptive smooth class is limited to 1 or 2 covariates")
2228c2227
<       x <- 1:(nk-2)/nk;m=2
---
>       x <- seq_len(nk-2)/nk;m=2
2240c2239
<      # for (i in 1:k) D[[i]] <- as.numeric(V[,i])*Db
---
>      # for (i in seq_len(k)) D[[i]] <- as.numeric(V[,i])*Db
2243c2242
<       for (i in 1:k) {
---
>       for (i in seq_len(k)) {
2259c2258
<       for (i in 1:2) {
---
>       for (i in seq_len(2)) {
2305c2304
<         for (i in 1:kp.tot) {
---
>         for (i in seq_len(kp.tot)) {
2338c2337
<   if (!is.null(object$id)) stop("random effects don't work with ids.")
---
>   if (!is.null(object$id)) stop("random effects don't work with ids")
2348c2347
<     for (i in 1:object$dim) {
---
>     for (i in seq_len(object$dim)) {
2358c2357
<       ind <- 1:ns;ind[maxi] <- ns ;ind[ns] <- maxi
---
>       ind <- seq_len(ns);ind[maxi] <- ns ;ind[ns] <- maxi
2361c2360
<       for (i in 1:ns) object$term <- c(object$term,object$margin[[i]]$term)
---
>       for (i in seq_len(ns)) object$term <- c(object$term,object$margin[[i]]$term)
2374,2375c2373,2374
<     for (i in 1:length(object$S)) { 
<       if (ncol(object$S[[i]])!=object$bs.dim||nrow(object$S[[i]])!=object$bs.dim) stop("supplied S matrices are wrong diminsion")
---
>     for (i in seq_len(length(object$S))) { 
>       if (ncol(object$S[[i]])!=object$bs.dim||nrow(object$S[[i]])!=object$bs.dim) stop("supplied S matrices are wrong dimension")
2431c2430
<   for (i in 1:n.poly) {
---
>   for (i in seq_len(n.poly)) {
2446c2445
<   for (i in 1:length(pc)) nb[[i]] <- rep(0,0)
---
>   for (i in seq_len(length(pc))) nb[[i]] <- rep(0,0)
2448c2447
<   for (k in 1:n.poly) { ## work through poly list looking for neighbours
---
>   for (k in seq_len(n.poly)) { ## work through poly list looking for neighbours
2454c2453
<     ind <- (1:n.poly)[ol] ## index of potential neighbours of poly k
---
>     ind <- seq_len(n.poly)[ol] ## index of potential neighbours of poly k
2457c2456
<     if (length(ind)>0) for (j in 1:length(ind)) {
---
>     if (length(ind)>0) for (j in seq_len(length(ind))) {
2466c2465
<   for (i in 1:length(pc)) nb[[i]] <- unique(nb[[i]])
---
>   for (i in seq_len(length(pc))) nb[[i]] <- unique(nb[[i]])
2523,2524c2522,2523
<       for (i in 1:length(d.name)) {
<         ind <- (1:length(a.name))[a.name==d.name[i]] ## index of duplicates 
---
>       for (i in seq_along(d.name)) {
>         ind <- seq_along(a.name)[a.name==d.name[i]] ## index of duplicates 
2529c2528
<       ind <- (1:length(a.name))[duplicated(a.name)]
---
>       ind <- seq_along(a.name)[duplicated(a.name)]
2550c2549
<     for (i in 1:np) {
---
>     for (i in seq_len(np)) {
2554c2553
<       if (lind>0) for (j in 1:lind) S[a.name[i],a.name[ind[j]]] <- -1
---
>       if (lind>0) for (j in seq_len(lind)) S[a.name[i],a.name[ind[j]]] <- -1
2583c2582
<       for (i in 1:length(mi)) object$X[i,mi[i]] <- 1
---
>       for (i in seq_len(length(mi))) object$X[i,mi[i]] <- 1
2589c2588
<     object$X <- if (length(mi)) rp$X[-(1:length(mi)),ind] else  rp$X[,ind] ## model matrix
---
>     object$X <- if (length(mi)) rp$X[-seq_len(length(mi)),ind] else  rp$X[,ind] ## model matrix
2736c2735
<   for (i in 1:2) {
---
>   for (i in seq_len(2)) {
2746c2745
<     for (i in 1:2) 
---
>     for (i in seq_len(2)) 
2758c2757
<     warning("more knots than data in an sos term: knots ignored.")
---
>     warning("more knots than data in an sos term: knots ignored")
2775c2774
<         ind <- sample(1:nu,nk,replace=FALSE)  ## by sampling these rows from xu
---
>         ind <- sample(seq_len(nu),nk,replace=FALSE)  ## by sampling these rows from xu
2794c2793
<   R <- makeR(la=knt[1:nk],lo=knt[-(1:nk)],lak=knt[1:nk],lok=knt[-(1:nk)],m=object$p.order)
---
>   R <- makeR(la=knt[seq_len(nk)],lo=knt[-seq_len(nk)],lak=knt[seq_len(nk)],lok=knt[-seq_len(nk)],m=object$p.order)
2796c2795
<   ind <- 1:ncol(T)
---
>   ind <- seq_len(ncol(T))
2849c2848
<   lak <- object$knt[1:nk];lok <- object$knt[-(1:nk)] ## knots
---
>   lak <- object$knt[seq_len(nk)];lok <- object$knt[-seq_len(nk)] ## knots
2853,2854c2852,2853
<     for (i in 1:n.chunk) { ## build predict matrix in chunks
<       ind <- 1:nk + (i-1)*nk
---
>     for (i in seq_len(n.chunk)) { ## build predict matrix in chunks
>       ind <- seq_len(nk) + (i-1)*nk
2902c2901
<   for (i in 1:M) {
---
>   for (i in seq_len(M)) {
2904c2903
<     for (j in 1:n) y <- y * x[,j]^p[i,j]
---
>     for (j in seq_len(n)) y <- y * x[,j]^p[i,j]
2912c2911
<   ind <- expand.grid(x=1:nrow(x),xk=1:nrow(xk))
---
>   ind <- expand.grid(x=seq_len(nrow(x)),xk=seq_len(nrow(xk)))
2943c2942
<   for (i in 1:object$dim) {
---
>   for (i in seq_len(object$dim)) {
2953c2952
<     for (i in 1:object$dim) 
---
>     for (i in seq_len(object$dim)) 
2965c2964
<     warning("more knots than data in a ds term: knots ignored.")
---
>     warning("more knots than data in a ds term: knots ignored")
2985c2984
<         ind <- sample(1:nu,nk,replace=FALSE)  ## by sampling these rows from xu
---
>         ind <- sample(seq_len(nu),nk,replace=FALSE)  ## by sampling these rows from xu
3039c3038
<   ind <- 1:ncol(T)
---
>   ind <- seq_len(ncol(T))
3093c3092
<   for (i in 1:object$dim) {
---
>   for (i in seq_len(object$dim)) {
3106,3107c3105,3106
<     for (i in 1:n.chunk) { ## build predict matrix in chunks
<       ind <- 1:nk + (i-1)*nk
---
>     for (i in seq_len(n.chunk)) { ## build predict matrix in chunks
>       ind <- seq_len(nk) + (i-1)*nk
3139c3138
<   ind <- expand.grid(x=1:nrow(x),xk=1:nrow(xk))
---
>   ind <- expand.grid(x=seq_len(nrow(x)),xk=seq_len(nrow(xk)))
3177c3176
<   for (i in 1:object$dim) {
---
>   for (i in seq_len(object$dim)) {
3187c3186
<     for (i in 1:object$dim) { 
---
>     for (i in seq_len(object$dim)) { 
3219c3218
<         ind <- sample(1:nu,nk,replace=FALSE)  ## by sampling these rows from xu
---
>         ind <- sample(seq_len(nu),nk,replace=FALSE)  ## by sampling these rows from xu
3258c3257
<     D[1:k,1:k] <- E  ## penalty
---
>     D[seq_len(k),seq_len(k)] <- E  ## penalty
3284c3283
<   for (i in 1:object$dim) {
---
>   for (i in seq_len(object$dim)) {
3297,3298c3296,3297
<     for (i in 1:n.chunk) { ## build predict matrix in chunks
<       ind <- 1:nk + (i-1)*nk
---
>     for (i in seq_len(n.chunk)) { ## build predict matrix in chunks
>       ind <- seq_len(nk) + (i-1)*nk
3403c3402
<    for (i in 1:length(object$term)) { 
---
>    for (i in seq_len(length(object$term))) { 
3415c3414
<          for (i in 1:m) dat[[i]] <- X[,i]     ## return only unique rows
---
>          for (i in seq_len(m)) dat[[i]] <- X[,i]     ## return only unique rows
3454c3453
<   if (!is.null(attr(sm,"qrc"))) warning("smooth objects should not have a qrc attribute.")
---
>   if (!is.null(attr(sm,"qrc"))) warning("smooth objects should not have a qrc attribute")
3490c3489
<         drop <- min((1:length(vcol))[vcol==min(vcol)])
---
>         drop <- min(seq_len(length(vcol))[vcol==min(vcol)])
3497c3496
<             sm$C <- ((1:length(xsd))[xsd==0])[1] ## index of coef to set to zero
---
>             sm$C <- (seq_len(length(xsd))[xsd==0])[1] ## index of coef to set to zero
3502c3501
<             sm$C <- ((1:length(xz))[xz==min(xz)])[1] ## index of coef to set to zero
---
>             sm$C <- (seq_len(length(xz))[xz==min(xz)])[1] ## index of coef to set to zero
3541c3540
<       for (i in 1:length(sm$S)) {
---
>       for (i in seq_len(length(sm$S))) {
3561c3560
<     if (!is.null(sm$by.done)) warning("handling `by' variables in smooth constructors may not work with the summation convention ")
---
>     if (!is.null(sm$by.done)) warning("handling 'by' variables in smooth constructors may not work with the summation convention")
3613c3612
<      for (l in 1:length(sm$S)) { # some smooths have > 1 penalty 
---
>      for (l in seq_len(length(sm$S))) { # some smooths have > 1 penalty 
3626c3625
<       if (matrixArg) stop("factor `by' variables can not be used with matrix arguments.")
---
>       if (matrixArg) stop("factor 'by' variables can not be used with matrix arguments")
3633c3632
<       for (j in 1:length(lev)) {
---
>       for (j in seq_len(length(lev))) {
3646c3645
<           (!is.null(sm$ind)&&length(by)!=length(sm$ind))) stop("`by' variable must be same dimension as smooth arguments")
---
>           (!is.null(sm$ind)&&length(by)!=length(sm$ind))) stop("'by' variable must be same dimension as smooth arguments")
3653c3652
<           ind <- 1:n 
---
>           ind <- seq_len(n)
3663c3662
<             ind <- 1:n 
---
>             ind <- seq_len(n)
3676c3675
<           for (i in 1:n) { ## in this case have to work down the rows
---
>           for (i in seq_len(n)) { ## in this case have to work down the rows
3711c3710
<       for (i in 1:length(sml)) { ## loop through smooth list
---
>       for (i in seq_len(length(sml))) { ## loop through smooth list
3716c3715
<           for (l in 1:length(sml[[i]]$S)) { # some smooths have > 1 penalty 
---
>           for (l in seq_len(length(sml[[i]]$S))) { # some smooths have > 1 penalty 
3727c3726
<         indi <- (1:ncol(sm$C))[colSums(sm$C)!=0] ## index of non-zero columns in C
---
>         indi <- seq_len(ncol(sm$C))[colSums(sm$C)!=0] ## index of non-zero columns in C
3733c3732
<           for (i in 1:length(sml)) { ## loop through smooth list
---
>           for (i in seq_len(length(sml))) { ## loop through smooth list
3735c3734
<             for (l in 1:length(sm$S)) # some smooths have > 1 penalty 
---
>             for (l in seq_len(length(sm$S))) # some smooths have > 1 penalty 
3737c3736
<               ZSZ[indi[1:nz],]<-qr.qty(qrc,sml[[i]]$S[[l]][indi,,drop=FALSE])[(nc+1):nx,] 
---
>               ZSZ[indi[seq_len(nz)],]<-qr.qty(qrc,sml[[i]]$S[[l]][indi,,drop=FALSE])[(nc+1):nx,] 
3739c3738
<               ZSZ[,indi[1:nz]]<-t(qr.qty(qrc,t(ZSZ[,indi,drop=FALSE]))[(nc+1):nx,])
---
>               ZSZ[,indi[seq_len(nz)]]<-t(qr.qty(qrc,t(ZSZ[,indi,drop=FALSE]))[(nc+1):nx,])
3745c3744
<             sml[[i]]$X[,indi[1:nz]]<-t(qr.qty(qrc,t(sml[[i]]$X[,indi,drop=FALSE]))[(nc+1):nx,])
---
>             sml[[i]]$X[,indi[seq_len(nz)]]<-t(qr.qty(qrc,t(sml[[i]]$X[,indi,drop=FALSE]))[(nc+1):nx,])
3761c3760
<         #    for (i in 1:length(sml)) { ## loop through smooth list
---
>         #    for (i in seq_along(sml)) { ## loop through smooth list
3766c3765
<         #      for (l in 1:length(sm$S)) { # some smooths have > 1 penalty 
---
>         #      for (l in seq_along(sm$S)) { # some smooths have > 1 penalty 
3773c3772
<             for (i in 1:length(sml)) { ## loop through smooth list
---
>             for (i in seq_len(length(sml))) { ## loop through smooth list
3775c3774
<               for (l in 1:length(sm$S)) { # some smooths have > 1 penalty 
---
>               for (l in seq_len(length(sm$S))) { # some smooths have > 1 penalty 
3785c3784
<           for (i in 1:length(sml)) { ## loop through smooth list
---
>           for (i in seq_len(length(sml))) { ## loop through smooth list
3795c3794
<         for (i in 1:length(sml)) {
---
>         for (i in seq_len(length(sml))) {
3801c3800
<        for (i in 1:length(sml)) { ## loop through smooth list
---
>        for (i in seq_len(length(sml))) { ## loop through smooth list
3803c3802
<           for (l in 1:length(sm$S)) { # some smooths have > 1 penalty 
---
>           for (l in seq_len(length(sm$S))) { # some smooths have > 1 penalty 
3816c3815
<        for (i in 1:length(sml)) { ## loop through smooth list
---
>        for (i in seq_len(length(sml))) { ## loop through smooth list
3818c3817
<           for (l in 1:length(sm$S)) { # some smooths have > 1 penalty 
---
>           for (l in seq_len(length(sm$S))) { # some smooths have > 1 penalty 
3834c3833
<       for (i in 1:length(sml)) { ## loop through smooth list
---
>       for (i in seq_len(length(sml))) { ## loop through smooth list
3841c3840
<   } else for (i in 1:length(sml)) attr(sml[[i]],"qrc") <-NULL ## no absorption
---
>   } else for (i in seq_len(length(sml))) attr(sml[[i]],"qrc") <-NULL ## no absorption
3882c3881
<         if (p>rank) for (i in 1:length(sml)) {
---
>         if (p>rank) for (i in seq_len(length(sml))) {
3893c3892
<       if (length(sml[[1]]$S)>1) for (i in 1:length(sml[[1]]$S)) St <- St + sml[[1]]$S[[i]]
---
>       if (length(sml[[1]]$S)>1) for (i in seq_len(length(sml[[1]]$S))) St <- St + sml[[1]]$S[[i]]
3900c3899
<         for (i in 1:length(sml)) {
---
>         for (i in seq_len(length(sml))) {
3910c3909
<   if (!apply.by) for (i in 1:length(sml)) {
---
>   if (!apply.by) for (i in seq_along(sml)) {
3931c3930
<     if (!deriv&&!is.null(object$margin)) for (i in 1:length(object$margin))
---
>     if (!deriv&&!is.null(object$margin)) for (i in seq_along(object$margin))
3948c3947
<     for (i in 1:n) { ## in this case have to work down the rows
---
>     for (i in seq_len(n)) { ## in this case have to work down the rows
3972c3971
<           if (length(by)!=nrow(X)) stop("`by' variable must be same dimension as smooth arguments")
---
>           if (length(by)!=nrow(X)) stop("'by' variable must be same dimension as smooth arguments")
3984c3983
<       ind <- 1:n 
---
>       ind <- seq_len(n)
4023c4022
<             X[ind,indi[1:nz]]<-t(qr.qty(qrc,t(X[ind,indi,drop=FALSE]))[(nc+1):nx,])
---
>             X[ind,indi[seq_len(nz)]]<-t(qr.qty(qrc,t(X[ind,indi,drop=FALSE]))[(nc+1):nx,])
4027c4026
<             X[,indi[1:nz]]<-t(qr.qty(qrc,t(X[,indi,drop=FALSE]))[(nc+1):nx,,drop=FALSE])
---
>             X[,indi[seq_len(nz)]]<-t(qr.qty(qrc,t(X[,indi,drop=FALSE]))[(nc+1):nx,,drop=FALSE])
diff -rEZbwB '--exclude=*.[lo,d,pdf,mo,po,tgz,gz,save]*' '--exclude=MD5' '--exclude=Makefile*' '--exclude=all.R' '--exclude=Changes' R-recommended/mgcv/R/soap.r Recommended/mgcv/R/soap.r
14c14
<     for (i in 1:length(beta.full)) {
---
>     for (i in seq_len(length(beta.full))) {
41c41
<           for (i in 1:length(beta.full)) {
---
>           for (i in seq_len(length(beta.full))) {
60c60
<         beta <- c(beta[1:(qrc[1]-1)],0,beta[qrc[1]:length(beta)])
---
>         beta <- c(beta[seq_len(qrc[1]-1)],0,beta[qrc[1]:length(beta)])
66c66
<         beta <- c(beta[1:(qrc-1)],0,beta[qrc:length(beta)])
---
>         beta <- c(beta[seq_len(qrc-1)],0,beta[qrc:length(beta)])
107c107
<   if (is.null(bnd.name)) for (i in 1:length(bnd)) { 
---
>   if (is.null(bnd.name)) for (i in seq_len(length(bnd))) { 
131c131
< { for (i in 1:length(bnd)) {
---
> { for (i in seq_len(length(bnd))) {
133c133
<     if (length(y)!=n) stop("x and y not same length")
---
>     if (length(y)!=n) stop("'x' and 'y' components of 'bnd' argument are not of same length")
142c142
<     len <- c(0,sqrt((x[1:(n-1)]-x[2:n])^2+(y[1:(n-1)]-y[2:n])^2)) ## seg lengths
---
>     len <- c(0,sqrt((x[seq_len(n-1)]-x[2:n])^2+(y[seq_len(n-1)]-y[2:n])^2)) ## seg lengths
157c157
<   for (k in 1:nk) {
---
>   for (k in seq_len(nk)) {
163c163
<         str <- paste("knot",k,"is on or outside boundary")
---
>         str <- gettextf("knot %d is on or outside boundary", k)
177c177
<   if (!inherits(bnd,"list")) stop("bnd must be a list.")
---
>   if (!inherits(bnd,"list")) stop("bnd must be a list")
181c181
<     else stop("lengths of k and bnd are not compatible.") 
---
>     else stop("lengths of 'k' and 'bnd' arguments are inconsistent") 
224c224
<   ind <- 1:o1$n
---
>   ind <- seq_len(o1$n)
239c239
<   for (i in 1:length(bnd)) {
---
>   for (i in seq_len(length(bnd))) {
255c255
<       bc[[i]] <- list(bsm=bsm,X=bsm$X[1:ret$nb[i],],S=bsm$S[[1]],free.bound=TRUE)
---
>       bc[[i]] <- list(bsm=bsm,X=bsm$X[seq_len(ret$nb[i]),],S=bsm$S[[1]],free.bound=TRUE)
292c292
<     for (i in 1:length(sd$bc)) { ## work through boundary loops
---
>     for (i in seq_len(length(sd$bc))) { ## work through boundary loops
318c318
<       gind[G[ind]] <- (1:length(G))[ind]
---
>       gind[G[ind]] <- seq_len(length(G))[ind]
350c350
<     for (i in 1:length(sd$bc)) { ## work through boundary loops
---
>     for (i in seq_len(length(sd$bc))) { ## work through boundary loops
360c360
<         for (j in 1:ncol(sd$bc[[i]]$X)) { ## loop over loop basis cols
---
>         for (j in seq_len(ncol(sd$bc[[i]]$X))) { ## loop over loop basis cols
384c384
<     for (i in 1:nc) g[sd$ki[i],i] <- 1
---
>     for (i in seq_len(nc)) g[sd$ki[i],i] <- 1
393c393
<     for (i in 1:nc) {
---
>     for (i in seq_len(nc)) {
433c433
<   for (i in 1:length(bnd)) { ## re-lable boundary
---
>   for (i in seq_len(length(bnd))) { ## re-lable boundary
446c446
<     stop("k and bnd lengths are inconsistent")
---
>     stop("lengths of 'bs.dim' and 'bnd' components of 'object' argument are inconsistent")
467c467
<   if (n>0) for (i in 1:n) if (sd$bc[[i]]$free.bound) 
---
>   if (n>0) for (i in seq_len(n)) if (sd$bc[[i]]$free.bound) 
471c471
<   for (i in 1:length(sd$bc)) 
---
>   for (i in seq_len(length(sd$bc))) 
478c478
<   for (i in  1:length(b$S)) {
---
>   for (i in  seq_len(length(b$S))) {
490c490
<     for (i in 1:length(b$S)) {
---
>     for (i in seq_len(length(b$S))) {
508c508
<   for (i in 1:length(sd$bc)) {
---
>   for (i in seq_len(length(sd$bc))) {
537c537
<   for (i in 1:length(bnd)) { ## re-lable boundary
---
>   for (i in seq_len(length(bnd))) { ## re-lable boundary
550c550
<     stop("k and bnd lengths are inconsistent")
---
>     stop("lengths of 'bs.dim' and 'bnd' components of 'object' argument are inconsistent")
572c572
<   if (n>0) for (i in 1:n) if (sd$bc[[i]]$free.bound) { 
---
>   if (n>0) for (i in seq_len(n)) if (sd$bc[[i]]$free.bound) { 
582c582
<   for (i in 1:length(sd$bc)) 
---
>   for (i in seq_len(length(sd$bc))) 
589c589
<   if (length(b$S)>0) for (i in  1:length(b$S)) {
---
>   if (length(b$S)>0) for (i in  seq_len(length(b$S))) {
601c601
<     if (length(b$S)>0) for (i in 1:length(b$S)) {
---
>     if (length(b$S)>0) for (i in seq_len(length(b$S))) {
614c614
<   for (i in 1:length(sd$bc)) {
---
>   for (i in seq_len(length(sd$bc))) {
642c642
<   for (i in 1:length(bnd)) { ## re-lable boundary
---
>   for (i in seq_len(length(bnd))) { ## re-lable boundary
655c655
<     stop("k and bnd lengths are inconsistent")
---
>     stop("lengths of 'bs.dim' and 'bnd' components of 'object' argument are inconsistent")
675c675
<   for (i in  1:length(b$S)) {
---
>   for (i in  seq_len(length(b$S))) {
686c686
<     for (i in 1:length(b$S)) {
---
>     for (i in seq_len(length(b$S))) {
703c703
<   for (i in 1:length(sd$bc)) {
---
>   for (i in seq_len(length(sd$bc))) {
766c766
<                 for (i in 1:length(P$bnd)) lines(P$bnd[[i]],lwd=2)
---
>                 for (i in seq_len(length(P$bnd))) lines(P$bnd[[i]],lwd=2)
802c802
<           for (i in 1:length(P$bnd)) lines(P$bnd[[i]],lwd=2)
---
>           for (i in seq_len(length(P$bnd))) lines(P$bnd[[i]],lwd=2)
diff -rEZbwB '--exclude=*.[lo,d,pdf,mo,po,tgz,gz,save]*' '--exclude=MD5' '--exclude=Makefile*' '--exclude=all.R' '--exclude=Changes' R-recommended/mgcv/R/sparse.r Recommended/mgcv/R/sparse.r
14c14
<   ## ni[1:off[1]] gives neighbours of point 1. 
---
>   ## ni[seq_len(off[1])] gives neighbours of point 1. 
16c16
<   return(list(ni = oo$T[1:oo$off[n]]+1,off=oo$off))
---
>   return(list(ni = oo$T[seq_len(oo$off[n])]+1,off=oo$off))
33,34c33,34
<   ii <- c(1:n,oo$ii[1:ni]+1) ## row index
<   jj <- c(1:n,oo$ni[1:ni]+1) ## col index
---
>   ii <- c(seq_len(n),oo$ii[seq_len(ni)]+1) ## row index
>   jj <- c(seq_len(n),oo$ni[seq_len(ni)]+1) ## col index
37,39c37,39
<   Kx <- sparseMatrix(i=ii,j=jj,x=oo$D[1:ni],dims=c(n,n))
<   Kz <- sparseMatrix(i=ii,j=jj,x=oo$D[1:ni+ni],dims=c(n,n))
<   Kxz <- sparseMatrix(i=ii,j=jj,x=oo$D[1:ni+2*ni],dims=c(n,n))
---
>   Kx <- sparseMatrix(i=ii,j=jj,x=oo$D[seq_len(ni)],dims=c(n,n))
>   Kz <- sparseMatrix(i=ii,j=jj,x=oo$D[seq_len(ni)+ni],dims=c(n,n))
>   Kxz <- sparseMatrix(i=ii,j=jj,x=oo$D[seq_len(ni)+2*ni],dims=c(n,n))
108c108
<   lo <- dd[,1:d];hi <- dd[,1:d+d]
---
>   lo <- dd[,seq_len(d)];hi <- dd[,seq_len(d)+d]
119c119
<   for (i in 1:nb) {
---
>   for (i in seq_len(nb)) {
140c140
<   } else { Xu <- X; ind <- 1:nrow(X)}
---
>   } else { Xu <- X; ind <- seq_len(nrow(X))}
146c146
<   if (get.a) a <- 1:n else a=1
---
>   if (get.a) a <- seq_len(n) else a=1
152,153c152,153
<   rind <- 1:nobs
<   rind[ind] <- 1:nobs
---
>   rind <- seq_len(nobs)
>   rind[ind] <- seq_len(nobs)
219c219
<   P <- sparseMatrix(i=1:n,j=ind,x=rep(1,n),dims=c(n,nrow(xu)))
---
>   P <- sparseMatrix(i=seq_len(n),j=ind,x=rep(1,n),dims=c(n,nrow(xu)))
259,260c259,260
<     for (i in 1:nb) {
<       ind[[i]] <- (1:n)[block==levels(block)[i]]
---
>     for (i in seq_len(nb)) {
>       ind[[i]] <- (seq_len(n))[block==levels(block)[i]]
265c265
<     ind[[1]] <- 1:n
---
>     ind[[1]] <- seq_len(n)
290c290
<   if (block==0) block <- 1:object$nblock
---
>   if (block==0) block <- seq_len(object$nblock)
328c328
<   } else for (i in 1:object$nblock) { ## work through all blocks 
---
>   } else for (i in seq_len(object$nblock)) { ## work through all blocks 
360,361c360,361
<     for (i in 1:nb) { 
<       ind[[i]] <- (1:n)[block==levels(block)[i]]
---
>     for (i in seq_len(nb)) { 
>       ind[[i]] <- (seq_len(n))[block==levels(block)[i]]
365c365
<     ind[[1]] <- 1:n
---
>     ind[[1]] <- seq_len(n)
Only in R-recommended/mgcv/inst/po: ko
diff -rEZbwB '--exclude=*.[lo,d,pdf,mo,po,tgz,gz,save]*' '--exclude=MD5' '--exclude=Makefile*' '--exclude=all.R' '--exclude=Changes' R-recommended/mgcv/src/general.h Recommended/mgcv/src/general.h
3,8d2
< #ifdef ENABLE_NLS
< #include <libintl.h>
< #define _(String) dgettext ("mgcv", String)
< #else
< #define _(String) (String)
< #endif
Only in Recommended/mgcv/src: localization.h
diff -rEZbwB '--exclude=*.[lo,d,pdf,mo,po,tgz,gz,save]*' '--exclude=MD5' '--exclude=Makefile*' '--exclude=all.R' '--exclude=Changes' R-recommended/mgcv/src/magic.c Recommended/mgcv/src/magic.c
27a28
> #include "localization.h"
diff -rEZbwB '--exclude=*.[lo,d,pdf,mo,po,tgz,gz,save]*' '--exclude=MD5' '--exclude=Makefile*' '--exclude=all.R' '--exclude=Changes' R-recommended/mgcv/src/mat.c Recommended/mgcv/src/mat.c
31a32
> #include "localization.h"
47c48
<     Rprintf("\nFailed to open file\n");
---
>     Rprintf(_("\nFailed to open file\n"));
69c70
<     Rprintf("\nFailed to open file\n");
---
>     Rprintf(_("\nFailed to open file\n"));
77c78
<    if (j!= *r * *c)  Rprintf("\nfile dim problem\n");
---
>    if (j != *r * *c)  Rprintf(_("\nfile dim problem\n"));
2603c2604
<     if (k) Rprintf("Non orthogonal eigenvectors %d %g\n",k,x/k);
---
>     if (k) Rprintf(_("Non orthogonal eigenvectors %d %g\n"), k, x / k);
2608c2609
<     if (k) Rprintf("Eigenvectors not normalized %d %g\n",k,x/k);
---
>     if (k) Rprintf(_("Eigenvectors not normalized %d %g\n"), k, x / k);
diff -rEZbwB '--exclude=*.[lo,d,pdf,mo,po,tgz,gz,save]*' '--exclude=MD5' '--exclude=Makefile*' '--exclude=all.R' '--exclude=Changes' R-recommended/mgcv/src/matrix.c Recommended/mgcv/src/matrix.c
30a31
> #include "localization.h"
diff -rEZbwB '--exclude=*.[lo,d,pdf,mo,po,tgz,gz,save]*' '--exclude=MD5' '--exclude=Makefile*' '--exclude=all.R' '--exclude=Changes' R-recommended/mgcv/src/matrix.h Recommended/mgcv/src/matrix.h
9,10c9,13
< typedef struct
< { int vec, r,c,original_r,original_c;long mem;double **M,*V;} matrix;
---
> typedef struct {
> 	int vec, r, c, original_r, original_c;
> 	long mem;
> 	double **M, *V;
> } matrix;
38c41,42
< void OrthoMult(matrix *Q,matrix *A,int off,int rows,int t,int pre,int o_pre);
---
> void OrthoMult(matrix *Q, matrix *A, int off, int rows, int t, int pre,
> 		int o_pre);
diff -rEZbwB '--exclude=*.[lo,d,pdf,mo,po,tgz,gz,save]*' '--exclude=MD5' '--exclude=Makefile*' '--exclude=all.R' '--exclude=Changes' R-recommended/mgcv/src/mvn.c Recommended/mgcv/src/mvn.c
15,16c15,16
<             int *m,double *ll,double *lb,double *lbb,double *dbeta,
<             double *dH,int *deriv,int *nsp,int *nt) {
---
> int *m, double *ll, double *lb, double *lbb, double *dbeta, double *dH,
> 		int *deriv, int *nsp, int *nt) {
31,33c31,35
<   double *R,*theta,ldetR,*Xl,*bl,oned=1.0,zerod=0.0,*p,*p1,*p2,*p3,xx,zz,yy,*yty,
<     *mu,*Rymu,rip,*dtheta,*db,*deriv_theta,*yX,*yRX;
<   int i,j,k,l,pl,one=1,bt,ct,nb,*din,ntheta,ncoef,*rri,*rci,ri,rj,ril,rjl,rik,rjk,rij,rjj,q,r;
---
> 	double *R, *theta, ldetR, *Xl, *bl, oned = 1.0, zerod = 0.0, *p, *p1, *p2,
> 			*p3, xx, zz, yy, *yty, *mu, *Rymu, rip, *dtheta, *db, *deriv_theta,
> 			*yX, *yRX;
> 	int i, j, k, l, pl, one = 1, bt, ct, nb, *din, ntheta, ncoef, *rri, *rci,
> 			ri, rj, ril, rjl, rik, rjk, rij, rjj, q, r;
35c37,38
<   ntheta = *m * (*m+1)/2;ncoef = lpi[*m-1];
---
> 	ntheta = *m * (*m + 1) / 2;
> 	ncoef = lpi[*m - 1];
47,48c50,53
<     R[i + *m * i] = deriv_theta[k];ldetR += theta[k];
<     rri[k]=rci[k]=i;k++; 
---
> 		R[i + *m * i] = deriv_theta[k];
> 		ldetR += theta[k];
> 		rri[k] = rci[k] = i;
> 		k++;
52c57,59
<       rri[k]=i;rci[k]=j;k++;
---
> 			rri[k] = i;
> 			rci[k] = j;
> 			k++;
58,60c65,76
<     if (l==0) { Xl = X;pl = lpi[0];bl=beta;} /* Xl is lth model matrix with pl columns, coef vec bl */ 
<     else { Xl = X + *n * lpi[l-1];pl = lpi[l]-lpi[l-1];bl = beta + lpi[l-1];}   
<     F77_CALL(dgemv)(&not_trans,n,&pl,&oned,Xl,n, bl, &one,&zerod, mu, &one); /* BLAS call for mu = Xl bl */
---
> 		if (l == 0) {
> 			Xl = X;
> 			pl = lpi[0];
> 			bl = beta;
> 		} /* Xl is lth model matrix with pl columns, coef vec bl */
> 		else {
> 			Xl = X + *n * lpi[l - 1];
> 			pl = lpi[l] - lpi[l - 1];
> 			bl = beta + lpi[l - 1];
> 		}
> 		F77_CALL(dgemv)(&not_trans, n, &pl, &oned, Xl, n, bl, &one, &zerod, mu,
> 				&one); /* BLAS call for mu = Xl bl */
62c78,79
<     for (p=mu,p1= mu + *n,p2=y+l;p<p1;p++,p2 += *m) *p2 -= *p;
---
> 		for (p = mu, p1 = mu + *n, p2 = y + l; p < p1; p++, p2 += *m)
> 			*p2 -= *p;
69c86,88
<   bt=0;ct=0;mgcv_pmmult(Rymu,R,y,&bt,&ct,m,n,m,nt);  
---
> 	bt = 0;
> 	ct = 0;
> 	mgcv_pmmult(Rymu, R, y, &bt, &ct, m, n, m, nt);
71c90,91
<   for (*ll=0.0,p=Rymu,p1=p + *n * *m;p<p1;p++) *ll += *p * *p;
---
> 	for (*ll = 0.0, p = Rymu, p1 = p + *n * *m; p < p1; p++)
> 		*ll += *p * *p;
79,80c99,106
<     if (l==0) { Xl = X;pl = lpi[0];} /* Xl is lth model matrix with pl columns */ 
<     else { Xl = X + *n * lpi[l-1];pl = lpi[l]-lpi[l-1];} 
---
> 		if (l == 0) {
> 			Xl = X;
> 			pl = lpi[0];
> 		} /* Xl is lth model matrix with pl columns */
> 		else {
> 			Xl = X + *n * lpi[l - 1];
> 			pl = lpi[l] - lpi[l - 1];
> 		}
85c111,113
<         for (p1=R + l * *m,p2 = p1 + l,p3 = Rymu + *m *j;p1<=p2;p1++,p3++) *p += xx * *p1 * *p3; 
---
> 				for (p1 = R + l * *m, p2 = p1 + l, p3 = Rymu + *m * j; p1 <= p2;
> 						p1++, p3++)
> 					*p += xx * *p1 * *p3;
94c122,123
<     xx = deriv_theta[k]; /* the non-zero element of R_theta^i at i,i */;
---
> 		xx = deriv_theta[k]; /* the non-zero element of R_theta^i at i,i */
> 		;
98c127,129
<     for (zz=0.0,l=0,p1 = Rymu+i,p2=y+i;l<*n;l++,p1 += *m,p2 += *m) zz += *p1 * *p2 * xx;
---
> 		for (zz = 0.0, l = 0, p1 = Rymu + i, p2 = y + i; l < *n;
> 				l++, p1 += *m, p2 += *m)
> 			zz += *p1 * *p2 * xx;
103c134,136
<       for (zz=0.0,l=0,p1 = Rymu+i,p2=y+j;l<*n;l++,p1 += *m,p2 += *m) zz += *p1 * *p2;
---
> 			for (zz = 0.0, l = 0, p1 = Rymu + i, p2 = y + j; l < *n; l++, p1 +=
> 					*m, p2 += *m)
> 				zz += *p1 * *p2;
113c146,147
<     if (i==lpi[k]) k++; 
---
> 		if (i == lpi[k])
> 			k++;
117,118c151,154
<   for (i=0;i<ncoef;i++) for (j=0;j<=i;j++) {
<      l=din[i];k=din[j]; /* note l>=k */
---
> 	for (i = 0; i < ncoef; i++)
> 		for (j = 0; j <= i; j++) {
> 			l = din[i];
> 			k = din[j]; /* note l>=k */
120c156,158
<      for (p=R+l * *m,p1=R+k * *m,rip=0.0,p2=p1+k;p1<=p2;p++,p1++) rip += *p * *p1;
---
> 			for (p = R + l * *m, p1 = R + k * *m, rip = 0.0, p2 = p1 + k;
> 					p1 <= p2; p++, p1++)
> 				rip += *p * *p1;
124c162,163
<   for (i=0;i<ncoef;i++) for (j=0;j<ntheta;j++) {
---
> 	for (i = 0; i < ncoef; i++)
> 		for (j = 0; j < ntheta; j++) {
131c170,173
<      if (l==rj) for (p = X + i* *n,p1=Rymu+ri,p2=p + *n;p<p2;p++,p1 += *m) xx += *p * *p1;
---
> 			if (l == rj)
> 				for (p = X + i * *n, p1 = Rymu + ri, p2 = p + *n; p < p2;
> 						p++, p1 += *m)
> 					xx += *p * *p1;
135c177,179
<        for (yy=0.0,p = X + i* *n,p1=y+rj,p2=p + *n;p<p2;p++,p1 += *m) yy += *p * *p1;
---
> 				for (yy = 0.0, p = X + i * *n, p1 = y + rj, p2 = p + *n; p < p2;
> 						p++, p1 += *m)
> 					yy += *p * *p1;
141c185,186
<   for (k=0;k<ntheta;k++) for (l=0;l<=k;l++) {
---
> 	for (k = 0; k < ntheta; k++)
> 		for (l = 0; l <= k; l++) {
144c189,190
<         ri=rri[k];rj=rci[k];
---
> 				ri = rri[k];
> 				rj = rci[k];
147c193,195
<           for (zz=0.0,i=0,p=Rymu+ri,p2=y+ri;i<*n;i++,p += *m,p2+= *m) zz += *p * *p2;
---
> 					for (zz = 0.0, i = 0, p = Rymu + ri, p2 = y + ri; i < *n;
> 							i++, p += *m, p2 += *m)
> 						zz += *p * *p2;
152c200,201
<       ri=rri[k];rj=rci[k];
---
> 			ri = rri[k];
> 			rj = rci[k];
155,156c204,207
<       ril=rri[l];rjl=rci[l];
<       rik=rri[k];rjk=rci[k];
---
> 			ril = rri[l];
> 			rjl = rci[l];
> 			rik = rri[k];
> 			rjk = rci[k];
158c209,211
< 	for (yy=0.0,i=0,p=y+rjl,p1=y+rjk;i<*n;i++,p+= *m, p1+= *m) yy += *p * *p1;
---
> 				for (yy = 0.0, i = 0, p = y + rjl, p1 = y + rjk; i < *n;
> 						i++, p += *m, p1 += *m)
> 					yy += *p * *p1;
160c213,214
<         if (ril==rjl) yy *= deriv_theta[l];
---
> 				if (ril == rjl)
> 					yy *= deriv_theta[l];
163c217,218
<       lbb[k + ncoef + nb * (l+ncoef)] = lbb[l + ncoef + nb * (k+ncoef)] = xx;
---
> 			lbb[k + ncoef + nb * (l + ncoef)] =
> 					lbb[l + ncoef + nb * (k + ncoef)] = xx;
170c225,227
<     bt=0;ct=0;mgcv_pmmult(yX,y,X,&bt,&ct,m,&ncoef,n,nt); /* rows, dim, cols coef */   
---
> 		bt = 0;
> 		ct = 0;
> 		mgcv_pmmult(yX, y, X, &bt, &ct, m, &ncoef, n, nt); /* rows, dim, cols coef */
172c229,231
<     bt=0;ct=0;mgcv_pmmult(yRX,Rymu,X,&bt,&ct,m,&ncoef,n,nt); /* rows, dim, cols coef */  
---
> 		bt = 0;
> 		ct = 0;
> 		mgcv_pmmult(yRX, Rymu, X, &bt, &ct, m, &ncoef, n, nt); /* rows, dim, cols coef */
174c233,235
<     bt=0;ct=1;mgcv_pmmult(yty,y,y,&bt,&ct,m,m,n,nt); /* rows, cols dim */  
---
> 		bt = 0;
> 		ct = 1;
> 		mgcv_pmmult(yty, y, y, &bt, &ct, m, m, n, nt); /* rows, cols dim */
181,183c242,248
<       for (i=0;i<ncoef;i++) for (j=0;j<=i;j++) {
< 	l = din[i];k = din[j]; /* dimensions for these elements */
< 	xx=0.0;p=R+l* *m;p1=R+k* *m;
---
> 			for (i = 0; i < ncoef; i++)
> 				for (j = 0; j <= i; j++) {
> 					l = din[i];
> 					k = din[j]; /* dimensions for these elements */
> 					xx = 0.0;
> 					p = R + l * *m;
> 					p1 = R + k * *m;
185,187c250,255
<           ri=rri[q];rj=rci[q]; /* row and col of non zero element of deriv of R wrt theta_q */
<           if (rj==l) xx += p1[ri]*deriv_theta[q]*dtheta[q];
<           if (rj==k) xx += p[ri]*deriv_theta[q]*dtheta[q];
---
> 						ri = rri[q];
> 						rj = rci[q]; /* row and col of non zero element of deriv of R wrt theta_q */
> 						if (rj == l)
> 							xx += p1[ri] * deriv_theta[q] * dtheta[q];
> 						if (rj == k)
> 							xx += p[ri] * deriv_theta[q] * dtheta[q];
194c262,263
<       for (i=0;i<ncoef;i++) for (j=0;j<ntheta;j++) {  
---
> 			for (i = 0; i < ncoef; i++)
> 				for (j = 0; j < ntheta; j++) {
199c268,269
<           ri=rri[j];rj=rci[j]; /* row and col of non zero element of deriv of R wrt theta_j */
---
> 						ri = rri[j];
> 						rj = rci[j]; /* row and col of non zero element of deriv of R wrt theta_j */
201,202c271,276
<           if (rj==l) xx += -R[ri + *m * k]*zz*XX[i + ncoef * q] * db[q];
<           if (rj==k) xx += -R[ri + *m * l]*zz*XX[i + ncoef * q] * db[q];
---
> 						if (rj == l)
> 							xx += -R[ri + *m * k] * zz * XX[i + ncoef * q]
> 									* db[q];
> 						if (rj == k)
> 							xx += -R[ri + *m * l] * zz * XX[i + ncoef * q]
> 									* db[q];
205c279,280
<         rij=rri[j];rjj=rci[j]; /* row and col of non zero element of deriv of R wrt theta_j */
---
> 					rij = rri[j];
> 					rjj = rci[j]; /* row and col of non zero element of deriv of R wrt theta_j */
208c283,284
<           rik=rri[k];rjk=rci[k]; /* row and col of non zero element of deriv of R wrt theta_k */
---
> 						rik = rri[k];
> 						rjk = rci[k]; /* row and col of non zero element of deriv of R wrt theta_k */
210,211c286,291
<             if (l==rjj) zz +=  yX[rjk + i * *m] * deriv_theta[j] * deriv_theta[k];
<             if (l==rjk) zz +=  yX[rjj + i * *m] * deriv_theta[j] * deriv_theta[k];
---
> 							if (l == rjj)
> 								zz += yX[rjk + i * *m] * deriv_theta[j]
> 										* deriv_theta[k];
> 							if (l == rjk)
> 								zz += yX[rjj + i * *m] * deriv_theta[j]
> 										* deriv_theta[k];
217c297,299
<           if (k==j&&rik==rjk) xx += dtheta[k]* deriv_theta[k] * R[rjj + *m * l] * yX[rjj + *m * i];/* x_i^l'R'R_tt^jk(y-mu) */
---
> 						if (k == j && rik == rjk)
> 							xx += dtheta[k] * deriv_theta[k] * R[rjj + *m * l]
> 									* yX[rjj + *m * i];/* x_i^l'R'R_tt^jk(y-mu) */
223,224c305,310
<       for (j=0;j<ntheta;j++) for (k=j;k<ntheta;k++) {
<         rij=rri[j];rjj=rci[j];rik=rri[k];rjk=rci[k];
---
> 			for (j = 0; j < ntheta; j++)
> 				for (k = j; k < ntheta; k++) {
> 					rij = rri[j];
> 					rjj = rci[j];
> 					rik = rri[k];
> 					rjk = rci[k];
228c314,315
< 	  zz=0.0;l=din[i];
---
> 						zz = 0.0;
> 						l = din[i];
230,231c317,322
<             if (l==rjj) zz +=  yX[rjk + i * *m] * deriv_theta[j] * deriv_theta[k];
<             if (l==rjk) zz +=  yX[rjj + i * *m] * deriv_theta[j] * deriv_theta[k];
---
> 							if (l == rjj)
> 								zz += yX[rjk + i * *m] * deriv_theta[j]
> 										* deriv_theta[k];
> 							if (l == rjk)
> 								zz += yX[rjj + i * *m] * deriv_theta[j]
> 										* deriv_theta[k];
236c327,328
<               if (l==rjj) zz +=  deriv_theta[k] * yRX[rjj + *m * i];  /* x_i^l'R_tt^jk R(y-mu) */
---
> 								if (l == rjj)
> 									zz += deriv_theta[k] * yRX[rjj + *m * i]; /* x_i^l'R_tt^jk R(y-mu) */
240c332,334
<           if (k==j&&rij==rjj) xx +=  db[i]*deriv_theta[k] * R[rjj + *m * l] * yX[rjj + *m * i]; /* x_i^l'R'R_tt^jk(y-mu) */
---
> 						if (k == j && rij == rjj)
> 							xx += db[i] * deriv_theta[k] * R[rjj + *m * l]
> 									* yX[rjj + *m * i]; /* x_i^l'R'R_tt^jk(y-mu) */
243,246c337,348
< 	  ri = rri[i];rj=rci[i];zz=0.0;
<           if (j==k&&ri==rij&&rjk==rik) zz += deriv_theta[j]*deriv_theta[i]*yty[rj * *m + rjj];  /* row rjj, col rj */ 
<           if (i==k&&rik==rij&&rj==ri) zz += deriv_theta[j]*deriv_theta[i]*yty[rjk * *m + rjj];  /* row rjj, col rjk */ 
<           if (i==j&&rik==rij&&rj==ri) zz += deriv_theta[k]*deriv_theta[i]*yty[rjk * *m + rj];  /* row rjk, col rj */ 
---
> 						ri = rri[i];
> 						rj = rci[i];
> 						zz = 0.0;
> 						if (j == k && ri == rij && rjk == rik)
> 							zz += deriv_theta[j] * deriv_theta[i]
> 									* yty[rj * *m + rjj]; /* row rjj, col rj */
> 						if (i == k && rik == rij && rj == ri)
> 							zz += deriv_theta[j] * deriv_theta[i]
> 									* yty[rjk * *m + rjj]; /* row rjj, col rjk */
> 						if (i == j && rik == rij && rj == ri)
> 							zz += deriv_theta[k] * deriv_theta[i]
> 									* yty[rjk * *m + rj]; /* row rjk, col rj */
249c351,353
<             for (yy=0.0,p=Rymu+ri,p1=y+ri,q=0;q<*n;p+= *m,p1+= *m,q++) yy += *p * *p1;           
---
> 							for (yy = 0.0, p = Rymu + ri, p1 = y + ri, q = 0;
> 									q < *n; p += *m, p1 += *m, q++)
> 								yy += *p * *p1;
254c358,359
< 	dH[k + ncoef + (j+ncoef) * nb] = dH[j+ncoef + (k+ncoef) * nb] = xx;
---
> 					dH[k + ncoef + (j + ncoef) * nb] = dH[j + ncoef
> 							+ (k + ncoef) * nb] = xx;
259c364,366
<     FREE(yX);FREE(yRX);FREE(yty);
---
> 		FREE(yX);
> 		FREE(yRX);
> 		FREE(yty);
262,265c369,375
< 
<   FREE(din); FREE(rri); FREE(rci);
<   
<   FREE(R);FREE(Rymu);FREE(deriv_theta);
---
> 	FREE(din);
> 	FREE(rri);
> 	FREE(rci);
> 
> 	FREE(R);
> 	FREE(Rymu);
> 	FREE(deriv_theta);
diff -rEZbwB '--exclude=*.[lo,d,pdf,mo,po,tgz,gz,save]*' '--exclude=MD5' '--exclude=Makefile*' '--exclude=all.R' '--exclude=Changes' R-recommended/mgcv/src/qp.c Recommended/mgcv/src/qp.c
29a29,30
> #include "localization.h"
> #include <R_ext/Minmax.h>
33,36d33
< 
< #define max(a,b)    (((a) > (b)) ? (a) : (b))
< #define min(a,b)    (((a) < (b)) ? (a) : (b))
< 
39,42c36,37
< 
< 
< 
< matrix addconQT(Q,T,a,u) matrix *Q,T,a,*u;
---
> matrix addconQT(Q, T, a, u)
> 	matrix *Q, T, a, *u;
48c43,44
< { int q,i,j;
---
> {
> 	int q, i, j;
51,52c47,52
<   c=initmat(Q->r,1);b=initmat(Q->r,1);(*u)=initmat(Q->r,1);
<   for (i=0;i<c.r;i++) for (j=0;j<a.c;j++) c.V[i]+=a.V[j]*Q->M[j][i];
---
> 	c = initmat(Q->r, 1);
> 	b = initmat(Q->r, 1);
> 	(*u) = initmat(Q->r, 1);
> 	for (i = 0; i < c.r; i++)
> 		for (j = 0; j < a.c; j++)
> 			c.V[i] += a.V[j] * Q->M[j][i];
54c54,55
<   cV=c.V;bV=b.V;
---
> 	cV = c.V;
> 	bV = b.V;
56,60c57,64
<   if (q!=0)
<   { for (i=q+1;i<a.c;i++) { ra+=cV[i]*cV[i];bV[i]=cV[i];}
<     if ((la-ra)<0.0)
<     { error(_("ERROR in addconQT."));}
<     else
---
> 	if (q != 0) {
> 		for (i = q + 1; i < a.c; i++) {
> 			ra += cV[i] * cV[i];
> 			bV[i] = cV[i];
> 		}
> 		if ((la - ra) < 0.0) {
> 			error(_("ERROR in 'addconQT()'"));
> 		} else
62c66,67
<     if (cV[q]>0.0) bV[q]= -bV[q];
---
> 		if (cV[q] > 0.0)
> 			bV[q] = -bV[q];
66,68c71,76
<   for (i=0;i<a.c;i++) bV[i]=cV[i];
<   T1V=T.M[T.r];T.r++;
<   for (j=0;j<T.c;j++) T1V[j]=bV[j];
---
> 		for (i = 0; i < a.c; i++)
> 			bV[i] = cV[i];
> 	T1V = T.M[T.r];
> 	T.r++;
> 	for (j = 0; j < T.c; j++)
> 		T1V[j] = bV[j];
87c95,96
< { int q,i,j;
---
> {
> 	int q, i, j;
90,92c99,106
<   b.V=T->M[T->r]; b.r=Q->r;b.c=1;
<   for (i=0;i<T->c;i++) b.V[i]=0.0;
<   for (i=0;i<b.r;i++) for (j=0;j<Q->r;j++) b.V[i]+=Q->M[j][i]*a->V[j];
---
> 	b.V = T->M[T->r];
> 	b.r = Q->r;
> 	b.c = 1;
> 	for (i = 0; i < T->c; i++)
> 		b.V[i] = 0.0;
> 	for (i = 0; i < b.r; i++)
> 		for (j = 0; j < Q->r; j++)
> 			b.V[i] += Q->M[j][i] * a->V[j];
95c109,112
<   bV=b.V;cV=c->V;sV=s->V;QM=Q->M;
---
> 	bV = b.V;
> 	cV = c->V;
> 	sV = s->V;
> 	QM = Q->M;
97,102c114,124
<   for (i=0;i<q;i++)
<   { /* first calculate the Givens transformation */
<     bb=bV[i];bb1=bV[i+1];
<     r=bb*bb+bb1*bb1;r=sqrt(r);
<     if (r==0.0) { ss=sV[i]=0.0;cc=cV[i]=1.0;} else
<     { ss=sV[i]=bb/r;cc=cV[i]= -bb1/r;
---
> 	for (i = 0; i < q; i++) { /* first calculate the Givens transformation */
> 		bb = bV[i];
> 		bb1 = bV[i + 1];
> 		r = bb * bb + bb1 * bb1;
> 		r = sqrt(r);
> 		if (r == 0.0) {
> 			ss = sV[i] = 0.0;
> 			cc = cV[i] = 1.0;
> 		} else {
> 			ss = sV[i] = bb / r;
> 			cc = cV[i] = -bb1 / r;
107,108c129,130
<     for (j=0;j<Q->r;j++)
<     { QV=QM[j];
---
> 		for (j = 0; j < Q->r; j++) {
> 			QV = QM[j];
117,120c139,140
< 
< 
< void LSQPaddcon(matrix *Ain,matrix *Q,matrix *T,matrix *Rf,matrix *Py,matrix *PX,
<                 matrix *s,matrix *c,int sth)
---
> void LSQPaddcon(matrix *Ain, matrix *Q, matrix *T, matrix *Rf, matrix *Py,
> 		matrix *PX, matrix *s, matrix *c, int sth)
130c150,151
< { matrix a;
---
> {
> 	matrix a;
133c154,156
<   a.V=Ain->M[sth];a.r=Ain->c;a.c=1; /* vector containing sth constraint */
---
> 	a.V = Ain->M[sth];
> 	a.r = Ain->c;
> 	a.c = 1; /* vector containing sth constraint */
138,142c161,168
<   for (i=0;i<s->r;i++)
<   { cc=c->V[i];ss=s->V[i];
<     k=i+2;if (k>Rf->r) k--;
<     for (j=0;j<k;j++)
<     { RfV=Rf->M[j];
---
> 	for (i = 0; i < s->r; i++) {
> 		cc = c->V[i];
> 		ss = s->V[i];
> 		k = i + 2;
> 		if (k > Rf->r)
> 			k--;
> 		for (j = 0; j < k; j++) {
> 			RfV = Rf->M[j];
152,155c178,186
<     RfV=Rf->M[i];RfV1=Rf->M[i+1];
<     x1=RfV[i];x2=RfV1[i];
<     r=sqrt(x1*x1+x2*x2);ss=x2/r;cc=x1/r;
<     Rf->M[i][i]=r;Rf->M[i+1][i]=0.0;
---
> 		RfV = Rf->M[i];
> 		RfV1 = Rf->M[i + 1];
> 		x1 = RfV[i];
> 		x2 = RfV1[i];
> 		r = sqrt(x1 * x1 + x2 * x2);
> 		ss = x2 / r;
> 		cc = x1 / r;
> 		Rf->M[i][i] = r;
> 		Rf->M[i + 1][i] = 0.0;
157c188,190
<     { x1=RfV[j];x2=RfV1[j];
---
> 		{
> 			x1 = RfV[j];
> 			x2 = RfV1[j];
162c195,196
<     x1=Py->V[i];x2=Py->V[i+1];
---
> 		x1 = Py->V[i];
> 		x2 = Py->V[i + 1];
167c201,203
<     { x1=PX->M[i][j];x2=PX->M[i+1][j];
---
> 		{
> 			x1 = PX->M[i][j];
> 			x2 = PX->M[i + 1][j];
174,175c210,211
< 
< int LSQPstep(int *ignore,matrix *Ain,matrix *b,matrix *p1,matrix *p,matrix *pk)
---
> int LSQPstep(int *ignore, matrix *Ain, matrix *b, matrix *p1, matrix *p,
> 		matrix *pk)
191c227,228
< { double Ap1,ap,apk,alpha,alphamin,*AV,*pV,*p1V,*pkV;
---
> {
> 	double Ap1, ap, apk, alpha, alphamin, *AV, *pV, *p1V, *pkV;
193,195c230,236
<   alphamin=1.0;imin= -1;
<   p1V=p1->V;pV=p->V;pkV=pk->V;
<   for (i=0;i<p->r;i++) p1V[i]=pV[i]+pkV[i]; /* step all the way to minimum */
---
> 	alphamin = 1.0;
> 	imin = -1;
> 	p1V = p1->V;
> 	pV = p->V;
> 	pkV = pk->V;
> 	for (i = 0; i < p->r; i++)
> 		p1V[i] = pV[i] + pkV[i]; /* step all the way to minimum */
197c238,239
<   { AV=Ain->M[i];
---
> 	{
> 		AV = Ain->M[i];
199,202c241,242
<     { Ap1=0.0;
<       for (j=0;j<Ain->c;j++) Ap1+=AV[j]*p1V[j]; /* form  A p1 = A(p+pk) */
<       if ((b->V[i]-Ap1)>0.0) /* does p+pk violate the ith constraint? */
<       { ap=0.0;apk=0.0;        /* working out quantities needed to find distance to constraint from p */
---
> 		{
> 			Ap1 = 0.0;
204c244,250
< 	{ ap+=AV[j]*pV[j];
---
> 				Ap1 += AV[j] * p1V[j]; /* form  A p1 = A(p+pk) */
> 			if ((b->V[i] - Ap1) > 0.0) /* does p+pk violate the ith constraint? */
> 			{
> 				ap = 0.0;
> 				apk = 0.0; /* working out quantities needed to find distance to constraint from p */
> 				for (j = 0; j < Ain->c; j++) {
> 					ap += AV[j] * pV[j];
207,208c253,254
< 	if (fabs(apk)>0.0)
< 	{ alpha=(b->V[i]-ap)/apk; /* p + alpha*pk is on the ith constraint */
---
> 				if (fabs(apk) > 0.0) {
> 					alpha = (b->V[i] - ap) / apk; /* p + alpha*pk is on the ith constraint */
210,211c256,260
< 	  { alphamin=max(0.0,alpha);imin=i;
<             for (j=0;j<p->r;j++) p1V[j]=pV[j]+alphamin*pkV[j]; /* 2/2/97 - avoids distance calc for all that would violate full step */
---
> 					{
> 						alphamin = max(0.0, alpha);
> 						imin = i;
> 						for (j = 0; j < p->r; j++)
> 							p1V[j] = pV[j] + alphamin * pkV[j]; /* 2/2/97 - avoids distance calc for all that would violate full step */
221,222c270,271
< 
< void LSQPdelcon(matrix *Q,matrix *T,matrix *Rf,matrix *Py,matrix *PX,int sth)
---
> void LSQPdelcon(matrix *Q, matrix *T, matrix *Rf, matrix *Py, matrix *PX,
> 		int sth)
239c288,289
< { int i,j,colj,coli,k,Tr,Tc,Qr,T1r,T1c;
---
> {
> 	int i, j, colj, coli, k, Tr, Tc, Qr, T1r, T1c;
241c291,295
<   Tr=T->r;TM=T->M;QM=Q->M;Tc=T->c;Qr=Q->r;
---
> 	Tr = T->r;
> 	TM = T->M;
> 	QM = Q->M;
> 	Tc = T->c;
> 	Qr = Q->r;
243,244c297,301
<   { coli=Tc-i-1;colj=Tc-i;    /* coli is zeroed - colj=coli+1 */
<     xi=TM[i][coli];xj=TM[i][colj];
---
> 	{
> 		coli = Tc - i - 1;
> 		colj = Tc - i; /* coli is zeroed - colj=coli+1 */
> 		xi = TM[i][coli];
> 		xj = TM[i][colj];
247c304,305
<     s=xi/r;c=xj/r;         /* Givens coefficients */
---
> 		s = xi / r;
> 		c = xj / r; /* Givens coefficients */
249c307,308
<     { TV=TM[j];
---
> 		{
> 			TV = TM[j];
255c314,315
<     { QV=QM[j];
---
> 		{
> 			QV = QM[j];
262c322,323
<     { RfV=Rf->M[j];       /* row to apply rotation to */
---
> 		{
> 			RfV = Rf->M[j]; /* row to apply rotation to */
268c329,330
<     xi=Rf->M[coli][coli];xj=Rf->M[colj][coli]; /* xj to be zeroed */
---
> 		xi = Rf->M[coli][coli];
> 		xj = Rf->M[colj][coli]; /* xj to be zeroed */
270,271c332,335
<     s=xj/r;c=xi/r;         /* Givens coefficients to zero xj into xi */
<     Rf->M[coli][coli]=r;Rf->M[colj][coli]=0.0;
---
> 		s = xj / r;
> 		c = xi / r; /* Givens coefficients to zero xj into xi */
> 		Rf->M[coli][coli] = r;
> 		Rf->M[colj][coli] = 0.0;
273,275c337,341
<     RfV=Rf->M[coli];RfV1=Rf->M[colj];
<     for (j=colj;j<Rf->c;j++)
<     { xi=RfV[j];xj=RfV1[j];
---
> 		RfV = Rf->M[coli];
> 		RfV1 = Rf->M[colj];
> 		for (j = colj; j < Rf->c; j++) {
> 			xi = RfV[j];
> 			xj = RfV1[j];
281c347,348
<     xi=Py->V[coli];xj=Py->V[colj];
---
> 		xi = Py->V[coli];
> 		xj = Py->V[colj];
286c353,355
<     { xi=PX->M[coli][j];xj=PX->M[colj][j];
---
> 		{
> 			xi = PX->M[coli][j];
> 			xj = PX->M[colj][j];
293,296c362,369
<   T->r--;T1r=T->r;T1c=T->c;
<   for (k=0;k<T1r;k++)
<   { T1V=TM[k];TV=TM[k];
<     for (j=0;j<T1c-k-1;j++) T1V[j]=0.0;
---
> 	T->r--;
> 	T1r = T->r;
> 	T1c = T->c;
> 	for (k = 0; k < T1r; k++) {
> 		T1V = TM[k];
> 		TV = TM[k];
> 		for (j = 0; j < T1c - k - 1; j++)
> 			T1V[j] = 0.0;
298,299c371,374
<     if (k<sth) T1V[j]=TV[j];
<     else T1V[j]=TM[k+1][j];
---
> 			if (k < sth)
> 				T1V[j] = TV[j];
> 			else
> 				T1V[j] = TM[k + 1][j];
303,306c378,379
< 
< 
< int LSQPlagrange(matrix *X,matrix *Q,matrix *T,matrix *p,matrix *Xy,matrix *p1,
<                  matrix *y1,int *fixed, int fixed_cons)
---
> int LSQPlagrange(matrix *X, matrix *Q, matrix *T, matrix *p, matrix *Xy,
> 		matrix *p1, matrix *y1, int *fixed, int fixed_cons)
332c405,406
< { int i,j,tk;
---
> {
> 	int i, j, tk;
337c411,412
<   for (i=0;i<p1->r;i++) p1->V[i]+= -Xy->V[i]; /* form p1 = g = X'Xp - X'y */
---
> 	for (i = 0; i < p1->r; i++)
> 		p1->V[i] += -Xy->V[i]; /* form p1 = g = X'Xp - X'y */
339,341c414,417
<   for (i=0;i<tk;i++)
<   { y1->V[i]=0.0;
<     for (j=0;j<Q->r;j++) y1->V[i]+=p1->V[j]*Q->M[j][Q->c-tk+i];
---
> 	for (i = 0; i < tk; i++) {
> 		y1->V[i] = 0.0;
> 		for (j = 0; j < Q->r; j++)
> 			y1->V[i] += p1->V[j] * Q->M[j][Q->c - tk + i];
345,346c421,428
<   { x=0.0;for (j=i+1;j<tk;j++) x+=p1->V[j]*T->M[j][T->c-i-1];
<     if (T->M[i][T->c-i-1]!=0.0) p1->V[i]=(y1->V[tk-i-1]-x)/T->M[i][T->c-i-1];else p1->V[i]=0.0;
---
> 	{
> 		x = 0.0;
> 		for (j = i + 1; j < tk; j++)
> 			x += p1->V[j] * T->M[j][T->c - i - 1];
> 		if (T->M[i][T->c - i - 1] != 0.0)
> 			p1->V[i] = (y1->V[tk - i - 1] - x) / T->M[i][T->c - i - 1];
> 		else
> 			p1->V[i] = 0.0;
349c431,432
<   x=0.0;j=-1;
---
> 	x = 0.0;
> 	j = -1;
351c434,437
<   if ((!fixed[i-fixed_cons])&&(p1->V[i]<x)) { j=i;x=p1->V[i];}
---
> 		if ((!fixed[i - fixed_cons]) && (p1->V[i] < x)) {
> 			j = i;
> 			x = p1->V[i];
> 		}
353c439,440
<   if (j!=-1) j -= fixed_cons;
---
> 	if (j != -1)
> 		j -= fixed_cons;
362c448,449
< void QPCLS(matrix *Z,matrix *X, matrix *p, matrix *y,matrix *Ain,matrix *b,matrix *Af,int *active)
---
> void QPCLS(matrix *Z, matrix *X, matrix *p, matrix *y, matrix *Ain, matrix *b,
> 		matrix *Af, int *active)
421c508,509
< { matrix Q,T,Rf,PX,Py,a,P,p1,s,c,Xy,y1,u,Pd,pz,pk;
---
> {
> 	matrix Q, T, Rf, PX, Py, a, P, p1, s, c, Xy, y1, u, Pd, pz, pk;
430c518,519
<   s=initmat(p->r,1);c=initmat(p->r,1); /* working space vectors for Givens rotation */
---
> 	s = initmat(p->r, 1);
> 	c = initmat(p->r, 1); /* working space vectors for Givens rotation */
438,442c527,536
<   for (i=0;i<p->r;i++) for (j=0;j<p->r;j++) Q.M[i][j]=0.0;
<   for (i=0;i<p->r;i++) Q.M[i][i]=1.0;
<   T.r=0;a.r=1;a.c=Af->c;
<   for (i=0;i<Af->r;i++)
<   { a.V=Af->M[i];
---
> 	for (i = 0; i < p->r; i++)
> 		for (j = 0; j < p->r; j++)
> 			Q.M[i][j] = 0.0;
> 	for (i = 0; i < p->r; i++)
> 		Q.M[i][i] = 1.0;
> 	T.r = 0;
> 	a.r = 1;
> 	a.c = Af->c;
> 	for (i = 0; i < Af->r; i++) {
> 		a.V = Af->M[i];
450c544,545
<   Py=initmat(y->r,1);mcopy(y,&Py);
---
> 	Py = initmat(y->r, 1);
> 	mcopy(y, &Py);
452c547,548
<   PX=initmat(X->r,X->c);mcopy(X,&PX);
---
> 	PX = initmat(X->r, X->c);
> 	mcopy(X, &PX);
456c552,554
<   Pd=initmat(y->r,1);pz=initmat(p->r,1);pk=initmat(p->r,1);
---
> 	Pd = initmat(y->r, 1);
> 	pz = initmat(p->r, 1);
> 	pk = initmat(p->r, 1);
459,460c557,558
<   while(1)
<   { iter++;
---
> 	while (1) {
> 		iter++;
463c561,562
<     for (i=0;i<Pd.r;i++) Pd.V[i] = Py.V[i]-Pd.V[i]; /* Pd=P(y-Xp) */
---
> 		for (i = 0; i < Pd.r; i++)
> 			Pd.V[i] = Py.V[i] - Pd.V[i]; /* Pd=P(y-Xp) */
465c564,566
<     for (i=0;i<Rf.c;i++) if (Rf.M[i][i]==0.0) error(_("QPCLS - Rank deficiency in model"));
---
> 		for (i = 0; i < Rf.c; i++)
> 			if (Rf.M[i][i] == 0.0)
> 				error(_("QPCLS - Rank deficiency in model"));
467c568,569
<     Rf.r=X->r;Rf.c=X->c; /* Restore Rf */
---
> 		Rf.r = X->r;
> 		Rf.c = X->c; /* Restore Rf */
470,471c572,576
<     for (i=0;i<pk.r;i++)
<     { pk.V[i]=0.0; for (j=0;j<pz.r;j++) pk.V[i]+=Q.M[i][j]*pz.V[j];}
---
> 		for (i = 0; i < pk.r; i++) {
> 			pk.V[i] = 0.0;
> 			for (j = 0; j < pz.r; j++)
> 				pk.V[i] += Q.M[i][j] * pz.V[j];
> 		}
476,477c581,585
<     { I[tk]=k;ignore[k]=1; /* keeping track of what's in working set */
<       LSQPaddcon(Ain,&Q,&T,&Rf,&Py,&PX,&s,&c,k);tk++;
---
> 		{
> 			I[tk] = k;
> 			ignore[k] = 1; /* keeping track of what's in working set */
> 			LSQPaddcon(Ain, &Q, &T, &Rf, &Py, &PX, &s, &c, k);
> 			tk++;
482c590,591
<     { k=LSQPlagrange(X,&Q,&T,p,&Xy,&p1,&y1,fixed,(int)Af->r);
---
> 		{
> 			k = LSQPlagrange(X, &Q, &T, p, &Xy, &p1, &y1, fixed, (int) Af->r);
484c593,594
<       { LSQPdelcon(&Q,&T,&Rf,&Py,&PX,k+(int)Af->r);  /* the Af.r added to k ensures that correct row of T deleted */
---
> 			{
> 				LSQPdelcon(&Q, &T, &Rf, &Py, &PX, k + (int) Af->r); /* the Af.r added to k ensures that correct row of T deleted */
487c597,598
<         { for (i=k;i<tk-1;i++)
---
> 				{
> 					for (i = k; i < tk - 1; i++)
492c603,604
<         { ignore[I[k]]=0;
---
> 				{
> 					ignore[I[k]] = 0;
494c606,607
<           for (i=k;i<tk;i++) I[i]=I[i+1];
---
> 					for (i = k; i < tk; i++)
> 						I[i] = I[i + 1];
499c612,615
<         x=0.0;for (i=0;i<c.r;i++) if (P.V[i]-b->V[i]<x) x=P.V[i]-b->V[i];
---
> 				x = 0.0;
> 				for (i = 0; i < c.r; i++)
> 					if (P.V[i] - b->V[i] < x)
> 						x = P.V[i] - b->V[i];
502c618,619
<         *Z=Q; Z->c -= tk;
---
> 				*Z = Q;
> 				Z->c -= tk;
505c622,623
<         for (i=0;i<tk;i++) active[i+1]=I[i]; 
---
> 				for (i = 0; i < tk; i++)
> 					active[i + 1] = I[i];
507,509c625,641
<         freemat(T);freemat(Rf);freemat(PX);freemat(Py);freemat(p1);freemat(y1);
<         freemat(s);freemat(c);freemat(Xy);freemat(Pd);freemat(pz);freemat(pk);
<         FREE(I);FREE(ignore);freemat(P);FREE(fixed);FREE(delog);
---
> 				freemat(T);
> 				freemat(Rf);
> 				freemat(PX);
> 				freemat(Py);
> 				freemat(p1);
> 				freemat(y1);
> 				freemat(s);
> 				freemat(c);
> 				freemat(Xy);
> 				freemat(Pd);
> 				freemat(pz);
> 				freemat(pk);
> 				FREE(I);
> 				FREE(ignore);
> 				freemat(P);
> 				FREE(fixed);
> 				FREE(delog);
519c650,651
<           matrix *Af,matrix *H,matrix *S,int *off,double *theta,int m,int *active)
---
> 		matrix *Af, matrix *H, matrix *S, int *off, double *theta, int m,
> 		int *active)
551c683,684
< { int i,j,k;
---
> {
> 	int i, j, k;
556c689,692
<   if (m>0) z=initmat(y->r+p->r,1);else z=initmat(y->r,1);
---
> 	if (m > 0)
> 		z = initmat(y->r + p->r, 1);
> 	else
> 		z = initmat(y->r, 1);
558c694,697
<   for (i=0;i<y->r;i++) { W.V[i]=sqrt(w->V[i]);z.V[i]=W.V[i]*y->V[i];}
---
> 	for (i = 0; i < y->r; i++) {
> 		W.V[i] = sqrt(w->V[i]);
> 		z.V[i] = W.V[i] * y->V[i];
> 	}
562c701,703
<   for (i=0;i<X->r;i++) for (j=0;j<X->c;j++) F.M[i][j]=W.V[i]*X->M[i][j];
---
> 	for (i = 0; i < X->r; i++)
> 		for (j = 0; j < X->c; j++)
> 			F.M[i][j] = W.V[i] * X->M[i][j];
565,567c706,710
<   if (m>0)
<   { B=initmat(p->r,p->r);
<     for (k=0;k<m;k++) for (i=0;i<S[k].r;i++) for (j=0;j<S[k].c;j++)
---
> 	if (m > 0) {
> 		B = initmat(p->r, p->r);
> 		for (k = 0; k < m; k++)
> 			for (i = 0; i < S[k].r; i++)
> 				for (j = 0; j < S[k].c; j++)
574,575c717,721
<     for (i=0;i<C.r;i++) for (j=0;j<C.c;j++) F.M[j+X->r][i]=C.M[i][j];
<     freemat(B);freemat(C);
---
> 		for (i = 0; i < C.r; i++)
> 			for (j = 0; j < C.c; j++)
> 				F.M[j + X->r][i] = C.M[i][j];
> 		freemat(B);
> 		freemat(C);
581,582c727,731
<   { freemat(W);W=initmat(Z.c,Z.c);
<     multi(4,W,Z,F,F,Z,1,1,0,0);invert(&W); /* Wildly inefficient!! */
---
> 	{
> 		freemat(W);
> 		W = initmat(Z.c, Z.c);
> 		multi(4, W, Z, F, F, Z, 1, 1, 0, 0);
> 		invert(&W); /* Wildly inefficient!! */
584c733,735
<     for (i=0;i<H->r;i++) for (j=0;j<H->c;j++) H->M[i][j]*=w->V[j];
---
> 		for (i = 0; i < H->r; i++)
> 			for (j = 0; j < H->c; j++)
> 				H->M[i][j] *= w->V[j];
587,588c738,744
<   B=initmat(z.r,1);matmult(B,F,*p,0,0);
<   xx=0.0;for (i=0;i<z.r;i++) { x=B.V[i]-z.V[i];xx+=x*x;}
---
> 	B = initmat(z.r, 1);
> 	matmult(B, F, *p, 0, 0);
> 	xx = 0.0;
> 	for (i = 0; i < z.r; i++) {
> 		x = B.V[i] - z.V[i];
> 		xx += x * x;
> 	}
591c747,750
<   freemat(F);freemat(z);freemat(W);freemat(Z);
---
> 	freemat(F);
> 	freemat(z);
> 	freemat(W);
> 	freemat(Z);
diff -rEZbwB '--exclude=*.[lo,d,pdf,mo,po,tgz,gz,save]*' '--exclude=MD5' '--exclude=Makefile*' '--exclude=all.R' '--exclude=Changes' R-recommended/mgcv/src/qp.h Recommended/mgcv/src/qp.h
7c7,8
< void QPCLS(matrix *Z,matrix *X, matrix *p, matrix *y,matrix *Ain,matrix *b,matrix *Af,int *active);
---
> void QPCLS(matrix *Z, matrix *X, matrix *p, matrix *y, matrix *Ain, matrix *b,
> 		matrix *Af, int *active);
9,10c10,11
<           matrix *Af,matrix *H,matrix *S,int *off,double *theta,int m, int *active);
< 
---
> 		matrix *Af, matrix *H, matrix *S, int *off, double *theta, int m,
> 		int *active);
14,15c15,16
< typedef struct
< { long constraints;
---
> typedef struct {
> 	long constraints;
diff -rEZbwB '--exclude=*.[lo,d,pdf,mo,po,tgz,gz,save]*' '--exclude=MD5' '--exclude=Makefile*' '--exclude=all.R' '--exclude=Changes' R-recommended/mgcv/src/sparse-smooth.c Recommended/mgcv/src/sparse-smooth.c
23a24
> #include "localization.h"
142c143
<     if (kd.box[i].p1-kd.box[i].p0>1) { Rprintf("More than 2 points in a box!!\n");ok=0;}
---
>     if (kd.box[i].p1-kd.box[i].p0>1) { Rprintf(_("More than 2 points in a box!!\n"));ok=0;}
147c148
<     if (count[i]!=1) { Rprintf("point %d in %d boxes!\n",i,count[i]);ok=0;}
---
>     if (count[i]!=1) { Rprintf(_("point %d in %d boxes!\n"),i,count[i]);ok=0;}
149c150
<   if (ok) Rprintf("kd tree sanity checks\n");
---
>   if (ok) Rprintf(_("kd tree sanity checks\n"));
309c310
<     if (bi>nb-1) Rprintf("too many boxes!!");
---
>     if (bi>nb-1) Rprintf(_("too many boxes!!"));
325c326
<     if (bi>nb-1) Rprintf("too many boxes!!");
---
>     if (bi>nb-1) Rprintf(_("too many boxes!!"));
341c342
<   if (bi!=nb-1) Rprintf("bi not equal to nb-1 %d %d\n",bi,nb-1);
---
>   if (bi!=nb-1) Rprintf(_("bi not equal to nb-1 %d %d\n"),bi,nb-1);
550c551
<   if (kd->d!=2) Rprintf("\n star only useful in 2D\n");
---
>   if (kd->d!=2) Rprintf(_("\n 'star()' function is useful only in 2D\n"));
607c608
<       if (!check) Rprintf("indexing error in p_area!\n");
---
>       if (!check) Rprintf(_("indexing error in p_area!\n"));
1054c1055
<       Rprintf("hello\n");
---
>       Rprintf(_("hello\n"));
1086c1087
<           Rprintf("%d upper neighbour claimed to be self d=%d!\n",i,j);
---
>           Rprintf(_("%d upper neighbour claimed to be self d=%d!\n"),i,j);
1149c1150
<           Rprintf("lower neighbour claimed to be self!\n");
---
>           Rprintf(_("lower neighbour claimed to be self!\n"));
diff -rEZbwB '--exclude=*.[lo,d,pdf,mo,po,tgz,gz,save]*' '--exclude=MD5' '--exclude=Makefile*' '--exclude=all.R' '--exclude=Changes' R-recommended/mgcv/src/tprs.c Recommended/mgcv/src/tprs.c
25a26
> #include "localization.h"
39,40c38,41
<   d2 = d/2;m2 = 2*m;
<   if (m2 <= d) error(_("You must have 2m>d for a thin plate spline."));
---
> 	d2 = d / 2;
> 	m2 = 2 * m;
> 	if (m2 <= d)
> 		error(_("You must have 2m>d for a thin plate spline."));
42,46c43,55
<   { if ((m+1+d2)%2) f= -1.0; else f=1.0; /* finding (-1)^{m+1+d/2} */
<     for (i=0;i<m2-1;i++) f/=2;  /* dividing by 2^{2m-1} */
<     for (i=0;i<d2;i++) f/=pi;  /* dividing by pi^{d/2} */
<     for (i=2;i<m;i++) f/=i; /* dividing by (m-1)! */
<     for (i=2;i<=m-d2;i++) f/=i; /* dividing by (m-d/2)! */
---
> 	{
> 		if ((m + 1 + d2) % 2)
> 			f = -1.0;
> 		else
> 			f = 1.0; /* finding (-1)^{m+1+d/2} */
> 		for (i = 0; i < m2 - 1; i++)
> 			f /= 2; /* dividing by 2^{2m-1} */
> 		for (i = 0; i < d2; i++)
> 			f /= pi; /* dividing by pi^{d/2} */
> 		for (i = 2; i < m; i++)
> 			f /= i; /* dividing by (m-1)! */
> 		for (i = 2; i <= m - d2; i++)
> 			f /= i; /* dividing by (m-d/2)! */
48c57,58
<   { f=Ghalf;
---
> 	{
> 		f = Ghalf;
50,52c60,65
<     for (i=0;i<k;i++) f/= -0.5-i; /* f = gamma function of d/2-m */
<     for (i=0;i<m;i++) f/= 4; /* divide by 2^{2m} */
<     for (i=0;i<d2;i++) f/=pi;
---
> 		for (i = 0; i < k; i++)
> 			f /= -0.5 - i; /* f = gamma function of d/2-m */
> 		for (i = 0; i < m; i++)
> 			f /= 4; /* divide by 2^{2m} */
> 		for (i = 0; i < d2; i++)
> 			f /= pi;
54c67,68
<     for (i=2;i<m;i++) f/=i;  /* divide by (m-1)! */
---
> 		for (i = 2; i < m; i++)
> 			f /= i; /* divide by (m-1)! */
63c77,78
<   if (r<=0.0) return(0.0); /* this is safe: even if eta() gets inlined so that r comes in in an fp register! */
---
> 	if (r <= 0.0)
> 		return (0.0); /* this is safe: even if eta() gets inlined so that r comes in in an fp register! */
66c81,82
<     for (i=0;i<m-d2;i++) f *= r; /* r^2m-d (noting r is really r^2) */
---
> 		for (i = 0; i < m - d2; i++)
> 			f *= r; /* r^2m-d (noting r is really r^2) */
68c84,85
<     for (i=0;i<m-d2-1 ;i++) f *= r; /* note r really r^2 */
---
> 		for (i = 0; i < m - d2 - 1; i++)
> 			f *= r; /* note r really r^2 */
79c96,97
< { int i,j,k,Xr,Xc;
---
> {
> 	int i, j, k, Xr, Xc;
84,86c102,107
<   XMi = X->M;Xr = X->r;Xc = X->c;
<   for (i=0;i<Xr;i++,XMi++) for (XMj = X->M,j=0;j<i;j++,XMj++)
<   { r=0.0;
---
> 	XMi = X->M;
> 	Xr = X->r;
> 	Xc = X->c;
> 	for (i = 0; i < Xr; i++, XMi++)
> 		for (XMj = X->M, j = 0; j < i; j++, XMj++) {
> 			r = 0.0;
107c127,128
< { int *index,i,j,sum;
---
> {
> 	int *index, i, j, sum;
109,110c130
<   for (i=0;i < *M;i++)
<   { /* copy index to pi */
---
> 	for (i = 0; i < *M; i++) { /* copy index to pi */
112c132,133
<     for (j=0;j< *d;j++) pi[i + *M * j]=index[j];
---
> 		for (j = 0; j < *d; j++)
> 			pi[i + *M * j] = index[j];
114c135,137
<     sum=0;for (j=0;j< *d;j++) sum += index[j];
---
> 		sum = 0;
> 		for (j = 0; j < *d; j++)
> 			sum += index[j];
118c141,142
<     { sum -= index[0];
---
> 		{
> 			sum -= index[0];
120,123c144,151
<       for (j=1;j< *d;j++)
<       { index[j]++;sum++;
<         if (sum== *m) { sum-=index[j];index[j]=0;}
<         else break; /* problem resolved! */
---
> 			for (j = 1; j < *d; j++) {
> 				index[j]++;
> 				sum++;
> 				if (sum == *m) {
> 					sum -= index[j];
> 					index[j] = 0;
> 				} else
> 					break; /* problem resolved! */
138c165,166
< { int M,i,j,k,*pin,z;
---
> {
> 	int M, i, j, k, *pin, z;
141,142c169,172
<   for (i=0;i<d;i++) M*=d+m-1-i;
<   for (i=2;i<=d;i++) M/=i;     /* M = (m+d+1)!/(d!(m-d!) */
---
> 	for (i = 0; i < d; i++)
> 		M *= d + m - 1 - i;
> 	for (i = 2; i <= d; i++)
> 		M /= i; /* M = (m+d+1)!/(d!(m-d!) */
152,154c182,186
<   for (j=0;j<M;j++)
<   { x=1.0;/* for (k=0;k<d;k++) for (z=0;z<pin[j][k];z++) x *= X->M[i][k]; */
<     for (k=0;k<d;k++) for (z=0;z<pin[j + M * k];z++) x *= X->M[i][k];
---
> 		for (j = 0; j < M; j++) {
> 			x = 1.0;/* for (k=0;k<d;k++) for (z=0;z<pin[j][k];z++) x *= X->M[i][k]; */
> 			for (k = 0; k < d; k++)
> 				for (z = 0; z < pin[j + M * k]; z++)
> 					x *= X->M[i][k];
169,170c200,206
< { int M,i;
<   if (2*m<=d) {m=1;while (2*m<d+2) m++;} 
---
> {
> 	int M, i;
> 	if (2 * m <= d) {
> 		m = 1;
> 		while (2 * m < d + 2)
> 			m++;
> 	}
172,173c208,211
<   for (i=0;i<d;i++) M*=d+m-1-i;/* get (m+d-1)!/(m-1)! = (m+d-1)*(m+d-2) ... *(m) -- d terms */ 
<   for (i=2;i<=d;i++) M/=i;     /* M = (m+d-1)!/(d!(m-1)!) */
---
> 	for (i = 0; i < d; i++)
> 		M *= d + m - 1 - i;/* get (m+d-1)!/(m-1)! = (m+d-1)*(m+d-2) ... *(m) -- d terms */
> 	for (i = 2; i <= d; i++)
> 		M /= i; /* M = (m+d-1)!/(d!(m-1)!) */
177,178c215,216
< 
< double tps_g(matrix *X,matrix *p,double *x,int d,int m,double *b,int constant)
---
> double tps_g(matrix *X, matrix *p, double *x, int d, int m, double *b,
> 		int constant)
200c238,239
< { static int sd=0,sm=0,*pin,M;
---
> {
> 	static int sd = 0, sm = 0, *pin, M;
204,205c243,249
<   if (sd==0&&d==0) return(0.0); /* There is nothing to clear up and nothing to calculate */
<   if (2*m<=d&&d>0) { m=0;while (2*m<d+2) m++;} 
---
> 	if (sd == 0 && d == 0)
> 		return (0.0); /* There is nothing to clear up and nothing to calculate */
> 	if (2 * m <= d && d > 0) {
> 		m = 0;
> 		while (2 * m < d + 2)
> 			m++;
> 	}
207,209c251,256
<   { if (sd>0&&sm>0) 
<     { /*for (i=0;i<M;i++) FREE(pin[i]);*/ FREE(pin);}
<     sd=d;sm=m;
---
> 	{
> 		if (sd > 0 && sm > 0) { /*for (i=0;i<M;i++) FREE(pin[i]);*/
> 			FREE(pin);
> 		}
> 		sd = d;
> 		sm = m;
211,213c258,263
<     { M=1;     /* dimension of penalty null space */
<       for (i=0;i<d;i++) M*=d+m-1-i;
<       for (i=2;i<=d;i++) M/=i;     /* M = (m+d+1)!/(d!(m-d!) */
---
> 		{
> 			M = 1; /* dimension of penalty null space */
> 			for (i = 0; i < d; i++)
> 				M *= d + m - 1 - i;
> 			for (i = 2; i <= d; i++)
> 				M /= i; /* M = (m+d+1)!/(d!(m-d!) */
219c269,270
<     } else return(0.0);
---
> 		} else
> 			return (0.0);
221,224c272,282
<   g=0.0;XM=X->M;n = X->r;
<   for (pb=b,i=0;i<n;i++,pb++)
<   { r=0.0;XMi=XM[i];
<     for (dum=x;dum<x+d;dum++) { z= *XMi - *dum;XMi++;r+=z*z;}
---
> 	g = 0.0;
> 	XM = X->M;
> 	n = X->r;
> 	for (pb = b, i = 0; i < n; i++, pb++) {
> 		r = 0.0;
> 		XMi = XM[i];
> 		for (dum = x; dum < x + d; dum++) {
> 			z = *XMi - *dum;
> 			XMi++;
> 			r += z * z;
> 		}
227c285,286
<     if (p->r) g += *pb *p->V[i];
---
> 		if (p->r)
> 			g += *pb * p->V[i];
231c290,291
<   { r=1.0;
---
> 	{
> 		r = 1.0;
234c294,296
<     for (j=0;j<d;j++) for (k=0;k<pin[i+M*j];k++)  r*=x[j];
---
> 		for (j = 0; j < d; j++)
> 			for (k = 0; k < pin[i + M * j]; k++)
> 				r *= x[j];
236c298,299
<     if (p->r) g+=p->V[i+n-off]*r;
---
> 		if (p->r)
> 			g += p->V[i + n - off] * r;
245,246c308,312
< { int i;
<   for (i=0;i<k;i++) if (a[i]!=b[i]) return(0);
---
> {
> 	int i;
> 	for (i = 0; i < k; i++)
> 		if (a[i] != b[i])
> 			return (0);
267c333,334
< { int *yxindex,start,stop,ok,i;
---
> {
> 	int *yxindex, start, stop, ok, i;
272,276c339,343
<   start=stop=0;ok=1;
<   while(ok)
<   { /* look for start of run of equal rows ..... */
<     while(start<Xd->r-1&&!Xd_row_comp(Xd->M[start],Xd->M[start+1],Xd->c-1)) 
<     { /* Xd->M[start] not tied with anything, nothing to erase.... */
---
> 	start = stop = 0;
> 	ok = 1;
> 	while (ok) { /* look for start of run of equal rows ..... */
> 		while (start < Xd->r - 1
> 				&& !Xd_row_comp(Xd->M[start], Xd->M[start + 1], Xd->c - 1)) { /* Xd->M[start] not tied with anything, nothing to erase.... */
281,282c348,349
<     if (start==Xd->r-1) 
<     { ok=0; /* reached end with no more ties */
---
> 		if (start == Xd->r - 1) {
> 			ok = 0; /* reached end with no more ties */
287,288c354,358
<     { stop=start+1;
<       while(stop<Xd->r-1&&Xd_row_comp(Xd->M[stop],Xd->M[stop+1],Xd->c-1)) stop++;
---
> 		{
> 			stop = start + 1;
> 			while (stop < Xd->r - 1
> 					&& Xd_row_comp(Xd->M[stop], Xd->M[stop + 1], Xd->c - 1))
> 				stop++;
290c360,361
<       { xi=Xd->M[i][Xd->c-1];
---
> 			{
> 				xi = Xd->M[i][Xd->c - 1];
294,295c365,367
<       for (i=stop+1;i<Xd->r;i++)
<       { Xd->M[i-stop+start]=Xd->M[i];}
---
> 			for (i = stop + 1; i < Xd->r; i++) {
> 				Xd->M[i - stop + start] = Xd->M[i];
> 			}
297,298c369,371
<       for (i=1;i<=stop-start;i++)
<       { Xd->M[Xd->r-1+i]=dum[i];}
---
> 			for (i = 1; i <= stop - start; i++) {
> 				Xd->M[Xd->r - 1 + i] = dum[i];
> 			}
305,306c378,379
< void tprs_setup(double **x,double **knt,int m,int d,int n,int k,int constant,matrix *X,matrix *S,
<                 matrix *UZ,matrix *Xu,int n_knots)
---
> void tprs_setup(double **x, double **knt, int m, int d, int n, int k,
> 		int constant, matrix *X, matrix *S, matrix *UZ, matrix *Xu, int n_knots)
355c428,429
< { matrix X1,E,U,v,TU,T,Z,p;
---
> {
> 	matrix X1, E, U, v, TU, T, Z, p;
358c432,433
<   double w,*xc,*XMi,*Ea,*Ua,tol=DOUBLE_EPS,*b,*a,*uz,alpha=1.0,beta=0.0,*p0,*p1;
---
> 	double w, *xc, *XMi, *Ea, *Ua, tol = DOUBLE_EPS, *b, *a, *uz, alpha = 1.0,
> 			beta = 0.0, *p0, *p1;
362,363c437,443
<   { *Xu=initmat(n,d+1);
<     for (i=0;i<n;i++) { for (j=0;j<d;j++) Xu->M[i][j]=x[j][i];Xu->M[i][d]=(double)i;}
---
> 	{
> 		*Xu = initmat(n, d + 1);
> 		for (i = 0; i < n; i++) {
> 			for (j = 0; j < d; j++)
> 				Xu->M[i][j] = x[j][i];
> 			Xu->M[i][d] = (double) i;
> 		}
365,366c445,451
<   { *Xu=initmat(n_knots,d+1);
<     for (i=0;i<n_knots;i++) { for (j=0;j<d;j++) Xu->M[i][j]=knt[j][i];Xu->M[i][d]=(double)i;}
---
> 	{
> 		*Xu = initmat(n_knots, d + 1);
> 		for (i = 0; i < n_knots; i++) {
> 			for (j = 0; j < d; j++)
> 				Xu->M[i][j] = knt[j][i];
> 			Xu->M[i][d] = (double) i;
> 		}
375,376c459,466
<   error(_("A term has fewer unique covariate combinations than specified maximum degrees of freedom"));
<   if (2*m<=d) { m=0;while (2*m<d+2) m++;} 
---
> 		error(
> 				_(
> 						"A term has fewer unique covariate combinations than specified maximum degrees of freedom"));
> 	if (2 * m <= d) {
> 		m = 0;
> 		while (2 * m < d + 2)
> 			m++;
> 	}
382,383c472,477
<   {  k=M+1;
<      if (Xu->r<k) error(_("A term has fewer unique covariate combinations than specified maximum degrees of freedom"));
---
> 	{
> 		k = M + 1;
> 		if (Xu->r < k)
> 			error(
> 					_(
> 							"A term has fewer unique covariate combinations than specified maximum degrees of freedom"));
385c479,480
<   if (Xu->r==k) pure_knot=1; /* basis dimension is number of knots - don't need eigen step */
---
> 	if (Xu->r == k)
> 		pure_knot = 1; /* basis dimension is number of knots - don't need eigen step */
388c483,484
<   { *UZ=initmat(T.r+M-1+constant,T.r);
---
> 	{
> 		*UZ = initmat(T.r + M - 1 + constant, T.r);
391c487,489
<     for (i=0;i<T.r;i++) for (j=0;j<T.c;j++) TU.M[j][i]=T.M[i][j];
---
> 		for (i = 0; i < T.r; i++)
> 			for (j = 0; j < T.c; j++)
> 				TU.M[j][i] = T.M[i][j];
393c491,493
<     for (i=0;i<T.r;i++) for (j=0;j<T.c;j++) TU.M[j][i]=T.M[i][j];
---
> 		for (i = 0; i < T.r; i++)
> 			for (j = 0; j < T.c; j++)
> 				TU.M[j][i] = T.M[i][j];
396,398c496,497
<   } else
<   { v=initmat(k,1);    /* eigen-value matrix for E */
< 
---
> 	} else {
> 		v = initmat(k, 1); /* eigen-value matrix for E */
404c503,504
<       minus = -1;kk=k; 
---
> 		minus = -1;
> 		kk = k;
408,409c508,510
<       U = Rmatrix(Ua,E.r,k);FREE(Ea);FREE(Ua);
<     
---
> 		U = Rmatrix(Ua, E.r, k);
> 		FREE(Ea);
> 		FREE(Ua);
419c520,521
<     *UZ=initmat(U.r+M-1+constant,U.c);UZ->r=U.r;
---
> 		*UZ = initmat(U.r + M - 1 + constant, U.c);
> 		UZ->r = U.r;
421c523,524
<     HQmult(*UZ,Z,0,0);UZ->c -= M;      /* Now UZ multiplied by truncated delta gives full delta */
---
> 		HQmult(*UZ, Z, 0, 0);
> 		UZ->c -= M; /* Now UZ multiplied by truncated delta gives full delta */
426,427c529,533
<   for (i=0;i<E.r;i++) for (j=k-M;j<UZ->c;j++) UZ->M[i][j]=0.0;
<   for (i=0;i<M-1+constant;i++) UZ->M[UZ->r-i-1][UZ->c-i-1]=1.0;
---
> 	for (i = 0; i < E.r; i++)
> 		for (j = k - M; j < UZ->c; j++)
> 			UZ->M[i][j] = 0.0;
> 	for (i = 0; i < M - 1 + constant; i++)
> 		UZ->M[UZ->r - i - 1][UZ->c - i - 1] = 1.0;
431c537,538
<   { X1=initmat(U.r,k);
---
> 	{
> 		X1 = initmat(U.r, k);
433c540,542
<     for (i=0;i<X1.r;i++) for (j=0;j<X1.c;j++) X1.M[i][j]*=v.V[j];
---
> 		for (i = 0; i < X1.r; i++)
> 			for (j = 0; j < X1.c; j++)
> 				X1.M[i][j] *= v.V[j];
435c544,546
<     for (i=0;i<X1.r;i++) for (j=X1.c-M;j<X1.c;j++) X1.M[i][j]=0.0;
---
> 		for (i = 0; i < X1.r; i++)
> 			for (j = X1.c - M; j < X1.c; j++)
> 				X1.M[i][j] = 0.0;
438,440c549,557
<     for (i=0;i<X1.r;i++) for (j=0;j<T.c;j++) X1.M[i][X1.c-M+j]=T.M[i][j];
<     else 
<     { for (i=0;i<X1.r;i++) for (j=1;j<T.c;j++) X1.M[i][X1.c-M+j-1]=T.M[i][j];X1.c--;}
---
> 			for (i = 0; i < X1.r; i++)
> 				for (j = 0; j < T.c; j++)
> 					X1.M[i][X1.c - M + j] = T.M[i][j];
> 		else {
> 			for (i = 0; i < X1.r; i++)
> 				for (j = 1; j < T.c; j++)
> 					X1.M[i][X1.c - M + j - 1] = T.M[i][j];
> 			X1.c--;
> 		}
444,446c561,564
<     for (i=0;i<n;i++)
<     { l=yxindex[i];
<       for (j=0;j<X1.c;j++) X->M[i][j]=X1.M[l][j];
---
> 		for (i = 0; i < n; i++) {
> 			l = yxindex[i];
> 			for (j = 0; j < X1.c; j++)
> 				X->M[i][j] = X1.M[l][j];
450c568,569
<   { p.r=0; /* don't want a value from tps_g() */
---
> 	{
> 		p.r = 0; /* don't want a value from tps_g() */
461c580,581
<       for (j=0;j<d;j++) xc[j]=x[j][i];
---
> 			for (j = 0; j < d; j++)
> 				xc[j] = x[j][i];
466c586,587
<       F77_CALL(dgemv)(&trans,&kk,&k,&alpha,uz,&kk, b, &one,&beta, a, &one); /* BLAS call for (UZ)'b */
---
> 			F77_CALL(dgemv)(&trans, &kk, &k, &alpha, uz, &kk, b, &one, &beta, a,
> 					&one); /* BLAS call for (UZ)'b */
468c589,590
<       for (p0=a,p1=a+k;p0<p1;p0++,XMi++) *XMi = *p0;
---
> 			for (p0 = a, p1 = a + k; p0 < p1; p0++, XMi++)
> 				*XMi = *p0;
477c599,602
<     FREE(xc);FREE(b);FREE(a);FREE(uz);
---
> 		FREE(xc);
> 		FREE(b);
> 		FREE(a);
> 		FREE(uz);
481,485c606,619
<   if (pure_knot) mcopy(&E,S);
<   else for (i=0;i<v.r;i++) S->M[i][i]=v.V[i];
<   HQmult(*S,Z,0,0);HQmult(*S,Z,1,1);
<   for (i=0;i<S->r;i++) for (j=S->r-M;j<S->r;j++) S->M[i][j]=S->M[j][i]=0.0;
<   if (!constant) {S->r--;S->c--;}
---
> 	if (pure_knot)
> 		mcopy(&E, S);
> 	else
> 		for (i = 0; i < v.r; i++)
> 			S->M[i][i] = v.V[i];
> 	HQmult(*S, Z, 0, 0);
> 	HQmult(*S, Z, 1, 1);
> 	for (i = 0; i < S->r; i++)
> 		for (j = S->r - M; j < S->r; j++)
> 			S->M[i][j] = S->M[j][i] = 0.0;
> 	if (!constant) {
> 		S->r--;
> 		S->c--;
> 	}
491,496c625,646
<   for (i=0;i<X->c;i++)
<   { w=0; for (j=0;j<X->r;j++) w+=X->M[j][i]*X->M[j][i]; w=sqrt(w/X->r);
<     for (j=0;j<X->r;j++) X->M[j][i]/=w;
<     for (j=0;j<UZ->r;j++) UZ->M[j][i]/=w;
<     for (j=0;j<S->r;j++) S->M[i][j]/=w;
<     for (j=0;j<S->r;j++) S->M[j][i]/=w;
---
> 	for (i = 0; i < X->c; i++) {
> 		w = 0;
> 		for (j = 0; j < X->r; j++)
> 			w += X->M[j][i] * X->M[j][i];
> 		w = sqrt(w / X->r);
> 		for (j = 0; j < X->r; j++)
> 			X->M[j][i] /= w;
> 		for (j = 0; j < UZ->r; j++)
> 			UZ->M[j][i] /= w;
> 		for (j = 0; j < S->r; j++)
> 			S->M[i][j] /= w;
> 		for (j = 0; j < S->r; j++)
> 			S->M[j][i] /= w;
> 	}
> 	FREE(yxindex);
> 	freemat(Z);
> 	freemat(TU);
> 	freemat(E);
> 	freemat(T);
> 	if (!pure_knot) {
> 		freemat(U);
> 		freemat(v);
498,499d647
<   FREE(yxindex);freemat(Z);freemat(TU);freemat(E);freemat(T);
<   if (!pure_knot) {freemat(U);freemat(v);}
502,504c650,652
< 
< void construct_tprs(double *x,int *d,int *n,double *knt,int *nk,int *m,int *k,double *X,double *S,
<                     double *UZ,double *Xu,int *nXu,double *C)
---
> void construct_tprs(double *x, int *d, int *n, double *knt, int *nk, int *m,
> 		int *k, double *X, double *S, double *UZ, double *Xu, int *nXu,
> 		double *C)
520c668,669
< { double **xx,**kk=NULL,*dum,**XM;
---
> {
> 	double **xx, **kk = NULL, *dum, **XM;
524,527c673,678
<   for (i=0;i<*d;i++) xx[i]=x + i * *n;
<   if (*nk)
<   { kk=(double **)CALLOC((size_t)(*d),sizeof(double*));
<     for (i=0;i<*d;i++) kk[i]=knt + i * *nk;
---
> 	for (i = 0; i < *d; i++)
> 		xx[i] = x + i * *n;
> 	if (*nk) {
> 		kk = (double **) CALLOC((size_t) (*d), sizeof(double*));
> 		for (i = 0; i < *d; i++)
> 			kk[i] = knt + i * *nk;
536,539c687,693
<   dum=C;XM=Xm.M;Xr=Xm.r;
<   for (i=0;i< *k;i++)
<   { *dum = 0.0;
<     for (j=0;j<Xr;j++) *dum += XM[j][i];
---
> 	dum = C;
> 	XM = Xm.M;
> 	Xr = Xm.r;
> 	for (i = 0; i < *k; i++) {
> 		*dum = 0.0;
> 		for (j = 0; j < Xr; j++)
> 			*dum += XM[j][i];
542,543c696,702
<   freemat(Xm);freemat(Sm);freemat(UZm);freemat(Xum);
<   FREE(xx);if(*nk) FREE(kk);
---
> 	freemat(Xm);
> 	freemat(Sm);
> 	freemat(UZm);
> 	freemat(Xum);
> 	FREE(xx);
> 	if (*nk)
> 		FREE(kk);
546,547c705,706
< void predict_tprs(double *x, int *d,int *n,int *m,int *k,int *M,double *Xu,int *nXu,
<                   double *UZ,double *by,int *by_exists,double *X)
---
> void predict_tprs(double *x, int *d, int *n, int *m, int *k, int *M, double *Xu,
> 		int *nXu, double *UZ, double *by, int *by_exists, double *X)
558,559c717,719
< { double *b,by_mult,*xx,*a,*xp,*xxp,*xxp1,*xp1,*Xp,alpha=1.0,beta=0.0,*Xup,*Xup1,r,z,*pb,
<          eta0;
---
> {
> 	double *b, by_mult, *xx, *a, *xp, *xxp, *xxp1, *xp1, *Xp, alpha = 1.0,
> 			beta = 0.0, *Xup, *Xup1, r, z, *pb, eta0;
563c723,727
<   if (2 * *m <= *d && *d > 0) { *m = 0;while ( 2 * *m < *d+2) (*m)++;} 
---
> 	if (2 * *m <= *d && *d > 0) {
> 		*m = 0;
> 		while (2 * *m < *d + 2)
> 			(*m)++;
> 	}
576,577c740,744
<   for (Xp=X,xp=x,i=0;i< *n;i++,xp++,Xp++) 
<   { if (*by_exists) by_mult=by[i]; else by_mult=1.0;
---
> 	for (Xp = X, xp = x, i = 0; i < *n; i++, xp++, Xp++) {
> 		if (*by_exists)
> 			by_mult = by[i];
> 		else
> 			by_mult = 1.0;
580c747,748
<       for (xxp=Xp,j=0;j < *k;j++,xxp+= *n) *xxp = 0.0; 
---
> 			for (xxp = Xp, j = 0; j < *k; j++, xxp += *n)
> 				*xxp = 0.0;
582c750,752
<       for (xxp=xx,xxp1=xx + *d,xp1=xp;xxp < xxp1;xxp++,xp1 += *n) *xxp = *xp1; /*xx[j]=x[j * *n + i];*/
---
> 			for (xxp = xx, xxp1 = xx + *d, xp1 = xp; xxp < xxp1; xxp++, xp1 +=
> 					*n)
> 				*xxp = *xp1; /*xx[j]=x[j * *n + i];*/
586c756,760
<         for (xxp=xx,xxp1=xx + *d,xp1=Xup;xxp<xxp1;xxp++,xp1+= *nXu) { z = *xp1 - *xxp;r += z*z;}
---
> 				for (xxp = xx, xxp1 = xx + *d, xp1 = Xup; xxp < xxp1;
> 						xxp++, xp1 += *nXu) {
> 					z = *xp1 - *xxp;
> 					r += z * z;
> 				}
593c767,769
<         for (j=0;j<*d;j++) for (kk=0;kk<pin[l + *M * j];kk++)  r *= xx[j];
---
> 				for (j = 0; j < *d; j++)
> 					for (kk = 0; kk < pin[l + *M * j]; kk++)
> 						r *= xx[j];
599c775,776
<       F77_CALL(dgemv)(&trans,&nobsM,k,&alpha,UZ,&nobsM, b, &one,&beta, a, &one); /* BLAS call for (UZ)'b */
---
> 			F77_CALL(dgemv)(&trans, &nobsM, k, &alpha, UZ, &nobsM, b, &one,
> 					&beta, a, &one); /* BLAS call for (UZ)'b */
601c778,780
<       for (xp1=Xp,xxp=a,xxp1=a + *k;xxp<xxp1;xxp++,xp1+= *n) *xp1 = *xxp * by_mult; 
---
> 				for (xp1 = Xp, xxp = a, xxp1 = a + *k; xxp < xxp1; xxp++, xp1 +=
> 						*n)
> 					*xp1 = *xxp * by_mult;
603c782,784
<       for (xp1=Xp,xxp=a,xxp1=a + *k;xxp<xxp1;xxp++,xp1+= *n) *xp1 = *xxp;
---
> 				for (xp1 = Xp, xxp = a, xxp1 = a + *k; xxp < xxp1; xxp++, xp1 +=
> 						*n)
> 					*xp1 = *xxp;
617,618c798,801
<   FREE(b);FREE(a);
<   FREE(xx);FREE(pin);
---
> 	FREE(b);
> 	FREE(a);
> 	FREE(xx);
> 	FREE(pin);
diff -rEZbwB '--exclude=*.[lo,d,pdf,mo,po,tgz,gz,save]*' '--exclude=MD5' '--exclude=Makefile*' '--exclude=all.R' '--exclude=Changes' R-recommended/mgcv/src/tprs.h Recommended/mgcv/src/tprs.h
10,12c10,14
< double tps_g(matrix *X,matrix *p,double *x,int d,int m,double *b,int constant);
< void tprs_setup(double **x,double **knt,int m,int d,int n,int k,int constant,matrix *X,matrix *S,
<                 matrix *UZ,matrix *Xu,int n_knots);
---
> double tps_g(matrix *X, matrix *p, double *x, int d, int m, double *b,
> 		int constant);
> void tprs_setup(double **x, double **knt, int m, int d, int n, int k,
> 		int constant, matrix *X, matrix *S, matrix *UZ, matrix *Xu,
> 		int n_knots);
18,21c20,22
< void tprs_setup(double **x,double **knt,int m,int d,int n,int k,int constant,matrix *X,matrix *S,
<                 matrix *UZ,matrix *Xu,int n_knots);
< 
< 
---
> void tprs_setup(double **x, double **knt, int m, int d, int n, int k,
> 		int constant, matrix *X, matrix *S, matrix *UZ, matrix *Xu,
> 		int n_knots);
