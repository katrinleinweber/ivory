diff -rEZbwB '--exclude=*.[lo,d,pdf,mo,po,tgz,gz,save]*' '--exclude=MD5' '--exclude=Makefile*' '--exclude=all.R' '--exclude=Changes' R-recommended/mgcv/R/bam.r Recommended/mgcv/R/bam.r
13c13
<  for (i in 1:n) sz[i] <- object.size(x[[i]])
---
>  for (i in seq_len(n)) sz[i] <- object.size(x[[i]])
38,39c38,39
<   ipiv <- piv <- attr(R,"pivot");ipiv[piv] <- 1:p
<   rank <- attr(R,"rank");ind <- 1:rank
---
>   ipiv <- piv <- attr(R,"pivot");ipiv[piv] <- seq_len(p)
>   rank <- attr(R,"rank");ind <- seq_len(rank)
71,72c71,72
<     fn <- qr.qty(qrx,yn)[1:p]
<     rp <- qrx$pivot;rp[rp] <- 1:p # reverse pivot
---
>     fn <- qr.qty(qrx,yn)[seq_len(p)]
>     rp <- qrx$pivot;rp[rp] <- seq_len(p) # reverse pivot
83c83
<   for (b in 1:arg$n.block) {
---
>   for (b in seq_len(arg$n.block)) {
121c121
<   for (i in 1:d) if (is.factor(dat[,i])) {  
---
>   for (i in seq_len(d)) if (is.factor(dat[,i])) {  
134c134
<     for (i in 1:d) if (!is.factor(dat[,i])) { ## round the metric variables
---
>     for (i in seq_len(d)) if (!is.factor(dat[,i])) { ## round the metric variables
155c155
<   ii <- sample(1:nrow(xu),nrow(xu),replace=FALSE) ## shuffling index
---
>   ii <- sample(seq_len(nrow(xu)),nrow(xu),replace=FALSE) ## shuffling index
207c207
<   for (i in 1:length(gp$smooth.spec)) nk <- nk + as.numeric(gp$smooth.spec[[i]]$by!="NA") +
---
>   for (i in seq_len(length(gp$smooth.spec))) nk <- nk + as.numeric(gp$smooth.spec[[i]]$by!="NA") +
210c210
<   k.start <- 1:(nk+1) ## record last column for each term
---
>   k.start <- seq_len(nk+1) ## record last column for each term
218c218
<   for (i in 1:length(gp$smooth.spec)) {
---
>   for (i in seq_len(length(gp$smooth.spec))) {
224c224
<     for (jj in 1:maxj) { ## loop through marginals
---
>     for (jj in seq_len(maxj)) { ## loop through marginals
342c342
<     for (i in 1:length(mf0)) {
---
>     for (i in seq_len(length(mf0))) {
356c356
<     mf <- mf[sample(1:nrow(mf),maxr,replace=TRUE),]
---
>     mf <- mf[sample(seq_len(nrow(mf)),maxr,replace=TRUE),]
377c377
<           ii0 <- if (ik>1) 1:(ik-1) else rep(0,0) ## earlier
---
>           ii0 <- if (ik>1) seq_len(ik-1) else rep(0,0) ## earlier
381c381
<           kk0 <- if (ik>1) 1:(k.start[ik]-1) else rep(0,0) ## earlier
---
>           kk0 <- if (ik>1) seq_len(k.start[ik]-1) else rep(0,0) ## earlier
402c402
<   for (j in 1:length(mf)) mn <- mn + if (is.factor(mf[[j]])) length(levels(mf[[j]])) else 2
---
>   for (j in seq_len(length(mf))) mn <- mn + if (is.factor(mf[[j]])) length(levels(mf[[j]])) else 2
416c416
<   ind <- sample(1:n,chunk.size)
---
>   ind <- sample(seq_len(n),chunk.size)
424c424
<   ind <- sample(1:n,n,replace=FALSE) ## randomized index for stratified sampling w.r.t. factor levels
---
>   ind <- sample(seq_len(n),n,replace=FALSE) ## randomized index for stratified sampling w.r.t. factor levels
427c427
<   for (j in 1:length(mf)) if (is.numeric(mf0[[j]])) {
---
>   for (j in seq_len(length(mf))) if (is.numeric(mf0[[j]])) {
429,430c429,430
<       j.min <- min((1:n)[as.logical(rowSums(mf[[j]]==min(mf[[j]])))])
<       j.max <- min((1:n)[as.logical(rowSums(mf[[j]]==max(mf[[j]])))])
---
>       j.min <- min((seq_len(n))[as.logical(rowSums(mf[[j]]==min(mf[[j]])))])
>       j.max <- min((seq_len(n))[as.logical(rowSums(mf[[j]]==max(mf[[j]])))])
477c477
<       ar.row <- c(1,rep(1:N,rep(2,N))[-c(1,2*N)]) ## index of rows to reweight
---
>       ar.row <- c(1,rep(seq_len(N),rep(2,N))[-c(1,2*N)]) ## index of rows to reweight
479c479
<       ar.stop <- c(1,1:(N-1)*2+1)    ## (stop[i-1]+1):stop[i] are the rows to reweight to get ith row
---
>       ar.stop <- c(1,seq_len(N-1)*2+1)    ## (stop[i-1]+1):stop[i] are the rows to reweight to get ith row
536c536
<     for (b in 1:length(Sl)) rank <- rank + Sl[[b]]$rank
---
>     for (b in seq_len(length(Sl))) rank <- rank + Sl[[b]]$rank
539c539
<     for (iter in 1L:control$maxit) { ## main fitting loop 
---
>     for (iter in seq_len(control$maxit)) { ## main fitting loop 
611c611
<         prop <- Sl.fitChol(Sl,qrx$XX,qrx$Xy,rho=lsp[1:n.sp],yy=qrx$y.norm2,L=G$L,rho0=G$lsp0,log.phi=log.phi,
---
>         prop <- Sl.fitChol(Sl,qrx$XX,qrx$Xy,rho=lsp[seq_len(n.sp)],yy=qrx$y.norm2,L=G$L,rho0=G$lsp0,log.phi=log.phi,
627c627
<           warning(gettextf("non-finite coefficients at iteration %d",
---
>           warning(gettextf("Non-finite coefficients at iteration %d",
634c634
<        warning("algorithm did not converge")
---
>        warning("Algorithm did not converge")
646c646
<   if (length(G$smooth)>1) for (i in 1:length(G$smooth)) Mp <- Mp + G$smooth[[i]]$null.space.dim
---
>   if (length(G$smooth)>1) for (i in seq_len(length(G$smooth))) Mp <- Mp + G$smooth[[i]]$null.space.dim
654c654
<   for (i in 1:ncol(prop$db)) prop$db[,i] <- ## d beta / d rho matrix
---
>   for (i in seq_len(ncol(prop$db))) prop$db[,i] <- ## d beta / d rho matrix
668c668
<   object$sp <- exp(lsp[1:n.sp]) 
---
>   object$sp <- exp(lsp[seq_len(n.sp)]) 
679c679
<     rV <- (ev$values*t(ev$vectors))[,1:M]
---
>     rV <- (ev$values*t(ev$vectors))[,seq_len(M)]
758c758
<         warning("Too many cluster nodes to use all efficiently")
---
>         warning("too many cluster nodes to use all efficiently")
768c768
<       for (i in 1:n.threads) {
---
>       for (i in seq_len(n.threads)) {
775c775
<           stop <- (1:n.block)*chunk.size
---
>           stop <- seq_len(n.block)*chunk.size
799c799
<         stop <- (1:n.block)*chunk.size
---
>         stop <- seq_len(n.block)*chunk.size
816c816
<     for (iter in 1L:control$maxit) { ## main fitting loop
---
>     for (iter in seq_len(control$maxit)) { ## main fitting loop
822c822
<          for (b in 1:n.block) {
---
>          for (b in seq_len(n.block)) {
848c848
<          for (i in 1:length(arg)) arg[[i]]$coef <- coef
---
>          for (i in seq_len(length(arg))) arg[[i]]$coef <- coef
852c852
<          #for (i in 1:length(arg)) {
---
>          #for (i in seq_len(length(arg))) {
876,877c876,877
<           f <- qr.qty(qrx,f)[1:ncol(R)]
<           rp <- qrx$pivot;rp[rp] <- 1:ncol(R) # reverse pivot
---
>           f <- qr.qty(qrx,f)[seq_len(ncol(R))]
>           rp <- qrx$pivot;rp[rp] <- seq_len(ncol(R)) # reverse pivot
984c984
<           warning(gettextf("non-finite coefficients at iteration %d",
---
>           warning(gettextf("Non-finite coefficients at iteration %d",
1003c1003
<        warning("algorithm did not converge")
---
>        warning("Algorithm did not converge")
1078c1078
<     for (iter in 1L:control$maxit) { ## main fitting loop
---
>     for (iter in seq_len(control$maxit)) { ## main fitting loop
1107c1107
<          message(gettextf("Deviance = %s Iterations - %d\n", dev, iter, domain = "R-mgcv"))
---
>          message(gettextf("Deviance = %s Iterations - %d", dev, iter, domain = "R-mgcv"))
1164,1165c1164
<           warning("non-finite coefficients at iteration ",
<                   iter)
---
>           warning(gettextf("Non-finite coefficients at iteration %d", iter))
1171c1170
<        warning("algorithm did not converge")
---
>        warning("Algorithm did not converge")
1199c1198
<   for (i in 1:arg$n.block) {
---
>   for (i in seq_len(arg$n.block)) {
1205c1204
<        row <- c(1,rep(1:N,rep(2,N))[-c(1,2*N)])
---
>        row <- c(1,rep(seq_len(N),rep(2,N))[-c(1,2*N)])
1207c1206
<        stop <- c(1,1:(N-1)*2+1)
---
>        stop <- c(1,seq_len(N-1)*2+1)
1283c1282
<     for (i in 1:n.threads) { 
---
>     for (i in seq_len(n.threads)) { 
1349c1348
<          warning("Too many cluster nodes to use all efficiently")
---
>          warning("too many cluster nodes to use all efficiently")
1362c1361
<        for (i in 1:n.threads) { 
---
>        for (i in seq_len(n.threads)) { 
1409c1408
<        for (i in 1:n.block) {
---
>        for (i in seq_len(n.block)) {
1414c1413
<            row <- c(1,rep(1:N,rep(2,N))[-c(1,2*N)])
---
>            row <- c(1,rep(seq_len(N),rep(2,N))[-c(1,2*N)])
1416c1415
<            stop <- c(1,1:(N-1)*2+1) 
---
>            stop <- c(1,seq_len(N-1)*2+1) 
1456c1455
<        # for (i in 1:length(arg)) {
---
>        # for (i in seq_len(length(arg))) {
1477,1478c1476,1477
<          f <- qr.qty(qrx,f)[1:ncol(R)]
<          rp <- qrx$pivot;rp[rp] <- 1:ncol(R) # reverse pivot
---
>          f <- qr.qty(qrx,f)[seq_len(ncol(R))]
>          rp <- qrx$pivot;rp[rp] <- seq_len(ncol(R)) # reverse pivot
1488c1487
<        row <- c(1,rep(1:n,rep(2,n))[-c(1,2*n)])
---
>        row <- c(1,rep(seq_len(n),rep(2,n))[-c(1,2*n)])
1490c1489
<        stop <- c(1,1:(n-1)*2+1)
---
>        stop <- c(1,seq_len(n-1)*2+1)
1624c1623
<     warning("iterms reset to terms")
---
>     warning("type 'iterms' reset to type 'terms'")
1627c1626
<   if (!is.null(exclude)) warning("exclude ignored by discrete prediction at present")
---
>   if (!is.null(exclude)) warning("'exclude' argument ignored by discrete prediction at present")
1642,1643c1641,1642
<     object$coefficients <-  object$coefficients[1:object$nsdf]
<     object$Vp <- object$V[1:object$nsdf,1:object$nsdf]
---
>     object$coefficients <-  object$coefficients[seq_len(object$nsdf)]
>     object$Vp <- object$V[seq_len(object$nsdf),seq_len(object$nsdf)]
1666c1665
<      kd <- cbind(1:nrow(newdata),dk$k) ## add index for parametric part to index list
---
>      kd <- cbind(seq_len(nrow(newdata)),dk$k) ## add index for parametric part to index list
1680c1679
<   for (i in 1:length(object$smooth)) { ## work through the smooth list
---
>   for (i in seq_len(length(object$smooth))) { ## work through the smooth list
1683c1682
<       by.var <- dk$mf[[object$smooth[[i]]$by]][1:dk$nr[k]]
---
>       by.var <- dk$mf[[object$smooth[[i]]$by]][seq_len(dk$nr[k])]
1702c1701
<       for (j in 1:nmar) {
---
>       for (j in seq_len(nmar)) {
1733c1732
<     for (i in 1:length(object$smooth)) {
---
>     for (i in seq_len(length(object$smooth))) {
1782c1781
<       stop <- (1:n.block)*chunk.size
---
>       stop <- seq_len(n.block)*chunk.size
1797c1796
<   for (b in 1:n.block) {    
---
>   for (b in seq_len(n.block)) {    
1810c1809
<   for (i in 1:ns) if (sm$margin[[i]]$bs.dim>=maxd) {
---
>   for (i in seq_len(ns)) if (sm$margin[[i]]$bs.dim>=maxd) {
1814c1813
<     ind <- 1:ns;ind[maxi] <- ns;ind[ns] <- maxi
---
>     ind <- seq_len(ns);ind[maxi] <- ns;ind[ns] <- maxi
1818c1817
<     for (i in 1:ns) sm$term <- c(sm$term,sm$margin[[i]]$term)
---
>     for (i in seq_len(ns)) sm$term <- c(sm$term,sm$margin[[i]]$term)
1831c1830
<   ar.row <- c(1,rep(1:N,rep(2,N))[-c(1,2*N)]) ## index of rows to reweight
---
>   ar.row <- c(1,rep(seq_len(N),rep(2,N))[-c(1,2*N)]) ## index of rows to reweight
1833c1832
<   ar.stop <- c(1,1:(N-1)*2+1)    ## (stop[i-1]+1):stop[i] are the rows to reweight to get ith row
---
>   ar.stop <- c(1,seq_len(N-1)*2+1)    ## (stop[i-1]+1):stop[i] are the rows to reweight to get ith row
1871,1872c1870
<     if (!method%in%c("fREML","GCV.Cp","REML",
<                     "ML","P-REML","P-ML")) stop("un-supported smoothness selection method")
---
>     if (!method%in%c("fREML","GCV.Cp","REML", "ML","P-REML","P-ML")) stop("unsupported smoothness selection method")
1900c1898
<       if (length(gp$smooth.spec)>0) for (i in 1:length(gp$smooth.spec)) { 
---
>       if (length(gp$smooth.spec)>0) for (i in seq_len(length(gp$smooth.spec))) { 
1909c1907
<           for (j in 1:gp$smooth.spec[[i]]$dim) gp$smooth.spec[[i]]$margin[[j]] <- list(term=gp$smooth.spec[[i]]$term[j])
---
>           for (j in seq_len(gp$smooth.spec[[i]]$dim)) gp$smooth.spec[[i]]$margin[[j]] <- list(term=gp$smooth.spec[[i]]$term[j])
1938c1936
<     if (rho!=0&&!is.null(mf$"(AR.start)")) if (!is.logical(mf$"(AR.start)")) stop("AR.start must be logical")
---
>     if (rho!=0&&!is.null(mf$"(AR.start)")) if (!is.logical(mf$"(AR.start)")) stop("'AR.start' argument must be logical")
1991c1989
<       G$kd <- cbind(1:nrow(mf),dk$k) ## add index for parametric part to index list
---
>       G$kd <- cbind(seq_len(nrow(mf)),dk$k) ## add index for parametric part to index list
2006c2004
<       for (i in 1:length(G$smooth)) {
---
>       for (i in seq_len(length(G$smooth))) {
2011c2009
<           by.var <- dk$mf[[G$smooth[[i]]$by]][1:dk$nr[k]]
---
>           by.var <- dk$mf[[G$smooth[[i]]$by]][seq_len(dk$nr[k])]
2034,2035c2032,2033
<           for (j in 1:nmar) {
<             G$Xd[[k]] <- G$smooth[[i]]$margin[[j]]$X[1:dk$nr[k],,drop=FALSE]
---
>           for (j in seq_len(nmar)) {
>             G$Xd[[k]] <- G$smooth[[i]]$margin[[j]]$X[seq_len(dk$nr[k]),,drop=FALSE]
2057c2055
<           G$Xd[[k]] <- G$X[1:dk$nr[k],G$smooth[[i]]$first.para:G$smooth[[i]]$last.para]
---
>           G$Xd[[k]] <- G$X[seq_len(dk$nr[k]),G$smooth[[i]]$first.para:G$smooth[[i]]$last.para]
2102c2100
<     if (G$m) for (i in 1:G$m) G$min.edf<-G$min.edf+G$smooth[[i]]$null.space.dim
---
>     if (G$m) for (i in seq_len(G$m)) G$min.edf<-G$min.edf+G$smooth[[i]]$null.space.dim
2132c2130
<   if (control$trace) cat("Setup complete. Calling fit\n")
---
>   if (control$trace) cat(gettext("Setup complete. Calling fit", domain = "R-mgcv"), "\n", sep = "")
2137c2135
<     warning("sparse=TRUE is deprecated")
---
>     warning("'sparse=TRUE' option is deprecated")
2157,2158c2155,2156
<       ind <- sample(1:nrow(mf),ceiling(nrow(mf)*samfrac))
<       if (length(ind)<2*ncol(G$X)) warning("samfrac too small - ignored") else {
---
>       ind <- sample(seq_len(nrow(mf)),ceiling(nrow(mf)*samfrac))
>       if (length(ind)<2*ncol(G$X)) warning("value of 'samfrac' argument is too small - ignored") else {
2180c2178
<   if (control$trace) cat("Fit complete. Finishing gam object.\n")
---
>   if (control$trace) cat(gettext("Fit complete. Finishing gam object.", domain = "R-mgcv"), "\n", sep = "")
2210c2208
<   if (G$nsdf>0) names(object$coefficients)[1:G$nsdf] <- colnamesX[1:G$nsdf]
---
>   if (G$nsdf>0) names(object$coefficients)[seq_len(G$nsdf)] <- colnamesX[seq_len(G$nsdf)]
2330c2328
<     row <- c(1,rep(1:m,rep(2,m))[-c(1,2*m)])
---
>     row <- c(1,rep(seq_len(m),rep(2,m))[-c(1,2*m)])
2332c2330
<     stop <- c(1,1:(m-1)*2+1)
---
>     stop <- c(1,seq_len(m-1)*2+1)
diff -rEZbwB '--exclude=*.[lo,d,pdf,mo,po,tgz,gz,save]*' '--exclude=MD5' '--exclude=Makefile*' '--exclude=all.R' '--exclude=Changes' R-recommended/mgcv/R/coxph.r Recommended/mgcv/R/coxph.r
18c18
<         else stop(linktemp, " link not available for coxph family; available link is \"identity\" ")
---
>         else stop(gettextf("\"%s\" link not available for coxph family; available link is \"identity\"", linktemp))
161c161
<         ind <- 1:(p^2)
---
>         ind <- seq_len(p^2)
163c163
<         for (i in 1:M) { 
---
>         for (i in seq_len(M)) { 
diff -rEZbwB '--exclude=*.[lo,d,pdf,mo,po,tgz,gz,save]*' '--exclude=MD5' '--exclude=Makefile*' '--exclude=all.R' '--exclude=Changes' R-recommended/mgcv/R/efam.r Recommended/mgcv/R/efam.r
57c57
<     } else stop(linktemp, " link not available for ordered categorical family; available links are \"identity\"")
---
>     } else stop(gettextf("\"%s\" link not available for ordered categorical family; available links are \"identity\"", linktemp))
93c93,94
<     paste("Ordered Categorical(",paste(round(object$family$getTheta(TRUE),2),collapse=","),")",sep="")
---
>     gettextf("Ordered Categorical(%s)", paste(round(object$family$getTheta(TRUE),2), collapse = ","), domain = "R-mgcv")
>     #paste("Ordered Categorical(",paste(round(object$family$getTheta(TRUE),2),collapse=","),")",sep="")
261c262
<       for (k in 1:(R-2)) { 
---
>       for (k in seq_len(R-2)) { 
310c311
<       for (j in 1:(R-2)) for (k in j:(R-2)) { 
---
>       for (j in seq_len(R-2)) for (k in j:(R-2)) { 
408c409
<     for (j in 1:(R-2)) for (k in j:(R-2)) { 
---
>     for (j in seq_len(R-2)) for (k in j:(R-2)) { 
427c428
<       for (i in 1:(R-2)) for (j in i:(R-2)) { 
---
>       for (i in seq_len(R-2)) for (j in i:(R-2)) { 
443c444
<       y <- c(1:R,y) ## make sure there is *something* in each class
---
>       y <- c(seq_len(R),y) ## make sure there is *something* in each class
489c490
<        for (i in 1:(R+1)) {
---
>        for (i in seq_len(R+1)) {
521c522
<       for (i in 1:R) {
---
>       for (i in seq_len(R)) {
550c551
<       for (i in 1:(R+1)) {
---
>       for (i in seq_len(R+1)) {
573c574
<     for (i in 1:R) {
---
>     for (i in seq_len(R)) {
609c610
<         else stop(linktemp, " link not available for negative binomial family; available links are \"identity\", \"log\" and \"sqrt\"")
---
>         else stop(gettextf("\"%s\" link not available for negative binomial family; available links are \"identity\", \"log\" and \"sqrt\"", linktemp))
709c710,711
<       paste("Negative Binomial(",round(object$family$getTheta(TRUE),3),")",sep="")
---
>       gettextf("Negative Binomial(%s)", paste(round(object$family$getTheta(TRUE),3), sep = ", ", collapse = ""), domain = "R-mgcv")
>       #paste("Negative Binomial(",round(object$family$getTheta(TRUE),3),")",sep="")
758,759c760
<         else  stop(gettextf("link \"%s\" not available for Tweedie family.", 
<                 linktemp, collapse = ""), domain = NA)
---
>         else  stop(gettextf("link \"%s\" is not available for Tweedie family",  linktemp, collapse = ""), domain = "R-mgcv")
881c882
<       paste("Tweedie(p=",round(object$family$getTheta(TRUE),3),")",sep="")
---
>       gettextf("Tweedie(p=%s)", round(object$family$getTheta(TRUE),3), domain = "R-mgcv")
927c928
<         else stop(linktemp, " link not available for beta regression; available links are  \"logit\", \"probit\", \"cloglog\" and \"cauchit\"")
---
>         else stop(gettextf("\"%s\" link not available for beta regression; available links are  \"logit\", \"probit\", \"cloglog\" and \"cauchit\"", linktemp))
1068c1069
<       mu <- LS <- ii <- 1:length(y)
---
>       mu <- LS <- ii <- seq_len(length(y))
1122c1123
<       paste("Beta regression(",round(theta,3),")",sep="")
---
>       gettextf("Beta regression(%s)",round(theta,3), domain = "R-mgcv")
1208c1209
<         else stop(linktemp, " link not available for scaled t distribution; available links are \"identity\", \"log\",  and \"inverse\"")
---
>         else stop(gettextf("\"%s\" link not available for scaled t distribution; available links are \"identity\", \"log\",  and \"inverse\"", linktemp))
1362c1363
<       paste("Scaled t(",paste(round(object$family$getTheta(TRUE),3),collapse=","),")",sep="")
---
>       gettextf("Scaled t(%s)",paste(round(object$family$getTheta(TRUE),3), collapse=","), domain = "R-mgcv")
1470c1471
<   } else  stop(linktemp, " link not available for zero inflated; available link for `lambda' is only  \"loga\"")
---
>   } else  stop(gettextf("\"%s\" link not available for zero inflated; available link for `lambda' is only  \"loga\"", linktemp))
diff -rEZbwB '--exclude=*.[lo,d,pdf,mo,po,tgz,gz,save]*' '--exclude=MD5' '--exclude=Makefile*' '--exclude=all.R' '--exclude=Changes' R-recommended/mgcv/R/fast-REML.r Recommended/mgcv/R/fast-REML.r
32,34c32,34
<     off <- unique(G$off[1:G$n.paraPen]) ## unique offset lists relating to paraPen
<     for (i in 1:length(off)) { ## loop over blocks
<       ind <- (1:G$n.paraPen)[G$off[1:G$n.paraPen]%in%off[i]] ## terms in same block
---
>     off <- unique(G$off[seq_len(G$n.paraPen)]) ## unique offset lists relating to paraPen
>     for (i in seq_len(length(off))) { ## loop over blocks
>       ind <- seq_len(G$n.paraPen)[G$off[seq_len(G$n.paraPen)]%in%off[i]] ## terms in same block
36c36
<         nr <- 0;for (k in 1:length(ind)) nr <- max(nr,nrow(G$S[[ind[k]]])) ## get block size
---
>         nr <- 0;for (k in seq_len(length(ind))) nr <- max(nr,nrow(G$S[[ind[k]]])) ## get block size
41c41
<         for (k in 1:length(ind)) { ## work through all penalties for this block
---
>         for (k in seq_len(length(ind))) { ## work through all penalties for this block
45c45
<             Sl[[b]]$S[[k]][1:nk,1:nk] <- G$S[[ind[k]]]
---
>             Sl[[b]]$S[[k]][seq_len(nk),seq_len(nk)] <- G$S[[ind[k]]]
61c61
<   if (length(G$smooth)) for (i in 1:length(G$smooth)) {
---
>   if (length(G$smooth)) for (i in seq_len(length(G$smooth))) {
87c87
<       for (j in 1:m) { ## get block range for each S[[j]]
---
>       for (j in seq_len(m)) { ## get block range for each S[[j]]
89c89
<         ir <- range((1:nb)[rowSums(abs(Sl[[b]]$S[[j]]))>0])
---
>         ir <- range(seq_len(nb)[rowSums(abs(Sl[[b]]$S[[j]]))>0])
93c93
<       for (j in 1:m) { ## test for overlap
---
>       for (j in seq_len(m)) { ## test for overlap
96c96
<           for (k in 1:m) if (j!=k) itot[diag(Sl[[b]]$S[[k]])!=0] <- TRUE
---
>           for (k in seq_len(m)) if (j!=k) itot[diag(Sl[[b]]$S[[k]])!=0] <- TRUE
101c101
<           for (k in 1:m) if (j!=k) itot[sbStart[k]:sbStop[k]] <- TRUE
---
>           for (k in seq_len(m)) if (j!=k) itot[sbStart[k]:sbStop[k]] <- TRUE
108c108
<         for (j in 1:m) {
---
>         for (j in seq_len(m)) {
135c135
<   for (b in 1:length(Sl)) { ## once more into the blocks, dear friends...
---
>   for (b in seq_len(length(Sl))) { ## once more into the blocks, dear friends...
152c152
<         ind[1:Sl[[b]]$rank] <- TRUE ## index penalized elements
---
>         ind[seq_len(Sl[[b]]$rank)] <- TRUE ## index penalized elements
173,174c173,174
<       ind <- 1:Sl[[b]]$rank
<       for (j in 1:length(Sl[[b]]$S)) { ## project penalties into range space of total penalty
---
>       ind <- seq_len(Sl[[b]]$rank)
>       for (j in seq_len(length(Sl[[b]]$S))) { ## project penalties into range space of total penalty
212c212
<         for (b in 1:length(Sl)) { 
---
>         for (b in seq_len(length(Sl))) { 
225c225
<          for (b in 1:length(Sl)) { 
---
>          for (b in seq_len(length(Sl))) { 
241c241
<       for (b in 1:length(Sl)) { 
---
>       for (b in seq_len(length(Sl))) { 
247c247
<   } else for (b in 1:length(Sl)) { ## model matrix re-para
---
>   } else for (b in seq_len(length(Sl))) { ## model matrix re-para
288c288
<     rp <- piv;rp[rp] <- 1:p ## reverse pivot
---
>     rp <- piv;rp[rp] <- seq_len(p) ## reverse pivot
292,293c292,293
<     R <- R[1:r,1:r]
<     piv <- piv[1:r]
---
>     R <- R[seq_len(r),seq_len(r)]
>     piv <- piv[seq_len(r)]
297c297
<   for (i in 1:m) {
---
>   for (i in seq_len(m)) {
303c303
<       for (j in 1:i) {
---
>       for (j in seq_len(i)) {
330c330
<   for (b in 1:length(Sl)) { ## work through blocks
---
>   for (b in seq_len(length(Sl))) { ## work through blocks
367c367
<         for (i in 1:m) {
---
>         for (i in seq_len(m)) {
395c395
<   for (b in 1:length(Sl)) {
---
>   for (b in seq_len(length(Sl))) {
401c401
<       for (j in 1:length(Sl[[b]]$S)) {
---
>       for (j in seq_len(length(Sl[[b]]$S))) {
419c419
<       for (i in 1:nr) {
---
>       for (i in seq_len(nr)) {
426c426
<      for (i in 1:nr) X[rp[[i]]$ind]  <- rp[[i]]$Qs %*% X[rp[[i]]$ind]
---
>      for (i in seq_len(nr)) X[rp[[i]]$ind]  <- rp[[i]]$Qs %*% X[rp[[i]]$ind]
430c430
<       for (i in 1:nr) X[,rp[[i]]$ind]  <- X[,rp[[i]]$ind]%*%rp[[i]]$Qs
---
>       for (i in seq_len(nr)) X[,rp[[i]]$ind]  <- X[,rp[[i]]$ind]%*%rp[[i]]$Qs
432c432
<       for (i in 1:nr) X[rp[[i]]$ind]  <- t(rp[[i]]$Qs) %*% X[rp[[i]]$ind]
---
>       for (i in seq_len(nr)) X[rp[[i]]$ind]  <- t(rp[[i]]$Qs) %*% X[rp[[i]]$ind]
448c448
<     for (b in 1:nb) { ## block loop
---
>     for (b in seq_len(nb)) { ## block loop
462,463c462,463
<     for (b in 1:nb) { ## block loop
<       for (i in 1:length(Sl[[b]]$S)) { ## S loop within blocks
---
>     for (b in seq_len(nb)) { ## block loop
>       for (i in seq_len(length(Sl[[b]]$S))) { ## S loop within blocks
517c517
<   for (b in 1:nb) { ## block loop
---
>   for (b in seq_len(nb)) { ## block loop
533c533
<       for (i in 1:length(Sl[[b]]$S)) { ## work through S terms
---
>       for (i in seq_len(length(Sl[[b]]$S))) { ## work through S terms
575c575
<   for (i in 1:nd) { 
---
>   for (i in seq_len(nd)) { 
602c602
<   for (i in 1:nd) { ## compute the first derivatives
---
>   for (i in seq_len(nd)) { ## compute the first derivatives
612c612
<   for (k in 1:nd) { ## second derivative loop 
---
>   for (k in seq_len(nd)) { ## second derivative loop 
636c636
<   for (i in 1:nd) { ## compute the first derivatives
---
>   for (i in seq_len(nd)) { ## compute the first derivatives
647c647
<   for (k in 1:nd) { ## second derivative loop 
---
>   for (k in seq_len(nd)) { ## second derivative loop 
683,684c683,684
<     R <- R[1:r,1:r]
<     piv <- piv[1:r]
---
>     R <- R[seq_len(r),seq_len(r)]
>     piv <- piv[seq_len(r)]
713c713
<     reml2 <- rbind(cbind(reml2,d[1:n]),d) 
---
>     reml2 <- rbind(cbind(reml2,d[seq_len(n)]),d) 
761c761
<   rp <- qrx$pivot;rp[rp] <- 1:np ## reverse pivot vector
---
>   rp <- qrx$pivot;rp[rp] <- seq_len(np) ## reverse pivot vector
765,766c765,766
<   beta <- backsolve(R,Qty0)[1:np]
<   rss.bSb <- sum(Qty0[-(1:np)]^2) + rss.extra
---
>   beta <- backsolve(R,Qty0)[seq_len(np)]
>   rss.bSb <- sum(Qty0[-seq_len(np)]^2) + rss.extra
791c791
<     reml2 <- rbind(cbind(reml2,d[1:n]),d)
---
>     reml2 <- rbind(cbind(reml2,d[seq_len(n)]),d)
818c818
<     rp[rp] <- 1:np
---
>     rp[rp] <- seq_len(np)
821,822c821,822
<     rss.extra <- rss.extra + sum(y[-(1:np)]^2)
<     y <- y[1:np]
---
>     rss.extra <- rss.extra + sum(y[-seq_len(np)]^2)
>     y <- y[seq_len(np)]
856c856
<   for (iter in 1:200) { ## the Newton loop
---
>   for (iter in seq_len(200)) { ## the Newton loop
880c880
<     trial <- Sl.fit(Sl,X,y,rho1[1:nr],fixed,log.phi,phi.fixed,rss.extra,nobs,Mp,nt=nt)
---
>     trial <- Sl.fit(Sl,X,y,rho1[seq_len(nr)],fixed,log.phi,phi.fixed,rss.extra,nobs,Mp,nt=nt)
885c885
<       trial <- Sl.fit(Sl,X,y,rho1[1:nr],fixed,log.phi,phi.fixed,rss.extra,nobs,Mp,nt=nt)
---
>       trial <- Sl.fit(Sl,X,y,rho1[seq_len(nr)],fixed,log.phi,phi.fixed,rss.extra,nobs,Mp,nt=nt)
913,915c913,915
<   if (step.failed) best$conv <- "step failed" else
<   if (iter==200) best$conv <- "no convergence in 200 iterations" else
<   best$conv <- "full convergence"
---
>   if (step.failed) best$conv <- gettext("step failed", domain = "R-mgcv") else
>   if (iter==200) best$conv <- gettext("no convergence in 200 iterations", domain = "R-mgcv") else
>   best$conv <- gettext("full convergence", domain = "R-mgcv")
937,938c937,938
<   drop <- qrx$pivot[-(1:rank)] ## index of un-identifiable coefs
<   undrop <- 1:ncol(X) 
---
>   drop <- qrx$pivot[-seq_len(rank)] ## index of un-identifiable coefs
>   undrop <- seq_len(ncol(X))
961c961
<   for (b in 1:length(Sl)) {
---
>   for (b in seq_len(length(Sl))) {
981c981
<       for (i in 1:length(Sl[[b]]$S)) {
---
>       for (i in seq_len(length(Sl[[b]]$S))) {
991c991
<     for (i in 1:length(Sl)) {
---
>     for (i in seq_len(length(Sl))) {
1014c1014
<   for (b in 1:length(Sl)) rank <- rank + Sl[[b]]$rank ## the total penalty rank
---
>   for (b in seq_len(length(Sl))) rank <- rank + Sl[[b]]$rank ## the total penalty rank
1034c1034
<     for (i in 1:ncol(d1b)) d1b[,i] <- 
---
>     for (i in seq_len(ncol(d1b))) d1b[,i] <- 
1057c1057
<     rV <- (ev$values*t(ev$vectors))[,1:M]
---
>     rV <- (ev$values*t(ev$vectors))[,seq_len(M)]
diff -rEZbwB '--exclude=*.[lo,d,pdf,mo,po,tgz,gz,save]*' '--exclude=MD5' '--exclude=Makefile*' '--exclude=all.R' '--exclude=Changes' R-recommended/mgcv/R/gamlss.r Recommended/mgcv/R/gamlss.r
35c35
<   for (i in 1:K) for (j in i:K) for (k in j:K) for (l in k:K) {
---
>   for (i in seq_len(K)) for (j in i:K) for (k in j:K) for (l in k:K) {
49c49
<   for (j in 1:K) for (k in j:K) for (l in k:K) {
---
>   for (j in seq_len(K)) for (k in j:K) for (l in k:K) {
57c57
<   for (k in 1:K) for (l in k:K) {
---
>   for (k in seq_len(K)) for (l in k:K) {
78c78
<   for (i in 1:K) { ## first derivative loop
---
>   for (i in seq_len(K)) { ## first derivative loop
86c86
<   for (i in 1:K) for (j in i:K) {
---
>   for (i in seq_len(K)) for (j in i:K) {
103c103
<   if (deriv>0) for (i in 1:K) for (j in i:K) for (l in j:K) {
---
>   if (deriv>0) for (i in seq_len(K)) for (j in i:K) for (l in j:K) {
130c130
<   if (deriv>2) for (i in 1:K) for (j in i:K) for (l in j:K) for (m in l:K) {
---
>   if (deriv>2) for (i in seq_len(K)) for (j in i:K) for (l in j:K) for (m in l:K) {
198c198
<   for (i in 1:K) { ## first derivative loop
---
>   for (i in seq_len(K)) { ## first derivative loop
204c204
<   for (i in 1:K) for (j in i:K) {
---
>   for (i in seq_len(K)) for (j in i:K) {
216,217c216,217
<     ind <- 1:n
<     for (i in 1:K) { 
---
>     ind <- seq_len(n)
>     for (i in seq_len(K)) { 
225,228c225,228
<     for (l in 1:m) {
<       for (i in 1:K) {
<         v <- rep(0,n);ind <- 1:n
<         for (q in 1:K) { 
---
>     for (l in seq_len(m)) {
>       for (i in seq_len(K)) {
>         v <- rep(0,n);ind <- seq_len(n)
>         for (q in seq_len(K)) { 
239c239
<     for (l in 1:m) {
---
>     for (l in seq_len(m)) {
241,243c241,243
<       for (i in 1:K) for (j in i:K) {
<         v <- rep(0,n);ind <- 1:n
<         for (q in 1:K) { 
---
>       for (i in seq_len(K)) for (j in i:K) {
>         v <- rep(0,n);ind <- seq_len(n)
>         for (q in seq_len(K)) { 
258,259c258,259
<     ind <- 1:n 
<     for (i in 1:K) { 
---
>     ind <- seq_len(n) 
>     for (i in seq_len(K)) { 
268c268
<        ipiv <- piv <- attr(fh,"pivot");ipiv[piv] <- 1:p
---
>        ipiv <- piv <- attr(fh,"pivot");ipiv[piv] <- seq_len(p)
273,274c273,274
<     ind <- 1:n
<     for (i in 1:K) { 
---
>     ind <- seq_len(n)
>     for (i in seq_len(K)) { 
280c280
<     for (k in 1:m) for (l in k:m) { ## looping over smoothing parameters...
---
>     for (k in seq_len(m)) for (l in k:m) { ## looping over smoothing parameters...
282,284c282,284
<       for (i in 1:K) for (j in 1:K) {
<         v <- rep(0,n);ind <- 1:n
<         for (q in 1:K) { ## accumulate the diagonal matrix for X_i'diag(v)X_j
---
>       for (i in seq_len(K)) for (j in seq_len(K)) {
>         v <- rep(0,n);ind <- seq_len(n)
>         for (q in seq_len(K)) { ## accumulate the diagonal matrix for X_i'diag(v)X_j
286,287c286,287
<           ins <- 1:n
<           for (s in 1:K) { 
---
>           ins <- seq_len(n)
>           for (s in seq_len(K)) { 
294c294
<           rind <- 1:n + (i-1)*n
---
>           rind <- seq_len(n) + (i-1)*n
297,298c297,298
<           rind1 <- 1:n + (i-1)*n
<           rind2 <- 1:n + (j-1)*n
---
>           rind1 <- seq_len(n) + (i-1)*n
>           rind2 <- seq_len(n) + (j-1)*n
332c332
<   for (i in 1:K) { ## first derivative loop
---
>   for (i in seq_len(K)) { ## first derivative loop
338c338
<   for (i in 1:K) for (j in i:K) {
---
>   for (i in seq_len(K)) for (j in i:K) {
351,352c351,352
<     ind <- 1:n
<     for (i in 1:K) { 
---
>     ind <- seq_len(n)
>     for (i in seq_len(K)) { 
360,363c360,363
<     for (l in 1:m) {
<       for (i in 1:K) {
<         v <- rep(0,n);ind <- 1:n
<         for (q in 1:K) { 
---
>     for (l in seq_len(m)) {
>       for (i in seq_len(K)) {
>         v <- rep(0,n);ind <- seq_len(n)
>         for (q in seq_len(K)) { 
374c374
<     for (l in 1:m) {
---
>     for (l in seq_len(m)) {
376,378c376,378
<       for (i in 1:K) for (j in i:K) {
<         v <- rep(0,n);ind <- 1:n
<         for (q in 1:K) { 
---
>       for (i in seq_len(K)) for (j in i:K) {
>         v <- rep(0,n);ind <- seq_len(n)
>         for (q in seq_len(K)) { 
394,395c394,395
<     ind <- 1:n 
<     for (i in 1:K) { 
---
>     ind <- seq_len(n) 
>     for (i in seq_len(K)) { 
404c404
<        ipiv <- piv <- attr(fh,"pivot");ipiv[piv] <- 1:p
---
>        ipiv <- piv <- attr(fh,"pivot");ipiv[piv] <- seq_len(p)
409,410c409,410
<     ind <- 1:n
<     for (i in 1:K) { 
---
>     ind <- seq_len(n)
>     for (i in seq_len(K)) { 
416c416
<     for (k in 1:m) for (l in k:m) { ## looping over smoothing parameters...
---
>     for (k in seq_len(m)) for (l in k:m) { ## looping over smoothing parameters...
418,420c418,420
<       for (i in 1:K) for (j in 1:K) {
<         v <- rep(0,n);ind <- 1:n
<         for (q in 1:K) { ## accumulate the diagonal matrix for X_i'diag(v)X_j
---
>       for (i in seq_len(K)) for (j in seq_len(K)) {
>         v <- rep(0,n);ind <- seq_len(n)
>         for (q in seq_len(K)) { ## accumulate the diagonal matrix for X_i'diag(v)X_j
422,423c422,423
<           ins <- 1:n
<           for (s in 1:K) { 
---
>           ins <- seq_len(n)
>           for (s in seq_len(K)) { 
430c430
<           rind <- 1:n + (i-1)*n
---
>           rind <- seq_len(n) + (i-1)*n
433,434c433,434
<           rind1 <- 1:n + (i-1)*n
<           rind2 <- 1:n + (j-1)*n
---
>           rind1 <- seq_len(n) + (i-1)*n
>           rind2 <- seq_len(n) + (j-1)*n
460c460
<   if (length(link)!=2) stop("gaulss requires 2 links specified as character strings")
---
>   if (length(link)!=2) stop(gettextf("'%s' function requires 2 links specified as character strings", "gaulss()"))
464c464
<   stop(link[[1]]," link not available for mu parameter of gaulss")
---
>   stop(gettextf("\"%s\" link not available for mu parameter of gaulss", link[[1]]))
486c486
<   } else stop(link[[2]]," link not available for precision parameter of gaulss")
---
>   } else stop(gettextf("\"%s\" link not available for precision parameter of gaulss", link[[2]]))
639c639
<   for (i in 1:K) {
---
>   for (i in seq_len(K)) {
662c662
<       sgn*sqrt(-2*log(pmax(.Machine$double.eps,p[1:n + object$y*n]))) 
---
>       sgn*sqrt(-2*log(pmax(.Machine$double.eps,p[seq_len(n) + object$y*n]))) 
677c677
<         lpi <- list(1:ncol(X))
---
>         lpi <- list(seq_len(ncol(X)))
685c685
<       for (i in 1:K) { 
---
>       for (i in seq_len(K)) { 
705c705
<       for (j in 1:(K+1)) {
---
>       for (j in seq_len(K+1)) {
714c714
<         for (i in 1:K) if (i<K) for (k in (i+1):K) {
---
>         for (i in seq_len(K)) if (i<K) for (k in (i+1):K) {
756c756
<       for (i in 1:K) eta[,i+1] <- X[,jj[[i]],drop=FALSE]%*%coef[jj[[i]]]
---
>       for (i in seq_len(K)) eta[,i+1] <- X[,jj[[i]],drop=FALSE]%*%coef[jj[[i]]]
766c766
<     l0 <- eta[1:n+y*n] - alpha ## log likelihood
---
>     l0 <- eta[seq_len(n)+y*n] - alpha ## log likelihood
772c772
<       for (i in 1:K) l1[,i] <- ee[,i]/beta ## alpha1
---
>       for (i in seq_len(K)) l1[,i] <- ee[,i]/beta ## alpha1
778c778
<       for (i in 1:K) for (j in i:K) {
---
>       for (i in seq_len(K)) for (j in i:K) {
784c784
<       for (i in 1:K) l1[,i] <- as.numeric(y==i) - l1[,i] 
---
>       for (i in seq_len(K)) l1[,i] <- as.numeric(y==i) - l1[,i] 
794c794
<       for (i in 1:K) for (j in i:K) for (k in j:K) {
---
>       for (i in seq_len(K)) for (j in i:K) for (k in j:K) {
810c810
<       for (i in 1:K) for (j in i:K) for (k in j:K) for (l in k:K) {
---
>       for (i in seq_len(K)) for (j in i:K) for (k in j:K) for (l in k:K) {
858c858
<         for (k in 1:length(jj)) { ## loop over the linear predictors      
---
>         for (k in seq_len(length(jj))) { ## loop over the linear predictors      
901c901
<   Qy <- qr.qty(qrx,y)[1:ncol(R)]  
---
>   Qy <- qr.qty(qrx,y)[seq_len(ncol(R))]  
906c906
<   edf <- sum(qr.Q(qrr)[1:r,]^2) 
---
>   edf <- sum(qr.Q(qrr)[seq_len(r),]^2) 
910c910
<     edf <- sum(qr.Q(qrr)[1:r,]^2)
---
>     edf <- sum(qr.Q(qrr)[seq_len(r),]^2)
915c915
<     edf <- sum(qr.Q(qrr)[1:r,]^2)
---
>     edf <- sum(qr.Q(qrr)[seq_len(r),]^2)
1114c1114
<   if (length(link)!=2) stop("ziplss requires 2 links specified as character strings")
---
>   if (length(link)!=2) stop(gettextf("'%s' function requires 2 links specified as character strings", "ziplss()"))
1120c1120
<     stop(link[[i]]," link not available for ",param.names[i]," parameter of ziplss")
---
>     stop(gettextf("\"%s\" link not available for parameter of ziplss %s", param.names[i], link[[i]]))
1350c1350
<         p <- drop(x1[1:nobs,,drop=FALSE] %*% startji) ## probability of presence
---
>         p <- drop(x1[seq_len(nobs),,drop=FALSE] %*% startji) ## probability of presence
diff -rEZbwB '--exclude=*.[lo,d,pdf,mo,po,tgz,gz,save]*' '--exclude=MD5' '--exclude=Makefile*' '--exclude=all.R' '--exclude=Changes' R-recommended/mgcv/R/gamm.r Recommended/mgcv/R/gamm.r
134c134
<   if (sum(is.na(value))>0) warning("NA's in pdTens factor")
---
>   if (sum(is.na(value))>0) warning("NA values in factor of class \"pdTens\"")
157c157
<   if (sum(is.na(value))>0) warning("NA's in pdTens matrix")
---
>   if (sum(is.na(value))>0) warning("NA values in matrix of class \"pdTens\"")
173c173
<     names(val) <- paste("sp.",1:length(val), sep ="")
---
>     names(val) <- paste("sp.", seq_len(length(val)), sep ="")
179c179
<   function(object, structName = "Tensor product smooth term", ...)
---
>   function(object, structName = gettext("Tensor product smooth term", domain = "R-mgcv"), ...)
219c219
<     nm <- paste("V", 1:len, sep = "")
---
>     nm <- paste("V", seq_len(len), sep = "")
246,247c246
<     stop(paste("An object of length", length(val),
< 	       "does not match the required parameter size"))
---
>     stop(gettextf("An object of length %d does not match the required parameter size", length(val)))
250,251c249
<     stop(paste("Must give names when initializing pdIdnot from parameter.",
< 	       "without a formula"))
---
>     stop("Must give names when initializing pdIdnot from parameter without a formula")
273c271
<     stop(paste("Cannot extract the matrix with uninitialized dimensions"))
---
>     stop("Cannot extract the matrix with uninitialized dimensions")
331c329
<   function(object, structName = "Multiple of an Identity", ...)
---
>   function(object, structName = gettext("Multiple of an Identity", domain = "R-mgcv"), ...)
354c352
<   ind <- 1:colx 
---
>   ind <- seq_len(colx )
366c364
<   for (i in 1:length(object$S)) { ## work through penalties
---
>   for (i in seq_len(length(object$S))) { ## work through penalties
392c390
<       for (j in 1:n.lev) { ## assemble full sparse model matrix
---
>       for (j in seq_len(n.lev)) { ## assemble full sparse model matrix
405c403
<     ind <- 1:length(rind)
---
>     ind <- seq_len(length(rind))
443c441
<   ind <- 1:ncol(object$X)
---
>   ind <- seq_len(ncol(object$X))
446c444
<   for (i in 1:length(object$S)) { ## work through penalties
---
>   for (i in seq_len(length(object$S))) { ## work through penalties
476c474
<        rind=1:n.para,rinc=rep(n.para,n.para),pen.ind=pen.ind)
---
>        rind=seq_len(n.para),rinc=rep(n.para,n.para),pen.ind=pen.ind)
507c505
<   D <- c(ev$values[1:p.rank],rep(1,null.rank))
---
>   D <- c(ev$values[seq_len(p.rank)],rep(1,null.rank))
523c521
<     attr(random[[1]],"Xr") <- X[,1:p.rank,drop=FALSE]
---
>     attr(random[[1]],"Xr") <- X[, seq_len(p.rank), drop = FALSE]
525c523
<     random <- list(X[,1:p.rank,drop=FALSE]) 
---
>     random <- list(X[, seq_len(p.rank), drop = FALSE]) 
529c527
<   rind <- 1:p.rank
---
>   rind <- seq_len(p.rank)
584,586c582,583
<   D <- c(ev$values[1:p.rank],rep(1,null.rank))
<   if (sum(D<=0)) stop(
<   "Tensor product penalty rank appears to be too low: please email Simon.Wood@R-project.org with details.")
---
>   D <- c(ev$values[seq_len(p.rank)],rep(1,null.rank))
>   if (sum(D<=0)) stop("Tensor product penalty rank appears to be too low: please email Simon.Wood@R-project.org with details.")
593,594c590,591
<   for (l in 1:length(object$S)) {   # transform penalty explicitly
<     object$S[[l]] <- (t(U)%*%object$S[[l]]%*%U)[1:p.rank,1:p.rank]
---
>   for (l in seq_len(length(object$S))) {   # transform penalty explicitly
>     object$S[[l]] <- (t(U)%*%object$S[[l]]%*%U)[seq_len(p.rank), seq_len(p.rank)]
607,608c604,605
<   attr(random[[1]],"Xr") <- X[,1:p.rank,drop=FALSE] ## random effect model matrix
<   rind <- 1:p.rank
---
>   attr(random[[1]],"Xr") <- X[, seq_len(p.rank), drop = FALSE] ## random effect model matrix
>   rind <- seq_len(p.rank)
620c617
<                       data=stop("No data supplied to gamm.setup"),knots=NULL,
---
>                       data=stop(gettextf("No data supplied to '%s' function", "gamm.setup()")),knots=NULL,
644c641
<   if (!is.null(G$L)) stop("gamm can not handle linked smoothing parameters (probably from use of `id' or adaptive smooths)")
---
>   if (!is.null(G$L)) stop("gamm can not handle linked smoothing parameters (probably from use of 'id' or adaptive smooths)")
653c650
<   if (G$nsdf>0) ind <- 1:G$nsdf else ind <- rep(0,0)  
---
>   if (G$nsdf>0) ind <- seq_len(G$nsdf) else ind <- rep(0,0)  
662c659
<     pord <- 1:G$m
---
>     pord <- seq_len(G$m)
666c663
<     for (i in 1:G$m) if (is.null(G$smooth[[i]]$fac)) { 
---
>     for (i in seq_len(G$m)) if (is.null(G$smooth[[i]]$fac)) { 
673c670
<       if (!is.null(attr(G$smooth[[i]],"del.index"))) stop("side conditions not allowed for nested smooths")
---
>       if (!is.null(attr(G$smooth[[i]],"del.index"))) stop("side conditions are not allowed for nested smooths")
675c672
<     if (k < G$m) pord[(k+1):G$m] <- (1:G$m)[!done] 
---
>     if (k < G$m) pord[(k+1):G$m] <- seq_len(G$m)[!done] 
679c676
<   if (G$m) for (i in 1:G$m) { ## work through the smooths
---
>   if (G$m) for (i in seq_len(G$m)) { ## work through the smooths
696c693
<       for (k in 1:length(rasm$rand)) {
---
>       for (k in seq_len(length(rasm$rand))) {
718c715
<       for (j in 1:ncol(rasm$Xf)) {
---
>       for (j in seq_len(ncol(rasm$Xf))) {
801c798
< { if (!inherits(b,"lme")) stop("object does not appear to be of class lme")
---
> { if (!inherits(b,"lme")) stop(gettextf("'%s' argument is not an object of class %s", "b", dQuote("lme")))
842c839
<     rCind <- 1:n; rCind[Cind] <- 1:n
---
>     rCind <- seq_len(n); rCind[Cind] <- seq_len(n)
848c845
<     for (i in 1:n.cg) size.cg[i] <- sum(Cgrps==Clevel[i]) # size of each coarse group
---
>     for (i in seq_len(n.cg)) size.cg[i] <- sum(Cgrps==Clevel[i]) # size of each coarse group
851c848
<   } else {n.cg <- 1;Cind<-1:n}
---
>   } else {n.cg <- 1;Cind<-seq_len(n)}
874c871
<       for (i in 1:n.cg) { 
---
>       for (i in seq_len(n.cg)) { 
876c873
<         ind[[i]] <- 1:size.cg[i]
---
>         ind[[i]] <- seq_len(size.cg[i])
884,885c881,882
<       ii <- 1:n
<       for (i in 1:n.g) # work through innermost groups
---
>       ii <- seq_len(n)
>       for (i in seq_len(n.g)) # work through innermost groups
889c886
<         k <- (1:n.cg)[Clevel==Clev] # index of coarse group - i.e. update V[[k]] 
---
>         k <- seq_len(n.cg)[Clevel==Clev] # index of coarse group - i.e. update V[[k]] 
902c899
<       for (k in 1:n.cg) { # pasting correlations into right place in each matrix
---
>       for (k in seq_len(n.cg)) { # pasting correlations into right place in each matrix
909c906
<   { for (i in 1:n.cg)
---
>   { for (i in seq_len(n.cg))
932c929
<   { for (i in 1:(n.levels-start.level+1)) # work through the r.e. groupings inner to outer
---
>   { for (i in seq_len(n.levels-start.level+1)) # work through the r.e. groupings inner to outer
948c945
<     for (i in 1:(n.levels-start.level+1))
---
>     for (i in seq_len(n.levels-start.level+1))
950c947
<       for (j in 1:b$dims$ngrps[i]) 
---
>       for (j in seq_len(b$dims$ngrps[i])) 
969c966
<       for (i in 1:n.cg) {
---
>       for (i in seq_len(n.cg)) {
976c973
<         for (i in 1:n.cg) V[[i]] <- V[[i]]+Vz[[i]] 
---
>         for (i in seq_len(n.cg)) V[[i]] <- V[[i]]+Vz[[i]] 
979c976
<         for (i in 1:n.cg) {
---
>         for (i in seq_len(n.cg)) {
998c995
< { if (!inherits(b,"lme")) stop("object does not appear to be of class lme")
---
> { if (!inherits(b,"lme")) stop(gettextf("'%s' argument is not an object of class %s", "b", dQuote("lme")))
1023,1024c1020,1021
<       ind<-ii<-1:n
<       for (i in 1:n.g) 
---
>       ind<-ii<-seq_len(n)
>       for (i in seq_len(n.g)) 
1046c1043
<   { for (i in 1:(n.levels-start.level+1)) # work through the r.e. groupings inner to outer
---
>   { for (i in seq_len(n.levels-start.level+1)) # work through the r.e. groupings inner to outer
1062c1059
<     for (i in 1:(n.levels-start.level+1))
---
>     for (i in seq_len(n.levels-start.level+1))
1064c1061
<       for (j in 1:b$dims$ngrps[i]) 
---
>       for (j in seq_len(b$dims$ngrps[i])) 
1084c1081
<     for (i in 1:length(V$V))
---
>     for (i in seq_len(length(V$V)))
1142,1143c1139
<   eval(parse(text=paste("fit0 <- glm(formula = fixed, family = family, data = data,",
<                         "weights =",wts.name,",...)")))
---
>   eval(parse(text=paste("fit0 <- glm(formula = fixed, family = family, data = data,", "weights =",wts.name,",...)")))
1166c1162
<   for (i in 1:niter) {
---
>   for (i in seq_len(niter)) {
1182c1178
<   } ## end i in 1:niter
---
>   } ## end i in seq_len(niter)
1198c1194
< { if (inherits(family,"extended.family")) warning("family are not designed for use with gamm!")
---
> { if (inherits(family,"extended.family")) warning("family are not designed for use with 'gamm()' function!")
1208c1204
<       else stop("gamm() can only handle random effects defined as named lists")
---
>       else stop("'gamm()' can only handle random effects defined as named lists")
1223c1219
<         for (i in 1:length(weights)) {
---
>         for (i in seq_len(length(weights))) {
1312c1308
<       for (i in 1:r.m) rand[[n.sr+i]]<-random[[i]]   
---
>       for (i in seq_len(r.m)) rand[[n.sr+i]]<-random[[i]]   
1354c1350
<       if (verbosePQL) cat("\n Maximum number of PQL iterations: ",niterPQL,"\n")
---
>       if (verbosePQL) cat("\n ", gettext("Maximum number of PQL iterations: ", domain = "R-mgcv"), niterPQL, "\n", sep = "")
1392,1393c1388,1389
<     if (G$nsdf) p <- bf[1:G$nsdf] else p <- array(0,0)
<     if (G$m>0) for (i in 1:G$m)
---
>     if (G$nsdf) p <- bf[seq_len(G$nsdf)] else p <- array(0,0)
>     if (G$m>0) for (i in seq_len(G$m))
1403c1399
<           for (j in 1:length(flev)) {
---
>           for (j in seq_len(length(flev))) {
1423c1419
<     if (G$m>0) for (i in 1:G$m) # var.param in reverse term order, but forward order within terms!!
---
>     if (G$m>0) for (i in seq_len(G$m)) # var.param in reverse term order, but forward order within terms!!
1438c1434
<     if (length(spl)) for (i in 1:length(spl)) if (!is.null(spl[[i]])) object$sp <- c(object$sp,spl[[i]]) 
---
>     if (length(spl)) for (i in seq_len(length(spl))) if (!is.null(spl[[i]])) object$sp <- c(object$sp,spl[[i]]) 
1449,1450c1445,1446
<       Xf <- G$Xf[,1:G$nsdf,drop=FALSE] 
<       if (G$m>0) for (i in 1:G$m) {# Accumulate the total model matrix
---
>       Xf <- G$Xf[, seq_len(G$nsdf), drop = FALSE] 
>       if (G$m>0) for (i in seq_len(G$m)) {# Accumulate the total model matrix
1459c1455
<           for (k in 1:length(flev)) {
---
>           for (k in seq_len(length(flev))) {
1470c1466
<       if (G$m>0) for (i in 1:G$m) {
---
>       if (G$m>0) for (i in seq_len(G$m)) {
1485c1481
<     if (G$m>0) for (i in 1:G$m) {# Accumulate the total penalty matrix 
---
>     if (G$m>0) for (i in seq_len(G$m)) {# Accumulate the total penalty matrix 
1489c1485
<         if (ns) for (l in 1:ns) { 
---
>         if (ns) for (l in seq_len(ns)) { 
1498,1499c1494,1495
<         for (j in 1:length(flev)) {
<            if (ns) for (l in 1:ns) { 
---
>         for (j in seq_len(length(flev))) {
>            if (ns) for (l in seq_len(ns)) { 
1513c1509
<     if (G$m) for (i in 1:G$m) { 
---
>     if (G$m) for (i in seq_len(G$m)) { 
1552c1548
<     if (G$nsdf>0) term.names<-colnames(G$X)[1:G$nsdf] else term.names<-array("",0)
---
>     if (G$nsdf>0) term.names<-colnames(G$X)[seq_len(G$nsdf)] else term.names<-array("",0)
1555c1551
<       for (i in 1:n.smooth)
---
>       for (i in seq_len(n.smooth))
1604,1606c1600,1602
<     if (fit.cor<.999) { cat("FAILED: fit.cor = ",fit.cor,"\n");return()}
<     if (edf.diff>edf.tol) { cat("FAILED: edf.diff = ",edf.diff,"\n");return()}
<     cat("PASSED \n")
---
>     if (fit.cor<.999) { cat(gettextf("TEST FAILED: fit.cor = %s",fit.cor, domain = "R-mgcv"), "\n", sep = "");return()}
>     if (edf.diff>edf.tol) { cat(gettext("TEST FAILED: edf.diff = %s",edf.diff, domain = "R-mgcv"), "\n", sep = "");return()}
>     cat(gettext("TEST PASSED", domain = "R-mgcv"), "\n", sep = "")
1612c1608
<   cat("testing covariate scale invariance ... ")  
---
>   cat(gettext("testing covariate scale invariance ... ", domain = "R-mgcv"))
1618c1614
<   cat("testing invariance w.r.t. response ... ")
---
>   cat(gettext("testing invariance w.r.t. response ... ", domain = "R-mgcv"))
1623c1619
<   cat("testing equivalence of te(x) and s(x) ... ")
---
>   cat(gettext("testing equivalence of te(x) and s(x) ... ", domain = "R-mgcv"))
1628c1624
<   cat("testing equivalence of gam and gamm with same sp ... ")
---
>   cat(gettext("testing equivalence of gam and gamm with same sp ... ", domain = "R-mgcv"))
diff -rEZbwB '--exclude=*.[lo,d,pdf,mo,po,tgz,gz,save]*' '--exclude=MD5' '--exclude=Makefile*' '--exclude=all.R' '--exclude=Changes' R-recommended/mgcv/R/jagam.r Recommended/mgcv/R/jagam.r
26c26
<     cat("  for (i in 1:n) { mu[i] <- ",iltab[family$link],"} ## expected response\n",file=file,append=TRUE)
---
>     cat("  for (i in seq_len(n)) { mu[i] <- ",iltab[family$link],"} ## expected response\n",file=file,append=TRUE)
30c30
<   cat("  for (i in 1:n) { ",file=file,append=TRUE)
---
>   cat("  for (i in seq_len(n)) { ",file=file,append=TRUE)
50c50
<   } else stop("family not implemented yet")
---
>   } else stop("family not implemented yet") #IVORY
68c68
<   for (i in 1:length(uoff)) {
---
>   for (i in seq_len(length(uoff))) {
81c81
<   rp <- qrx$pivot;rp[rp] <- 1:ncol(X)
---
>   rp <- qrx$pivot;rp[rp] <- seq_len(ncol(X))
96c96
<   if (is.null(file)) stop("jagam requires a file for the JAGS model specification")
---
>   if (is.null(file)) stop("'jagam()' function requires a file for the JAGS model specification")
99c99
<     warning("smoothing parameter prior choise not recognised, reset to gamma")
---
>     warning("smoothing parameter prior choise not recognised, reset to 'gamma'")
177c177
<     ptau <- min(prior.tau[1:G$nsdf]) 
---
>     ptau <- min(prior.tau[seq_len(G$nsdf)]) 
179c179
<     cat("  for (i in 1:",G$nsdf,") { b[i] ~ dnorm(0,",ptau,") }\n",file=file,append=TRUE,sep="")
---
>     cat("  for (i in seq_len(",G$nsdf,")) { b[i] ~ dnorm(0,",ptau,") }\n",file=file,append=TRUE,sep="")
193c193
<   for (i in 1:length(G$smooth)) {
---
>   for (i in seq_len(length(G$smooth))) {
204c204
<       if (M>0) for (j in 1:M) {
---
>       if (M>0) for (j in seq_len(M)) {
216c216
<       } else for (j in 1:M) {
---
>       } else for (j in seq_len(M)) {
227c227
<       cat("  ",Kname," <- ",Sname,"[1:",p,",1:",p,"] * lambda[",n.sp+1,"] ",
---
>       cat("  ",Kname," <- ",Sname,"[seq_len(",p,"), seq_len(",p,")] * lambda[",n.sp+1,"] ",
230c230
<         for (j in 2:M) cat(" + ",Sname,"[1:",p,",",(j-1)*p+1,":",j*p,"] * lambda[",n.sp+j,"]",
---
>         for (j in 2:M) cat(" + ",Sname,"[seq_len(",p,"), ",(j-1)*p+1,":",j*p,"] * lambda[",n.sp+j,"]",
248c248
<       cat("  for (i in 1:",n.sp,") {\n",file=file,append=TRUE,sep="")
---
>       cat("  for (i in seq_len(",n.sp,")) {\n",file=file,append=TRUE,sep="")
254c254
<       cat("  for (i in 1:",n.sp,") {\n",file=file,append=TRUE,sep="")
---
>       cat("  for (i in seq_len(",n.sp,")) {\n",file=file,append=TRUE,sep="")
269c269
<       cat("  for (i in 1:",nr,") { rho0[i] ~ dunif(-12,12) }\n",file=file,append=TRUE,sep="")
---
>       cat("  for (i in seq_len(",nr,")) { rho0[i] ~ dunif(-12,12) }\n",file=file,append=TRUE,sep="")
272c272
<       cat("  for (i in 1:",n.sp,") { lambda[i] <- exp(rho[i]) }\n",file=file,append=TRUE,sep="")
---
>       cat("  for (i in seq_len(",n.sp,")) { lambda[i] <- exp(rho[i]) }\n",file=file,append=TRUE,sep="")
275c275
<       cat("  for (i in 1:",nr,") {\n",file=file,append=TRUE,sep="")
---
>       cat("  for (i in seq_len(",nr,")) {\n",file=file,append=TRUE,sep="")
281c281
<       cat("  for (i in 1:",n.sp,") { lambda[i] <- exp(rho[i]) }\n",file=file,append=TRUE,sep="")
---
>       cat("  for (i in seq_len(",n.sp,")) { lambda[i] <- exp(rho[i]) }\n",file=file,append=TRUE,sep="")
302c302
<       warning("burnin too large, reset")
---
>       warning(gettextf("'%s' argument is too large, reset", "burnin"))
329c329
<     warning("rho missing from simulation data edf.type reset to 2")
---
>     warning("'rho' slot for 'sam' argument is missing from simulation data, 'edf.type' argument reset to 2")
345c345
<     for (i in 1:length(lambda)) {
---
>     for (i in seq_len(length(lambda))) {
369,372c369,372
<     if ("residuals"%in% arg.names) stop("residuals argument not supported")
<     if ("unconditional"%in% arg.names) stop("unconditional argument not meaningful here")
<     if ("by.resids"%in% arg.names) stop("by.resids argument not supported")
<     if ("all.terms"%in% arg.names) stop("all.terms argument not supported")
---
>     if ("residuals"%in% arg.names) stop(gettextf("'%s' argument is not supported", "residuals"))
>     if ("unconditional"%in% arg.names) stop(gettextf("'%s' argument is not meaningful here", "unconfitional"))
>     if ("by.resids"%in% arg.names) stop(gettextf("'%s' argument is not supported", "by.resids"))
>     if ("all.terms"%in% arg.names) stop(gettextf("'%s' argument is not supported", "all.terms"))
388c388
<     if ("unconditional"%in% arg.names) warning("unconditional argument not meaningful here")
---
>     if ("unconditional"%in% arg.names) warning(gettextf("'%s' argument is not meaningful here", "unconditional"))
diff -rEZbwB '--exclude=*.[lo,d,pdf,mo,po,tgz,gz,save]*' '--exclude=MD5' '--exclude=Makefile*' '--exclude=all.R' '--exclude=Changes' R-recommended/mgcv/R/mgcv.r Recommended/mgcv/R/mgcv.r
32c32
<    if (k<0) stop("argument k must be positive.")
---
>    if (k<0) stop("argument 'k' must be positive")
36c36
<    if (n != ncol(A)) stop("A not square")
---
>    if (n != ncol(A)) stop("matrix 'A' is not square")
59c59
<   for (i in 1:length(na)) {
---
>   for (i in seq_len(length(na))) {
93,96c93,96
<   if (nrow(M$X)!=nar[1]) stop("nrow(M$X) != length(M$y)") 
<   if (ncol(M$X)!=nar[2]) stop("ncol(M$X) != length(M$p)")
<   if (length(M$w)!=nar[1]) stop("length(M$w) != length(M$y)")
<   if (nar[3]!=length(M$bin)) stop("nrow(M$Ain) != length(M$bin)")
---
>   if (nrow(M$X)!=nar[1]) stop("nrow(M$X) != length(M$y)", domain = NA)
>   if (ncol(M$X)!=nar[2]) stop("ncol(M$X) != length(M$p)", domain = NA)
>   if (length(M$w)!=nar[1]) stop("length(M$w) != length(M$y)", domain = NA)
>   if (nar[3]!=length(M$bin)) stop("nrow(M$Ain) != length(M$bin)", domain = NA)
98c98
<     if (ncol(M$Ain)!=nar[2]) stop("nrow(M$Ain) != length(M$p)") 
---
>     if (ncol(M$Ain)!=nar[2]) stop("nrow(M$Ain) != length(M$p)", domain = NA) 
103c103
<       warning("initial point very close to some inequality constraints")
---
>       warning("initial point is very close to some inequality constraints")
106c106
<       warning("initial parameters very close to inequality constraints")
---
>       warning("initial parameters are very close to inequality constraints")
109,111c109,111
<   if (nrow(M$C)>0) if (ncol(M$C)!=nar[2]) stop("ncol(M$C) != length(M$p)")  
<   if (length(M$S)!=length(M$off)) stop("M$S and M$off have different lengths")
<   if (length(M$S)!=length(M$sp)) stop("M$sp has different length to M$S and M$off")
---
>   if (nrow(M$C)>0) if (ncol(M$C)!=nar[2]) stop("ncol(M$C) != length(M$p)", domain = NA) 
>   if (length(M$S)!=length(M$off)) stop(gettextf("'%s' and '%s' components should have the same length", "M$S", "M$off"))
>   if (length(M$S)!=length(M$sp)) stop(gettextf("'%s', '%s' and '%s' components should have the same length", "M$sp", "M$S", "M$off"))
117c117
<   if (m>0) for (i in 1:m)
---
>   if (m>0) for (i in seq_len(m))
174,175c174,175
<   if (length(sp)>0) for (i in 1:length(sp)) {
<     ind <- (1:nt)[as.logical(vtab[sp[i],])]
---
>   if (length(sp)>0) for (i in seq_len(length(sp))) {
>     ind <- seq_len(nt)[as.logical(vtab[sp[i],])]
178,179c178,179
<   if (length(tp)>0) for (i in 1:length(tp)) {
<     ind <- (1:nt)[as.logical(vtab[tp[i],])]
---
>   if (length(tp)>0) for (i in seq_len(length(tp))) {
>     ind <- seq_len(nt)[as.logical(vtab[tp[i],])]
182,183c182,183
<   if (length(tip)>0) for (i in 1:length(tip)) {
<     ind <- (1:nt)[as.logical(vtab[tip[i],])]
---
>   if (length(tip)>0) for (i in seq_len(length(tip))) {
>     ind <- seq_len(nt)[as.logical(vtab[tip[i],])]
186,187c186,187
<    if (length(t2p)>0) for (i in 1:length(t2p)) {
<     ind <- (1:nt)[as.logical(vtab[t2p[i],])]
---
>    if (length(t2p)>0) for (i in seq_len(length(t2p))) {
>     ind <- seq_len(nt)[as.logical(vtab[t2p[i],])]
200c200
<   if (nt) for (i in 1:nt) { # work through all terms
---
>   if (nt) for (i in seq_len(nt)) { # work through all terms
248c248
<   for (i in 1:length(smooth.spec)) {
---
>   for (i in seq_len(length(smooth.spec))) {
250c250
<     ff1 <- paste(smooth.spec[[i]]$term[1:nt],collapse="+")
---
>     ff1 <- paste(smooth.spec[[i]]$term[seq_len(nt)],collapse="+")
301c301
<     for (i in 1:d) {
---
>     for (i in seq_len(d)) {
329c329
<     for (i in 1:d) if (max(ret[[i]]$lpi)>nlp||min(ret[[i]]$lpi)<1) stop("linear predictor labels out of range")
---
>     for (i in seq_len(d)) if (max(ret[[i]]$lpi)>nlp||min(ret[[i]]$lpi)<1) stop("linear predictor labels out of range")
348c348
<     QtX2[-(1:r),] <- 0
---
>     QtX2[-seq_len(r),] <- 0
350,351c350,351
<     if (rank.def>0) ind <- (1:ncol(X2))[rank(mdiff) <= rank.def] else
<     ind <- (1:ncol(X2))[mdiff < R11*tol]
---
>     if (rank.def>0) ind <- seq_len(ncol(X2))[rank(mdiff) <= rank.def] else
>     ind <- seq_len(ncol(X2))[mdiff < R11*tol]
407c407
<   for (i in 1:m) { ## collect all term names and max smooth `dim'
---
>   for (i in seq_len(m)) { ## collect all term names and max smooth `dim'
436c436
<   for (i in 1:length(sm.id)) sm.id[[i]]<-array(0,0)
---
>   for (i in seq_len(length(sm.id))) sm.id[[i]]<-array(0,0)
438,440c438,440
<   for (d in 1:maxDim) {
<     for (i in 1:m) {
<       if (sm[[i]]$dim==d&&sm[[i]]$side.constrain) for (j in 1:d) { ## work through terms
---
>   for (d in seq_len(maxDim)) {
>     for (i in seq_len(m)) {
>       if (sm[[i]]$dim==d&&sm[[i]]$side.constrain) for (j in seq_len(d)) { ## work through terms
452c452
<   if (maxDim==1) warning("model has repeated 1-d smooths of same variable.")
---
>   if (maxDim==1) warning("model has repeated 1-d smooths of same variable")
458c458
<     for (i in 1:m) { ## create parameter indices for each term
---
>     for (i in seq_len(m)) { ## create parameter indices for each term
467,468c467,468
<   for (d in 1:maxDim) { ## work up through dimensions 
<     for (i in 1:m) { ## work through smooths
---
>   for (d in seq_len(maxDim)) { ## work up through dimensions 
>     for (i in seq_len(m)) { ## work through smooths
472c472
<         for (j in 1:d) { ## work through variables
---
>         for (j in seq_len(d)) { ## work through variables
474,475c474,475
<           k <- (1:length(b))[b==i] ## locate current smooth in list 
<           if (k>1) for (l in 1:(k-1)) { ## collect X columns
---
>           k <- seq_len(length(b))[b==i] ## locate current smooth in list 
>           if (k>1) for (l in seq_len(k-1)) { ## collect X columns
509c509
<             if (mi>1) for (j in 1:mi) St <- St + 
---
>             if (mi>1) for (j in seq_len(mi)) St <- St + 
539c539
<     } ## end i in 1:m loop
---
>     } ## end i in seq_len(m) loop
541c541
<   if (with.pen) for (i in 1:m) { ## remove working variables that were added
---
>   if (with.pen) for (i in seq_len(m)) { ## remove working variables that were added
553c553
<  if (specb$dim!=spec$dim) stop("`id' linked smooths must have same number of arguments") 
---
>  if (specb$dim!=spec$dim) stop("'id' linked smooths must have same number of arguments") 
560c560
<     for (i in 1:length(specb$margin)) {
---
>     for (i in seq_len(length(specb$margin))) {
562c562
<          for (j in 1:length(specb$margin[[i]]$term)) {
---
>          for (j in seq_len(length(specb$margin[[i]]$term))) {
599c599
<   if (n.t>0) for (j in 1:n.t) if (tind[j]>0) {
---
>   if (n.t>0) for (j in seq_len(n.t)) if (tind[j]>0) {
603c603
<       ind <- (1:length(assign))[assign==tind[j]] ## index of coefs involved here
---
>       ind <- seq_len(length(assign))[assign==tind[j]] ## index of coefs involved here
610,611c610,611
<       if (!is.null(ranki)&&length(ranki)!=np) stop("`rank' has wrong length in `paraPen'") 
<       if (np) for (i in 1:np) { ## unpack penalty matrices, offsets and ranks
---
>       if (!is.null(ranki)&&length(ranki)!=np) stop("'rank' has wrong length in 'paraPen'") 
>       if (np) for (i in seq_len(np)) { ## unpack penalty matrices, offsets and ranks
624c624
<         if (nrow(Li)!=np) stop("L has wrong dimension in `paraPen'")
---
>         if (nrow(Li)!=np) stop("'L' has wrong dimension in 'paraPen'")
632c632
<           if (length(spi)!=ncol(Li)) stop("`sp' dimension wrong in `paraPen'")
---
>           if (length(spi)!=ncol(Li)) stop("'sp' dimension wrong in 'paraPen'")
646,647c646,647
<     if (length(sp0)<length(sp)) stop("`sp' too short")
<     sp0 <- sp0[1:length(sp)]
---
>     if (length(sp0)<length(sp)) stop("'sp' is too short")
>     sp0 <- sp0[seq_len(length(sp))]
696c696
<   ii <- 1:n
---
>   ii <- seq_len(n)
700c700
<   for (i in 1:nf) {
---
>   for (i in seq_len(nf)) {
703c703
<       ind <- pstart[i] + 1:nsdf[i] - 1
---
>       ind <- pstart[i] + seq_len(nsdf[i]) - 1
728c728
<       for (i in 1:nlp) { 
---
>       for (i in seq_len(nlp)) { 
742c742
<                     data=stop("No data supplied to gam.setup"),knots=NULL,sp=NULL,
---
>                     data=stop(gettextf("No data supplied to '%s' function", "gam.setup()")),knots=NULL,sp=NULL,
749,750c749,750
<   if (!is.null(paraPen)) stop("paraPen not supported for multi-formula models")
<   if (!absorb.cons) stop("absorb.cons must be TRUE for multi-formula models")
---
>   if (!is.null(paraPen)) stop("'paraPen' argument is not supported for multi-formula models")
>   if (!absorb.cons) stop("'absorb.cons' argument must be TRUE for multi-formula models")
767,768c767,768
<   for (i in 1:formula$nlp) lpi[[i]] <- rep(0,0)
<   lpi[[1]] <- 1:ncol(G$X) ## lpi[[j]] is index of cols for jth linear predictor 
---
>   for (i in seq_len(formula$nlp)) lpi[[i]] <- rep(0,0)
>   lpi[[1]] <- seq_len(ncol(G$X)) ## lpi[[j]] is index of cols for jth linear predictor 
786c786
<       lpi[[j]] <- c(lpi[[j]],pof + 1:ncol(um$X)) ## add these cols to lpi[[j]]
---
>       lpi[[j]] <- c(lpi[[j]],pof + seq_len(ncol(um$X))) ## add these cols to lpi[[j]]
800c800
<     if (um$m) for (j in 1:um$m) {
---
>     if (um$m) for (j in seq_len(um$m)) {
817c817
<     if (M) for (j in 1:M) {
---
>     if (M) for (j in seq_len(M)) {
832c832
<     if (um$nsdf>0) um$term.names[1:um$nsdf] <- paste(um$term.names[1:um$nsdf],i-1,sep=".")
---
>     if (um$nsdf>0) um$term.names[seq_len(um$nsdf)] <- paste(um$term.names[seq_len(um$nsdf)],i-1,sep=".")
851c851
<       for (i in 1:length(G$smooth)) {
---
>       for (i in seq_len(length(G$smooth))) {
856c856
<       for (i in 1:length(G$off)) G$off[i] <- G$off[i] - sum(rt$dind < G$off[i])
---
>       for (i in seq_len(length(G$off))) G$off[i] <- G$off[i] - sum(rt$dind < G$off[i])
872c872
<                      data=stop("No data supplied to gam.setup"),knots=NULL,sp=NULL,
---
>                      data=stop(gettextf("No data supplied to '%s' function", "gam.setup()")),knots=NULL,sp=NULL,
949c949
<     ind <- 1:length(PP$sp)
---
>     ind <- seq_len(length(PP$sp))
963c963
<     if (m>0) for (i in 1:m) attr(split$smooth.spec[[i]],"gamm") <- TRUE
---
>     if (m>0) for (i in seq_len(m)) attr(split$smooth.spec[[i]],"gamm") <- TRUE
968c968
<     for (i in 1:m) if (!is.null(split$smooth.spec[[i]]$id)) {
---
>     for (i in seq_len(m)) if (!is.null(split$smooth.spec[[i]]$id)) {
984c984
<         for (j in 1:length(temp.term)) id.list[[id]]$data[[j]] <- cbind(id.list[[id]]$data[[j]],
---
>         for (j in seq_len(length(temp.term))) id.list[[id]]$data[[j]] <- cbind(id.list[[id]]$data[[j]],
993c993
<         for (j in 1:length(term)) id.list[[id]]$data[[j]] <- get.var(term[j],data,vecMat=FALSE)
---
>         for (j in seq_len(length(term))) id.list[[id]]$data[[j]] <- get.var(term[j],data,vecMat=FALSE)
1002c1002
<   if (m>0) for (i in 1:m) {
---
>   if (m>0) for (i in seq_len(m)) {
1019c1019
<     for (j in 1:length(sml)) {
---
>     for (j in seq_len(length(sml))) {
1031c1031
<     if (!apply.by) for (i in 1:length(sm)) { ## restore any by-free model matrices
---
>     if (!apply.by) for (i in seq_len(length(sm))) { ## restore any by-free model matrices
1045c1045
<   if (m>0) for (i in 1:m) {
---
>   if (m>0) for (i in seq_len(m)) {
1054c1054
<           if (is.null(Sname)) spn <- paste(sm[[i]]$label,1:length.S,sep="") else
---
>           if (is.null(Sname)) spn <- paste(sm[[i]]$label, seq_len(length.S),sep="") else
1074c1074
<         stop("Later terms sharing an `id' can not have more smoothing parameters than the first such term")
---
>         stop("Later terms sharing an 'id' can not have more smoothing parameters than the first such term")
1087c1087
<   if (m>0) for (i in 1:m) {
---
>   if (m>0) for (i in seq_len(m)) {
1125c1125
<     QtX <- qr.qty(qrx,X)[1:rank,]
---
>     QtX <- qr.qty(qrx,X)[seq_len(rank),]
1127c1127
<       R <- R[1:rank,]
---
>       R <- R[seq_len(rank),]
1139c1139
<   if (G$nsdf>0) G$cmX[-(1:G$nsdf)] <- 0 ## zero the smooth parts here 
---
>   if (G$nsdf>0) G$cmX[-seq_len(G$nsdf)] <- 0 ## zero the smooth parts here 
1157,1158c1157,1158
<   { if (length(sp)!=ncol(L)) { warning("Supplied smoothing parameter vector is too short - ignored.")}
<     if (sum(is.na(sp))) { warning("NA's in supplied smoothing parameter vector - ignoring.")}
---
>   { if (length(sp)!=ncol(L)) { warning("Supplied smoothing parameter vector is too short - ignored")}
>     if (sum(is.na(sp))) { warning("NA values in supplied smoothing parameter vector - ignoring")}
1171c1171
<   if (m>0) for (i in 1:m) {
---
>   if (m>0) for (i in seq_len(m)) {
1197,1198c1197,1198
<   if (length(idx)) for (i in 1:length(idx)) idx[[i]]$sp.done <- FALSE
<   if (m>0) for (i in 1:m) { ## work through all smooths
---
>   if (length(idx)) for (i in seq_len(length(idx))) idx[[i]]$sp.done <- FALSE
>   if (m>0) for (i in seq_len(m)) { ## work through all smooths
1218,1220c1218,1220
<   { if (length(min.sp)!=nrow(L)) stop("length of min.sp is wrong.")
<     if (sum(is.na(min.sp))) stop("NA's in min.sp.")
<     if (sum(min.sp<0)) stop("elements of min.sp must be non negative.")
---
>   { if (length(min.sp)!=nrow(L)) stop(gettextf("'%s' argument is of the wrong length", "min.sp"))
>     if (sum(is.na(min.sp))) stop("NA values in 'min.sp' argument")
>     if (sum(min.sp<0)) stop("elements of 'min.sp' argument must be non negative")
1225c1225
<   if (m>0) for (i in 1:m) {
---
>   if (m>0) for (i in seq_len(m)) {
1228c1228
<     for (j in 1:length(sm$S)) {  # work through penalty matrices
---
>     for (j in seq_len(length(sm$S))) {  # work through penalty matrices
1254c1254
<       for (i in 1:length(PP$S)) {
---
>       for (i in seq_len(length(PP$S))) {
1270,1271c1270,1271
<     ef0 <- indi <- (1:length(ind))[ind]
<     if (length(indi)>0) for (i in 1:length(indi)) {
---
>     ef0 <- indi <- seq_len(length(ind))[ind]
>     if (length(indi)>0) for (i in seq_len(length(indi))) {
1294c1294
<       for (i in 1:m) {
---
>       for (i in seq_len(m)) {
1317c1317
<   if (G$nsdf > 0) term.names <- colnames(G$X)[1:G$nsdf] else term.names<-array("",0)
---
>   if (G$nsdf > 0) term.names <- colnames(G$X)[seq_len(G$nsdf)] else term.names<-array("",0)
1320c1320
<   for (i in 1:n.smooth) { ## create coef names, if smooth has any coefs!
---
>   for (i in seq_len(n.smooth)) { ## create coef names, if smooth has any coefs!
1358c1358
<   warning("`negbin' with unknown theta and outer iteration is deprecated - use `nb'. ")
---
>   warning("'negbin()' with unknown theta and outer iteration is deprecated - use 'nb()'.")
1378c1378
<   for (i in 1:n.th) { ## search through theta values
---
>   for (i in seq_len(n.th)) { ## search through theta values
1503c1503
<   if (!optimizer[2]%in%c("newton","bfgs","nlm","optim","nlm.fd")) stop("unknown outer optimization method.")
---
>   if (!optimizer[2]%in%c("newton","bfgs","nlm","optim","nlm.fd")) stop("unknown outer optimization method")
1535c1535
<       warning("only outer methods `newton' & `bfgs' supports `negbin' family and theta selection: reset")
---
>       warning("only outer methods 'newton' & 'bfgs' supports 'negbin' family and theta selection: reset")
1645c1645
<        if (!is.null(G$offset)) if (is.list(G$offset)) { for (i in 1:length(G$offset)) 
---
>        if (!is.null(G$offset)) if (is.list(G$offset)) { for (i in seq_len(length(G$offset)))
1674c1674
<   if (length(G$S)>0) for (i in 1:length(G$S)) G$UrS[[i]] <- t(Ssp$Y)%*%G$rS[[i]] else i <- 0
---
>   if (length(G$S)>0) for (i in seq_len(length(G$S))) G$UrS[[i]] <- t(Ssp$Y)%*%G$rS[[i]] else i <- 0
1796c1796
<       ind <- 1:nlsp + nth ## only used if nlsp>0
---
>       ind <- seq_len(nlsp) + nth ## only used if nlsp>0
1820c1820
<     if (inherits(G$family,"extended.family")&&nth>0) object$sp <- object$sp[-(1:nth)] ## drop theta params
---
>     if (inherits(G$family,"extended.family")&&nth>0) object$sp <- object$sp[-seq_len(nth)] ## drop theta params
1873c1873
<    ## if (v.n) for (i in 1:v.n) if (length(dl[[i]])<n) dl[[i]] <- NULL 
---
>    ## if (v.n) for (i in seq_len(v.n)) if (length(dl[[i]])<n) dl[[i]] <- NULL 
1878c1878
<      for (i in 1:v.n) if (length(dl[[i]])>=n) { 
---
>      for (i in seq_len(v.n)) if (length(dl[[i]])>=n) { 
1882c1882
<      if (k>0) v.name <- v.name[1:k] else v.name <- rep("",k)
---
>      if (k>0) v.name <- v.name[seq_len(k)] else v.name <- rep("",k)
1889c1889
<    if (v.n>0) for (i in 1:v.n) {
---
>    if (v.n>0) for (i in seq_len(v.n)) {
1901c1901
<          ii <- min((1:length(lx))[freq==max(freq)])
---
>          ii <- min(seq_len(length(lx))[freq==max(freq)])
1973c1973
<       for (i in 1:length(formula)) {
---
>       for (i in seq_len(length(formula))) {
2022c2022
<     if (G$m) for (i in 1:G$m) G$min.edf<-G$min.edf+G$smooth[[i]]$null.space.dim
---
>     if (G$m) for (i in seq_len(G$m)) G$min.edf<-G$min.edf+G$smooth[[i]]$null.space.dim
2083c2083
<   if (is.list(x$formula)) for (i in 1:length(x$formula)) print(x$formula[[i]]) else
---
>   if (is.list(x$formula)) for (i in seq_len(length(x$formula))) print(x$formula[[i]]) else
2087c2087
<   cat("Total model degrees of freedom",sum(x$edf),"\n")
---
>   cat(gettextf("Total model degrees of freedom %s",sum(x$edf), domain = "R-mgcv"), "\n", sep = "")
2090,2091c2090,2091
<     cat("\nEstimated degrees of freedom:\n")
<     for (i in 1:n.smooth)
---
>     cat("\n", gettext("Estimated degrees of freedom:", domain = "R-mgcv"), "\n", sep = "")
>     for (i in seq_len(n.smooth))
2094c2094
<     for (i in 1:n.smooth) {   
---
>     for (i in seq_len(n.smooth)) {   
2098c2098
<     cat(" total =",round(sum(x$edf),digits=2),"\n")
---
>     cat(gettextf(" total df = %s",round(sum(x$edf),digits=2), domain = "R-mgcv"), "\n", sep = "")
2101,2102c2101,2102
<   cat("\n",x$method," score: ",x$gcv.ubre,"     ",sep="")
<   if (!is.null(x$rank) && x$rank< length(x$coefficients)) cat("rank: ",x$rank,"/",length(x$coefficients),sep="") 
---
>   cat("\n", gettextf("%s score = %s", sQuote(x$method), x$gcv.ubre, domain = "R-mgcv"), "     ", sep = "")
>   if (!is.null(x$rank) && x$rank< length(x$coefficients)) cat(gettextf("Rank: %s/%s", x$rank, length(x$coefficients), domain = "R-mgcv"), sep = "") 
2123,2124c2123,2124
<     if (!is.numeric(nthreads) || nthreads <1) stop("nthreads must be a positive integer") 
<     if (!is.numeric(irls.reg) || irls.reg <0.0) stop("IRLS regularizing parameter must be a non-negative number.")
---
>     if (!is.numeric(nthreads) || nthreads <1) stop("'nthreads' argument must be a positive integer") 
>     if (!is.numeric(irls.reg) || irls.reg <0.0) stop("IRLS regularizing parameter must be a non-negative number")
2131c2131
<       warning("silly value supplied for rank.tol: reset to square root of machine precision.")
---
>       warning("silly value supplied for rank.tol: reset to square root of machine precision")
2223c2223
<   for (i in 1:length(G$S))
---
>   for (i in seq_len(length(G$S)))
2278c2278
<       for (i in 1:n.S) S.size[i]<-mean(abs(G$S[[i]])) 
---
>       for (i in seq_len(n.S)) S.size[i]<-mean(abs(G$S[[i]])) 
2290c2290
<         stop("illegal `family' argument")
---
>         stop("invalid 'family' argument")
2305c2305
<         stop("y must be univariate unless binomial")
---
>         stop("'y' must be univariate unless binomial")
2313c2313
<     stop(gettextf("Length of start should equal %d and correspond to initial coefs.",nvars)) 
---
>     stop(gettextf("Length of start should equal %d and correspond to initial coefs", nvars))
2333c2333
<     for (iter in 1:(control$maxit)) 
---
>     for (iter in seq_len(control$maxit)) 
2338c2338
<             stop("NAs in V(mu)")
---
>             stop("NA values in V(mu)")
2343c2343
<             stop("NAs in d(mu)/d(eta)")
---
>             stop("NA values in d(mu)/d(eta)")
2367c2367
<         stop("iterative weights or data non-finite in gam.fit - regularization may help. See ?gam.control.")
---
>         stop("iterative weights or data non-finite in gam.fit - regularization may help. See ?gam.control")
2405,2406c2405
<             stop("no valid set of coefficients has been found:please supply starting values",
<             call. = FALSE)
---
>             stop("no valid set of coefficients has been found:please supply starting values", call. = FALSE)
2411c2410
<                   stop("inner loop 1; can't correct step size")
---
>                   stop(gettextf("inner loop %d; can't correct step size", 1))
2421c2420
<                 cat("Step halved: new deviance =", dev, "\n")
---
>                 cat(gettextf("Step halved: new deviance = %g", dev, domain = "R-mgcv"), "\n", sep = "")
2424c2423
<             warning("Step size truncated: out of bounds.",call.=FALSE)
---
>             warning("Step size truncated: out of bounds",call. = FALSE)
2428c2427
<                   stop("inner loop 2; can't correct step size")
---
>                   stop(gettextf("inner loop %d; can't correct step size", 2))
2438c2437
<                 cat("Step halved: new deviance =", dev, "\n")
---
>                 cat(gettextf("Step halved: new deviance = %g", dev, domain = "R-mgcv"), "\n", sep = "")
2509c2508
< { if (!inherits(object,"gam")) stop("`object' is not of class \"gam\"")
---
> { if (!inherits(object,"gam")) stop(gettextf("'%s' argument is not an object of class %s", "object", dQuote("gam")))
2564c2563
<     warning("Unknown type, reset to terms.")
---
>     warning("Unknown type, reset to terms")
2596,2597c2595
<         if (sum(!(names(object$model)%in%names(newdata)))) stop(
<         "newdata is a model.frame: it should contain all required variables\n")
---
>         if (sum(!(names(object$model)%in%names(newdata)))) stop("newdata is a model.frame: it should contain all required variables\n")
2654c2652
<     for (i in 1:length(newdata)) 
---
>     for (i in seq_len(length(newdata))) 
2659c2657
<         msg <- paste(paste(levn[!levn%in%levm],collapse=", "),"not in original fit",collapse="")
---
>         msg <- gettextf("%s not in original fit", paste(levn[!levn%in%levm], collapse = ", "), domain = "R-mgcv")
2723c2721
<       warning("type iterms not available for multiple predictor cases")
---
>       warning("type 'iterms' is not available for multiple predictor cases")
2729c2727
<     for (i in 1:length(object$nsdf)) {
---
>     for (i in seq_len(length(object$nsdf))) {
2731c2729
<       if (object$nsdf[i]>0) pind <- c(pind,pstart[i]-1+1:object$nsdf[i])
---
>       if (object$nsdf[i]>0) pind <- c(pind,pstart[i]-1+seq_len(object$nsdf[i]))
2737c2735
<     pind <- 1:object$nsdf ## index of parameteric coefficients
---
>     pind <- seq_len(object$nsdf) ## index of parameteric coefficients
2745c2743
<     for (i in 1:length(Terms)) attr(Terms[[i]],"intercept") <- 1 
---
>     for (i in seq_len(length(Terms))) attr(Terms[[i]],"intercept") <- 1 
2760c2758
<   if (n.blocks > 0) for (b in 1:n.blocks) { # work through prediction blocks
---
>   if (n.blocks > 0) for (b in seq_len(n.blocks)) { # work through prediction blocks
2766c2764
<     for (i in 1:length(Terms)) { ## loop for parametric components (1 per lp)
---
>     for (i in seq_len(length(Terms))) { ## loop for parametric components (1 per lp)
2785c2783
<       if (object$nsdf[i]>0) X[,pstart[i]-1 + 1:object$nsdf[i]] <- Xp
---
>       if (object$nsdf[i]>0) X[,pstart[i]-1 + seq_len(object$nsdf[i])] <- Xp
2790c2788
<     if (n.smooth) for (k in 1:n.smooth) { ## loop through smooths
---
>     if (n.smooth) for (k in seq_len(n.smooth)) { ## loop through smooths
2815,2816c2813,2814
<       for (j in 1:length(lass)) if (length(lass[[j]])) { ## work through assign list
<         ind <- 1:length(lass[[j]]) ## index vector for coefs involved
---
>       for (j in seq_len(length(lass))) if (length(lass[[j]])) { ## work through assign list
>         ind <- seq_len(length(lass[[j]])) ## index vector for coefs involved
2818c2816
<         if (nptj>0) for (i in 1:nptj) { ## work through parametric part
---
>         if (nptj>0) for (i in seq_len(nptj)) { ## work through parametric part
2827c2825
<         for (k in 1:n.smooth) # work through the smooth terms 
---
>         for (k in seq_len(n.smooth)) # work through the smooth terms 
2872,2873c2870,2871
<           off.ind <- (1:n.smooth)[as.logical(colSums(abs(Xoff)))]
<           for (j in 1:nlp) { ## looping over the model formulae
---
>           off.ind <- seq_len(n.smooth)[as.logical(colSums(abs(Xoff)))]
>           for (j in seq_len(nlp)) { ## looping over the model formulae
3017c3015
<   if (!inherits(b,"gam")) stop("requires an object of class gam")
---
>   if (!inherits(b,"gam")) stop(gettextf("'%s' argument is not an object of class %s", "b", dQuote("gam")))
3026c3024
<   for (i in 1:m) { ## loop through smooths
---
>   for (i in seq_len(m)) { ## loop through smooths
3044c3042
<     for (i in 1:m) {
---
>     for (i in seq_len(m)) {
3048c3046
<       R <- qr.R(qr(cbind(Xi,Xj),LAPACK=FALSE,tol=0))[,-(1:r),drop=FALSE] ## No pivoting!!  
---
>       R <- qr.R(qr(cbind(Xi,Xj),LAPACK=FALSE,tol=0))[,-seq_len(r),drop=FALSE] ## No pivoting!!  
3052c3050
<       conc[1,i] <- svd(forwardsolve(t(Rt),t(R[1:r,,drop=FALSE])))$d[1]^2
---
>       conc[1,i] <- svd(forwardsolve(t(Rt),t(R[seq_len(r),,drop=FALSE])))$d[1]^2
3056c3054
<       conc[2,i] <- sum((R[1:r,,drop=FALSE]%*%beta)^2)/sum((Rt%*%beta)^2)
---
>       conc[2,i] <- sum((R[seq_len(r),,drop=FALSE]%*%beta)^2)/sum((Rt%*%beta)^2)
3059c3057
<       conc[3,i] <- sum(R[1:r,]^2)/sum(R^2)
---
>       conc[3,i] <- sum(R[seq_len(r),]^2)/sum(R^2)
3065,3066c3063,3064
<     for (i in 1:n.measures) conc[[i]] <- matrix(1,m,m) ## concurvity matrix
<     for (i in 1:m) { ## concurvity calculation loop
---
>     for (i in seq_len(n.measures)) conc[[i]] <- matrix(1,m,m) ## concurvity matrix
>     for (i in seq_len(m)) { ## concurvity calculation loop
3069c3067
<       for (j in 1:m) if (i!=j) { 
---
>       for (j in seq_len(m)) if (i!=j) { 
3071c3069
<         R <- qr.R(qr(cbind(Xi,Xj),LAPACK=FALSE,tol=0))[,-(1:r),drop=FALSE] ## No pivoting!!  
---
>         R <- qr.R(qr(cbind(Xi,Xj),LAPACK=FALSE,tol=0))[,-seq_len(r),drop=FALSE] ## No pivoting!!  
3075c3073
<         conc[[1]][i,j] <- svd(forwardsolve(t(Rt),t(R[1:r,,drop=FALSE])))$d[1]^2
---
>         conc[[1]][i,j] <- svd(forwardsolve(t(Rt),t(R[seq_len(r),,drop=FALSE])))$d[1]^2
3079c3077
<         conc[[2]][i,j] <- sum((R[1:r,,drop=FALSE]%*%beta)^2)/sum((Rt%*%beta)^2)
---
>         conc[[2]][i,j] <- sum((R[seq_len(r),,drop=FALSE]%*%beta)^2)/sum((Rt%*%beta)^2)
3082c3080
<         conc[[3]][i,j] <- sum(R[1:r,]^2)/sum(R^2)
---
>         conc[[3]][i,j] <- sum(R[seq_len(r),]^2)/sum(R^2)
3091c3089
<     for (i in 1:n.measures) rownames(conc[[i]]) <- colnames(conc[[i]]) <- lab
---
>     for (i in seq_len(n.measures)) rownames(conc[[i]]) <- colnames(conc[[i]]) <- lab
3125c3123
<       warning("Pearson residuals not available for this family - returning deviance residuals")
---
>       warning("Pearson residuals are not available for this family - returning deviance residuals")
3152c3150
<   f <- t(ed$vectors[,1:k])%*%R%*%b
---
>   f <- t(ed$vectors[,seq_len(k)])%*%R%*%b
3155c3153
<   lambda <- as.numeric(ed$values[1:k])
---
>   lambda <- as.numeric(ed$values[seq_len(k)])
3175c3173
< #    for (i in 1:length(x)) r[i] <- davies(x[i],lambda,h)$Qq
---
> #    for (i in seq_len(length(x))) r[i] <- davies(x[i],lambda,h)$Qq
3179c3177
<   if (length(h) != length(lambda)) stop("lambda and h should have the same length!")
---
>   if (length(h) != length(lambda)) stop(gettextf("'%s' and '%s' arguments should have the same length", "lambda", "h"))
3219c3217
<   p <- (1:nq-.5)/nq
---
>   p <- (seq_len(nq)-.5)/nq
3238c3236
<   if (!inherits(b,"gam")) stop("recov works with fitted gam objects only") 
---
>   if (!inherits(b,"gam")) stop(gettextf("'%s' argument is not an object of class %s", "b", dQuote("gam")))
3245c3243
<       for (i in 1:length(b$smooth)) { 
---
>       for (i in seq_len(length(b$smooth))) { 
3248c3246
<         if (ns>0) for (j in 1:ns) {
---
>         if (ns>0) for (j in seq_len(ns)) {
3264c3262
<   if (m%in%re) stop("m can't be in re")
---
>   if (m%in%re) stop("'m' argument  can't be in 're' argument")
3268c3266
<   for (i in 1:length(re)) {
---
>   for (i in seq_len(length(re))) {
3274,3275c3272,3273
<   map[rind] <- 1:p2 ## random
<   map[!rind] <- 1:p1 ## fixed
---
>   map[rind] <- seq_len(p2) ## random
>   map[!rind] <- seq_len(p1) ## fixed
3286c3284
<   for (i in 1:length(b$smooth)) { 
---
>   for (i in seq_len(length(b$smooth))) { 
3290c3288
<     if (ns>0) for (j in 1:ns) {
---
>     if (ns>0) for (j in seq_len(ns)) {
3349c3347
<   for (i in 1:length(b$smooth)) if (!is.null(b$smooth[[i]]$random)&&b$smooth[[i]]$random&&i!=m) rind <- c(rind,i)
---
>   for (i in seq_len(length(b$smooth))) if (!is.null(b$smooth[[i]]$random)&&b$smooth[[i]]$random&&i!=m) rind <- c(rind,i)
3424c3422
<   if (k1<ncol(vec)) vec <- vec[,1:k1,drop=FALSE]
---
>   if (k1<ncol(vec)) vec <- vec[,seq_len(k1),drop=FALSE]
3428c3426
<      if (k>1) vec[,1:(k-1)] <- t(t(vec[,1:(k-1)])/sqrt(ed$val[1:(k-1)]))
---
>      if (k>1) vec[,seq_len(k-1)] <- t(t(vec[,seq_len(k-1)])/sqrt(ed$val[seq_len(k-1)]))
3442c3440
<             t(t(vec)/sqrt(ed$val[1:k]))
---
>             t(t(vec)/sqrt(ed$val[seq_len(k)]))
3519c3517
<     warning("p-values for any terms that can be penalized to zero will be unreliable: refit model to fix this.")
---
>     warning("p-values for any terms that can be penalized to zero will be unreliable: refit model to fix this")
3525c3523
<   if (p.type!=0) warning("p.type!=0 is deprecated, and liable to be removed in future")
---
>   if (p.type!=0) warning("'p.type != 0' is deprecated, and liable to be removed in future")
3550c3548
<       for (i in 1:length(object$nsdf)) if (object$nsdf[i]>0) ind <- 
---
>       for (i in seq_len(length(object$nsdf))) if (object$nsdf[i]>0) ind <- 
3552c3550
<     } else { pstart <- 1;ind <- 1:object$nsdf} ## only one lp
---
>     } else { pstart <- 1;ind <- seq_len(object$nsdf)} ## only one lp
3575c3573
<   for (j in 1:length(pterms)) {
---
>   for (j in seq_len(length(pterms))) {
3583c3581
<       ind <- pstart[j] - 1 + 1:np 
---
>       ind <- pstart[j] - 1 + seq_len(np)
3589c3587
<       for (i in 1:nt) { 
---
>       for (i in seq_len(nt)) { 
3628c3626
<     for (i in 1:m) { 
---
>     for (i in seq_len(m)) { 
3650c3648
<           ind <- sample(1:nrow(object$model),sub.samp,replace=FALSE)  ## sample these rows from X
---
>           ind <- sample(seq_len(nrow(object$model)),sub.samp,replace=FALSE)  ## sample these rows from X
3661c3659
<     for (i in 1:m) { ## loop through smooths
---
>     for (i in seq_len(m)) { ## loop through smooths
3748c3746
<   cat("Formula:\n") 
---
>   cat(gettext("Formula:", domain = "R-mgcv"), "\n", sep = "")
3750c3748
<   if (is.list(x$formula)) for (i in 1:length(x$formula)) print(x$formula[[i]]) else
---
>   if (is.list(x$formula)) for (i in seq_len(length(x$formula))) print(x$formula[[i]]) else
3754c3752
<   { cat("\nParametric coefficients:\n")
---
>   { cat("\n", gettext("Parametric coefficients:", domain = "R-mgcv"), "\n", sep = "")
3759c3757
<   { cat("Approximate significance of smooth terms:\n")
---
>   { cat(gettext("Approximate significance of smooth terms:", domain = "R-mgcv"), "\n", sep = "")
3763,3765c3761,3763
<   if (!is.null(x$rank) && x$rank< x$np) cat("Rank: ",x$rank,"/",x$np,"\n",sep="") 
<   if (!is.null(x$r.sq)) cat("R-sq.(adj) = ",formatC(x$r.sq,digits=3,width=5),"  ")
<   if (length(x$dev.expl)>0) cat("Deviance explained = ",formatC(x$dev.expl*100,digits=3,width=4),"%",sep="")
---
>   if (!is.null(x$rank) && x$rank< x$np) cat(gettextf("Rank: %s/%s", x$rank, x$np, domain = "R-mgcv"), "\n", sep = "")
>   if (!is.null(x$r.sq)) cat(gettextf("R-sq.(adj) = %s", formatC(x$r.sq,digits=3,width=5), domain = "R-mgcv"), "  ", sep = "")
>   if (length(x$dev.expl)>0) cat(gettextf("Deviance explained = %s %%", formatC(x$dev.expl*100,digits=3,width=4), domain = "R-mgcv"), sep = "")
3770c3768
<   cat("  Scale est. = ",formatC(x$scale,digits=5,width=8,flag="-"),"  n = ",x$n,"\n",sep="")
---
>   cat(gettextf("  Scale est. = %s  n = %s", formatC(x$scale,digits=5,width=8,flag="-"), x$n, domain = "R-mgcv"), "\n", sep = "")
3783,3784c3781
<         warning("The following arguments to anova.glm(..) are invalid and dropped: ",
<             paste(deparse(dotargs[named]), collapse = ", "))
---
>         warning(gettext("The following arguments to anova.glm(..) are invalid and dropped: ", domain = "R-mgcv"), paste(deparse(dotargs[named]), collapse = ", "), domain = NA)
3794,3795c3791,3792
<     if (!is.null(test)) warning("test argument ignored")
<     if (!inherits(object,"gam")) stop("anova.gam called with non gam object")
---
>     if (!is.null(test)) warning("'test' argument ignored")
>     if (!inherits(object,"gam")) stop(gettextf("'%s' argument is not an object of class %s", "object", dQuote("gam")))
3806,3807c3803,3804
<   cat("Formula:\n") 
<   if (is.list(x$formula)) for (i in 1:length(x$formula)) print(x$formula[[i]]) else
---
>   cat(gettext("Formula:", domain = "R-mgcv"), "\n", sep = "")
>   if (is.list(x$formula)) for (i in seq_len(length(x$formula))) print(x$formula[[i]]) else
3810c3807
<   { cat("\nParametric Terms:\n")
---
>   { cat("\n", gettext("Parametric Terms:", domain = "R-mgcv"), "\n", sep = "")
3815c3812
<   { cat("Approximate significance of smooth terms:\n")
---
>   { cat(gettext("Approximate significance of smooth terms:", domain = "R-mgcv"), "\n", sep = "")
3829c3826
<   if (!inherits(x,"gam")) stop("not a gam object")
---
>   if (!inherits(x,"gam")) stop(gettextf("'%s' argument is not an object of class %s", "x", dQuote("gam")))
3834c3831
<   for (i in 1:length(x$smooth)) { ## work through smooths
---
>   for (i in seq_len(length(x$smooth))) { ## work through smooths
3838c3835
<       if (is.null(Snames)) Snames <- as.character(1:length(x$smooth[[i]]$S))
---
>       if (is.null(Snames)) Snames <- as.character(seq_len(length(x$smooth[[i]]$S)))
3840c3837
<       for (j in 1:length(x$smooth[[i]]$S)) {
---
>       for (j in seq_len(length(x$smooth[[i]]$S))) {
3866c3863
<   if (!inherits(x,"gam")) stop("argument is not a gam object")
---
>   if (!inherits(x,"gam")) stop(gettextf("'%s' argument is not an object of class %s", "x", dQuote("gam")))
3875c3872
<   if (!inherits(x,"gam")) stop("requires an object of class gam")
---
>   if (!inherits(x,"gam")) stop(gettextf("'%s' argument is not an object of class %s", "x", dQuote("gam")))
3889c3886
<     if (m>0) for (i in 1:m) { ## loop through all smooths
---
>     if (m>0) for (i in seq_len(m)) { ## loop through all smooths
3901,3902c3898,3899
<          warning("S.scale vector doesn't match S list - please report to maintainer")
<         for (j in 1:length(x$smooth[[i]]$S.scale)) {
---
>          warning("'S.scale' vector doesn't match S list - please report to maintainer")
>         for (j in seq_len(length(x$smooth[[i]]$S.scale))) {
3917c3914
<         for (j in 1:length(x$smooth[[ii]]$S.scale)) {
---
>         for (j in seq_len(length(x$smooth[[ii]]$S.scale))) {
3937c3934
<       ind <- 1:x$family$n.theta
---
>       ind <- seq_len(x$family$n.theta)
3969c3966
<     cat(paste("Standard deviations and",conf.lev,"confidence intervals:\n\n"))
---
>     cat(gettextf("Standard deviations and %s confidence intervals:", conf.lev, domain = "R-mgcv"), "\n\n", sep = "")
3971c3968
<     cat("\nRank: ");cat(rank);cat("/");cat(ncol(H));cat("\n")
---
>     cat("\n", gettextf("Rank: %s/%s", rank, ncol(H), domain = "R-mgcv"), "\n", sep = "")
3973c3970
<       cat("\nAll smooth components:\n")
---
>       cat("\n", gettext("All smooth components:", domain = "R-mgcv"), "\n", sep = "")
4048,4049c4045,4046
<     d<-um$d[1:rank]^0.5
<     return(t(t(um$u[,1:rank])*as.vector(d))) # note recycling rule used for efficiency
---
>     d<-um$d[seq_len(rank)]^0.5
>     return(t(t(um$u[,seq_len(rank)])*as.vector(d))) # note recycling rule used for efficiency
4061c4058
<     L <- L[,piv,drop=FALSE]; L <- t(L[1:rank,,drop=FALSE])
---
>     L <- L[,piv,drop=FALSE]; L <- t(L[seq_len(rank),,drop=FALSE])
4064c4061
<   stop("method not recognised.")
---
>   stop("method was not recognised")
4141c4138
<     for (i in 1:length(S)) {
---
>     for (i in seq_len(length(S))) {
4170c4167
<       for (i in 1:length(S)) {
---
>       for (i in seq_len(length(S))) {
4201c4198
<     for (i in 1:n.p) { # loop over penalties
---
>     for (i in seq_len(n.p)) { # loop over penalties
4215c4212
<       if (sizeS <= 0) stop(gettextf("S[[%d]] matrix is not +ve definite.", i)) 
---
>       if (sizeS <= 0) stop(gettextf("S[[%d]] matrix is not +ve definite", i))
4276,4278c4273,4275
<     if (!inherits(L,"matrix")) stop("L must be a matrix.")
<     if (nrow(L)<ncol(L)) stop("L must have at least as many rows as columns.")
<     if (nrow(L)!=n.p||ncol(L)!=length(sp)) stop("L has inconsistent dimensions.")
---
>     if (!inherits(L,"matrix")) stop("'L' argument must be a matrix")
>     if (nrow(L)<ncol(L)) stop("'L' argument must have at least as many rows as columns")
>     if (nrow(L)!=n.p||ncol(L)!=length(sp)) stop("'L' argument has inconsistent dimensions")
4285c4282
<   { for (i in 1:n.p) 
---
>   { for (i in seq_len(n.p)) 
4305c4302
<     if (n.p>0) for (i in 1:n.p) { 
---
>     if (n.p>0) for (i in seq_len(n.p)) { 
4322c4319
<     { if (dim(w)[1]!=dim(w)[2]||dim(w)[2]!=dim(X)[1]) stop("dimensions of supplied w wrong.")
---
>     { if (dim(w)[1]!=dim(w)[2]||dim(w)[2]!=dim(X)[1]) stop("dimensions of supplied 'w' argument is wrong")
4326c4323
<     { if (length(y)!=length(w)) stop("w different length from y!")
---
>     { if (length(y)!=length(w)) stop("'w' argument has different length from 'y' argument!")
4333c4330
<     if (n!=length(X)) stop("X lost dimensions in magic!!")
---
>     if (n!=length(X)) stop("'X' lost dimensions in magic!!")
4338c4335
<   if (n.p>0) for (i in 1:n.p) { 
---
>   if (n.p>0) for (i in seq_len(n.p)) { 
4366,4367c4363,4364
<   res$R <- matrix(um$X[1:q^2],q,q)
<   res$rV<-matrix(um$rV[1:(um$info[1]*q)],q,um$info[1])
---
>   res$R <- matrix(um$X[seq_len(q)^2],q,q)
>   res$rV<-matrix(um$rV[seq_len(um$info[1]*q)],q,um$info[1])
4379c4376
< } ## magic
---
> }
4387c4384
<   hello <- paste("This is mgcv ",version,". For overview type 'help(\"mgcv-package\")'.",sep="")
---
>   hello <- gettextf("This is mgcv %s. For overview type 'help(\"mgcv-package\")'", paste(version, collapse = ""), domain = "R-mgcv")
diff -rEZbwB '--exclude=*.[lo,d,pdf,mo,po,tgz,gz,save]*' '--exclude=MD5' '--exclude=Makefile*' '--exclude=all.R' '--exclude=Changes' R-recommended/mgcv/R/misc.r Recommended/mgcv/R/misc.r
11c11
<     if (ncol(mu)!=p||nrow(mu)!=n) stop("mu dimensions wrong")
---
>     if (ncol(mu)!=p||nrow(mu)!=n) stop("'mu' dimensions are wrong")
14c14
<     if (length(mu)!=p) stop("mu dimensions wrong")
---
>     if (length(mu)!=p) stop("'mu' dimensions are wrong")
46,47c46,47
<     dH <- list();ind <- 1:(nb*nb)
<     for (i in 1:nsp) { 
---
>     dH <- list();ind <- seq_len(nb*nb)
>     for (i in seq_len(nsp)) { 
69c69
<   for (i in 1:nt) pt <- pt + prod(p[ts[i]:(ts[i]+dt[i]-1)]) - as.numeric(qc[i]>0) 
---
>   for (i in seq_len(nt)) pt <- pt + prod(p[ts[i]:(ts[i]+dt[i]-1)]) - as.numeric(qc[i]>0) 
83c83
<   for (i in 1:nt) pt <- pt + prod(p[ts[i]:(ts[i]+dt[i]-1)]) - as.numeric(qc[i]>0) 
---
>   for (i in seq_len(nt)) pt <- pt + prod(p[ts[i]:(ts[i]+dt[i]-1)]) - as.numeric(qc[i]>0) 
157c157
<     piv <- 1:ncol(X); piv[qrx$pivot] <- 1:ncol(X)
---
>     piv <- seq_len(ncol(X)); piv[qrx$pivot] <- seq_len(ncol(X))
159c159
<     d <- er$d*0;d[1:rr] <- 1/er$d[1:rr]
---
>     d <- er$d*0;d[seq_len(rr)] <- 1/er$d[seq_len(rr)]
163c163
<     Ri[1:rr,1:rr] <- backsolve(R[1:rr,1:rr],diag(rr))
---
>     Ri[seq_len(rr),seq_len(rr)] <- backsolve(R[seq_len(rr),seq_len(rr)],diag(rr))
292,293c292,293
<     if (is.matrix(a)) { if (nrow(a) != x$r) stop("a has wrong number of rows") }
<     else if (length(a) != x$r) stop("a has wrong number of rows")
---
>     if (is.matrix(a)) { if (nrow(a) != x$r) stop("'a' argument has wrong number of rows") }
>     else if (length(a) != x$r) stop("'a' argument has wrong number of rows")
295,296c295,296
<     if (is.matrix(a)) { if (nrow(a) != x$c) stop("a has wrong number of rows") }
<     else if (length(a) != x$c)  stop("a has wrong number of rows")
---
>     if (is.matrix(a)) { if (nrow(a) != x$c) stop("'a' argument has wrong number of rows") }
>     else if (length(a) != x$c)  stop("'a' argument has wrong number of rows")
301c301
<   if (tr) return(matrix(oo$a[1:(a.c*x$c)],x$c,a.c)) else
---
>   if (tr) return(matrix(oo$a[seq_len(a.c*x$c)],x$c,a.c)) else
diff -rEZbwB '--exclude=*.[lo,d,pdf,mo,po,tgz,gz,save]*' '--exclude=MD5' '--exclude=Makefile*' '--exclude=all.R' '--exclude=Changes' R-recommended/mgcv/R/mvam.r Recommended/mgcv/R/mvam.r
18,19c18,19
<   for (i in 1:length(lpi)) {
<     lpi[[i]] <- 1:length(lpi[[i]]) + k
---
>   for (i in seq_len(length(lpi))) {
>     lpi[[i]] <- seq_len(length(lpi[[i]])) + k
41c41
<       lpi[[length(lpi)+1]] <- 1:nt + max(ip)
---
>       lpi[[length(lpi)+1]] <- seq_len(nt) + max(ip)
50,51c50,51
<       for (i in 1:length(lpi)) { 
<         ii <- 1:length(lpi[[i]]) + k
---
>       for (i in seq_len(length(lpi))) { 
>         ii <- seq_len(length(lpi[[i]])) + k
60,61c60,61
<       for (i in 1:length(lpi)) { 
<         ii <- 1:length(lpi[[i]]) + k
---
>       for (i in seq_len(length(lpi))) { 
>         ii <- seq_len(length(lpi[[i]])) + k
68,69c68,69
<     for (i in 1:length(lpi)) {
<       ii <- 1:length(lpi[[i]]) + k
---
>     for (i in seq_len(length(lpi))) {
>       ii <- seq_len(length(lpi[[i]])) + k
79c79
<   if (d<2) stop("mvn requires 2 or more dimensional data")
---
>   if (d<2) stop(gettextf("'%s' function requires 2 or more dimensional data", "mvn()"))
81c81
<   for (i in 1:d) {
---
>   for (i in seq_len(d)) {
102c102
<       G$term.names <- c(G$term.names,paste("R",1:ntheta,sep="."))
---
>       G$term.names <- c(G$term.names,paste("R",seq_len(ntheta),sep="."))
110c110
<       for (k in 1:ydim) {
---
>       for (k in seq_len(ydim)) {
127c127
<       ind <- G$family$data$nbeta + 1:(ydim*(ydim+1)/2);
---
>       ind <- G$family$data$nbeta + seq_len(ydim*(ydim+1)/2);
129c129
<       k <- 1;for (i in 1:ydim) for (j in i:ydim) {
---
>       k <- 1;for (i in seq_len(ydim)) for (j in i:ydim) {
195c195
<       for (i in 1:(m-1)) lpstart[i] <- lpi[[i+1]][1]
---
>       for (i in seq_len(m-1)) lpstart[i] <- lpi[[i+1]][1]
219c219
<         for (i in 1:nsp) { 
---
>         for (i in seq_len(nsp)) { 
226,227c226,227
<         d1H <- list();ind <- 1:(nb*nb)
<         for (i in 1:nsp) { 
---
>         d1H <- list();ind <- seq_len(nb*nb)
>         for (i in seq_len(nsp)) { 
diff -rEZbwB '--exclude=*.[lo,d,pdf,mo,po,tgz,gz,save]*' '--exclude=MD5' '--exclude=Makefile*' '--exclude=all.R' '--exclude=Changes' R-recommended/mgcv/R/plots.r Recommended/mgcv/R/plots.r
26c26
<         stop("fam not a family object")
---
>         stop(gettextf("'%s' argument is not an object of class %s", "fam", dQuote("family")))
53c53
<         stop("fam not a family object")
---
>         stop(gettextf("'%s' argument is not an object of class %s", "fam", dQuote("family")))
90c90
<   } else stop("object is not a glm or gam")
---
>   } else stop("'object' argument is not an object of class \"glm\" or \"gam\"")
117c117
<       for (i in 1:rep) { 
---
>       for (i in seq_len(rep)) { 
126c126
<       Dq <- quantile(as.numeric(dm),(1:n - .5)/n) 
---
>       Dq <- quantile(as.numeric(dm),(seq_len(n) - .5)/n) 
141c141
<       for (i in 1:s.rep) { 
---
>       for (i in seq_len(s.rep)) { 
159c159
<   { qqplot(Dq,D,ylab=ylab,xlab="theoretical quantiles",ylim=range(c(lim,D)),
---
>   { qqplot(Dq,D,ylab=ylab,xlab=gettext("theoretical quantiles", domain = "R-mgcv"), ylim=range(c(lim,D)),
163c163
<       if (level>=1) for (i in 1:rep) lines(Dq,dm[,i],col=rep.col) else {
---
>       if (level>=1) for (i in seq_len(rep)) lines(Dq,dm[,i],col=rep.col) else {
188c188
<     ind <- sample(1:n,subsample)
---
>     ind <- sample(seq_len(n), subsample)
193c193
<   for (k in 1:m) { ## work through smooths
---
>   for (k in seq_len(m)) { ## work through smooths
204,205c204,205
<     if (ok && ncol(dat)>nc) dat <- dat[,1:nc,drop=FALSE] ## drop any by variables
<     for (j in 1:nc) if (is.factor(dat[[j]])) ok <- FALSE 
---
>     if (ok && ncol(dat)>nc) dat <- dat[, seq_len(nc), drop = FALSE] ## drop any by variables
>     for (j in seq_len(nc)) if (is.factor(dat[[j]])) ok <- FALSE 
212,213c212,213
<         for (i in 1:n.rep) {
<           e <- diff(rsd[sample(1:nr,nr)]) ## shuffle 
---
>         for (i in seq_len(n.rep)) {
>           e <- diff(rsd[sample(seq_len(nr), nr)]) ## shuffle 
224c224
<           for (i in 1:nc) {
---
>           for (i in seq_len(nc)) {
230c230
<           for (i in 1:nc) { ## rescale distances
---
>           for (i in seq_len(nc)) { ## rescale distances
240,241c240,241
<         for (i in 1:n.rep) {
<           rsdr <- rsd[sample(1:nr,nr)] ## shuffle
---
>         for (i in seq_len(n.rep)) {
>           rsdr <- rsd[sample(seq_len(nr), nr)] ## shuffle
275,277c275,277
<     plot(linpred, resid,main="Resids vs. linear pred.",
<          xlab="linear predictor",ylab="residuals",...)
<     hist(resid,xlab="Residuals",main="Histogram of residuals",...)
---
>     plot(linpred, resid,main=gettext("Resids vs. linear pred.", domain = "R-mgcv"),
>          xlab=gettext("linear predictor", domain = "R-mgcv"), ylab=gettext("Residuals", domain = "R-mgcv"),...)
>     hist(resid,xlab=gettext("Residuals", domain = "R-mgcv"), main=gettext("Histogram of residuals", domain = "R-mgcv"),...)
281c281
<          xlab="Fitted Values",ylab="Response",main="Response vs. Fitted Values",...)
---
>          xlab=gettext("Fitted Values", domain = "R-mgcv"), ylab=gettext("Response", domain = "R-mgcv"), main=gettext("Response vs. Fitted Values", domain = "R-mgcv"),...)
287c287
<     cat("\nMethod:",b$method,"  Optimizer:",b$optimizer)
---
>     cat("\n", gettextf("Method: %s  Optimizer: %s", paste(b$method, collapse = ""), paste(b$optimizer, collapse = ""), domain = "R-mgcv"))
291,294c291,293
<         cat("\n",boi$conv," after ",boi$iter," iteration",sep="")
<         if (boi$iter==1) cat(".") else cat("s.")
<         cat("\nGradient range [",min(boi$grad),",",max(boi$grad),"]",sep="")
<         cat("\n(score ",b$gcv.ubre," & scale ",b$sig2,").",sep="")
---
>         cat("\n", sprintf(ngettext(boi$iter, "%s after %d iteration.", "%s after %d iterations.", domain = "R-mgcv"), boi$conv, boi$iter), sep = "")
>         cat("\n", gettextf("Gradient range [%s, %s]", min(boi$grad), max(boi$grad), domain = "R-mgcv"), sep = "")
>         cat("\n", gettextf("(score %s & scale %s).", b$gcv.ubre, b$sig2, domain = "R-mgcv"), sep = "")
296,297c295,296
<         if (min(ev)>0) cat("\nHessian positive definite, ") else cat("\n")
<         cat("eigenvalue range [",min(ev),",",max(ev),"].\n",sep="")
---
>         if (min(ev)>0) cat("\n", gettext("Hessian positive definite, eigenvalue range [%s, %s].", domain = "R-mgcv"), "\n", sep = "")
> 	 else cat("\n", gettextf("eigenvalue range [%s, %s].", min(ev), max(ev), domain = "R-mgcv"), "\n", sep = "")
303c302
<         cat("\nModel required no smoothing parameter selection")
---
>         cat("\n", gettext("Model required no smoothing parameter selection", domain = "R-mgcv"), "\n", sep = "")
305,310c304,312
<         cat("\nSmoothing parameter selection converged after",b$mgcv.conv$iter,"iteration")       
<         if (b$mgcv.conv$iter>1) cat("s")
<          
<         if (!b$mgcv.conv$fully.converged)
<         cat(" by steepest\ndescent step failure.\n") else cat(".\n")
<         cat("The RMS",b$method,"score gradiant at convergence was",b$mgcv.conv$rms.grad,".\n")
---
>      if (!b$mgcv.conv$fully.converged) {
>         cat("\n", sprintf(ngettext(b$mgcv.conv$iter, "Smoothing parameter selection converged after %d iteration by steepest descent step failure.",
> 				"Smoothing parameter selection converged after %d iterations by steepest descent step failure.",
> 				 domain = "R-mgcv"), b$mgcv.conv$iter), "\n", sep = "")
>      } else {
>         cat("\n", sprintf(ngettext(b$mgcv.conv$iter, "Smoothing parameter selection converged after %d iteration.",
> 				"Smoothing parameter selection converged after %d iterations.", domain = "R-mgcv"), b$mgcv.conv$iter), sep = "")       
>     }
>         cat(gettextf("The RMS %s score gradient at convergence was %s.", b$method, b$mgcv.conv$rms.grad, domain = "R-mgcv"),"\n", sep = "")
312,314c314,315
<         cat("The Hessian was positive definite.\n") else cat("The Hessian was not positive definite.\n")
<         cat("The estimated model rank was ",b$mgcv.conv$rank,
<                    " (maximum possible: ",b$mgcv.conv$full.rank,")\n",sep="")
---
>         cat(gettext("The Hessian was positive definite.", domain = "R-mgcv"), "\n", sep = "") else cat(gettext("The Hessian was not positive definite.", domain = "R-mgcv"), "\n", sep = "")
>         cat(gettextf("The estimated model rank was %s (maximum possible: %s)", b$mgcv.conv$rank, b$mgcv.conv$full.rank, domain = "R-mgcv"), "\n", sep = "")
318c319
<       cat("Model rank = ",b$rank,"/",length(b$coefficients),"\n")
---
>       cat(gettextf("Model rank = %s/%s", b$rank, length(b$coefficients), domain = "R-mgcv"), "\n", sep = "")
325,326c326
<       cat("Basis dimension (k) checking results. Low p-value (k-index<1) may\n") 
<       cat("indicate that k is too low, especially if edf is close to k\'.\n\n")
---
>       cat(gettext("Basis dimension (k) checking results. Low p-value (k-index<1) may\nindicate that k is too low, especially if edf is close to k.", domain = "R-mgcv"), "\n\n", sep = "")
349,350c349,350
<       if (is.null(xlab)) xlabel<- "Gaussian quantiles" else xlabel <- xlab
<       if (is.null(ylab)) ylabel <- "effects" else ylabel <- ylab
---
>       if (is.null(xlab)) xlabel<- gettext("Gaussian quantiles", domain = "R-mgcv") else xlabel <- xlab
>       if (is.null(ylab)) ylabel <- gettext("effects", domain = "R-mgcv") else ylabel <- ylab
548c548
<   ind <- (1:nrow(x))[is.na(rowSums(x))] ## where are the splits?
---
>   ind <- seq_len(nrow(x))[is.na(rowSums(x))] ## where are the splits?
567c567
<   for (i in 1:length(pc)) {
---
>   for (i in seq_len(length(pc))) {
587c587
<      for (i in 1:length(pc)) { 
---
>      for (i in seq_len(length(pc))) { 
595c595
<       if (all.equal(sort(nz),sort(npc))!=TRUE) stop("names of z and pc must match")
---
>       if (all.equal(sort(nz),sort(npc))!=TRUE) stop("names of 'z' and 'pc' must match")
611c611
<     for (i in 1:length(pc)) pc[[i]][,2] <- zlim[1] + 
---
>     for (i in seq_len(length(pc))) pc[[i]][,2] <- zlim[1] + 
616c616
<     for (i in 1:length(pc)) {
---
>     for (i in seq_len(length(pc))) {
630c630
<     for (i in 1:n.col) {
---
>     for (i in seq_len(n.col)) {
685c685
<     ind <- 1:P$n
---
>     ind <- seq_len(P$n)
1040c1040
<     warn <- paste("scheme should be a single number, or a vector with",m,"elements")
---
>     warn <- gettextf("scheme should be a single number, or a vector with %d elements", m)
1079c1079
<   if (m>0) for (i in 1:m) { ## work through smooth terms
---
>   if (m>0) for (i in seq_len(m)) { ## work through smooth terms
1130c1130
<   if (m>0) for (i in 1:m) n.plots <- n.plots + as.numeric(pd[[i]]$plot.me) 
---
>   if (m>0) for (i in seq_len(m)) n.plots <- n.plots + as.numeric(pd[[i]]$plot.me) 
1171c1171
<     if (m>0) for (i in 1:m) if (pd[[i]]$plot.me&&pd[[i]]$scale) { ## loop through plot data 
---
>     if (m>0) for (i in seq_len(m)) if (pd[[i]]$plot.me&&pd[[i]]$scale) { ## loop through plot data 
1202c1202
<   if (m>0) for (i in 1:m) if (pd[[i]]$plot.me&&(is.null(select)||i==select)) {
---
>   if (m>0) for (i in seq_len(m)) if (pd[[i]]$plot.me&&(is.null(select)||i==select)) {
1276c1276
<     if (fn>gn) mf<-factor(levels(fac))[1:gn]
---
>     if (fn>gn) mf<-factor(levels(fac))[seq_len(gn)]
1280c1280
<       mf[1:(ln*fn)]<-rep(levels(fac),rep(ln,fn))
---
>       mf[seq_len(ln*fn)]<-rep(levels(fac),rep(ln,fn))
1301c1301
<     for (i in 1:length(v.names)) {
---
>     for (i in seq_len(length(v.names))) {
1318,1319c1318
< 
<     for (i in 1:2) 
---
>     for (i in seq_len(2)) 
1325c1324
<   for (i in 1:2) if (is.factor(x$var.summary[[view[i]]])) {
---
>   for (i in seq_len(2)) if (is.factor(x$var.summary[[view[i]]])) {
1345c1344
<   for (i in 1:length(x$var.summary)) { 
---
>   for (i in seq_len(length(x$var.summary))) { 
1358,1359c1357,1358
<   if (type=="link") zlab<-paste("linear predictor") ## ignore codetools
<   else if (type=="response") zlab<-type
---
>   if (type=="link") zlab<-gettext("linear predictor", domain = "R-mgcv") ## ignore codetools
>   else if (type=="response") zlab<-gettext("response", domain = "R-mgcv")
diff -rEZbwB '--exclude=*.[lo,d,pdf,mo,po,tgz,gz,save]*' '--exclude=MD5' '--exclude=Makefile*' '--exclude=all.R' '--exclude=Changes' R-recommended/mgcv/R/smooth.r Recommended/mgcv/R/smooth.r
43c43
<     E <- rep(1,ncol(X));E[1:rank] <- sqrt(er$value[1:rank])
---
>     E <- rep(1,ncol(X));E[seq_len(rank)] <- sqrt(er$value[seq_len(rank)])
48c48
<     av.norm <- mean(col.norm[1:rank])
---
>     av.norm <- mean(col.norm[seq_len(rank)])
73c73
<       ind <- 1:rank
---
>       ind <- seq_len(rank)
96c96
<   D <- er$values[1:rank] 
---
>   D <- er$values[seq_len(rank)]
111c111
<     ind <- 1:rank
---
>     ind <- seq_len(rank)
143c143
<   if (n<4) stop("At least three knots required in call to mono.con.")
---
>   if (n<4) stop("At least three knots required in call passed to 'mono.con()'")
146c146
<   if (lo*hi==1&&lower>=upper) stop("lower bound >= upper bound in call to mono.con()")
---
>   if (lo*hi==1&&lower>=upper) stop("lower bound >= upper bound in call passed to 'mono.con()'")
158c158
<   if (is.null(x)) stop("x is null")
---
>   if (is.null(x)) stop("'x' argument is null")
160,161c160,161
<   #if (is.null(nrow(x))) stop("x has no row attribute")
<   #if (is.null(ncol(x))) stop("x has no col attribute")
---
>   #if (is.null(nrow(x))) stop(gettextf("'%s' argument has no '%s' attribute", "x", "row"))
>   #if (is.null(ncol(x))) stop(gettextf("'%s' argument has no '%s' attribute", "x", "col"))
170c170
<   x <- matrix(res$x[1:n],res$r,res$c)
---
>   x <- matrix(res$x[seq_len(n)],res$r,res$c)
174c174
<     for (i in 1:ncol(xo)) if (is.factor(xo[,i])) { ## may need to reset factors to factors
---
>     for (i in seq_len(ncol(xo))) if (is.factor(xo[,i])) { ## may need to reset factors to factors
176,177c176,177
<       x[,i] <- if (is.ordered(xo[,i])) ordered(x[,i],levels=1:length(xoi),labels=xoi) else 
<                factor(x[,i],levels=1:length(xoi),labels=xoi)
---
>       x[,i] <- if (is.ordered(xo[,i])) ordered(x[,i],levels=seq_len(length(xoi)),labels=xoi) else 
>                factor(x[,i],levels=seq_len(length(xoi)),labels=xoi)
193c193
<   if (min(x)<k1||max(x)>knots[nk]) stop("x out of range")
---
>   if (min(x)<k1||max(x)>knots[nk]) stop("'x' out of range")
268c268
<   for (i in 1:dim) term[i] <- attr(terms(reformulate(term[i])),"term.labels")
---
>   for (i in seq_len(dim)) term[i] <- attr(terms(reformulate(term[i])),"term.labels")
281c281
<     { warning("something wrong with argument d.")
---
>     { warning("something wrong with argument 'd'")
300c300
<   { warning("dimension of fx is wrong") 
---
>   { warning("dimension of 'fx' is wrong") 
306c306
<   if (is.null(xt)||length(xt)==1) for (i in 1:n.bases) xtra[[i]] <- xt else
---
>   if (is.null(xt)||length(xt)==1) for (i in seq_len(n.bases)) xtra[[i]] <- xt else
308c308
<   stop("xt argument is faulty.")
---
>   stop(gettextf("'%s' argument is faulty", "xt"))
312c312
<   if (length(bs)!=n.bases) {warning("bs wrong length and ignored.");bs<-rep("cr",n.bases)}
---
>   if (length(bs)!=n.bases) { warning(gettextf("'%s' argument is of the wrong length and ignored", "bs")); bs <- rep("cr",n.bases) }
318c318
<     warning("m wrong length and ignored.");
---
>     warning(gettextf("'%s' argument is of the wrong length and ignored", "m"));
328c328
<   for (i in 1:n.bases)
---
>   for (i in seq_len(n.bases))
347c347
<       warning("only first element of `id' used")
---
>       warning("only first element of 'id' used")
376c376
<   for (i in 1:dim) term[i] <- attr(terms(reformulate(term[i])),"term.labels")
---
>   for (i in seq_len(dim)) term[i] <- attr(terms(reformulate(term[i])),"term.labels")
389c389
<     { warning("something wrong with argument d.")
---
>     { warning("something wrong with argument 'd'")
408c408
<   if (is.null(xt)||length(xt)==1) for (i in 1:n.bases) xtra[[i]] <- xt else
---
>   if (is.null(xt)||length(xt)==1) for (i in seq_len(n.bases)) xtra[[i]] <- xt else
410c410
<   stop("xt argument is faulty.")
---
>   stop(gettextf("'%s' argument is faulty", "xt"))
414c414
<   if (length(bs)!=n.bases) {warning("bs wrong length and ignored.");bs<-rep("cr",n.bases)}
---
>   if (length(bs)!=n.bases) { warning(gettextf("'%s' argument is of the wrong length and ignored", "bs")); bs<-rep("cr",n.bases) }
420c420
<     warning("m wrong length and ignored.");
---
>     warning(gettextf("'%s' argument is of the wrong length and ignored", "m"));
430c430
<   for (i in 1:n.bases)
---
>   for (i in seq_len(n.bases))
444c444
<       warning("ord is wrong. reset to NULL.")
---
>       warning("ord is wrong. reset to NULL")
457c457
<       warning("only first element of `id' used")
---
>       warning("only first element of 'id' used")
484c484
<   if (by.var==".") stop("by=. not allowed")
---
>   if (by.var==".") stop("'by=.' is not allowed")
486c486
<   if (term[1]==".") stop("s(.) not yet supported.")
---
>   if (term[1]==".") stop("'s(.)' function is not yet supported")
490c490
<     if (term[i]==".") stop("s(.) not yet supported.")
---
>     if (term[i]==".") stop("'s(.)' function is not yet supported")
492c492
<   for (i in 1:d) term[i] <- attr(terms(reformulate(term[i])),"term.labels")
---
>   for (i in seq_len(d)) term[i] <- attr(terms(reformulate(term[i])),"term.labels")
496c496
<   if (all.equal(k.new,k)!=TRUE) {warning("argument k of s() should be integer and has been rounded")}
---
>   if (all.equal(k.new,k)!=TRUE) {warning("argument 'k' of 's()' function should be integer and has been rounded")}
507c507
<       warning("only first element of `id' used")
---
>       warning("only first element of 'id' used")
532c532
<     for (j in 1:ncol(X[[i]]))
---
>     for (j in seq_len(ncol(X[[i]])))
564c564
<   I<-list(); for (i in 1:m) { 
---
>   I<-list(); for (i in seq_len(m)) { 
571c571
<   for (i in 1:m)
---
>   for (i in seq_len(m))
596c596
<   for (i in 1:m) { 
---
>   for (i in seq_len(m)) { 
599c599
<     for (j in 1:length(term)) { 
---
>     for (j in seq_len(length(term))) { 
612c612
<     stop("Sorry, tensor products of smooths with multiple penalties are not supported.")
---
>     stop("Sorry, tensor products of smooths with multiple penalties are not supported")
621c621
<   for (i in 1:m) {
---
>   for (i in seq_len(m)) {
650c650
<   for (i in 1:m)  Sm[[i]] <- Sm[[i]]/eigen(Sm[[i]],symmetric=TRUE,only.values=TRUE)$values[1] 
---
>   for (i in seq_len(m))  Sm[[i]] <- Sm[[i]]/eigen(Sm[[i]],symmetric=TRUE,only.values=TRUE)$values[1] 
690c690
<   for (i in 1:m) { 
---
>   for (i in seq_len(m)) { 
693c693
<     for (j in 1:length(term)) dat[[term[j]]] <- data[[term[j]]]
---
>     for (j in seq_len(length(term))) dat[[term[j]]] <- data[[term[j]]]
699c699
<   for (i in 1:mxp) if (!is.null(object$XP[[i]])) X[[i]] <- X[[i]]%*%object$XP[[i]]
---
>   for (i in seq_len(mxp)) if (!is.null(object$XP[[i]])) X[[i]] <- X[[i]]%*%object$XP[[i]]
722c722
<   Zi <- Xm[[1]][,1:rank[1],drop=FALSE] ## range space basis for first margin
---
>   Zi <- Xm[[1]][,seq_len(rank)[1],drop=FALSE] ## range space basis for first margin
733c733
<       colnames(Xi) <- as.character(1:ncol(Xi)) 
---
>       colnames(Xi) <- as.character(seq_len(ncol(Xi))) 
744c744
<     Zi <- Xm[[i]][,1:rank[i],drop=FALSE]   ## margin i range space
---
>     Zi <- Xm[[i]][,seq_len(rank)[i],drop=FALSE]   ## margin i range space
748c748
<       if (full) colnames(Xi)  <- as.character(1:ncol(Xi))
---
>       if (full) colnames(Xi)  <- as.character(seq_len(ncol(Xi)))
755c755
<     for (ii in 1:length(X1)) { ## form products with Zi
---
>     for (ii in seq_len(length(X1))) { ## form products with Zi
758c758
<         for (j in 1:ncol(X1[[ii]])) A <- cbind(A,X1[[ii]][,j]*Zi)
---
>         for (j in seq_len(ncol(X1[[ii]]))) A <- cbind(A,X1[[ii]][,j]*Zi)
766c766
<         for (j in 1:ncol(X1[[ii]])) {
---
>         for (j in seq_len(ncol(X1[[ii]]))) {
777c777
<       for (ii in 1:length(X1)) { ## form products with Xi
---
>       for (ii in seq_len(length(X1))) { ## form products with Xi
784c784
<           for (j in 1:ncol(X1[[ii]])) { 
---
>           for (j in seq_len(ncol(X1[[ii]]))) { 
796c796
<            for (j in 1:ncol(Xi)) {
---
>            for (j in seq_len(ncol(Xi))) {
840c840
<   for (i in 1:m) { ## create marginal model matrices and penalties...
---
>   for (i in seq_len(m)) { ## create marginal model matrices and penalties...
844c844
<     for (j in 1:length(term)) { 
---
>     for (j in seq_len(length(term))) { 
856c856
<     stop("Sorry, tensor products of smooths with multiple penalties are not supported.")
---
>     stop("Sorry, tensor products of smooths with multiple penalties are not supported")
867c867
<     dS <- rep(0,ncol(Xm[[i]]));dS[1:r[i]] <- 1;
---
>     dS <- rep(0,ncol(Xm[[i]]));dS[seq_len(r[i])] <- 1;
886c886
<   if (nsc>0) for (j in 1:nsc) {
---
>   if (nsc>0) for (j in seq_len(nsc)) {
908c908
<   nup <- sum(sub.cols[1:nsc]) ## range space rank
---
>   nup <- sum(sub.cols[seq_len(nsc)]) ## range space rank
914,915c914,915
<     ##  X.shift <- colMeans(X[,1:nup])
<     ##  X[,1:nup] <- sweep(X[,1:nup],2,X.shift) ## make penalized columns orthog to constant col.
---
>     ##  X.shift <- colMeans(X[,seq_len(nup)])
>     ##  X[,seq_len(nup)] <- sweep(X[,seq_len(nup)],2,X.shift) ## make penalized columns orthog to constant col.
930c930
<   object$rank <- sub.cols[1:nsc] ## ranks of individual penalties
---
>   object$rank <- sub.cols[seq_len(nsc)] ## ranks of individual penalties
942c942
<   for (i in 1:m) { 
---
>   for (i in seq_len(m)) { 
945c945
<     for (j in 1:length(term)) dat[[term[j]]] <- data[[term[j]]]
---
>     for (j in seq_len(length(term))) dat[[term[j]]] <- data[[term[j]]]
956c956
<   ind <- 1:ncol(object$S[[1]])                   ## index of penalty columns 
---
>   ind <- seq_len(ncol(object$S[[1]]))                   ## index of penalty columns 
961c961
<   for (i in 1:length(object$S)) { ## work through penalties
---
>   for (i in seq_len(length(object$S))) { ## work through penalties
1001c1001
<   for (i in 1:m) if (inherits(sm[[i]],"t2.smooth")&&length(sm[[i]]$S)>1) { not.needed <- FALSE;break}
---
>   for (i in seq_len(m)) if (inherits(sm[[i]],"t2.smooth")&&length(sm[[i]]$S)>1) { not.needed <- FALSE;break}
1005c1005
<   for (i in 1:m) {
---
>   for (i in seq_len(m)) {
1009c1009
<       for (j in 1:length(smi)) {
---
>       for (j in seq_len(length(smi))) {
1027c1027
< { if (sum(d<0)) stop("d can not be negative in call to null.space.dimension().")
---
> { if (sum(d<0)) stop("'d' can not be negative in call passed to 'null.space.dimension()'")
1059c1059
<   for (i in 1:object$dim) 
---
>   for (i in seq_len(object$dim)) 
1071c1071
<     for (i in 1:object$dim) 
---
>     for (i in seq_len(object$dim)) 
1082c1082
<   warning("more knots than data in a tp term: knots ignored.")}
---
>   warning("more knots than data in a tp term: knots ignored")}
1097c1097
<       ind <- sample(1:nu,nk,replace=FALSE)  ## by sampling these rows from xu
---
>       ind <- sample(seq_len(nu),nk,replace=FALSE)  ## by sampling these rows from xu
1150c1150
<   object$UZ<-matrix(oo$UZ[1:UZ.len],oo$n.Xu+M,k)         # truncated basis matrix
---
>   object$UZ<-matrix(oo$UZ[seq_len(UZ.len)],oo$n.Xu+M,k)         # truncated basis matrix
1152c1152
<   object$Xu<-matrix(oo$Xu[1:Xu.len],oo$n.Xu,object$dim)  # unique covariate combinations
---
>   object$Xu<-matrix(oo$Xu[seq_len(Xu.len)],oo$n.Xu,object$dim)  # unique covariate combinations
1160c1160
<     ind <- 1:(k-M)
---
>     ind <- seq_len(k-M)
1193c1193
<   for (i in 1:object$dim) 
---
>   for (i in seq_len(object$dim)) 
1206c1206
<   ind <- 1:object$bs.dim
---
>   ind <- seq_len(object$bs.dim)
1265,1266c1265
<   { msg <- paste(object$term," has insufficient unique values to support ",
<                  nk," knots: reduce k.",sep="")
---
>   { msg <- gettextf("%s has insufficient unique values to support %d knots: reduce k", object$term, nk)
1366,1367c1365,1366
<   lbi<-floor(delta*1:(nk-2))+1 # lower interval bound index
<   frac<-delta*1:(nk-2)+1-lbi # left over proportion of interval  
---
>   lbi<-floor(delta*seq_len(nk-2))+1 # lower interval bound index
>   frac<-delta*seq_len(nk-2)+1-lbi # left over proportion of interval  
1383c1382
<     h<-x[2:n]-x[1:(n-1)]
---
>     h<-x[2:n]-x[seq_len(n-1)]
1458c1457
<     h<-knots[2:n]-knots[1:(n-1)]
---
>     h<-knots[2:n]-knots[seq_len(n-1)]
1510c1509
<     stop(paste("there should be ",nk," supplied knots"))
---
>     stop(gettextf("there should be %d supplied knots", nk))
1513c1512
<   if (length(k)!=nk) stop(paste("there should be",nk,"knots supplied"))
---
>   if (length(k)!=nk) stop(gettextf("there should be %d knots supplied", nk))
1528,1530c1527,1529
<     for (i in 1:p.ord) De <- diff(De)
<     D <- De[,-(1:p.ord)]
<     D[,(np-p.ord+1):np] <-  D[,(np-p.ord+1):np] + De[,1:p.ord]
---
>     for (i in seq_len(p.ord)) De <- diff(De)
>     D <- De[,-seq_len(p.ord)]
>     D[,(np-p.ord+1):np] <-  D[,(np-p.ord+1):np] + De[,seq_len(p.ord)]
1580c1579
<     stop(paste("there should be ",nk+2*m[1]+2," supplied knots"))
---
>     stop(gettextf("there should be %d supplied knots",nk+2*m[1]+2))
1589c1588
<   if (m[2]) for (i in 1:m[2]) S <- diff(S)
---
>   if (m[2]) for (i in seq_len(m)[2]) S <- diff(S)
1657c1656
<   for (i in 1:length(object$term)) if (is.factor(data[[object$term[i]]])) { 
---
>   for (i in seq_len(length(object$term))) if (is.factor(data[[object$term[i]]])) { 
1681c1680
<   for (i in 1:object$dim) if (object$term[i]!=fterm) {
---
>   for (i in seq_len(object$dim)) if (object$term[i]!=fterm) {
1707c1706
<   for (i in 1:null.d) { ## create null space element penalties
---
>   for (i in seq_len(null.d)) { ## create null space element penalties
1719c1718
<   #for (i in 1:null.d) { ## null space penalties
---
>   #for (i in seq_len(null.d)) { ## null space penalties
1741c1740
<     for (i in 1:null.d) { ## null space penalties
---
>     for (i in seq_len(null.d)) { ## null space penalties
1795c1794
<   for (i in 1:length(object$flev)) {
---
>   for (i in seq_len(length(object$flev))) {
1807c1806
< ## sets M[i[k],j[k]] <- m[k] for all k in 1:length(m) without
---
> ## sets M[i[k],j[k]] <- m[k] for all k in seq_len(length(m)) without
1826,1828c1825,1827
<   Ind <- matrix(1:(ni*nj),ni,nj) ## the indexing matrix
<   rmt <- rep(1:ni,nj) ## the row index
<   cmt <- rep(1:nj,rep(ni,nj)) ## the column index
---
>   Ind <- matrix(seq_len(ni*nj),ni,nj) ## the indexing matrix
>   rmt <- rep(seq_len(ni),nj) ## the row index
>   cmt <- rep(seq_len(nj),rep(ni,nj)) ## the column index
1830c1829
<   ci <- Ind[2:(ni-1),1:nj] ## column index
---
>   ci <- Ind[2:(ni-1),seq_len(nj)] ## column index
1836,1840c1835,1839
<   Drr <- mfil(Drr,1:n.ci,ci,-2) ## central coefficient
<   ci <- Ind[1:(ni-2),1:nj] 
<   Drr <- mfil(Drr,1:n.ci,ci,1) ## back coefficient
<   ci <- Ind[3:ni,1:nj]
<   Drr <- mfil(Drr,1:n.ci,ci,1) ## forward coefficient
---
>   Drr <- mfil(Drr,seq_len(n.ci),ci,-2) ## central coefficient
>   ci <- Ind[seq_len(ni-2),seq_len(nj)] 
>   Drr <- mfil(Drr,seq_len(n.ci),ci,1) ## back coefficient
>   ci <- Ind[3:ni,seq_len(nj)]
>   Drr <- mfil(Drr,seq_len(n.ci),ci,1) ## forward coefficient
1843c1842
<   ci <- Ind[1:ni,2:(nj-1)] ## column index
---
>   ci <- Ind[seq_len(ni),2:(nj-1)] ## column index
1849,1853c1848,1852
<   Dcc <- mfil(Dcc,1:n.ci,ci,-2) ## central coefficient
<   ci <- Ind[1:ni,1:(nj-2)]
<   Dcc <- mfil(Dcc,1:n.ci,ci,1) ## back coefficient
<   ci <- Ind[1:ni,3:nj]
<   Dcc <- mfil(Dcc,1:n.ci,ci,1) ## forward coefficient
---
>   Dcc <- mfil(Dcc,seq_len(n.ci),ci,-2) ## central coefficient
>   ci <- Ind[seq_len(ni),seq_len(nj-2)]
>   Dcc <- mfil(Dcc,seq_len(n.ci),ci,1) ## back coefficient
>   ci <- Ind[seq_len(ni),3:nj]
>   Dcc <- mfil(Dcc,seq_len(n.ci),ci,1) ## forward coefficient
1862,1863c1861,1862
<   ci <- Ind[1:(ni-2),1:(nj-2)] 
<   Dcr <- mfil(Dcr,1:n.ci,ci,sqrt(0.125)) ## -- coefficient
---
>   ci <- Ind[seq_len(ni-2),seq_len(nj-2)] 
>   Dcr <- mfil(Dcr,seq_len(n.ci),ci,sqrt(0.125)) ## -- coefficient
1865,1869c1864,1868
<   Dcr <- mfil(Dcr,1:n.ci,ci,sqrt(0.125)) ## ++ coefficient
<   ci <- Ind[1:(ni-2),3:nj] 
<   Dcr <- mfil(Dcr,1:n.ci,ci,-sqrt(0.125)) ## -+ coefficient
<   ci <- Ind[3:ni,1:(nj-2)] 
<   Dcr <- mfil(Dcr,1:n.ci,ci,-sqrt(0.125)) ## +- coefficient
---
>   Dcr <- mfil(Dcr,seq_len(n.ci),ci,sqrt(0.125)) ## ++ coefficient
>   ci <- Ind[seq_len(ni-2),3:nj] 
>   Dcr <- mfil(Dcr,seq_len(n.ci),ci,-sqrt(0.125)) ## -+ coefficient
>   ci <- Ind[3:ni,seq_len(nj-2)] 
>   Dcr <- mfil(Dcr,seq_len(n.ci),ci,-sqrt(0.125)) ## +- coefficient
1887c1886
<   if (object$dim> 2 )  stop("the adaptive smooth class is limited to 1 or 2 covariates.")
---
>   if (object$dim> 2 )  stop("the adaptive smooth class is limited to 1 or 2 covariates")
1908c1907
<       x <- 1:(nk-2)/nk;m=2
---
>       x <- seq_len(nk-2)/nk;m=2
1920c1919
<      # for (i in 1:k) D[[i]] <- as.numeric(V[,i])*Db
---
>      # for (i in seq_len(k)) D[[i]] <- as.numeric(V[,i])*Db
1923c1922
<       for (i in 1:k) {
---
>       for (i in seq_len(k)) {
1939c1938
<       for (i in 1:2) {
---
>       for (i in seq_len(2)) {
1985c1984
<         for (i in 1:kp.tot) {
---
>         for (i in seq_len(kp.tot)) {
2018c2017
<   if (!is.null(object$id)) stop("random effects don't work with ids.")
---
>   if (!is.null(object$id)) stop("random effects don't work with ids")
2031c2030
<     for (i in 1:object$dim) {
---
>     for (i in seq_len(object$dim)) {
2041c2040
<       ind <- 1:ns;ind[maxi] <- ns ;ind[ns] <- maxi
---
>       ind <- seq_len(ns);ind[maxi] <- ns ;ind[ns] <- maxi
2044c2043
<       for (i in 1:ns) object$term <- c(object$term,object$margin[[i]]$term)
---
>       for (i in seq_len(ns)) object$term <- c(object$term,object$margin[[i]]$term)
2105c2104
<   for (i in 1:n.poly) {
---
>   for (i in seq_len(n.poly)) {
2120c2119
<   for (i in 1:length(pc)) nb[[i]] <- rep(0,0)
---
>   for (i in seq_len(length(pc))) nb[[i]] <- rep(0,0)
2122c2121
<   for (k in 1:n.poly) { ## work through poly list looking for neighbours
---
>   for (k in seq_len(n.poly)) { ## work through poly list looking for neighbours
2128c2127
<     ind <- (1:n.poly)[ol] ## index of potential neighbours of poly k
---
>     ind <- seq_len(n.poly)[ol] ## index of potential neighbours of poly k
2131c2130
<     if (length(ind)>0) for (j in 1:length(ind)) {
---
>     if (length(ind)>0) for (j in seq_len(length(ind))) {
2140c2139
<   for (i in 1:length(pc)) nb[[i]] <- unique(nb[[i]])
---
>   for (i in seq_len(length(pc))) nb[[i]] <- unique(nb[[i]])
2197,2198c2196,2197
<     for (i in 1:length(d.name)) {
<       ind <- (1:length(a.name))[a.name==d.name[i]] ## index of duplicates 
---
>     for (i in seq_len(length(d.name))) {
>       ind <- seq_len(length(a.name))[a.name==d.name[i]] ## index of duplicates 
2203c2202
<       ind <- (1:length(a.name))[duplicated(a.name)]
---
>       ind <- seq_len(length(a.name))[duplicated(a.name)]
2220c2219
<     for (i in 1:np) {
---
>     for (i in seq_len(np)) {
2224c2223
<       if (lind>0) for (j in 1:lind) S[a.name[i],a.name[ind[j]]] <- -1
---
>       if (lind>0) for (j in seq_len(lind)) S[a.name[i],a.name[ind[j]]] <- -1
2253c2252
<       for (i in 1:length(mi)) object$X[i,mi[i]] <- 1
---
>       for (i in seq_len(length(mi))) object$X[i,mi[i]] <- 1
2259c2258
<     object$X <- if (length(mi)) rp$X[-(1:length(mi)),ind] else  rp$X[,ind] ## model matrix
---
>     object$X <- if (length(mi)) rp$X[-seq_len(length(mi)),ind] else  rp$X[,ind] ## model matrix
2404c2403
<   for (i in 1:2) {
---
>   for (i in seq_len(2)) {
2414c2413
<     for (i in 1:2) 
---
>     for (i in seq_len(2)) 
2426c2425
<     warning("more knots than data in an sos term: knots ignored.")
---
>     warning("more knots than data in an sos term: knots ignored")
2443c2442
<         ind <- sample(1:nu,nk,replace=FALSE)  ## by sampling these rows from xu
---
>         ind <- sample(seq_len(nu),nk,replace=FALSE)  ## by sampling these rows from xu
2462c2461
<   R <- makeR(la=knt[1:nk],lo=knt[-(1:nk)],lak=knt[1:nk],lok=knt[-(1:nk)],m=object$p.order)
---
>   R <- makeR(la=knt[seq_len(nk)],lo=knt[-seq_len(nk)],lak=knt[seq_len(nk)],lok=knt[-seq_len(nk)],m=object$p.order)
2464c2463
<   ind <- 1:ncol(T)
---
>   ind <- seq_len(ncol(T))
2517c2516
<   lak <- object$knt[1:nk];lok <- object$knt[-(1:nk)] ## knots
---
>   lak <- object$knt[seq_len(nk)];lok <- object$knt[-seq_len(nk)] ## knots
2521,2522c2520,2521
<     for (i in 1:n.chunk) { ## build predict matrix in chunks
<       ind <- 1:nk + (i-1)*nk
---
>     for (i in seq_len(n.chunk)) { ## build predict matrix in chunks
>       ind <- seq_len(nk) + (i-1)*nk
2570c2569
<   for (i in 1:M) {
---
>   for (i in seq_len(M)) {
2572c2571
<     for (j in 1:n) y <- y * x[,j]^p[i,j]
---
>     for (j in seq_len(n)) y <- y * x[,j]^p[i,j]
2580c2579
<   ind <- expand.grid(x=1:nrow(x),xk=1:nrow(xk))
---
>   ind <- expand.grid(x=seq_len(nrow(x)),xk=seq_len(nrow(xk)))
2611c2610
<   for (i in 1:object$dim) {
---
>   for (i in seq_len(object$dim)) {
2621c2620
<     for (i in 1:object$dim) 
---
>     for (i in seq_len(object$dim)) 
2633c2632
<     warning("more knots than data in a ds term: knots ignored.")
---
>     warning("more knots than data in a ds term: knots ignored")
2654c2653
<         ind <- sample(1:nu,nk,replace=FALSE)  ## by sampling these rows from xu
---
>         ind <- sample(seq_len(nu),nk,replace=FALSE)  ## by sampling these rows from xu
2708c2707
<   ind <- 1:ncol(T)
---
>   ind <- seq_len(ncol(T))
2762c2761
<   for (i in 1:object$dim) {
---
>   for (i in seq_len(object$dim)) {
2775,2776c2774,2775
<     for (i in 1:n.chunk) { ## build predict matrix in chunks
<       ind <- 1:nk + (i-1)*nk
---
>     for (i in seq_len(n.chunk)) { ## build predict matrix in chunks
>       ind <- seq_len(nk) + (i-1)*nk
2808c2807
<   ind <- expand.grid(x=1:nrow(x),xk=1:nrow(xk))
---
>   ind <- expand.grid(x=seq_len(nrow(x)),xk=seq_len(nrow(xk)))
2845c2844
<   for (i in 1:object$dim) {
---
>   for (i in seq_len(object$dim)) {
2855c2854
<     for (i in 1:object$dim) { 
---
>     for (i in seq_len(object$dim)) { 
2887c2886
<         ind <- sample(1:nu,nk,replace=FALSE)  ## by sampling these rows from xu
---
>         ind <- sample(seq_len(nu),nk,replace=FALSE)  ## by sampling these rows from xu
2926c2925
<     D[1:k,1:k] <- E  ## penalty
---
>     D[seq_len(k),seq_len(k)] <- E  ## penalty
2952c2951
<   for (i in 1:object$dim) {
---
>   for (i in seq_len(object$dim)) {
2965,2966c2964,2965
<     for (i in 1:n.chunk) { ## build predict matrix in chunks
<       ind <- 1:nk + (i-1)*nk
---
>     for (i in seq_len(n.chunk)) { ## build predict matrix in chunks
>       ind <- seq_len(nk) + (i-1)*nk
3067c3066
<    for (i in 1:length(object$term)) { 
---
>    for (i in seq_len(length(object$term))) { 
3079c3078
<          for (i in 1:m) dat[[i]] <- X[,i]     ## return only unique rows
---
>          for (i in seq_len(m)) dat[[i]] <- X[,i]     ## return only unique rows
3116c3115
<   if (!is.null(attr(sm,"qrc"))) warning("smooth objects should not have a qrc attribute.")
---
>   if (!is.null(attr(sm,"qrc"))) warning("smooth objects should not have a qrc attribute")
3140c3139
<         drop <- min((1:length(vcol))[vcol==min(vcol)])
---
>         drop <- min(seq_len(length(vcol))[vcol==min(vcol)])
3147c3146
<             sm$C <- ((1:length(xsd))[xsd==0])[1] ## index of coef to set to zero
---
>             sm$C <- (seq_len(length(xsd))[xsd==0])[1] ## index of coef to set to zero
3152c3151
<             sm$C <- ((1:length(xz))[xz==min(xz)])[1] ## index of coef to set to zero
---
>             sm$C <- (seq_len(length(xz))[xz==min(xz)])[1] ## index of coef to set to zero
3189c3188
<       for (i in 1:length(sm$S)) {
---
>       for (i in seq_len(length(sm$S))) {
3209c3208
<     if (!is.null(sm$by.done)) warning("handling `by' variables in smooth constructors may not work with the summation convention ")
---
>     if (!is.null(sm$by.done)) warning("handling 'by' variables in smooth constructors may not work with the summation convention")
3232c3231
<       if (matrixArg) stop("factor `by' variables can not be used with matrix arguments.")
---
>       if (matrixArg) stop("factor 'by' variables can not be used with matrix arguments")
3239c3238
<       for (j in 1:length(lev)) {
---
>       for (j in seq_len(length(lev))) {
3252c3251
<           (!is.null(sm$ind)&&length(by)!=length(sm$ind))) stop("`by' variable must be same dimension as smooth arguments")
---
>           (!is.null(sm$ind)&&length(by)!=length(sm$ind))) stop("'by' variable must be same dimension as smooth arguments")
3259c3258
<           ind <- 1:n 
---
>           ind <- seq_len(n)
3269c3268
<             ind <- 1:n 
---
>             ind <- seq_len(n)
3282c3281
<           for (i in 1:n) { ## in this case have to work down the rows
---
>           for (i in seq_len(n)) { ## in this case have to work down the rows
3334c3333
<       for (i in 1:length(sml)) { ## loop through smooth list
---
>       for (i in seq_len(length(sml))) { ## loop through smooth list
3339c3338
<           for (l in 1:length(sml[[i]]$S)) { # some smooths have > 1 penalty 
---
>           for (l in seq_len(length(sml[[i]]$S))) { # some smooths have > 1 penalty 
3350c3349
<         indi <- (1:ncol(sm$C))[colSums(sm$C)!=0] ## index of non-zero columns in C
---
>         indi <- seq_len(ncol(sm$C))[colSums(sm$C)!=0] ## index of non-zero columns in C
3356c3355
<           for (i in 1:length(sml)) { ## loop through smooth list
---
>           for (i in seq_len(length(sml))) { ## loop through smooth list
3358c3357
<             for (l in 1:length(sm$S)) # some smooths have > 1 penalty 
---
>             for (l in seq_len(length(sm$S))) # some smooths have > 1 penalty 
3360c3359
<               ZSZ[indi[1:nz],]<-qr.qty(qrc,sml[[i]]$S[[l]][indi,,drop=FALSE])[(nc+1):nx,] 
---
>               ZSZ[indi[seq_len(nz)],]<-qr.qty(qrc,sml[[i]]$S[[l]][indi,,drop=FALSE])[(nc+1):nx,] 
3362c3361
<               ZSZ[,indi[1:nz]]<-t(qr.qty(qrc,t(ZSZ[,indi,drop=FALSE]))[(nc+1):nx,])
---
>               ZSZ[,indi[seq_len(nz)]]<-t(qr.qty(qrc,t(ZSZ[,indi,drop=FALSE]))[(nc+1):nx,])
3368c3367
<             sml[[i]]$X[,indi[1:nz]]<-t(qr.qty(qrc,t(sml[[i]]$X[,indi,drop=FALSE]))[(nc+1):nx,])
---
>             sml[[i]]$X[,indi[seq_len(nz)]]<-t(qr.qty(qrc,t(sml[[i]]$X[,indi,drop=FALSE]))[(nc+1):nx,])
3384c3383
<             for (i in 1:length(sml)) { ## loop through smooth list
---
>             for (i in seq_len(length(sml))) { ## loop through smooth list
3389c3388
<               for (l in 1:length(sm$S)) { # some smooths have > 1 penalty 
---
>               for (l in seq_len(length(sm$S))) { # some smooths have > 1 penalty 
3395c3394
<             for (i in 1:length(sml)) { ## loop through smooth list
---
>             for (i in seq_len(length(sml))) { ## loop through smooth list
3397c3396
<               for (l in 1:length(sm$S)) { # some smooths have > 1 penalty 
---
>               for (l in seq_len(length(sm$S))) { # some smooths have > 1 penalty 
3407c3406
<           for (i in 1:length(sml)) { ## loop through smooth list
---
>           for (i in seq_len(length(sml))) { ## loop through smooth list
3417c3416
<         for (i in 1:length(sml)) {
---
>         for (i in seq_len(length(sml))) {
3423c3422
<        for (i in 1:length(sml)) { ## loop through smooth list
---
>        for (i in seq_len(length(sml))) { ## loop through smooth list
3425c3424
<           for (l in 1:length(sm$S)) { # some smooths have > 1 penalty 
---
>           for (l in seq_len(length(sm$S))) { # some smooths have > 1 penalty 
3438c3437
<        for (i in 1:length(sml)) { ## loop through smooth list
---
>        for (i in seq_len(length(sml))) { ## loop through smooth list
3440c3439
<           for (l in 1:length(sm$S)) { # some smooths have > 1 penalty 
---
>           for (l in seq_len(length(sm$S))) { # some smooths have > 1 penalty 
3456c3455
<       for (i in 1:length(sml)) { ## loop through smooth list
---
>       for (i in seq_len(length(sml))) { ## loop through smooth list
3463c3462
<   } else for (i in 1:length(sml)) attr(sml[[i]],"qrc") <-NULL ## no absorption
---
>   } else for (i in seq_len(length(sml))) attr(sml[[i]],"qrc") <-NULL ## no absorption
3504c3503
<         if (p>rank) for (i in 1:length(sml)) {
---
>         if (p>rank) for (i in seq_len(length(sml))) {
3515c3514
<       if (length(sml[[1]]$S)>1) for (i in 1:length(sml[[1]]$S)) St <- St + sml[[1]]$S[[i]]
---
>       if (length(sml[[1]]$S)>1) for (i in seq_len(length(sml[[1]]$S))) St <- St + sml[[1]]$S[[i]]
3522c3521
<         for (i in 1:length(sml)) {
---
>         for (i in seq_len(length(sml))) {
3532c3531
<   if (!apply.by) for (i in 1:length(sml)) {
---
>   if (!apply.by) for (i in seq_len(length(sml))) {
3558c3557
<     for (i in 1:n) { ## in this case have to work down the rows
---
>     for (i in seq_len(n)) { ## in this case have to work down the rows
3582c3581
<           if (length(by)!=nrow(X)) stop("`by' variable must be same dimension as smooth arguments")
---
>           if (length(by)!=nrow(X)) stop("'by' variable must be same dimension as smooth arguments")
3594c3593
<       ind <- 1:n 
---
>       ind <- seq_len(n)
3633c3632
<             X[ind,indi[1:nz]]<-t(qr.qty(qrc,t(X[ind,indi,drop=FALSE]))[(nc+1):nx,])
---
>             X[ind,indi[seq_len(nz)]]<-t(qr.qty(qrc,t(X[ind,indi,drop=FALSE]))[(nc+1):nx,])
3637c3636
<             X[,indi[1:nz]]<-t(qr.qty(qrc,t(X[,indi,drop=FALSE]))[(nc+1):nx,,drop=FALSE])
---
>             X[,indi[seq_len(nz)]]<-t(qr.qty(qrc,t(X[,indi,drop=FALSE]))[(nc+1):nx,,drop=FALSE])
diff -rEZbwB '--exclude=*.[lo,d,pdf,mo,po,tgz,gz,save]*' '--exclude=MD5' '--exclude=Makefile*' '--exclude=all.R' '--exclude=Changes' R-recommended/mgcv/R/soap.r Recommended/mgcv/R/soap.r
14c14
<     for (i in 1:length(beta.full)) {
---
>     for (i in seq_len(length(beta.full))) {
41c41
<           for (i in 1:length(beta.full)) {
---
>           for (i in seq_len(length(beta.full))) {
60c60
<         beta <- c(beta[1:(qrc[1]-1)],0,beta[qrc[1]:length(beta)])
---
>         beta <- c(beta[seq_len(qrc[1]-1)],0,beta[qrc[1]:length(beta)])
66c66
<         beta <- c(beta[1:(qrc-1)],0,beta[qrc:length(beta)])
---
>         beta <- c(beta[seq_len(qrc-1)],0,beta[qrc:length(beta)])
107c107
<   if (is.null(bnd.name)) for (i in 1:length(bnd)) { 
---
>   if (is.null(bnd.name)) for (i in seq_len(length(bnd))) { 
131c131
< { for (i in 1:length(bnd)) {
---
> { for (i in seq_len(length(bnd))) {
133c133
<     if (length(y)!=n) stop("x and y not same length")
---
>     if (length(y)!=n) stop("'x' and 'y' components of 'bnd' argument are not of same length")
142c142
<     len <- c(0,sqrt((x[1:(n-1)]-x[2:n])^2+(y[1:(n-1)]-y[2:n])^2)) ## seg lengths
---
>     len <- c(0,sqrt((x[seq_len(n-1)]-x[2:n])^2+(y[seq_len(n-1)]-y[2:n])^2)) ## seg lengths
157c157
<   for (k in 1:nk) {
---
>   for (k in seq_len(nk)) {
163c163
<         str <- paste("knot",k,"is on or outside boundary")
---
>         str <- gettextf("knot %d is on or outside boundary", k)
177c177
<   if (!inherits(bnd,"list")) stop("bnd must be a list.")
---
>   if (!inherits(bnd,"list")) stop("bnd must be a list")
181c181
<     else stop("lengths of k and bnd are not compatible.") 
---
>     else stop("lengths of 'k' and 'bnd' arguments are inconsistent") 
224c224
<   ind <- 1:o1$n
---
>   ind <- seq_len(o1$n)
239c239
<   for (i in 1:length(bnd)) {
---
>   for (i in seq_len(length(bnd))) {
255c255
<       bc[[i]] <- list(bsm=bsm,X=bsm$X[1:ret$nb[i],],S=bsm$S[[1]],free.bound=TRUE)
---
>       bc[[i]] <- list(bsm=bsm,X=bsm$X[seq_len(ret$nb[i]),],S=bsm$S[[1]],free.bound=TRUE)
292c292
<     for (i in 1:length(sd$bc)) { ## work through boundary loops
---
>     for (i in seq_len(length(sd$bc))) { ## work through boundary loops
318c318
<       gind[G[ind]] <- (1:length(G))[ind]
---
>       gind[G[ind]] <- seq_len(length(G))[ind]
350c350
<     for (i in 1:length(sd$bc)) { ## work through boundary loops
---
>     for (i in seq_len(length(sd$bc))) { ## work through boundary loops
360c360
<         for (j in 1:ncol(sd$bc[[i]]$X)) { ## loop over loop basis cols
---
>         for (j in seq_len(ncol(sd$bc[[i]]$X))) { ## loop over loop basis cols
384c384
<     for (i in 1:nc) g[sd$ki[i],i] <- 1
---
>     for (i in seq_len(nc)) g[sd$ki[i],i] <- 1
393c393
<     for (i in 1:nc) {
---
>     for (i in seq_len(nc)) {
433c433
<   for (i in 1:length(bnd)) { ## re-lable boundary
---
>   for (i in seq_len(length(bnd))) { ## re-lable boundary
446c446
<     stop("k and bnd lengths are inconsistent")
---
>     stop("lengths of 'bs.dim' and 'bnd' components of 'object' argument are inconsistent")
467c467
<   if (n>0) for (i in 1:n) if (sd$bc[[i]]$free.bound) 
---
>   if (n>0) for (i in seq_len(n)) if (sd$bc[[i]]$free.bound) 
471c471
<   for (i in 1:length(sd$bc)) 
---
>   for (i in seq_len(length(sd$bc))) 
478c478
<   for (i in  1:length(b$S)) {
---
>   for (i in  seq_len(length(b$S))) {
490c490
<     for (i in 1:length(b$S)) {
---
>     for (i in seq_len(length(b$S))) {
508c508
<   for (i in 1:length(sd$bc)) {
---
>   for (i in seq_len(length(sd$bc))) {
537c537
<   for (i in 1:length(bnd)) { ## re-lable boundary
---
>   for (i in seq_len(length(bnd))) { ## re-lable boundary
550c550
<     stop("k and bnd lengths are inconsistent")
---
>     stop("lengths of 'bs.dim' and 'bnd' components of 'object' argument are inconsistent")
572c572
<   if (n>0) for (i in 1:n) if (sd$bc[[i]]$free.bound) { 
---
>   if (n>0) for (i in seq_len(n)) if (sd$bc[[i]]$free.bound) { 
582c582
<   for (i in 1:length(sd$bc)) 
---
>   for (i in seq_len(length(sd$bc))) 
589c589
<   if (length(b$S)>0) for (i in  1:length(b$S)) {
---
>   if (length(b$S)>0) for (i in  seq_len(length(b$S))) {
601c601
<     if (length(b$S)>0) for (i in 1:length(b$S)) {
---
>     if (length(b$S)>0) for (i in seq_len(length(b$S))) {
614c614
<   for (i in 1:length(sd$bc)) {
---
>   for (i in seq_len(length(sd$bc))) {
642c642
<   for (i in 1:length(bnd)) { ## re-lable boundary
---
>   for (i in seq_len(length(bnd))) { ## re-lable boundary
655c655
<     stop("k and bnd lengths are inconsistent")
---
>     stop("lengths of 'bs.dim' and 'bnd' components of 'object' argument are inconsistent")
675c675
<   for (i in  1:length(b$S)) {
---
>   for (i in  seq_len(length(b$S))) {
686c686
<     for (i in 1:length(b$S)) {
---
>     for (i in seq_len(length(b$S))) {
703c703
<   for (i in 1:length(sd$bc)) {
---
>   for (i in seq_len(length(sd$bc))) {
766c766
<                 for (i in 1:length(P$bnd)) lines(P$bnd[[i]],lwd=2)
---
>                 for (i in seq_len(length(P$bnd))) lines(P$bnd[[i]],lwd=2)
802c802
<           for (i in 1:length(P$bnd)) lines(P$bnd[[i]],lwd=2)
---
>           for (i in seq_len(length(P$bnd))) lines(P$bnd[[i]],lwd=2)
diff -rEZbwB '--exclude=*.[lo,d,pdf,mo,po,tgz,gz,save]*' '--exclude=MD5' '--exclude=Makefile*' '--exclude=all.R' '--exclude=Changes' R-recommended/mgcv/R/sparse.r Recommended/mgcv/R/sparse.r
14c14
<   ## ni[1:off[1]] gives neighbours of point 1. 
---
>   ## ni[seq_len(off[1])] gives neighbours of point 1. 
16c16
<   return(list(ni = oo$T[1:oo$off[n]]+1,off=oo$off))
---
>   return(list(ni = oo$T[seq_len(oo$off[n])]+1,off=oo$off))
33,34c33,34
<   ii <- c(1:n,oo$ii[1:ni]+1) ## row index
<   jj <- c(1:n,oo$ni[1:ni]+1) ## col index
---
>   ii <- c(seq_len(n),oo$ii[seq_len(ni)]+1) ## row index
>   jj <- c(seq_len(n),oo$ni[seq_len(ni)]+1) ## col index
37,39c37,39
<   Kx <- sparseMatrix(i=ii,j=jj,x=oo$D[1:ni],dims=c(n,n))
<   Kz <- sparseMatrix(i=ii,j=jj,x=oo$D[1:ni+ni],dims=c(n,n))
<   Kxz <- sparseMatrix(i=ii,j=jj,x=oo$D[1:ni+2*ni],dims=c(n,n))
---
>   Kx <- sparseMatrix(i=ii,j=jj,x=oo$D[seq_len(ni)],dims=c(n,n))
>   Kz <- sparseMatrix(i=ii,j=jj,x=oo$D[seq_len(ni)+ni],dims=c(n,n))
>   Kxz <- sparseMatrix(i=ii,j=jj,x=oo$D[seq_len(ni)+2*ni],dims=c(n,n))
108c108
<   lo <- dd[,1:d];hi <- dd[,1:d+d]
---
>   lo <- dd[,seq_len(d)];hi <- dd[,seq_len(d)+d]
119c119
<   for (i in 1:nb) {
---
>   for (i in seq_len(nb)) {
140c140
<   } else { Xu <- X; ind <- 1:nrow(X)}
---
>   } else { Xu <- X; ind <- seq_len(nrow(X))}
146c146
<   if (get.a) a <- 1:n else a=1
---
>   if (get.a) a <- seq_len(n) else a=1
152,153c152,153
<   rind <- 1:nobs
<   rind[ind] <- 1:nobs
---
>   rind <- seq_len(nobs)
>   rind[ind] <- seq_len(nobs)
219c219
<   P <- sparseMatrix(i=1:n,j=ind,x=rep(1,n),dims=c(n,nrow(xu)))
---
>   P <- sparseMatrix(i=seq_len(n),j=ind,x=rep(1,n),dims=c(n,nrow(xu)))
259,260c259,260
<     for (i in 1:nb) {
<       ind[[i]] <- (1:n)[block==levels(block)[i]]
---
>     for (i in seq_len(nb)) {
>       ind[[i]] <- (seq_len(n))[block==levels(block)[i]]
265c265
<     ind[[1]] <- 1:n
---
>     ind[[1]] <- seq_len(n)
290c290
<   if (block==0) block <- 1:object$nblock
---
>   if (block==0) block <- seq_len(object$nblock)
328c328
<   } else for (i in 1:object$nblock) { ## work through all blocks 
---
>   } else for (i in seq_len(object$nblock)) { ## work through all blocks 
360,361c360,361
<     for (i in 1:nb) { 
<       ind[[i]] <- (1:n)[block==levels(block)[i]]
---
>     for (i in seq_len(nb)) { 
>       ind[[i]] <- (seq_len(n))[block==levels(block)[i]]
365c365
<     ind[[1]] <- 1:n
---
>     ind[[1]] <- seq_len(n)
Only in R-recommended/mgcv/inst/po: ko
diff -rEZbwB '--exclude=*.[lo,d,pdf,mo,po,tgz,gz,save]*' '--exclude=MD5' '--exclude=Makefile*' '--exclude=all.R' '--exclude=Changes' R-recommended/mgcv/src/coxph.c Recommended/mgcv/src/coxph.c
19,21c19,21
< 
< void coxpred(double *X,double *t,double *beta,double *Vb,double *a,double *h,double *q,
<              double *tr,int *n,int *p, int *nt,double *s,double *se) {
---
> void coxpred(double *X, double *t, double *beta, double *Vb, double *a,
> 		double *h, double *q, double *tr, int *n, int *p, int *nt, double *s,
> 		double *se) {
41,42c41,44
<       pv = v;pa = a;
<       for (eta=0,p1=X,p2=beta + *p,p3=beta;p3<p2;pa++,p3++,pv++,p1+= *n) { 
---
> 			pv = v;
> 			pa = a;
> 			for (eta = 0, p1 = X, p2 = beta + *p, p3 = beta; p3 < p2;
> 					pa++, p3++, pv++, p1 += *n) {
48c50,52
<       p1 = Vb;pv = v;p2 = pv + *p;
---
> 			p1 = Vb;
> 			pv = v;
> 			p2 = pv + *p;
50c54,55
<         for (x=0.0,p3 = v;p3<p2;p3++,p1++) x += *p3 * *p1;
---
> 				for (x = 0.0, p3 = v; p3 < p2; p3++, p1++)
> 					x += *p3 * *p1;
60,61c65,66
< void coxpp(double *eta,double *X,int *r, int *d,double *h,double *q,double *km, 
<             int *n,int *p, int *nt) {
---
> void coxpp(double *eta, double *X, int *r, int *d, double *h, double *q,
> 		double *km, int *n, int *p, int *nt) {
86c91,92
<   double *b,*gamma_p,*gamma,*gamma_np,*bj,*bj1,*p1,*p2,gamma_i,*Xp,*aj,*aj1,x,y;
---
> 	double *b, *gamma_p, *gamma, *gamma_np, *bj, *bj1, *p1, *p2, gamma_i, *Xp,
> 	*aj, *aj1, x, y;
93,94c99,104
<   if (*p>0) for (i=0;i<*n;i++) gamma[i] = exp(eta[i]);
<   else for (p1=gamma,p2=p1 + *n;p1<p2;p1++) *p1 = 1.0;
---
> 	if (*p > 0)
> 		for (i = 0; i < *n; i++)
> 			gamma[i] = exp(eta[i]);
> 	else
> 		for (p1 = gamma, p2 = p1 + *n; p1 < p2; p1++)
> 			*p1 = 1.0;
99c109,110
<       gamma_p[j] = gamma_p[j-1]; gamma_np[j] = gamma_np[j-1];
---
> 			gamma_p[j] = gamma_p[j - 1];
> 			gamma_np[j] = gamma_np[j - 1];
101c112,113
<       for (p1=bj,p2=p1 + *p;p1<p2;p1++,bj1++) *p1 = *bj1;
---
> 			for (p1 = bj, p2 = p1 + *p; p1 < p2; p1++, bj1++)
> 				*p1 = *bj1;
105c117,118
<       gamma_p[j] +=  gamma_i; gamma_np[j] += 1.0;
---
> 			gamma_p[j] += gamma_i;
> 			gamma_np[j] += 1.0;
108c121,122
<       for (p1=bj,p2=p1 + *p,Xp = X + i;p1<p2;p1++,Xp += *n) *bj += *Xp * gamma_i; 
---
> 			for (p1 = bj, p2 = p1 + *p, Xp = X + i; p1 < p2; p1++, Xp += *n)
> 				*bj += *Xp * gamma_i;
117,118c131,135
<   x =  dc[j]/gamma_p[j];h[j] = x;km[j] = dc[j]/gamma_np[j];
<   x /= gamma_p[j];q[j] = x;
---
> 	x = dc[j] / gamma_p[j];
> 	h[j] = x;
> 	km[j] = dc[j] / gamma_np[j];
> 	x /= gamma_p[j];
> 	q[j] = x;
120c137,138
<   for (aj=X+i,p1=aj+ *p,p2=b+i;aj<p1;p2++,aj++) *aj = *p1 * x;
---
> 	for (aj = X + i, p1 = aj + *p, p2 = b + i; aj < p1; p2++, aj++)
> 		*aj = *p1 * x;
131c149,150
<     for (aj=X+i,aj1=p1=aj+ *p,p2=b+i;aj<p1;p2++,aj++) *aj = *aj1 + *p1 * x; 
---
> 		for (aj = X + i, aj1 = p1 = aj + *p, p2 = b + i; aj < p1; p2++, aj++)
> 			*aj = *aj1 + *p1 * x;
133,134c152,156
<   FREE(b);FREE(gamma);FREE(dc);
<   FREE(gamma_p);FREE(gamma_np);
---
> 	FREE(b);
> 	FREE(gamma);
> 	FREE(dc);
> 	FREE(gamma_p);
> 	FREE(gamma_np);
137,145c159,161
< 
< 
< void coxlpl(double *eta,double *X,int *r, int *d,double *tr, 
<             int *n,int *p, int *nt,double *lp,double *g,double *H,
<             double *d1beta,
<             double *d1H,
<             double *d2beta,
<             double *d2H,
<             int *n_sp,int *deriv)
---
> void coxlpl(double *eta, double *X, int *r, int *d, double *tr, int *n, int *p,
> 		int *nt, double *lp, double *g, double *H, double *d1beta, double *d1H,
> 		double *d2beta, double *d2H, int *n_sp, int *deriv)
189,194c205,209
< { int dr,i,j,tB=0,tC=0,k,l,m,off,nhh;
<   double lpl=0.0,*gamma,gamma_p=0.0,
<     eta_sum,
<     *b_p=NULL,*A_p=NULL,*p1,*p2,*p3,*p4,
<     *d1gamma=NULL,
<     *d1gamma_p=NULL,*d1eta=NULL,xx,xx0,xx1,xx2,xx3,*d1b_p=NULL,*d1A_p=NULL,
---
> {
> 	int dr, i, j, tB = 0, tC = 0, k, l, m, off, nhh;
> 	double lpl = 0.0, *gamma, gamma_p = 0.0, eta_sum, *b_p = NULL, *A_p = NULL,
> 			*p1, *p2, *p3, *p4, *d1gamma = NULL, *d1gamma_p = NULL, *d1eta =
> 					NULL, xx, xx0, xx1, xx2, xx3, *d1b_p = NULL, *d1A_p = NULL,
204c219,220
<   for (i=0;i<*n;i++) gamma[i] = exp(eta[i]);
---
> 	for (i = 0; i < *n; i++)
> 		gamma[i] = exp(eta[i]);
214c230,232
< 	*p1 = *p2 * gamma[i]; p1++; p2++;
---
> 				*p1 = *p2 * gamma[i];
> 				p1++;
> 				p2++;
236c254,257
< 	    p1++;p2++;p3++;p4++;
---
> 					p1++;
> 					p2++;
> 					p3++;
> 					p4++;
249c270,271
<     for (j = *n_sp * *p * *p,k=0;k<j;k++) d1H[k] = 0.0;
---
> 		for (j = *n_sp * *p * *p, k = 0; k < j; k++)
> 			d1H[k] = 0.0;
253c275,276
<       for (j = nhh * *p,k=0;k<j;k++) d2H[k] = 0.0; 
---
> 			for (j = nhh * *p, k = 0; k < j; k++)
> 				d2H[k] = 0.0;
259,260c282,286
<   for (k=0;k<*p;k++) g[k] =0.0; 
<   for (k = 0;k < *p;k++) for (m = 0;m < *p ;m++)  H[k + *p * m] = 0.0;
---
> 	for (k = 0; k < *p; k++)
> 		g[k] = 0.0;
> 	for (k = 0; k < *p; k++)
> 		for (m = 0; m < *p; m++)
> 			H[k + *p * m] = 0.0;
269c295,298
<       if (d[i]==1) { dr++;eta_sum+=eta[i];}
---
> 			if (d[i] == 1) {
> 				dr++;
> 				eta_sum += eta[i];
> 			}
272,273c301,305
<         for (k=0;k<*p;k++) b_p[k] += gamma[i]*X[i + *n * k];
<         if (d[i]==1) for (k=0;k<*p;k++) g[k] += X[i + *n * k];
---
> 				for (k = 0; k < *p; k++)
> 					b_p[k] += gamma[i] * X[i + *n * k];
> 				if (d[i] == 1)
> 					for (k = 0; k < *p; k++)
> 						g[k] += X[i + *n * k];
275,276c307,310
<         for (k = 0;k < *p;k++) for (m = k;m < *p ;m++)
< 	    A_p[k + *p *m] +=  gamma[i]*X[i + *n * k] * X[i + *n * m];
---
> 				for (k = 0; k < *p; k++)
> 					for (m = k; m < *p; m++)
> 						A_p[k + *p * m] += gamma[i] * X[i + *n * k]
> 														* X[i + *n * m];
280c314,315
<         for (k=0;k<*n_sp;k++) d1gamma_p[k] += d1gamma[i + *n * k];
---
> 				for (k = 0; k < *n_sp; k++)
> 					d1gamma_p[k] += d1gamma[i + *n * k];
283c318,319
<           for (k=0;k<*p;k++) d1b_p[k + *p * m] += xx * X[i + *n * k];
---
> 					for (k = 0; k < *p; k++)
> 						d1b_p[k + *p * m] += xx * X[i + *n * k];
293c329,330
<               d2b_p[l + off * *p] +=  d2gamma[i+ off * *n] * X[i + *n * l];
---
> 							d2b_p[l + off * *p] += d2gamma[i + off * *n]
> 														   * X[i + *n * l];
301,302c338,341
<               for (k = 0;k < *p;k++) for (l = k;l < *p ;l++) 
<               d1A_p[k + *p * l + m * *p * *p] += xx * X[i + *n * k] * X[i + *n * l];             
---
> 					for (k = 0; k < *p; k++)
> 						for (l = k; l < *p; l++)
> 							d1A_p[k + *p * l + m * *p * *p] += xx
> 							* X[i + *n * k] * X[i + *n * l];
309c348,349
<                 d2ldA_p[l + off * *p] +=  d2gamma[i+ off * *n] * X[i + *n * l] * X[ i + *n *l];
---
> 								d2ldA_p[l + off * *p] += d2gamma[i + off * *n]
> 																 * X[i + *n * l] * X[i + *n * l];
320,323c360,365
<       for (k=0;k<*p;k++) g[k] += - dr/gamma_p * b_p[k]; 
<       for (k = 0;k < *p;k++) for (m = k;m < *p ;m++) 
<       H[k + *p * m] += - dr * A_p[k + *p *m] /gamma_p +
<         	        dr * b_p[k]*b_p[m]/(gamma_p*gamma_p); 
---
> 			for (k = 0; k < *p; k++)
> 				g[k] += -dr / gamma_p * b_p[k];
> 			for (k = 0; k < *p; k++)
> 				for (m = k; m < *p; m++)
> 					H[k + *p * m] += -dr * A_p[k + *p * m] / gamma_p
> 					+ dr * b_p[k] * b_p[m] / (gamma_p * gamma_p);
332c374,375
<             for (k = 0;k < *p;k++) for (l = k;l < *p ;l++) {
---
> 				for (k = 0; k < *p; k++)
> 					for (l = k; l < *p; l++) {
334,335c377,381
<                 d1H[off] += xx1 * (d1b_p[k + *p *m] * b_p[l] + b_p[k] * d1b_p[l + *p *m]) -
< 		    xx2 * b_p[k] * b_p[l] + xx * A_p[k + *p * l] - xx0 * d1A_p[off];
---
> 						d1H[off] += xx1
> 								* (d1b_p[k + *p * m] * b_p[l]
> 														   + b_p[k] * d1b_p[l + *p * m])
> 														   - xx2 * b_p[k] * b_p[l] + xx * A_p[k + *p * l]
> 																							  - xx0 * d1A_p[off];
348,359c394,429
< 		  d2H[l + off * *p] += xx3 * (A_p[l + *p *l] * d1gamma_p[k] + 
<                                               2 * d1b_p[l + *p * k] * b_p[l]) + 
< 		                       xx0 * (d1A_p[l + l * *p + m * *p * *p] * d1gamma_p[k] 
<                                               + A_p[l + *p * l] * d2gamma_p[off] + 
<                                               d2b_p[l + off * *p] * b_p[l] + 
<                                               2 * d1b_p[l + *p * k] * d1b_p[ l + *p * m] + 
< 		                              b_p[l] * d2b_p[l + off * *p]) +
<                                        xx0 * d1gamma_p[m] * d1A_p[l + l * *p + k * *p * *p] -
<                                        xx * d2ldA_p[l + off * *p] + 
<                                        6 * xx2 * d1gamma_p[m] * b_p[l] * b_p[l] * d1gamma_p[k] -
< 		                       2 * xx1 * (2*d1b_p[l + *p * m] * b_p[l] * d1gamma_p[k] +
< 						  b_p[l]*b_p[l]*d2gamma_p[off]);
---
> 							d2H[l + off * *p] +=
> 									xx3
> 									* (A_p[l + *p * l] * d1gamma_p[k]
> 																   + 2 * d1b_p[l + *p * k]
> 																			   * b_p[l])
> 																			   + xx0
> 																			   * (d1A_p[l + l * *p
> 																						+ m * *p * *p]
> 																						* d1gamma_p[k]
> 																									+ A_p[l + *p * l]
> 																										  * d2gamma_p[off]
> 																													  + d2b_p[l + off * *p]
> 																															  * b_p[l]
> 																																	+ 2
> 																																	* d1b_p[l
> 																																			+ *p
> 																																			* k]
> 																																			* d1b_p[l
> 																																					+ *p
> 																																					* m]
> 																																					+ b_p[l]
> 																																						  * d2b_p[l
> 																																								  + off
> 																																								  * *p])
> 																																								  + xx0 * d1gamma_p[m]
> 																																													* d1A_p[l + l * *p
> 																																															+ k * *p * *p]
> 																																															- xx * d2ldA_p[l + off * *p]
> 																																																		   + 6 * xx2 * d1gamma_p[m] * b_p[l]
> 																																																										  * b_p[l] * d1gamma_p[k]
> 																																																															   - 2 * xx1
> 																																																															   * (2 * d1b_p[l + *p * m]
> 																																																																			* b_p[l]
> 																																																																				  * d1gamma_p[k]
> 																																																																							  + b_p[l] * b_p[l]
> 																																																																											 * d2gamma_p[off]);
369,370c439,443
<   for (k=0;k<*p;k++) for (m=0;m<k;m++) H[k + *p *m] = H[m + *p *k];
<   if (*deriv>1) for (m=0;m<*n_sp;m++) {
---
> 	for (k = 0; k < *p; k++)
> 		for (m = 0; m < k; m++)
> 			H[k + *p * m] = H[m + *p * k];
> 	if (*deriv > 1)
> 		for (m = 0; m < *n_sp; m++) {
372c445,446
<     for (k = 0;k < *p;k++) for (l = 0;l < k ;l++) 
---
> 			for (k = 0; k < *p; k++)
> 				for (l = 0; l < k; l++)
376c450,453
<   if (*deriv>=0) { FREE(A_p);FREE(b_p);}
---
> 	if (*deriv >= 0) {
> 		FREE(A_p);
> 		FREE(b_p);
> 	}
380,381c457,460
<     FREE(d1eta);FREE(d1gamma);
<     FREE(d1gamma_p);FREE(d1b_p);
---
> 		FREE(d1eta);
> 		FREE(d1gamma);
> 		FREE(d1gamma_p);
> 		FREE(d1b_p);
386,387c465,468
<     FREE(d2eta);FREE(d2gamma);
<     FREE(d2gamma_p);FREE(d2b_p);
---
> 		FREE(d2eta);
> 		FREE(d2gamma);
> 		FREE(d2gamma_p);
> 		FREE(d2b_p);
diff -rEZbwB '--exclude=*.[lo,d,pdf,mo,po,tgz,gz,save]*' '--exclude=MD5' '--exclude=Makefile*' '--exclude=all.R' '--exclude=Changes' R-recommended/mgcv/src/discrete.c Recommended/mgcv/src/discrete.c
101c101
<   int pb=1,i,j,pd,q;
---
>   int pb=1,i,j,pd;
diff -rEZbwB '--exclude=*.[lo,d,pdf,mo,po,tgz,gz,save]*' '--exclude=MD5' '--exclude=Makefile*' '--exclude=all.R' '--exclude=Changes' R-recommended/mgcv/src/gdi.c Recommended/mgcv/src/gdi.c
37c35,36
< { double tr=0.0,x,*p,*p1,*p2;
---
> {
> 	double tr = 0.0, x, *p, *p1, *p2;
41c40,41
<       p = A + *n * k;p2 = p + *n;
---
> 			p = A + *n * k;
> 			p2 = p + *n;
44c44,45
<       for (;p<p2;p++,p1++) tr += *p * *p1 * x;   
---
> 			for (; p < p2; p++, p1++)
> 				tr += *p * *p1 * x;
49,50c50,51
< 
< void multSk(double *y,double *x,int *xcol,int k,double *rS,int *rSncol,int *q,double *work)
---
> void multSk(double *y, double *x, int *xcol, int k, double *rS, int *rSncol,
> 		int *q, double *work)
58c59,60
< { int i,off,nc,bt,ct;
---
> {
> 	int i, off, nc, bt, ct;
61c63,64
<   for (i=0;i<k;i++) off += *q * rSncol[i];
---
> 	for (i = 0; i < k; i++)
> 		off += *q * rSncol[i];
64c67,68
<   bt=1;ct=0;
---
> 	bt = 1;
> 	ct = 0;
75c79,80
< { int j;
---
> {
> 	int j;
78c83,84
<     for (pa=A,pb=B,p1=pa + *r,pd=d;pa<p1;pa++,pb++,pd++) *pd = *pa * *pb;
---
> 		for (pa = A, pb = B, p1 = pa + *r, pd = d; pa < p1; pa++, pb++, pd++)
> 			*pd = *pa * *pb;
80c86,87
<     for (p1=d + *r,pd=d;pd<p1;pa++,pb++,pd++) *pd += *pa * *pb;
---
> 			for (p1 = d + *r, pd = d; pd < p1; pa++, pb++, pd++)
> 				*pd += *pa * *pb;
82c89,90
<     for (pd=d,p1=d + *r;pd < p1;pd++) tr += *pd;
---
> 		for (pd = d, p1 = d + *r; pd < p1; pd++)
> 			tr += *pd;
91c98,99
< { double *p,*pa,*pb,tr=0.0;
---
> {
> 	double *p, *pa, *pb, tr = 0.0;
94c102,103
<     for (p=pb,i=0;i<*n;i++,p += *m,pa++) tr+= *p * *pa;
---
> 		for (p = pb, i = 0; i < *n; i++, p += *m, pa++)
> 			tr += *p * *pa;
121c130,131
< { double *Sb,*Skb,*work,*work1,*p1,*p0,*p2,xx;
---
> {
> 	double *Sb, *Skb, *work, *work1, *p1, *p0, *p2, xx;
126,127c136,141
<   bt=0;ct=0;mgcv_mmult(work,E,beta,&bt,&ct,Enrow,&one,q);
<   bt=1;ct=0;mgcv_mmult(Sb,E,work,&bt,&ct,q,&one,Enrow); /* S \hat \beta */
---
> 	bt = 0;
> 	ct = 0;
> 	mgcv_mmult(work, E, beta, &bt, &ct, Enrow, &one, q);
> 	bt = 1;
> 	ct = 0;
> 	mgcv_mmult(Sb, E, work, &bt, &ct, q, &one, Enrow); /* S \hat \beta */
129c143,144
<   for (*bSb=0.0,i=0;i<*q;i++) *bSb += beta[i] * Sb[i]; /* \hat \beta' S \hat \beta */
---
> 	for (*bSb = 0.0, i = 0; i < *q; i++)
> 		*bSb += beta[i] * Sb[i]; /* \hat \beta' S \hat \beta */
131c146,150
<   if (*deriv <=0) {FREE(work);FREE(Sb);return;}
---
> 	if (*deriv <= 0) {
> 		FREE(work);
> 		FREE(Sb);
> 		return;
> 	}
138,140c157,164
<      bt=1;ct=0;mgcv_mmult(work,rS + rSoff ,beta,&bt,&ct,rSncol+i,&one,q);
<      for (j=0;j<rSncol[i];j++) work[j] *= sp[i]; 
<      bt=0;ct=0;mgcv_mmult(p1,rS + rSoff ,work,&bt,&ct,q,&one,rSncol+i);
---
> 		bt = 1;
> 		ct = 0;
> 		mgcv_mmult(work, rS + rSoff, beta, &bt, &ct, rSncol + i, &one, q);
> 		for (j = 0; j < rSncol[i]; j++)
> 			work[j] *= sp[i];
> 		bt = 0;
> 		ct = 0;
> 		mgcv_mmult(p1, rS + rSoff, work, &bt, &ct, q, &one, rSncol + i);
144c168,169
<      for (xx=0.0,j=0;j<*q;j++,p1++) xx += beta[j] * *p1;
---
> 		for (xx = 0.0, j = 0; j < *q; j++, p1++)
> 			xx += beta[j] * *p1;
148,151c173,180
< 
<   if (*deriv>1)  for (m=0;m < *M;m++) { /* Hessian */
<      bt=0;ct=0;mgcv_mmult(work1,E,b1+m * *q,&bt,&ct,Enrow,&one,q);
<      bt=1;ct=0;mgcv_mmult(work,E,work1,&bt,&ct,q,&one,Enrow);  /* S dbeta/drho_m */
---
> 	if (*deriv > 1)
> 		for (m = 0; m < *M; m++) { /* Hessian */
> 			bt = 0;
> 			ct = 0;
> 			mgcv_mmult(work1, E, b1 + m * *q, &bt, &ct, Enrow, &one, q);
> 			bt = 1;
> 			ct = 0;
> 			mgcv_mmult(work, E, work1, &bt, &ct, q, &one, Enrow); /* S dbeta/drho_m */
154c183,184
<       km=k * *M + m;mk=m * *M + k;  /* second derivatives needed */
---
> 				km = k * *M + m;
> 				mk = m * *M + k; /* second derivatives needed */
156c186,187
<       for (xx=0.0,p0=Sb,p1=Sb + *q;p0<p1;p0++,b2++) xx += *b2 * *p0;
---
> 				for (xx = 0.0, p0 = Sb, p1 = Sb + *q; p0 < p1; p0++, b2++)
> 					xx += *b2 * *p0;
160c191,193
<       for (xx=0.0,p0=b1+k* *q,p1=p0 + *q,p2=work;p0<p1;p0++,p2++) xx += *p2 * *p0;
---
> 				for (xx = 0.0, p0 = b1 + k * *q, p1 = p0 + *q, p2 = work;
> 						p0 < p1; p0++, p2++)
> 					xx += *p2 * *p0;
164c197,199
<       for (xx=0.0,p0=Skb + k* *q,p1=p0 + *q,p2= b1+m* *q;p0<p1;p0++,p2++) xx += *p2 * *p0;
---
> 				for (xx = 0.0, p0 = Skb + k * *q, p1 = p0 + *q, p2 = b1 + m * *q;
> 						p0 < p1; p0++, p2++)
> 					xx += *p2 * *p0;
168c203,205
<       for (xx=0.0,p0=Skb + m* *q,p1=p0 + *q,p2= b1+k* *q;p0<p1;p0++,p2++) xx += *p2 * *p0;
---
> 				for (xx = 0.0, p0 = Skb + m * *q, p1 = p0 + *q, p2 = b1 + k * *q;
> 						p0 < p1; p0++, p2++)
> 					xx += *p2 * *p0;
171c208,211
<       if (k==m) bSb2[km] += bSb1[k]; else bSb2[mk] = bSb2[km];
---
> 				if (k == m)
> 					bSb2[km] += bSb1[k];
> 				else
> 					bSb2[mk] = bSb2[km];
176,177c216,220
<   bt=1;ct=0;mgcv_mmult(work,b1,Sb,&bt,&ct,M,&one,q);
<   for (i=0;i<*M;i++) bSb1[i] += 2*work[i];
---
> 	bt = 1;
> 	ct = 0;
> 	mgcv_mmult(work, b1, Sb, &bt, &ct, M, &one, q);
> 	for (i = 0; i < *M; i++)
> 		bSb1[i] += 2 * work[i];
179c222,225
<   FREE(Sb);FREE(work);FREE(Skb);FREE(work1);
---
> 	FREE(Sb);
> 	FREE(work);
> 	FREE(Skb);
> 	FREE(work1);
212c257,258
< { double *Sb,*Skb,*work,*work1,*p1,*p0,*p2,xx;
---
> {
> 	double *Sb, *Skb, *work, *work1, *p1, *p0, *p2, xx;
217,218c263,268
<   bt=0;ct=0;mgcv_mmult(work,E,beta,&bt,&ct,Enrow,&one,q);
<   bt=1;ct=0;mgcv_mmult(Sb,E,work,&bt,&ct,q,&one,Enrow); /* S \hat \beta */
---
> 	bt = 0;
> 	ct = 0;
> 	mgcv_mmult(work, E, beta, &bt, &ct, Enrow, &one, q);
> 	bt = 1;
> 	ct = 0;
> 	mgcv_mmult(Sb, E, work, &bt, &ct, q, &one, Enrow); /* S \hat \beta */
220c270,271
<   for (*bSb=0.0,i=0;i<*q;i++) *bSb += beta[i] * Sb[i]; /* \hat \beta' S \hat \beta */
---
> 	for (*bSb = 0.0, i = 0; i < *q; i++)
> 		*bSb += beta[i] * Sb[i]; /* \hat \beta' S \hat \beta */
222c273,277
<   if (*deriv <=0) {FREE(work);FREE(Sb);return;}
---
> 	if (*deriv <= 0) {
> 		FREE(work);
> 		FREE(Sb);
> 		return;
> 	}
229,231c284,291
<      bt=1;ct=0;mgcv_mmult(work,rS + rSoff ,beta,&bt,&ct,rSncol+i,&one,q);
<      for (j=0;j<rSncol[i];j++) work[j] *= sp[i]; 
<      bt=0;ct=0;mgcv_mmult(p1,rS + rSoff ,work,&bt,&ct,q,&one,rSncol+i);
---
> 		bt = 1;
> 		ct = 0;
> 		mgcv_mmult(work, rS + rSoff, beta, &bt, &ct, rSncol + i, &one, q);
> 		for (j = 0; j < rSncol[i]; j++)
> 			work[j] *= sp[i];
> 		bt = 0;
> 		ct = 0;
> 		mgcv_mmult(p1, rS + rSoff, work, &bt, &ct, q, &one, rSncol + i);
235c295,296
<      for (xx=0.0,j=0;j<*q;j++,p1++) xx += beta[j] * *p1;
---
> 		for (xx = 0.0, j = 0; j < *q; j++, p1++)
> 			xx += beta[j] * *p1;
238c299,300
<   for (i=0;i<*M0;i++) bSb1[i] = 0.0;
---
> 	for (i = 0; i < *M0; i++)
> 		bSb1[i] = 0.0;
241,243c303,310
<   if (*deriv>1)  for (m=0;m < Mtot;m++) { /* Hessian */
<      bt=0;ct=0;mgcv_mmult(work1,E,b1 + m * *q,&bt,&ct,Enrow,&one,q);
<      bt=1;ct=0;mgcv_mmult(work,E,work1,&bt,&ct,q,&one,Enrow);  /* S dbeta/drho_m */
---
> 	if (*deriv > 1)
> 		for (m = 0; m < Mtot; m++) { /* Hessian */
> 			bt = 0;
> 			ct = 0;
> 			mgcv_mmult(work1, E, b1 + m * *q, &bt, &ct, Enrow, &one, q);
> 			bt = 1;
> 			ct = 0;
> 			mgcv_mmult(work, E, work1, &bt, &ct, q, &one, Enrow); /* S dbeta/drho_m */
249c316,317
<       for (xx=0.0,p0=Sb,p1=Sb + *q;p0<p1;p0++,b2++) xx += *b2 * *p0;
---
> 				for (xx = 0.0, p0 = Sb, p1 = Sb + *q; p0 < p1; p0++, b2++)
> 					xx += *b2 * *p0;
253c321,323
<       for (xx=0.0,p0=b1+ k  * *q,p1=p0 + *q,p2=work;p0<p1;p0++,p2++) xx += *p2 * *p0;
---
> 				for (xx = 0.0, p0 = b1 + k * *q, p1 = p0 + *q, p2 = work;
> 						p0 < p1; p0++, p2++)
> 					xx += *p2 * *p0;
258c328,329
<         for (xx=0.0,p0=Skb + (k- *M0) * *q,p1=p0 + *q,p2= b1+ m  * *q;p0<p1;p0++,p2++) 
---
> 					for (xx = 0.0, p0 = Skb + (k - *M0) * *q, p1 = p0 + *q, p2 =
> 							b1 + m * *q; p0 < p1; p0++, p2++)
264c335,336
<         for (xx=0.0,p0=Skb + (m - *M0) * *q,p1=p0 + *q,p2= b1 + k  * *q;p0<p1;p0++,p2++) 
---
> 					for (xx = 0.0, p0 = Skb + (m - *M0) * *q, p1 = p0 + *q, p2 =
> 							b1 + k * *q; p0 < p1; p0++, p2++)
269c341,344
<       if (k==m) bSb2[km] += bSb1[k]; else bSb2[mk] = bSb2[km];
---
> 				if (k == m)
> 					bSb2[km] += bSb1[k];
> 				else
> 					bSb2[mk] = bSb2[km];
275,276c349,353
<   bt=1;ct=0;mgcv_mmult(work,b1,Sb,&bt,&ct,&Mtot,&one,q);
<   for (i=0;i<Mtot;i++) bSb1[i] += 2*work[i];
---
> 	bt = 1;
> 	ct = 0;
> 	mgcv_mmult(work, b1, Sb, &bt, &ct, &Mtot, &one, q);
> 	for (i = 0; i < Mtot; i++)
> 		bSb1[i] += 2 * work[i];
278c355,358
<   FREE(Sb);FREE(work);FREE(Skb);FREE(work1);
---
> 	FREE(Sb);
> 	FREE(work);
> 	FREE(Skb);
> 	FREE(work1);
286c366,367
< { double fnorm=0.0,*p1;
---
> {
> 	double fnorm = 0.0, *p1;
289c370,371
<   for (p1=X+n;X<p1;X++) fnorm += *X * *X;
---
> 	for (p1 = X + n; X < p1; X++)
> 		fnorm += *X * *X;
309c391,392
< { double *dum,*px,*pd,*pd1,*p,*p1;
---
> {
> 	double *dum, *px, *pd, *pd1, *p, *p1;
315,317c398,406
< 	 for (px=x+i,pi=pivot,pi1=pi+*c;pi<pi1;pi++,px+=*r) dum[*pi]= *px; /*dum[pivot[j]] = x[j* *r + i] */ 
<          for (px=x+i,pd=dum,pd1=dum+*c;pd<pd1;pd++,px += *r) *px = *pd;    /* x[j * *r + i] = dum[j]; */
<        } else /* pivot x */
---
> 				for (px = x + i, pi = pivot, pi1 = pi + *c; pi < pi1;
> 						pi++, px += *r)
> 					dum[*pi] = *px; /*dum[pivot[j]] = x[j* *r + i] */
> 				for (px = x + i, pd = dum, pd1 = dum + *c; pd < pd1; pd++, px +=
> 						*r)
> 					*px = *pd; /* x[j * *r + i] = dum[j]; */
> 			}
> 		else
> 			/* pivot x */
319,320c408,413
< 	 for (px = x+i,pd=dum,pd1=dum + *c,j=0;pd < pd1;pd++,j++)  *pd = px[pivot[j] * *r];
< 	 for (px=x+i,pd=dum,pd1=dum+*c;pd<pd1;pd++,px += *r) *px = *pd;  /* x[j * *r + i] = dum[j]; */ 
---
> 				for (px = x + i, pd = dum, pd1 = dum + *c, j = 0; pd < pd1;
> 						pd++, j++)
> 					*pd = px[pivot[j] * *r];
> 				for (px = x + i, pd = dum, pd1 = dum + *c; pd < pd1; pd++, px +=
> 						*r)
> 					*px = *pd; /* x[j * *r + i] = dum[j]; */
326,327c419,422
<       for (pi=pivot,pi1=pi+*r,p1=p;pi<pi1;pi++,p1++) dum[*pi] = *p1; /*dum[pivot[i]] = p[i]; ith row of pivoted -> pivot[i] row of unpivoted */
<       for (pd=dum,pd1=dum+*r,p1=p;pd<pd1;pd++,p1++) *p1 = *pd;       /* store unpivoted column in x */
---
> 				for (pi = pivot, pi1 = pi + *r, p1 = p; pi < pi1; pi++, p1++)
> 					dum[*pi] = *p1; /*dum[pivot[i]] = p[i]; ith row of pivoted -> pivot[i] row of unpivoted */
> 				for (pd = dum, pd1 = dum + *r, p1 = p; pd < pd1; pd++, p1++)
> 					*p1 = *pd; /* store unpivoted column in x */
329c424,426
<     } else  /* pivot x */
---
> 			}
> 		else
> 			/* pivot x */
331,332c428,431
< 	for (pi=pivot,pi1=pi+*r,pd=dum;pi<pi1;pd++,pi++) *pd = p[*pi];  /* dum[i] = p[pivot[i]]; pivot[i] row of unpivoted -> ith row of pivoted */
<         for (pd=dum,pd1=dum+*r,p1=p;pd<pd1;pd++,p1++) *p1 = *pd;        /* store pivoted column in x */
---
> 				for (pi = pivot, pi1 = pi + *r, pd = dum; pi < pi1; pd++, pi++)
> 					*pd = p[*pi]; /* dum[i] = p[pivot[i]]; pivot[i] row of unpivoted -> ith row of pivoted */
> 				for (pd = dum, pd1 = dum + *r, p1 = p; pd < pd1; pd++, p1++)
> 					*p1 = *pd; /* store pivoted column in x */
345c443,444
< { double *tau,ldet,*p,*Qt;
---
> {
> 	double *tau, ldet, *p, *Qt;
354c453,454
<   for (ldet=0.0,p=X,i=0;i<*r;i++,p += *r+1) ldet += log(fabs(*p));
---
> 	for (ldet = 0.0, p = X, i = 0; i < *r; i++, p += *r + 1)
> 		ldet += log(fabs(*p));
359c459,460
<     for (p=Qt,i=0;i<*r;i++,p += *r+1) *p = 1.0;
---
> 		for (p = Qt, i = 0; i < *r; i++, p += *r + 1)
> 			*p = 1.0;
370,371c471,474
<       for (i=0;i<*r;i++) tau[pivot[i]] = p[i]; /* ith row of pivoted -> pivot[i] row of unpivoted */
<       for (i=0;i<*r;i++) p[i] = tau[i];        /* store unpivoted column in Xi */
---
> 			for (i = 0; i < *r; i++)
> 				tau[pivot[i]] = p[i]; /* ith row of pivoted -> pivot[i] row of unpivoted */
> 			for (i = 0; i < *r; i++)
> 				p[i] = tau[i]; /* store unpivoted column in Xi */
376c479,480
<   FREE(pivot);FREE(tau);
---
> 	FREE(pivot);
> 	FREE(tau);
380,383c484,485
< 
< 
< void get_detS2(double *sp,double *sqrtS, int *rSncol, int *q,int *M, int * deriv, 
<                double *det, double *det1, double *det2, double *d_tol,
---
> void get_detS2(double *sp, double *sqrtS, int *rSncol, int *q, int *M,
> 		int * deriv, double *det, double *det1, double *det2, double *d_tol,
405,406c507,511
< { double *R,*work,*tau,*rS1,*rS2, *S,*Si,*Sb,*B,*Sg,*p,*p1,*p2,*p3,*p4,*frob,max_frob,x,*spf,Rcond;
<   int *pivot,iter,i,j,k,bt,ct,rSoff,K,Q,Qr,*gamma,*gamma1,*alpha,r,max_col,Mf,tot_col=0,left,tp;
---
> {
> 	double *R, *work, *tau, *rS1, *rS2, *S, *Si, *Sb, *B, *Sg, *p, *p1, *p2,
> 			*p3, *p4, *frob, max_frob, x, *spf, Rcond;
> 	int *pivot, iter, i, j, k, bt, ct, rSoff, K, Q, Qr, *gamma, *gamma1, *alpha,
> 			r, max_col, Mf, tot_col = 0, left, tp;
411,413c516,522
<     for (i=0;i<*M;i++) spf[i]=sp[i];spf[*M]=1.0; /* includes sp for fixed term */
<   } 
<   else {spf=sp;Mf = *M;} /* total number of components, including fixed one */
---
> 		for (i = 0; i < *M; i++)
> 			spf[i] = sp[i];
> 		spf[*M] = 1.0; /* includes sp for fixed term */
> 	} else {
> 		spf = sp;
> 		Mf = *M;
> 	} /* total number of components, including fixed one */
419c528,530
<     for (j=i=0;i<Mf;i++) j += rSncol[i];tot_col=j;
---
> 		for (j = i = 0; i < Mf; i++)
> 			j += rSncol[i];
> 		tot_col = j;
423,424c534,539
<     for (p=rS1,p3=rS2,p1=rS1+j,p2=sqrtS;p<p1;p++,p2++,p3++) *p3 = *p = *p2;
<   } else {rS1=rS2=NULL;}
---
> 		for (p = rS1, p3 = rS2, p1 = rS1 + j, p2 = sqrtS; p < p1;
> 				p++, p2++, p3++)
> 			*p3 = *p = *p2;
> 	} else {
> 		rS1 = rS2 = NULL;
> 	}
430c545,547
<   for (i=0;i<Mf;i++) if (rSncol[i]>max_col) max_col=rSncol[i];
---
> 	for (i = 0; i < Mf; i++)
> 		if (rSncol[i] > max_col)
> 			max_col = rSncol[i];
435c552,555
<     bt=0;ct=1;mgcv_mmult(p,sqrtS+rSoff * *q,sqrtS+rSoff * *q,&bt,&ct,q,q,rSncol+i);   
---
> 		bt = 0;
> 		ct = 1;
> 		mgcv_mmult(p, sqrtS + rSoff * *q, sqrtS + rSoff * *q, &bt, &ct, q, q,
> 				rSncol + i);
440c559,560
<   K = 0;Q = *q;
---
> 	K = 0;
> 	Q = *q;
445c565,566
<   for (i=0;i<Mf;i++) gamma[i] = 1; /* no terms dealt with initially */
---
> 	for (i = 0; i < Mf; i++)
> 		gamma[i] = 1; /* no terms dealt with initially */
468c589,590
<         if (frob[i] *spf[i] >max_frob) max_frob=frob[i]  * spf[i];
---
> 				if (frob[i] * spf[i] > max_frob)
> 					max_frob = frob[i] * spf[i];
474c596,597
<           alpha[i] = 1;gamma1[i] = 0; /* deal with it now */
---
> 					alpha[i] = 1;
> 					gamma1[i] = 0; /* deal with it now */
476c599,600
<           alpha[i] = 0;gamma1[i] = 1; /* put it off */ 
---
> 					alpha[i] = 0;
> 					gamma1[i] = 1; /* put it off */
486,487c610,613
<     for (p=Sb,p1=p + *q * Q;p<p1;p++) *p=0.0; /* clear Sb */
<     for (p=Si,i=0;i<Mf;i++,p += *q * Q) if (alpha[i]) { 
---
> 		for (p = Sb, p1 = p + *q * Q; p < p1; p++)
> 			*p = 0.0; /* clear Sb */
> 		for (p = Si, i = 0; i < Mf; i++, p += *q * Q)
> 			if (alpha[i]) {
489c615,616
<       for (p1=p,p2=Sb,p3=p + *q * Q;p1<p3;p1++,p2++) *p2 += *p1 / x;
---
> 				for (p1 = p, p2 = Sb, p3 = p + *q * Q; p1 < p3; p1++, p2++)
> 					*p2 += *p1 / x;
491c618,619
<     for (i=0;i<*q;i++) pivot[i]=0; 
---
> 		for (i = 0; i < *q; i++)
> 			pivot[i] = 0;
496c624,627
<     while (*r_tol * Rcond > 1) { r--;R_cond(Sb,&Q,&r,work,&Rcond);}
---
> 		while (*r_tol * Rcond > 1) {
> 			r--;
> 			R_cond(Sb, &Q, &r, work, &Rcond);
> 		}
513c643,644
<           for (p1=p,p2=S,p3=p+Q*Q;p1<p3;p1++,p2++) *p2 += *p1 * x;
---
> 					for (p1 = p, p2 = S, p3 = p + Q * Q; p1 < p3; p1++, p2++)
> 						*p2 += *p1 * x;
516c647,648
<       } else break; /* just use current S */ 
---
> 			} else
> 				break; /* just use current S */
520,521c652,655
<     for (p=Sb,p1=p + *q * Q;p<p1;p++) *p = 0.0; /* clear Sb */
<     for (p=Si,i=0;i<Mf;i++,p += *q * Q) if (alpha[i]) { /* summing S[[i]]*sp[i] over i in alpha */
---
> 		for (p = Sb, p1 = p + *q * Q; p < p1; p++)
> 			*p = 0.0; /* clear Sb */
> 		for (p = Si, i = 0; i < Mf; i++, p += *q * Q)
> 			if (alpha[i]) { /* summing S[[i]]*sp[i] over i in alpha */
523c657,658
<       for (p1=p,p2=Sb,p3=p+ *q * Q;p1<p3;p1++,p2++) *p2 += *p1 * x;
---
> 				for (p1 = p, p2 = Sb, p3 = p + *q * Q; p1 < p3; p1++, p2++)
> 					*p2 += *p1 * x;
525c660,661
<     for (i=0;i<*q;i++) pivot[i]=0; 
---
> 		for (i = 0; i < *q; i++)
> 			pivot[i] = 0;
529,530c665,669
<     for (p=R,p1=R + *q * r;p<p1;p++) *p=0.0; /* clear R */
<     for (i=0;i<r;i++) for (j=i;j<*q;j++) R[i + pivot[j] * r] = Sb[i + j * Q]; 
---
> 		for (p = R, p1 = R + *q * r; p < p1; p++)
> 			*p = 0.0; /* clear R */
> 		for (i = 0; i < r; i++)
> 			for (j = i; j < *q; j++)
> 				R[i + pivot[j] * r] = Sb[i + j * Q];
539,540c678,681
<     for (p=Sg,p1=p + *q * Q;p<p1;p++) *p=0.0; /* clear Sg */
<     for (p=Si,i=0;i<Mf;i++,p += *q * Q) if (gamma1[i]) { /* summing S[[i]]*sp[i] over i in gamma1 */
---
> 		for (p = Sg, p1 = p + *q * Q; p < p1; p++)
> 			*p = 0.0; /* clear Sg */
> 		for (p = Si, i = 0; i < Mf; i++, p += *q * Q)
> 			if (gamma1[i]) { /* summing S[[i]]*sp[i] over i in gamma1 */
542c683,684
<       for (p1=p,p2=Sg,p3=p+ *q * Q;p1<p3;p1++,p2++) *p2 += *p1 * x;
---
> 				for (p1 = p, p2 = Sg, p3 = p + *q * Q; p1 < p3; p1++, p2++)
> 					*p2 += *p1 * x;
548c690,691
<     left=1;tp=1; 
---
> 		left = 1;
> 		tp = 1;
552c695,697
<     for (i=0;i<Q;i++) for (j=0;j<*q;j++) S[i+K + j * *q] = Sg[i + j * Q];
---
> 		for (i = 0; i < Q; i++)
> 			for (j = 0; j < *q; j++)
> 				S[i + K + j * *q] = Sg[i + j * Q];
554,555c699,701
<     for (i=0;i<r;i++) for (j=0;j<*q;j++) S[i+K + j * *q] += R[i + j * r];       
< 
---
> 		for (i = 0; i < r; i++)
> 			for (j = 0; j < *q; j++)
> 				S[i + K + j * *q] += R[i + j * r];
558,559c704,707
<     for (p1=p=Si,i=0;i<Mf;i++,p += *q * Q,p1 += *q *Qr) if (gamma1[i]) {
<       left=1;tp=1;
---
> 		for (p1 = p = Si, i = 0; i < Mf; i++, p += *q * Q, p1 += *q * Qr)
> 			if (gamma1[i]) {
> 				left = 1;
> 				tp = 1;
561,562c709,713
<       p2=p+r;p3=p1;
<       for (j=0;j<*q;j++,p2+=r) for (k=0;k<Qr;k++,p3++,p2++) *p3 = *p2; /* copy to correct place */ 
---
> 				p2 = p + r;
> 				p3 = p1;
> 				for (j = 0; j < *q; j++, p2 += r)
> 					for (k = 0; k < Qr; k++, p3++, p2++)
> 						*p3 = *p2; /* copy to correct place */
568c719,721
<       for (i=0;i<Q;i++) for (j=0;j<tot_col;j++) rS2[i+Q*j] = rS1[K + i + *q * j];
---
> 			for (i = 0; i < Q; i++)
> 				for (j = 0; j < tot_col; j++)
> 					rS2[i + Q * j] = rS1[K + i + *q * j];
570c723,724
<       left=1;tp=1;
---
> 			left = 1;
> 			tp = 1;
574c728,730
<       for (i=0;i<Q;i++) for (j=0;j<tot_col;j++) rS1[K + i + *q * j] = rS2[i+Q*j];
---
> 			for (i = 0; i < Q; i++)
> 				for (j = 0; j < tot_col; j++)
> 					rS1[K + i + *q * j] = rS2[i + Q * j];
577,578c733,737
<       for (p=rS1,k=0;k<Mf;p +=rSncol[k] * *q, k++) if (alpha[k]) {
<         for (i=K+r;i<*q;i++) for (j=0;j<rSncol[k];j++) p[i + j * *q] = 0.0;
---
> 			for (p = rS1, k = 0; k < Mf; p += rSncol[k] * *q, k++)
> 				if (alpha[k]) {
> 					for (i = K + r; i < *q; i++)
> 						for (j = 0; j < rSncol[k]; j++)
> 							p[i + j * *q] = 0.0;
588,589c746,749
<     K = K + r; Q = Qr;
<     for (i=0;i<Mf;i++) gamma[i] = gamma1[i];
---
> 		K = K + r;
> 		Q = Qr;
> 		for (i = 0; i < Mf; i++)
> 			gamma[i] = gamma1[i];
593c753,755
<   for (i=0;i<*q;i++) for (j=0;j<*q;j++) R[i + *q * j] = S[j + *q * i]; 
---
> 	for (i = 0; i < *q; i++)
> 		for (j = 0; j < *q; j++)
> 			R[i + *q * j] = S[j + *q * i];
605c767,769
<     bt=0;ct=0;mgcv_mmult(Si,B,sqrtS,&bt,&ct,q,&tot_col,q);
---
> 		bt = 0;
> 		ct = 0;
> 		mgcv_mmult(Si, B, sqrtS, &bt, &ct, q, &tot_col, q);
607,608c771,775
<     for (p=Si,p1=rS1,i=0;i<*M;p += *q *rSncol[i],p1+= *q *rSncol[i],i++) {
<       for (x=0.0,p2=p1,p3=p,p4=p1+ *q*rSncol[i];p2<p4;p2++,p3++) x += *p2 * *p3; 
---
> 		for (p = Si, p1 = rS1, i = 0; i < *M;
> 				p += *q * rSncol[i], p1 += *q * rSncol[i], i++) {
> 			for (x = 0.0, p2 = p1, p3 = p, p4 = p1 + *q * rSncol[i]; p2 < p4;
> 					p2++, p3++)
> 				x += *p2 * *p3;
614c781,782
<     for (p=Si,p1=rS2,p2 = p1 + *q * tot_col;p1<p2;p1++,p++) *p1 = *p; /* copy S^{-1} sqrtS into rS2 */   
---
> 		for (p = Si, p1 = rS2, p2 = p1 + *q * tot_col; p1 < p2; p1++, p++)
> 			*p1 = *p; /* copy S^{-1} sqrtS into rS2 */
617,618c785,789
<     for (p1=Si,p=rS2,p2=rS1,i=0;i<*M;p2+= *q * rSncol[i], p += *q *rSncol[i],i++,p1 += *q * *q) {
<       bt=0;ct=1;mgcv_mmult(p1,p,p2,&bt,&ct,q,q,rSncol+i);
---
> 		for (p1 = Si, p = rS2, p2 = rS1, i = 0; i < *M;
> 				p2 += *q * rSncol[i], p += *q * rSncol[i], i++, p1 += *q * *q) {
> 			bt = 0;
> 			ct = 1;
> 			mgcv_mmult(p1, p, p2, &bt, &ct, q, q, rSncol + i);
624,626c795,800
<     for (i=0;i<*M;i++) for (j=i;j<*M;j++) 
<       det2[i + *M * j] = det2[j + *M * i] = -sp[i]*sp[j]*trAB(Si + *q * *q *i,Si + *q * *q *j,q,q);
<     for (i=0;i<*M;i++) det2[i + *M * i] += det1[i];
---
> 		for (i = 0; i < *M; i++)
> 			for (j = i; j < *M; j++)
> 				det2[i + *M * j] = det2[j + *M * i] = -sp[i] * sp[j]
> 						* trAB(Si + *q * *q * i, Si + *q * *q * j, q, q);
> 		for (i = 0; i < *M; i++)
> 			det2[i + *M * i] += det1[i];
637,638c811,817
<   if (*deriv) { FREE(rS1);FREE(rS2);}
<   if (*fixed_penalty) {FREE(spf);}
---
> 	if (*deriv) {
> 		FREE(rS1);
> 		FREE(rS2);
> 	}
> 	if (*fixed_penalty) {
> 		FREE(spf);
> 	}
641c820,821
<   FREE(pivot);FREE(tau);
---
> 	FREE(pivot);
> 	FREE(tau);
644,649c824,826
< 
< 
< 
< void get_stableS(double *S,double *Qf,double *sp,double *sqrtS, int *rSncol, int *q,int *M, int * deriv, 
<                double *det, double *det1, double *det2, double *d_tol,
<                double *r_tol,int *fixed_penalty)
---
> void get_stableS(double *S, double *Qf, double *sp, double *sqrtS, int *rSncol,
> 		int *q, int *M, int * deriv, double *det, double *det1, double *det2,
> 		double *d_tol, double *r_tol, int *fixed_penalty)
683,684c860,864
< { double *rS, *Un, *U, *Si,*Sb,*B,*C,*Sg,*p,*p1,*p2,*p3,*frob,*ev,max_frob,x,*spf;
<   int iter,i,j,k,bt,ct,rSoff,K,Q,Qr,*gamma,*gamma1,*alpha,TRUE=1,FALSE=0,r,max_col,Mf,n_gamma1;
---
> {
> 	double *rS, *Un, *U, *Si, *Sb, *B, *C, *Sg, *p, *p1, *p2, *p3, *frob, *ev,
> 			max_frob, x, *spf;
> 	int iter, i, j, k, bt, ct, rSoff, K, Q, Qr, *gamma, *gamma1, *alpha, TRUE =
> 			1, FALSE = 0, r, max_col, Mf, n_gamma1;
689,691c869,875
<     for (i=0;i<*M;i++) spf[i]=sp[i];spf[*M]=1.0; /* includes sp for fixed term */
<   } 
<   else {spf=sp;Mf = *M;} /* total number of components, including fixed one */
---
> 		for (i = 0; i < *M; i++)
> 			spf[i] = sp[i];
> 		spf[*M] = 1.0; /* includes sp for fixed term */
> 	} else {
> 		spf = sp;
> 		Mf = *M;
> 	} /* total number of components, including fixed one */
702,703c886,891
<     bt=0;ct=1;mgcv_mmult(p,sqrtS+rSoff * *q,sqrtS+rSoff * *q,&bt,&ct,q,q,rSncol+i);
<     if (rSncol[i]>max_col) max_col=rSncol[i];
---
> 		bt = 0;
> 		ct = 1;
> 		mgcv_mmult(p, sqrtS + rSoff * *q, sqrtS + rSoff * *q, &bt, &ct, q, q,
> 				rSncol + i);
> 		if (rSncol[i] > max_col)
> 			max_col = rSncol[i];
714c901,902
<   for (i=0;i<Mf;i++) gamma[i] = 1; /* no terms dealt with initially */
---
> 	for (i = 0; i < Mf; i++)
> 		gamma[i] = 1; /* no terms dealt with initially */
735c923,924
<         if (frob[i] *spf[i] >max_frob) max_frob=frob[i]  * spf[i];
---
> 				if (frob[i] * spf[i] > max_frob)
> 					max_frob = frob[i] * spf[i];
742c931,932
<           alpha[i] = 1;gamma1[i] = 0; /* deal with it now */
---
> 					alpha[i] = 1;
> 					gamma1[i] = 0; /* deal with it now */
744c934,936
<           alpha[i] = 0;gamma1[i] = 1; n_gamma1++; /* put it off */ 
---
> 					alpha[i] = 0;
> 					gamma1[i] = 1;
> 					n_gamma1++; /* put it off */
753,754c945,948
<       for (p=Sb,p1=p+Q*Q;p<p1;p++) *p=0.0; /* clear Sb */
<       for (p=Si,i=0;i<Mf;i++,p += Q*Q) if (alpha[i]) { 
---
> 			for (p = Sb, p1 = p + Q * Q; p < p1; p++)
> 				*p = 0.0; /* clear Sb */
> 			for (p = Si, i = 0; i < Mf; i++, p += Q * Q)
> 				if (alpha[i]) {
756c950,951
<         for (p1=p,p2=Sb,p3=p+Q*Q;p1<p3;p1++,p2++) *p2 += *p1 / x;
---
> 					for (p1 = p, p2 = Sb, p3 = p + Q * Q; p1 < p3; p1++, p2++)
> 						*p2 += *p1 / x;
761c956,957
<       while(r<Q&&(ev[Q-r-1]>ev[Q-1] * *r_tol)) r++;
---
> 			while (r < Q && (ev[Q - r - 1] > ev[Q - 1] * *r_tol))
> 				r++;
774c969,970
<           for (p1=p,p2=S,p3=p+Q*Q;p1<p3;p1++,p2++) *p2 += *p1 * x;
---
> 					for (p1 = p, p2 = S, p3 = p + Q * Q; p1 < p3; p1++, p2++)
> 						*p2 += *p1 * x;
777,778c973,976
<         for (p=Qf,p1=p+Q*Q;p<p1;p++) *p=0.0;
<         for (p=Qf,i=0;i<Q;i++,p+=Q+1) *p=1.0;
---
> 				for (p = Qf, p1 = p + Q * Q; p < p1; p++)
> 					*p = 0.0;
> 				for (p = Qf, i = 0; i < Q; i++, p += Q + 1)
> 					*p = 1.0;
780c978,979
<       } else break; /* just use current S */ 
---
> 			} else
> 				break; /* just use current S */
784,785c983,986
<     for (p=Sb,p1=p+Q*Q;p<p1;p++) *p = 0.0; /* clear Sb */
<     for (p=Si,i=0;i<Mf;i++,p += Q*Q) if (alpha[i]) { /* summing S[[i]]*sp[i] over i in alpha */
---
> 		for (p = Sb, p1 = p + Q * Q; p < p1; p++)
> 			*p = 0.0; /* clear Sb */
> 		for (p = Si, i = 0; i < Mf; i++, p += Q * Q)
> 			if (alpha[i]) { /* summing S[[i]]*sp[i] over i in alpha */
787c988,989
<       for (p1=p,p2=Sb,p3=p+Q*Q;p1<p3;p1++,p2++) *p2 += *p1 * x;
---
> 				for (p1 = p, p2 = Sb, p3 = p + Q * Q; p1 < p3; p1++, p2++)
> 					*p2 += *p1 * x;
793c995,997
<     if (iter==1) for (p=U,p1=Qf,p2 = p+Q*Q;p<p2;p++,p1++) *p1 = *p;
---
> 		if (iter == 1)
> 			for (p = U, p1 = Qf, p2 = p + Q * Q; p < p2; p++, p1++)
> 				*p1 = *p;
795,796c999,1003
<       bt=0;ct=0;mgcv_mmult(B,Qf+K * *q,U,&bt,&ct,q,&Q,&Q);
<       for (p=Qf + K * *q,p1=Qf + *q * *q,p2=B;p<p1;p++,p2++) *p = *p2;
---
> 			bt = 0;
> 			ct = 0;
> 			mgcv_mmult(B, Qf + K * *q, U, &bt, &ct, q, &Q, &Q);
> 			for (p = Qf + K * *q, p1 = Qf + *q * *q, p2 = B; p < p1; p++, p2++)
> 				*p = *p2;
800,801c1007,1010
<     for (p=Sg,p1=p+Q*Q;p<p1;p++) *p=0.0; /* clear Sg */
<     for (p=Si,i=0;i<Mf;i++,p += Q*Q) if (gamma1[i]) { /* summing S[[i]]*sp[i] over i in gamma1 */
---
> 		for (p = Sg, p1 = p + Q * Q; p < p1; p++)
> 			*p = 0.0; /* clear Sg */
> 		for (p = Si, i = 0; i < Mf; i++, p += Q * Q)
> 			if (gamma1[i]) { /* summing S[[i]]*sp[i] over i in gamma1 */
803c1012,1013
<       for (p1=p,p2=Sg,p3=p+Q*Q;p1<p3;p1++,p2++) *p2 += *p1 * x;
---
> 				for (p1 = p, p2 = Sg, p3 = p + Q * Q; p1 < p3; p1++, p2++)
> 					*p2 += *p1 * x;
809c1019,1021
<       for (j=0;j<Q;j++) for (i=0;i<K;i++) C[i + K * j] = S[i + *q * (j+K)];
---
> 			for (j = 0; j < Q; j++)
> 				for (i = 0; i < K; i++)
> 					C[i + K * j] = S[i + *q * (j + K)];
812c1024,1026
<       bt=0;ct=0;mgcv_mmult(B,C,U,&bt,&ct,&K,&Q,&Q);
---
> 			bt = 0;
> 			ct = 0;
> 			mgcv_mmult(B, C, U, &bt, &ct, &K, &Q, &Q);
814c1028,1030
<       for (j=0;j<Q;j++) for (i=0;i<K;i++) S[i + *q * (j+K)]= S[j + K + *q * i] = B[i + K * j];
---
> 			for (j = 0; j < Q; j++)
> 				for (i = 0; i < K; i++)
> 					S[i + *q * (j + K)] = S[j + K + *q * i] = B[i + K * j];
820,821c1036,1041
<     bt=0;ct=0;mgcv_mmult(B,Sg,U,&bt,&ct,&Q,&Q,&Q); /* SgU is in B */
<     bt=1;ct=0;mgcv_mmult(C,U,B,&bt,&ct,&Q,&Q,&Q);  /* U'SgU is in C */ 
---
> 		bt = 0;
> 		ct = 0;
> 		mgcv_mmult(B, Sg, U, &bt, &ct, &Q, &Q, &Q); /* SgU is in B */
> 		bt = 1;
> 		ct = 0;
> 		mgcv_mmult(C, U, B, &bt, &ct, &Q, &Q, &Q); /* U'SgU is in C */
823c1043,1044
<     for (i=0;i<r;i++) C[i+i * Q] += ev[i];  /* Adding in the non-zero eigenvalues */
---
> 		for (i = 0; i < r; i++)
> 			C[i + i * Q] += ev[i]; /* Adding in the non-zero eigenvalues */
826c1047,1049
<     for (j=0;j<Q;j++) for (i=0;i<Q;i++) S[i + K + *q * (j+K)] = C[i + Q * j];
---
> 		for (j = 0; j < Q; j++)
> 			for (i = 0; i < Q; i++)
> 				S[i + K + *q * (j + K)] = C[i + Q * j];
830c1053,1054
<      for (p=rS,k=0;k<*M;p += rSncol[k] * *q,k++) if (alpha[k]) {  /* p points to the square root of S_i */    
---
> 		for (p = rS, k = 0; k < *M; p += rSncol[k] * *q, k++)
> 			if (alpha[k]) { /* p points to the square root of S_i */
832,835c1056,1067
<         for (i=0;i<Q;i++) for (j=0;j<rSncol[k];j++) C[i + Q * j] = p[i + K + *q * j]; 
<         bt=1;ct=0;mgcv_mmult(B,U,C,&bt,&ct,&r,rSncol+k,&Q); 
<         for (i=0;i<r;i++) for (j=0;j<rSncol[k];j++) p[i + K + *q * j] = B[i + r * j];
<         for (i=K+r;i<K+Q;i++) for (j=0;j<rSncol[k];j++) p[i + *q * j] = 0.0;
---
> 				for (i = 0; i < Q; i++)
> 					for (j = 0; j < rSncol[k]; j++)
> 						C[i + Q * j] = p[i + K + *q * j];
> 				bt = 1;
> 				ct = 0;
> 				mgcv_mmult(B, U, C, &bt, &ct, &r, rSncol + k, &Q);
> 				for (i = 0; i < r; i++)
> 					for (j = 0; j < rSncol[k]; j++)
> 						p[i + K + *q * j] = B[i + r * j];
> 				for (i = K + r; i < K + Q; i++)
> 					for (j = 0; j < rSncol[k]; j++)
> 						p[i + *q * j] = 0.0;
837,840c1069,1078
<         for (i=0;i<Q;i++) for (j=0;j<rSncol[k];j++) C[i + Q * j] = p[i + K + *q * j];
<        
<         bt=1;ct=0;mgcv_mmult(B,U,C,&bt,&ct,&Q,rSncol+k,&Q);
<         for (i=0;i<Q;i++) for (j=0;j<rSncol[k];j++) p[i + K + *q * j] = B[i + Q * j];
---
> 				for (i = 0; i < Q; i++)
> 					for (j = 0; j < rSncol[k]; j++)
> 						C[i + Q * j] = p[i + K + *q * j];
> 
> 				bt = 1;
> 				ct = 0;
> 				mgcv_mmult(B, U, C, &bt, &ct, &Q, rSncol + k, &Q);
> 				for (i = 0; i < Q; i++)
> 					for (j = 0; j < rSncol[k]; j++)
> 						p[i + K + *q * j] = B[i + Q * j];
845c1082,1083
<     Qr = Q - r;Un = U + r * Q;
---
> 		Qr = Q - r;
> 		Un = U + r * Q;
847,849c1085,1092
<     for (p1=p=Si,i=0;i<Mf;i++,p += Q*Q,p1 +=Qr*Qr) if (gamma1[i]) { /* p points to old Si, and p1 to new */
<       bt=1;ct=0;mgcv_mmult(B,Un,p,&bt,&ct,&Qr,&Q,&Q);
<       bt=0;ct=0;mgcv_mmult(p1,B,Un,&bt,&ct,&Qr,&Qr,&Q); 
---
> 		for (p1 = p = Si, i = 0; i < Mf; i++, p += Q * Q, p1 += Qr * Qr)
> 			if (gamma1[i]) { /* p points to old Si, and p1 to new */
> 				bt = 1;
> 				ct = 0;
> 				mgcv_mmult(B, Un, p, &bt, &ct, &Qr, &Q, &Q);
> 				bt = 0;
> 				ct = 0;
> 				mgcv_mmult(p1, B, Un, &bt, &ct, &Qr, &Qr, &Q);
852,853c1095,1098
<     K = K + r; Q = Qr;
<     for (i=0;i<Mf;i++) gamma[i] = gamma1[i];
---
> 		K = K + r;
> 		Q = Qr;
> 		for (i = 0; i < Mf; i++)
> 			gamma[i] = gamma1[i];
858c1103,1104
<   for (p=S,p1=S + *q * *q,p2=C;p<p1;p++,p2++) *p2 = *p; /* copy S to C */
---
> 	for (p = S, p1 = S + *q * *q, p2 = C; p < p1; p++, p2++)
> 		*p2 = *p; /* copy S to C */
863c1109,1110
<    for (p=rS,i=0;i<*M;p += *q *rSncol[i],i++) det1[i] = trBtAB(B,p,q,rSncol+i)*sp[i]; /* tr(S^{-1}S_i) */
---
> 		for (p = rS, i = 0; i < *M; p += *q * rSncol[i], i++)
> 			det1[i] = trBtAB(B, p, q, rSncol + i) * sp[i]; /* tr(S^{-1}S_i) */
867,873c1114,1128
<     for (p1=Si,p=rS,i=0;i<*M;p += *q *rSncol[i],i++,p1 += *q * *q) { /* loop through creating S^{-1} S_i and storing in Si*/
<       bt=0;ct=0;mgcv_mmult(C,B,p,&bt,&ct,q,rSncol+i,q);
<       bt=0;ct=1;mgcv_mmult(p1,C,p,&bt,&ct,q,q,rSncol+i);
<     }
<     for (i=0;i<*M;i++) for (j=i;j<*M;j++) 
<       det2[i + *M * j] = det2[j + *M * i] = -sp[i]*sp[j]*trAB(Si + *q * *q *i,Si + *q * *q *j,q,q);
<     for (i=0;i<*M;i++) det2[i + *M * i] += det1[i];
---
> 		for (p1 = Si, p = rS, i = 0; i < *M;
> 				p += *q * rSncol[i], i++, p1 += *q * *q) { /* loop through creating S^{-1} S_i and storing in Si*/
> 			bt = 0;
> 			ct = 0;
> 			mgcv_mmult(C, B, p, &bt, &ct, q, rSncol + i, q);
> 			bt = 0;
> 			ct = 1;
> 			mgcv_mmult(p1, C, p, &bt, &ct, q, q, rSncol + i);
> 		}
> 		for (i = 0; i < *M; i++)
> 			for (j = i; j < *M; j++)
> 				det2[i + *M * j] = det2[j + *M * i] = -sp[i] * sp[j]
> 						* trAB(Si + *q * *q * i, Si + *q * *q * j, q, q);
> 		for (i = 0; i < *M; i++)
> 			det2[i + *M * i] += det1[i];
883c1137,1139
<   if (*fixed_penalty) {FREE(spf);}
---
> 	if (*fixed_penalty) {
> 		FREE(spf);
> 	}
890,894c1146,1148
< 
< 
< void get_ddetXWXpS0(double *det1,double *det2,double *P,double *K,double *sp,
<              double *rS,int *rSncol,double *Tk,double *Tkm,int *n,int *q,int *r,int *M,
< 		   int *deriv,int nthreads)
---
> void get_ddetXWXpS0(double *det1, double *det2, double *P, double *K,
> 		double *sp, double *rS, int *rSncol, double *Tk, double *Tkm, int *n,
> 		int *q, int *r, int *M, int *deriv, int nthreads)
910c1164,1166
< { double *diagKKt,xx,*KtTK,*PtrSm,*PtSP,*trPtSP,*work,*pdKK,*p1,*pTkm;
---
> {
> 	double *diagKKt, xx, *KtTK, *PtrSm, *PtSP, *trPtSP, *work, *pdKK, *p1,
> 			*pTkm;
916c1172,1173
<   if (nthreads<1) nthreads = 1;
---
> 	if (nthreads < 1)
> 		nthreads = 1;
918c1175,1178
<   if (*deriv==2) deriv2=1; else deriv2=0;
---
> 	if (*deriv == 2)
> 		deriv2 = 1;
> 	else
> 		deriv2 = 0;
947c1207,1209
<   } else { KtTK=(double *)NULL;} /* keep compiler happy */
---
> 	} else {
> 		KtTK = (double *) NULL;
> 	} /* keep compiler happy */
950c1212,1214
<   bt=1;ct=0;mgcv_mmult(det1,Tk,diagKKt,&bt,&ct,M,&one,n); /* tr(TkKK') */ 
---
> 	bt = 1;
> 	ct = 0;
> 	mgcv_mmult(det1, Tk, diagKKt, &bt, &ct, M, &one, n); /* tr(TkKK') */
955c1219,1221
<   for (j=0;j<*M;j++) if (max_col<rSncol[j]) max_col=rSncol[j]; /* under ML can have q < max(rSncol) */
---
> 	for (j = 0; j < *M; j++)
> 		if (max_col < rSncol[j])
> 			max_col = rSncol[j]; /* under ML can have q < max(rSncol) */
957c1223,1224
<   PtrSm = (double *)CALLOC((size_t)(*r * max_col * nthreads),sizeof(double)); /* storage for P' rSm */
---
> 	PtrSm = (double *) CALLOC((size_t) (*r * max_col * nthreads),
> 			sizeof(double)); /* storage for P' rSm */
962,963c1229,1231
<   } else { PtSP = (double *) NULL;}
<   
---
> 	} else {
> 		PtSP = (double *) NULL;
> 	}
966c1234,1236
<   rSoff[0] = 0;for (m=0;m < *M-1;m++) rSoff[m+1] = rSoff[m] + rSncol[m];
---
> 	rSoff[0] = 0;
> 	for (m = 0; m < *M - 1; m++)
> 		rSoff[m + 1] = rSoff[m] + rSncol[m];
979c1249,1252
<       bt=1;ct=0;mgcv_mmult(PtrSm + tid * *r * max_col,P,rS+rSoff[m] * *q,&bt,&ct,r,rSncol+m,q);
---
> 			bt = 1;
> 			ct = 0;
> 			mgcv_mmult(PtrSm + tid * *r * max_col, P, rS + rSoff[m] * *q, &bt,
> 					&ct, r, rSncol + m, q);
981c1254,1255
<       trPtSP[m] = sp[m] * diagABt(work + *n * tid,PtrSm + tid * *r * max_col,
---
> 			trPtSP[m] = sp[m]
> 					* diagABt(work + *n * tid, PtrSm + tid * *r * max_col,
985c1259,1261
<         bt=0;ct=1;mgcv_mmult(PtSP+ m * *r * *r,PtrSm + tid * *r * max_col,
---
> 				bt = 0;
> 				ct = 1;
> 				mgcv_mmult(PtSP + m * *r * *r, PtrSm + tid * *r * max_col,
996,997c1272
<   if (deriv2) 
<   { /* start of parallel section */ 
---
> 	if (deriv2) { /* start of parallel section */
1006c1281,1284
<       if (m==0) pTkm = Tkm; else pTkm = Tkm + (m * *M - (m*(m-1))/2) * *n;        
---
> 			if (m == 0)
> 				pTkm = Tkm;
> 			else
> 				pTkm = Tkm + (m * *M - (m * (m - 1)) / 2) * *n;
1008c1286,1287
<         km=k * *M + m;mk=m * *M + k;
---
> 				km = k * *M + m;
> 				mk = m * *M + k;
1011c1290,1292
<         for (xx=0.0,pdKK=diagKKt,p1=pdKK + *n;pdKK<p1;pdKK++,pTkm++) xx += *pTkm * *pdKK;
---
> 				for (xx = 0.0, pdKK = diagKKt, p1 = pdKK + *n; pdKK < p1;
> 						pdKK++, pTkm++)
> 					xx += *pTkm * *pdKK;
1015c1296,1297
<         det2[km] -= diagABt(work + *n * tid,KtTK + k * *r * *r,KtTK+ m * *r * *r,r,r);
---
> 				det2[km] -= diagABt(work + *n * tid, KtTK + k * *r * *r,
> 						KtTK + m * *r * *r, r, r);
1018c1300,1301
<         if (k==m) det2[km] += trPtSP[m];
---
> 				if (k == m)
> 					det2[km] += trPtSP[m];
1021c1304,1306
<         det2[km] -= sp[m]*diagABt(work + *n * tid,KtTK + k * *r * *r,PtSP + m * *r * *r,r,r);
---
> 				det2[km] -= sp[m]
> 						* diagABt(work + *n * tid, KtTK + k * *r * *r,
> 								PtSP + m * *r * *r, r, r);
1024c1309,1311
<         det2[km] -= sp[k]*diagABt(work + *n * tid,KtTK + m * *r * *r,PtSP + k * *r * *r,r,r);
---
> 				det2[km] -= sp[k]
> 						* diagABt(work + *n * tid, KtTK + m * *r * *r,
> 								PtSP + k * *r * *r, r, r);
1027c1314,1316
<         det2[km] -= sp[m]*sp[k]*diagABt(work + *n * tid,PtSP + k * *r * *r,PtSP + m * *r * *r,r,r);
---
> 				det2[km] -= sp[m] * sp[k]
> 						* diagABt(work + *n * tid, PtSP + k * *r * *r,
> 								PtSP + m * *r * *r, r, r);
1035,1037c1324,1331
<   if (deriv2) {FREE(PtSP);FREE(KtTK);}
<   FREE(diagKKt);FREE(work);
<   FREE(PtrSm);FREE(trPtSP);
---
> 	if (deriv2) {
> 		FREE(PtSP);
> 		FREE(KtTK);
> 	}
> 	FREE(diagKKt);
> 	FREE(work);
> 	FREE(PtrSm);
> 	FREE(trPtSP);
1045,1046c1338,1339
<       double *rS,int *rSncol,double *Tk,double *Tkm,int *n,int *q,int *r,int *M,int *M0,
< 		   int *deriv,int nthreads)
---
> 		double *rS, int *rSncol, double *Tk, double *Tkm, int *n, int *q,
> 		int *r, int *M, int *M0, int *deriv, int nthreads)
1066c1359,1361
< { double *diagKKt,xx,*KtTK,*PtrSm,*PtSP,*trPtSP,*work,*pdKK,*p1,*pTkm;
---
> {
> 	double *diagKKt, xx, *KtTK, *PtrSm, *PtSP, *trPtSP, *work, *pdKK, *p1,
> 			*pTkm;
1069c1364,1365
<   if (nthreads<1) nthreads = 1;
---
> 	if (nthreads < 1)
> 		nthreads = 1;
1073c1369,1372
<   if (*deriv==2) deriv2=1; else deriv2=0;
---
> 	if (*deriv == 2)
> 		deriv2 = 1;
> 	else
> 		deriv2 = 0;
1102c1401,1403
<   } else { KtTK=(double *)NULL;} /* keep compiler happy */
---
> 	} else {
> 		KtTK = (double *) NULL;
> 	} /* keep compiler happy */
1105c1406,1408
<   bt=1;ct=0;mgcv_mmult(det1,Tk,diagKKt,&bt,&ct,&Mtot,&one,n); /* tr(TkKK') */ 
---
> 	bt = 1;
> 	ct = 0;
> 	mgcv_mmult(det1, Tk, diagKKt, &bt, &ct, &Mtot, &one, n); /* tr(TkKK') */
1110c1413,1415
<   for (j=0;j<*M;j++) if (max_col<rSncol[j]) max_col=rSncol[j]; /* under ML can have q < max(rSncol) */
---
> 	for (j = 0; j < *M; j++)
> 		if (max_col < rSncol[j])
> 			max_col = rSncol[j]; /* under ML can have q < max(rSncol) */
1112c1417,1418
<   PtrSm = (double *)CALLOC((size_t)(*r * max_col * nthreads),sizeof(double)); /* storage for P' rSm */
---
> 	PtrSm = (double *) CALLOC((size_t) (*r * max_col * nthreads),
> 			sizeof(double)); /* storage for P' rSm */
1117,1118c1423,1425
<   } else { PtSP = (double *) NULL;}
<   
---
> 	} else {
> 		PtSP = (double *) NULL;
> 	}
1122c1429,1431
<     rSoff[0] = 0;for (m=0;m < *M-1;m++) rSoff[m+1] = rSoff[m] + rSncol[m];
---
> 		rSoff[0] = 0;
> 		for (m = 0; m < *M - 1; m++)
> 			rSoff[m + 1] = rSoff[m] + rSncol[m];
1136c1445,1448
<       bt=1;ct=0;mgcv_mmult(PtrSm + tid * *r * max_col,P,rS+rSoff[m] * *q,&bt,&ct,r,rSncol+m,q);
---
> 			bt = 1;
> 			ct = 0;
> 			mgcv_mmult(PtrSm + tid * *r * max_col, P, rS + rSoff[m] * *q, &bt,
> 					&ct, r, rSncol + m, q);
1138c1450,1451
<       trPtSP[m] = sp[m] * diagABt(work + *n * tid,PtrSm + tid * *r * max_col,
---
> 			trPtSP[m] = sp[m]
> 					* diagABt(work + *n * tid, PtrSm + tid * *r * max_col,
1142c1455,1457
<         bt=0;ct=1;mgcv_mmult(PtSP+ m * *r * *r,PtrSm + tid * *r * max_col,
---
> 				bt = 0;
> 				ct = 1;
> 				mgcv_mmult(PtSP + m * *r * *r, PtrSm + tid * *r * max_col,
1153,1154c1468
<   if (deriv2)
<   { /* start of parallel section */ 
---
> 	if (deriv2) { /* start of parallel section */
1163c1477,1480
<       if (m==0) pTkm = Tkm; else pTkm = Tkm + (m * Mtot - (m*(m-1))/2) * *n;        
---
> 			if (m == 0)
> 				pTkm = Tkm;
> 			else
> 				pTkm = Tkm + (m * Mtot - (m * (m - 1)) / 2) * *n;
1165c1482,1483
<         km=k * Mtot + m;mk=m * Mtot + k;
---
> 				km = k * Mtot + m;
> 				mk = m * Mtot + k;
1168c1486,1488
<         for (xx=0.0,pdKK=diagKKt,p1=pdKK + *n;pdKK<p1;pdKK++,pTkm++) xx += *pTkm * *pdKK;
---
> 				for (xx = 0.0, pdKK = diagKKt, p1 = pdKK + *n; pdKK < p1;
> 						pdKK++, pTkm++)
> 					xx += *pTkm * *pdKK;
1172c1492,1493
<         det2[km] -= diagABt(work + *n * tid,KtTK + k * *r * *r,KtTK+ m * *r * *r,r,r);
---
> 				det2[km] -= diagABt(work + *n * tid, KtTK + k * *r * *r,
> 						KtTK + m * *r * *r, r, r);
1175c1496,1497
<         if (k >= *M0 && k==m) det2[km] += trPtSP[m - *M0];
---
> 				if (k >= *M0 && k == m)
> 					det2[km] += trPtSP[m - *M0];
1178c1500,1503
<         if (m >= *M0) det2[km] -= sp[m - *M0]*diagABt(work + *n * tid,KtTK + k * *r * *r,PtSP + (m - *M0) * *r * *r,r,r);
---
> 				if (m >= *M0)
> 					det2[km] -= sp[m - *M0]
> 							* diagABt(work + *n * tid, KtTK + k * *r * *r,
> 									PtSP + (m - *M0) * *r * *r, r, r);
1181c1506,1509
<         if (k >= *M0) det2[km] -= sp[k - *M0]*diagABt(work + *n * tid,KtTK + m * *r * *r,PtSP + (k - *M0) * *r * *r,r,r);
---
> 				if (k >= *M0)
> 					det2[km] -= sp[k - *M0]
> 							* diagABt(work + *n * tid, KtTK + m * *r * *r,
> 									PtSP + (k - *M0) * *r * *r, r, r);
1184,1185c1512,1516
<         if (k >= *M0 && m >= *M0) det2[km] -= sp[m - *M0]*sp[k - *M0]*
<                                   diagABt(work + *n * tid,PtSP + (k - *M0) * *r * *r,PtSP + (m - *M0) * *r * *r,r,r);
---
> 				if (k >= *M0 && m >= *M0)
> 					det2[km] -= sp[m - *M0] * sp[k - *M0]
> 							* diagABt(work + *n * tid,
> 									PtSP + (k - *M0) * *r * *r,
> 									PtSP + (m - *M0) * *r * *r, r, r);
1193,1195c1524,1531
<   if (deriv2) {FREE(PtSP);FREE(KtTK);}
<   FREE(diagKKt);FREE(work);
<   FREE(PtrSm);FREE(trPtSP);
---
> 	if (deriv2) {
> 		FREE(PtSP);
> 		FREE(KtTK);
> 	}
> 	FREE(diagKKt);
> 	FREE(work);
> 	FREE(PtrSm);
> 	FREE(trPtSP);
1199,1202c1535,1537
< 
< void get_trA2(double *trA,double *trA1,double *trA2,double *P,double *K,double *sp,
< 	      double *rS,int *rSncol,double *Tk,double *Tkm,double *w,int *n,int *q,
<               int *r,int *M,int *deriv,int *nt)
---
> void get_trA2(double *trA, double *trA1, double *trA2, double *P, double *K,
> 		double *sp, double *rS, int *rSncol, double *Tk, double *Tkm, double *w,
> 		int *n, int *q, int *r, int *M, int *deriv, int *nt)
1222,1223c1557,1561
< { double *diagKKt,*diagKKtKKt,xx,*KtTK,*KtTKKtK,*KKtK,*KtK,*work,*pTk,*pTm,*pdKKt,*pdKKtKKt,*p0,*p1,*p2,*p3,*pd,
<     *PtrSm,*PtSP,*KPtrSm,*diagKPtSPKt,*diagKPtSPKtKKt,*PtSPKtK, *KtKPtrSm, *KKtKPtrSm,*Ip,*IpK/*,lowK,hiK*/;
---
> {
> 	double *diagKKt, *diagKKtKKt, xx, *KtTK, *KtTKKtK, *KKtK, *KtK, *work, *pTk,
> 			*pTm, *pdKKt, *pdKKtKKt, *p0, *p1, *p2, *p3, *pd, *PtrSm, *PtSP,
> 			*KPtrSm, *diagKPtSPKt, *diagKPtSPKtKKt, *PtSPKtK, *KtKPtrSm,
> 			*KKtKPtrSm, *Ip, *IpK/*,lowK,hiK*/;
1228c1566,1569
<   if (*deriv==2) deriv2=1; else deriv2=0;
---
> 	if (*deriv == 2)
> 		deriv2 = 1;
> 	else
> 		deriv2 = 0;
1231c1572,1577
<   for (p0=w,p1=p0+ *n,p2=Ip;p0<p1;p0++,p2++) if (*p0 < 0) {*p2 = -1.0;neg_w=1;} else *p2 = 1.0;
---
> 	for (p0 = w, p1 = p0 + *n, p2 = Ip; p0 < p1; p0++, p2++)
> 		if (*p0 < 0) {
> 			*p2 = -1.0;
> 			neg_w = 1;
> 		} else
> 			*p2 = 1.0;
1237c1583,1585
<     for (*trA=0.0,p0=diagKKt,p1=p0 + *n,p2=Ip;p0<p1;p0++,p2++) *trA += *p2 * *p0;
---
> 		for (*trA = 0.0, p0 = diagKKt, p1 = p0 + *n, p2 = Ip; p0 < p1;
> 				p0++, p2++)
> 			*trA += *p2 * *p0;
1240c1588,1589
<     FREE(Ip);FREE(diagKKt); 
---
> 		FREE(Ip);
> 		FREE(diagKKt);
1254c1603,1604
<       for (p1=Ip,p2=p1 + *n;p1<p2;p1++,p0++,p3++) *p0 = *p1 * *p3; 
---
> 			for (p1 = Ip, p2 = p1 + *n; p1 < p2; p1++, p0++, p3++)
> 				*p0 = *p1 * *p3;
1257c1607,1608
<     for (p0=IpK,p1=K,p2=K+ *n * *r;p1<p2;p0++,p1++) *p0 = *p1; 
---
> 		for (p0 = IpK, p1 = K, p2 = K + *n * *r; p1 < p2; p0++, p1++)
> 			*p0 = *p1;
1266,1267c1617,1623
<   bt=1;ct=0;mgcv_pmmult(KtK,K,IpK,&bt,&ct,r,r,n,nt);  
<   if (neg_w) FREE(IpK); else FREE(IpK);
---
> 	bt = 1;
> 	ct = 0;
> 	mgcv_pmmult(KtK, K, IpK, &bt, &ct, r, r, n, nt);
> 	if (neg_w)
> 		FREE(IpK);
> 	else
> 		FREE(IpK);
1269c1625,1627
<   bt=0;ct=0;mgcv_pmmult(KKtK,K,KtK,&bt,&ct,n,r,r,nt);  
---
> 	bt = 0;
> 	ct = 0;
> 	mgcv_pmmult(KKtK, K, KtK, &bt, &ct, n, r, r, nt);
1292c1650,1652
<         bt=ct=0;mgcv_mmult(KtTKKtK + k * *r * *r ,KtTK + j,KtK,&bt,&ct,r,r,r);
---
> 				bt = ct = 0;
> 				mgcv_mmult(KtTKKtK + k * *r * *r, KtTK + j, KtK, &bt, &ct, r, r,
> 						r);
1295c1655,1657
<   } else { KtTK=KtTKKtK=(double *)NULL;}
---
> 	} else {
> 		KtTK = KtTKKtK = (double *) NULL;
> 	}
1298,1300c1660,1667
<   bt=1;ct=0;mgcv_mmult(trA1,Tk,diagKKt,&bt,&ct,M,&one,n); /* tr(KK'Tk) */ 
<   bt=1;ct=0;mgcv_mmult(work,Tk,diagKKtKKt,&bt,&ct,M,&one,n); /* tr(KK'TkKK') */
<   for (i=0;i<*M;i++) trA1[i] +=  - work[i];
---
> 	bt = 1;
> 	ct = 0;
> 	mgcv_mmult(trA1, Tk, diagKKt, &bt, &ct, M, &one, n); /* tr(KK'Tk) */
> 	bt = 1;
> 	ct = 0;
> 	mgcv_mmult(work, Tk, diagKKtKKt, &bt, &ct, M, &one, n); /* tr(KK'TkKK') */
> 	for (i = 0; i < *M; i++)
> 		trA1[i] += -work[i];
1303,1304c1670,1674
<   if (deriv2) for (m=0;m < *M;m++) for (k=m;k < *M;k++){
<      km=k * *M + m;mk=m * *M + k;
---
> 	if (deriv2)
> 		for (m = 0; m < *M; m++)
> 			for (k = m; k < *M; k++) {
> 				km = k * *M + m;
> 				mk = m * *M + k;
1307c1677,1678
<      for (xx=0.0,pdKKt=diagKKt,pdKKtKKt=diagKKtKKt,p1=pdKKt + *n;pdKKt<p1;pdKKt++,pdKKtKKt++,Tkm++) 
---
> 				for (xx = 0.0, pdKKt = diagKKt, pdKKtKKt = diagKKtKKt, p1 =
> 						pdKKt + *n; pdKKt < p1; pdKKt++, pdKKtKKt++, Tkm++)
1312c1683,1685
<      trA2[km] -= 2*diagABt(work,KtTK + k * *r * *r,KtTK+ m * *r * *r,r,r);
---
> 				trA2[km] -= 2
> 						* diagABt(work, KtTK + k * *r * *r, KtTK + m * *r * *r,
> 								r, r);
1315c1688,1690
<      xx = 2*diagABt(work,KtTK+k * *r * *r,KtTKKtK+m * *r * *r,r,r);
---
> 				xx = 2
> 						* diagABt(work, KtTK + k * *r * *r,
> 								KtTKKtK + m * *r * *r, r, r);
1323c1698,1701
<   if (deriv2) {FREE(KtTKKtK);FREE(KtTK);} 
---
> 	if (deriv2) {
> 		FREE(KtTKKtK);
> 		FREE(KtTK);
> 	}
1325c1703,1704
<   FREE(diagKKtKKt);FREE(diagKKt);
---
> 	FREE(diagKKtKKt);
> 	FREE(diagKKt);
1337c1716,1719
<   } else {  KKtKPtrSm=PtSPKtK= PtSP=KtKPtrSm=diagKPtSPKtKKt=(double *)NULL; }
---
> 	} else {
> 		KKtKPtrSm = PtSPKtK = PtSP = KtKPtrSm = diagKPtSPKtKKt =
> 				(double *) NULL;
> 	}
1340c1722,1724
<   rSoff[0] = 0;for (m=0;m < *M-1;m++) rSoff[m+1] = rSoff[m] + rSncol[m];
---
> 	rSoff[0] = 0;
> 	for (m = 0; m < *M - 1; m++)
> 		rSoff[m + 1] = rSoff[m] + rSncol[m];
1353,1354c1737,1744
<       bt=1;ct=0;mgcv_mmult(PtrSm + *r * *q * tid,P,rS+rSoff[m] * *q,&bt,&ct,r,rSncol+m,q);
<       bt=0;ct=0;mgcv_mmult(KPtrSm + *n * *q * tid,K,PtrSm + *r * *q * tid ,&bt,&ct,n,rSncol+m,r); 
---
> 			bt = 1;
> 			ct = 0;
> 			mgcv_mmult(PtrSm + *r * *q * tid, P, rS + rSoff[m] * *q, &bt, &ct,
> 					r, rSncol + m, q);
> 			bt = 0;
> 			ct = 0;
> 			mgcv_mmult(KPtrSm + *n * *q * tid, K, PtrSm + *r * *q * tid, &bt,
> 					&ct, n, rSncol + m, r);
1356,1357c1746,1753
<         bt=0;ct=0;mgcv_mmult(KtKPtrSm + *r * *q * tid,KtK,PtrSm + *r * *q * tid,&bt,&ct,r,rSncol+m,r); 
<         bt=0;ct=1;mgcv_mmult(PtSP+ m * *r * *r,PtrSm + *r * *q * tid,PtrSm + *r * *q * tid,&bt,&ct,r,r,rSncol+m);
---
> 				bt = 0;
> 				ct = 0;
> 				mgcv_mmult(KtKPtrSm + *r * *q * tid, KtK, PtrSm + *r * *q * tid,
> 						&bt, &ct, r, rSncol + m, r);
> 				bt = 0;
> 				ct = 1;
> 				mgcv_mmult(PtSP + m * *r * *r, PtrSm + *r * *q * tid,
> 						PtrSm + *r * *q * tid, &bt, &ct, r, r, rSncol + m);
1359,1363c1755,1768
<         bt=0;ct=0;mgcv_mmult(KKtKPtrSm + *n * *q * tid,KKtK,PtrSm + *r * *q * tid,&bt,&ct,n,rSncol+m,r);      
<         bt=0;ct=1;mgcv_mmult(PtSPKtK + m * *r * *r,PtrSm + *r * *q * tid,KtKPtrSm+ *r * *q * tid,&bt,&ct,r,r,rSncol+m); 
<         xx = diagABt(diagKPtSPKtKKt+ m * *n,KPtrSm + *n * *q * tid,KKtKPtrSm + *n * *q * tid,n,rSncol+m);
<       }
<       xx = sp[m] * diagABt(diagKPtSPKt+ m * *n,KPtrSm + *n * *q * tid,KPtrSm + *n * *q * tid,n,rSncol+m);
---
> 				bt = 0;
> 				ct = 0;
> 				mgcv_mmult(KKtKPtrSm + *n * *q * tid, KKtK,
> 						PtrSm + *r * *q * tid, &bt, &ct, n, rSncol + m, r);
> 				bt = 0;
> 				ct = 1;
> 				mgcv_mmult(PtSPKtK + m * *r * *r, PtrSm + *r * *q * tid,
> 						KtKPtrSm + *r * *q * tid, &bt, &ct, r, r, rSncol + m);
> 				xx = diagABt(diagKPtSPKtKKt + m * *n, KPtrSm + *n * *q * tid,
> 						KKtKPtrSm + *n * *q * tid, n, rSncol + m);
> 			}
> 			xx = sp[m]
> 					* diagABt(diagKPtSPKt + m * *n, KPtrSm + *n * *q * tid,
> 							KPtrSm + *n * *q * tid, n, rSncol + m);
1365c1770,1772
<         for (xx=0.0,p0=diagKPtSPKt+m * *n,p1=p0 + *n,p2=Ip;p0<p1;p0++,p2++) xx += *p0 * *p2;
---
> 				for (xx = 0.0, p0 = diagKPtSPKt + m * *n, p1 = p0 + *n, p2 = Ip;
> 						p0 < p1; p0++, p2++)
> 					xx += *p0 * *p2;
1369c1776,1777
<       if (deriv2) trA2[m * *M + m] -=xx; /* the extra diagonal term of trA2 */
---
> 			if (deriv2)
> 				trA2[m * *M + m] -= xx; /* the extra diagonal term of trA2 */
1376,1377c1783,1788
<     FREE(PtrSm);FREE(KPtrSm);FREE(diagKPtSPKt);
<     FREE(work);FREE(KtK);FREE(KKtK); 
---
> 		FREE(PtrSm);
> 		FREE(KPtrSm);
> 		FREE(diagKPtSPKt);
> 		FREE(work);
> 		FREE(KtK);
> 		FREE(KKtK);
1384,1385c1795,1798
<    for (m=0;m < *M;m++) for (k=m;k < *M;k++){
<      km=k * *M + m;mk=m * *M + k;
---
> 	for (m = 0; m < *M; m++)
> 		for (k = m; k < *M; k++) {
> 			km = k * *M + m;
> 			mk = m * *M + k;
1389c1802,1804
<      for (xx=0.0,pd = diagKPtSPKtKKt + m * *n,p1=pd + *n;pd < p1;pd++,pTk++) xx += *pd * *pTk;
---
> 			for (xx = 0.0, pd = diagKPtSPKtKKt + m * *n, p1 = pd + *n; pd < p1;
> 					pd++, pTk++)
> 				xx += *pd * *pTk;
1394c1809,1811
<      for (xx=0.0,pd = diagKPtSPKtKKt + k * *n,p1=pd + *n;pd < p1;pd++,pTm++) xx += *pd * *pTm;
---
> 			for (xx = 0.0, pd = diagKPtSPKtKKt + k * *n, p1 = pd + *n; pd < p1;
> 					pd++, pTm++)
> 				xx += *pd * *pTm;
1399c1816,1818
<      for (xx=0.0,pd = diagKPtSPKt + m * *n,p1=pd + *n;pd < p1;pd++,pTk++) xx += *pd * *pTk;
---
> 			for (xx = 0.0, pd = diagKPtSPKt + m * *n, p1 = pd + *n; pd < p1;
> 					pd++, pTk++)
> 				xx += *pd * *pTk;
1404c1823,1825
<      for (xx=0.0,pd = diagKPtSPKt + k * *n,p1=pd + *n;pd < p1;pd++,pTm++) xx += *pd * *pTm;
---
> 			for (xx = 0.0, pd = diagKPtSPKt + k * *n, p1 = pd + *n; pd < p1;
> 					pd++, pTm++)
> 				xx += *pd * *pTm;
1408c1829,1831
<      trA2[km] += 2 * sp[k]*sp[m]*diagABt(work,PtSP + m * *r * *r,PtSPKtK + k * *r * *r,r,r);
---
> 			trA2[km] += 2 * sp[k] * sp[m]
> 					* diagABt(work, PtSP + m * *r * *r, PtSPKtK + k * *r * *r,
> 							r, r);
1413,1414c1836,1846
<    FREE(PtrSm);FREE(KPtrSm);FREE(PtSP);FREE(KtKPtrSm);FREE(diagKPtSPKt);
<    FREE(diagKPtSPKtKKt);FREE(work);FREE(KtK);FREE(KKtK);FREE(PtSPKtK);FREE(KKtKPtrSm);
---
> 	FREE(PtrSm);
> 	FREE(KPtrSm);
> 	FREE(PtSP);
> 	FREE(KtKPtrSm);
> 	FREE(diagKPtSPKt);
> 	FREE(diagKPtSPKtKKt);
> 	FREE(work);
> 	FREE(KtK);
> 	FREE(KKtK);
> 	FREE(PtSPKtK);
> 	FREE(KKtKPtrSm);
1431c1858,1859
< { int i;
---
> {
> 	int i;
1435c1863,1864
<       for (pz=z;pz<pz1;pz++,y++,x++) *y = *pz * *x;
---
> 		for (pz = z; pz < pz1; pz++, y++, x++)
> 			*y = *pz * *x;
1444c1872,1873
< { int i,j,k,eye;
---
> {
> 	int i, j, k, eye;
1449c1878,1879
< 	  for (xx=0.0,j=k+1;j <=i;j++) xx += R[k + j * *r] * rc[j];
---
> 			for (xx = 0.0, j = k + 1; j <= i; j++)
> 				xx += R[k + j * *r] * rc[j];
1453c1883,1884
<       for (k=i+1;k<*c;k++) rc[k]=0.0;
---
> 		for (k = i + 1; k < *c; k++)
> 			rc[k] = 0.0;
1458,1461c1889,1892
< 
< void pearson2(double *P, double *P1, double *P2,
<               double *y,double *mu,double *V, double *V1,double *V2,double *g1,double *g2,
<               double *p_weights,double *eta1, double *eta2,int n,int M,int deriv, int deriv2)
---
> void pearson2(double *P, double *P1, double *P2, double *y, double *mu,
> 		double *V, double *V1, double *V2, double *g1, double *g2,
> 		double *p_weights, double *eta1, double *eta2, int n, int M, int deriv,
> 		int deriv2)
1464c1895,1896
< { double resid,xx,*Pe1,*Pe2,*pp,*p1,*p0,*v2,*Pi1,*Pi2;
---
> {
> 	double resid, xx, *Pe1, *Pe2, *pp, *p1, *p0, *v2, *Pi1, *Pi2;
1474,1475c1906,1911
<     } else {Pe2=v2=Pi2=NULL;}
<   } else {Pi1 = Pe2 = v2 = Pe1 = Pi2 = NULL;}
---
> 		} else {
> 			Pe2 = v2 = Pi2 = NULL;
> 		}
> 	} else {
> 		Pi1 = Pe2 = v2 = Pe1 = Pi2 = NULL;
> 	}
1484,1485c1920,1924
<         Pe2[i] = - Pe1[i]*g2[i]/g1[i] + 
< 	  (2*p_weights[i]/V[i]+2*xx*V1[i] - Pe1[i]*V1[i]*g1[i] - xx*resid*(V2[i]-V1[i]*V1[i]))/(g1[i]*g1[i]);
---
> 				Pe2[i] = -Pe1[i] * g2[i] / g1[i]
> 						+ (2 * p_weights[i] / V[i] + 2 * xx * V1[i]
> 								- Pe1[i] * V1[i] * g1[i]
> 								- xx * resid * (V2[i] - V1[i] * V1[i]))
> 								/ (g1[i] * g1[i]);
1494c1933,1934
<         for (pp=Pi2,m=0;m < M;m++) for (k=m;k < M;k++) {
---
> 			for (pp = Pi2, m = 0; m < M; m++)
> 				for (k = m; k < M; k++) {
1498c1938,1939
<             for (p0=v2;p0<p1;p0++,pp++) *pp += *p0;        
---
> 					for (p0 = v2; p0 < p1; p0++, pp++)
> 						*pp += *p0;
1507c1948,1953
<     for (k=0;k<M;k++) { xx=0.0; for (i=0;i<n;i++,pp++) xx += *pp;P1[k] = xx;}
---
> 		for (k = 0; k < M; k++) {
> 			xx = 0.0;
> 			for (i = 0; i < n; i++, pp++)
> 				xx += *pp;
> 			P1[k] = xx;
> 		}
1509c1955,1956
<         for (pp=Pi2,m=0;m < M;m++) for (k=m;k < M;k++) {
---
> 			for (pp = Pi2, m = 0; m < M; m++)
> 				for (k = m; k < M; k++) {
1511c1958,1959
<           for (i=0;i<n;i++,pp++) xx += *pp;
---
> 					for (i = 0; i < n; i++, pp++)
> 						xx += *pp;
1519c1967,1968
<     FREE(Pe1);FREE(Pi1);
---
> 		FREE(Pe1);
> 		FREE(Pi1);
1521c1970,1972
<       FREE(Pe2);FREE(Pi2);FREE(v2);
---
> 			FREE(Pe2);
> 			FREE(Pi2);
> 			FREE(v2);
1527,1529c1978,1979
< 
< 
< void applyP(double *y,double *x,double *R,double *Vt,int neg_w,int nr,int r,int c,int right)
---
> void applyP(double *y, double *x, double *R, double *Vt, int neg_w, int nr,
> 		int r, int c, int right)
1533c1983,1984
< { double *x1;
---
> {
> 	double *x1;
1539c1990,1992
<       bt=0;ct=1;mgcv_mmult(y,x1,Vt,&bt,&ct,&c,&r,&r);   /* y = x R^{-1} V */
---
> 			bt = 0;
> 			ct = 1;
> 			mgcv_mmult(y, x1, Vt, &bt, &ct, &c, &r, &r); /* y = x R^{-1} V */
1541c1994,1996
<       bt=1;ct=0;mgcv_mmult(x1,Vt,x,&bt,&ct,&r,&c,&r);   /* x1 = V x */    
---
> 			bt = 1;
> 			ct = 0;
> 			mgcv_mmult(x1, Vt, x, &bt, &ct, &r, &c, &r); /* x1 = V x */
1545c2000,2001
<   } else mgcv_backsolve(R,&nr,&r,x,y, &c,&right);            /* y = R^{-1} x */
---
> 	} else
> 		mgcv_backsolve(R, &nr, &r, x, y, &c, &right); /* y = R^{-1} x */
1548c2004,2005
< void applyPt(double *y,double *x,double *R,double *Vt,int neg_w,int nr,int r,int c,int right)
---
> void applyPt(double *y, double *x, double *R, double *Vt, int neg_w, int nr,
> 		int r, int c, int right)
1552c2009,2010
< { double *x1;
---
> {
> 	double *x1;
1557c2015,2017
<       bt=0;ct=0;mgcv_mmult(x1,x,Vt,&bt,&ct,&c,&r,&r);   /* x1 = x V' */
---
> 			bt = 0;
> 			ct = 0;
> 			mgcv_mmult(x1, x, Vt, &bt, &ct, &c, &r, &r); /* x1 = x V' */
1561c2021,2023
<       bt=0;ct=0;mgcv_mmult(y,Vt,x1,&bt,&ct,&r,&c,&r);   /* y = V'R^{-T} x */    
---
> 			bt = 0;
> 			ct = 0;
> 			mgcv_mmult(y, Vt, x1, &bt, &ct, &r, &c, &r); /* y = V'R^{-T} x */
1564c2026,2027
<   } else mgcv_forwardsolve(R,&nr,&r,x,y, &c,&right);            /* y = R^{-T} x */
---
> 	} else
> 		mgcv_forwardsolve(R, &nr, &r, x, y, &c, &right); /* y = R^{-T} x */
1567,1570c2030,2033
< 
< void ift1(double *R,double *Vt,double *X,double *rS,double *beta,double *sp,double *w,
<          double *dwdeta,double *b1, double *b2,double *eta1,double *eta2,
< 	  int *n,int *r, int *M,int *rSncol,int *deriv2,int *neg_w,int *nr)
---
> void ift1(double *R, double *Vt, double *X, double *rS, double *beta,
> 		double *sp, double *w, double *dwdeta, double *b1, double *b2,
> 		double *eta1, double *eta2, int *n, int *r, int *M, int *rSncol,
> 		int *deriv2, int *neg_w, int *nr)
1582c2045,2046
< { int n_2dCols,i,j,k,one=1,bt,ct;
---
> {
> 	int n_2dCols, i, j, k, one = 1, bt, ct;
1590c2054,2055
<     for (j=0;j<*r;j++) Skb[j] *= -sp[i]; 
---
> 		for (j = 0; j < *r; j++)
> 			Skb[j] *= -sp[i];
1595c2060,2062
<   bt=0;ct=0;mgcv_mmult(eta1,X,b1,&bt,&ct,n,M,r); /* first deriv of eta */
---
> 	bt = 0;
> 	ct = 0;
> 	mgcv_mmult(eta1, X, b1, &bt, &ct, n, M, r); /* first deriv of eta */
1599,1602c2066,2074
<     for (i=0;i<*M;i++) for (k=i;k<*M;k++) { 
<       p0 = eta1 + *n * i;p1 = eta1 + *n * k;
<       for (j=0;j<*n;j++,p0++,p1++) work[j] = - *p0 * *p1 * dwdeta[j];
<       bt=1;ct=0;mgcv_mmult(Skb,X,work,&bt,&ct,r,&one,n); /* X'f */
---
> 		for (i = 0; i < *M; i++)
> 			for (k = i; k < *M; k++) {
> 				p0 = eta1 + *n * i;
> 				p1 = eta1 + *n * k;
> 				for (j = 0; j < *n; j++, p0++, p1++)
> 					work[j] = -*p0 * *p1 * dwdeta[j];
> 				bt = 1;
> 				ct = 0;
> 				mgcv_mmult(Skb, X, work, &bt, &ct, r, &one, n); /* X'f */
1604c2076,2077
<       for (j=0;j<*r;j++) Skb[j] += -sp[i]*work[j];
---
> 				for (j = 0; j < *r; j++)
> 					Skb[j] += -sp[i] * work[j];
1606c2079,2080
<       for (j=0;j<*r;j++) Skb[j] += -sp[k]*work[j];
---
> 				for (j = 0; j < *r; j++)
> 					Skb[j] += -sp[k] * work[j];
1609c2083,2085
<       if (i==k) for (j=0;j< *r;j++) pp[j] += b1[i * *r + j];
---
> 				if (i == k)
> 					for (j = 0; j < *r; j++)
> 						pp[j] += b1[i * *r + j];
1613c2089,2091
<     bt=0;ct=0;mgcv_mmult(eta2,X,b2,&bt,&ct,n,&n_2dCols,r); /* second derivatives of eta */
---
> 		bt = 0;
> 		ct = 0;
> 		mgcv_mmult(eta2, X, b2, &bt, &ct, n, &n_2dCols, r); /* second derivatives of eta */
1616c2094,2096
<   FREE(work);FREE(Skb);FREE(work1);
---
> 	FREE(work);
> 	FREE(Skb);
> 	FREE(work1);
1619,1622c2099,2103
< void ift2(double *R,double *Vt,double *X,double *rS,double *beta,double *sp,double *theta,
<           double *Det_th,double *Det2_th,double *Det3,double *Det_th2,double *b1, double *b2,
<           double *eta1,double *eta2,
< 	  int *n,int *r, int *M,int *n_theta,int *rSncol,int *deriv2,int *neg_w,int *nr)
---
> void ift2(double *R, double *Vt, double *X, double *rS, double *beta,
> 		double *sp, double *theta, double *Det_th, double *Det2_th,
> 		double *Det3, double *Det_th2, double *b1, double *b2, double *eta1,
> 		double *eta2, int *n, int *r, int *M, int *n_theta, int *rSncol,
> 		int *deriv2, int *neg_w, int *nr)
1637c2118,2119
< { int n_2dCols,i,j,k,one=1,bt,ct,ntot,kk;
---
> {
> 	int n_2dCols, i, j, k, one = 1, bt, ct, ntot, kk;
1648,1649c2130,2134
<       bt=1;ct=0;mgcv_mmult(Db_th,X,Det_th + i * *n,&bt,&ct,r,&one,n);
<       for (j=0;j<*r;j++) Db_th[j] *= -.5;
---
> 			bt = 1;
> 			ct = 0;
> 			mgcv_mmult(Db_th, X, Det_th + i * *n, &bt, &ct, r, &one, n);
> 			for (j = 0; j < *r; j++)
> 				Db_th[j] *= -.5;
1652c2137,2138
<       for (j=0;j<*r;j++) Db_th[j] *=  - sp[i - *n_theta];
---
> 			for (j = 0; j < *r; j++)
> 				Db_th[j] *= -sp[i - *n_theta];
1660c2146,2148
<   bt=0;ct=0;mgcv_mmult(eta1,X,b1,&bt,&ct,n,&ntot,r); /* first deriv of eta */
---
> 	bt = 0;
> 	ct = 0;
> 	mgcv_mmult(eta1, X, b1, &bt, &ct, n, &ntot, r); /* first deriv of eta */
1665c2153,2154
<     for (i=0;i<ntot;i++) for (k=i;k<ntot;k++) { 
---
> 		for (i = 0; i < ntot; i++)
> 			for (k = i; k < ntot; k++) {
1667,1669c2156,2162
<       p0 = eta1 + *n * i;p1 = eta1 + *n * k; 
<       for (j=0;j<*n;j++,p0++,p1++) work[j] = - *p0 * *p1 * Det3[j];
<       bt=1;ct=0;mgcv_mmult(Db_th,X,work,&bt,&ct,r,&one,n); /* D_bbb^lpq db_q/dtheta_j db_p/dtheta_k */
---
> 				p0 = eta1 + *n * i;
> 				p1 = eta1 + *n * k;
> 				for (j = 0; j < *n; j++, p0++, p1++)
> 					work[j] = -*p0 * *p1 * Det3[j];
> 				bt = 1;
> 				ct = 0;
> 				mgcv_mmult(Db_th, X, work, &bt, &ct, r, &one, n); /* D_bbb^lpq db_q/dtheta_j db_p/dtheta_k */
1674,1675c2167,2171
<         for (j=0;j<*n;j++,p0++,p1++) work[j] = *p0 * *p1 ;
<         bt=1;ct=0;mgcv_mmult(work1,X,work,&bt,&ct,r,&one,n); 
---
> 					for (j = 0; j < *n; j++, p0++, p1++)
> 						work[j] = *p0 * *p1;
> 					bt = 1;
> 					ct = 0;
> 					mgcv_mmult(work1, X, work, &bt, &ct, r, &one, n);
1677,1678c2173,2176
<         multSk(work1,b1+ i * *r,&one,k - *n_theta,rS,rSncol,r,work);
<         for (j=0;j<*r;j++) work1[j] *=  sp[k - *n_theta] * 2; 
---
> 					multSk(work1, b1 + i * *r, &one, k - *n_theta, rS, rSncol,
> 							r, work);
> 					for (j = 0; j < *r; j++)
> 						work1[j] *= sp[k - *n_theta] * 2;
1680c2178,2179
<       for (j=0;j<*r;j++) Db_th[j] -=  work1[j];
---
> 				for (j = 0; j < *r; j++)
> 					Db_th[j] -= work1[j];
1686,1687c2185,2189
<         for (j=0;j<*n;j++,p0++,p1++) work[j] = *p0 * *p1 ;
<         bt=1;ct=0;mgcv_mmult(work1,X,work,&bt,&ct,r,&one,n); 
---
> 					for (j = 0; j < *n; j++, p0++, p1++)
> 						work[j] = *p0 * *p1;
> 					bt = 1;
> 					ct = 0;
> 					mgcv_mmult(work1, X, work, &bt, &ct, r, &one, n);
1689,1690c2191,2194
<         multSk(work1,b1+ k * *r,&one,i - *n_theta,rS,rSncol,r,work);
<         for (j=0;j<*r;j++) work1[j] *=  sp[i - *n_theta] * 2; 
---
> 					multSk(work1, b1 + k * *r, &one, i - *n_theta, rS, rSncol,
> 							r, work);
> 					for (j = 0; j < *r; j++)
> 						work1[j] *= sp[i - *n_theta] * 2;
1692c2196,2197
<       for (j=0;j<*r;j++) Db_th[j] -=  work1[j];
---
> 				for (j = 0; j < *r; j++)
> 					Db_th[j] -= work1[j];
1696,1697c2201,2206
<         bt=1;ct=0;mgcv_mmult(work,X,p0,&bt,&ct,r,&one,n);
<         for (j=0;j<*r;j++) Db_th[j] -=  work[j];kk++;
---
> 					bt = 1;
> 					ct = 0;
> 					mgcv_mmult(work, X, p0, &bt, &ct, r, &one, n);
> 					for (j = 0; j < *r; j++)
> 						Db_th[j] -= work[j];
> 					kk++;
1699,1700c2208,2211
<         multSk(work1,beta,&one,i - *n_theta,rS,rSncol,r,work); /* get S_i \beta */
<         for (j=0;j<*r;j++) Db_th[j] -= work1[j] * sp[i - *n_theta] *2 ;
---
> 					multSk(work1, beta, &one, i - *n_theta, rS, rSncol, r,
> 							work); /* get S_i \beta */
> 					for (j = 0; j < *r; j++)
> 						Db_th[j] -= work1[j] * sp[i - *n_theta] * 2;
1702c2213,2214
<       for (j=0;j<*r;j++) Db_th[j] *= .5; /* since PPt is twice inv Hessian */
---
> 				for (j = 0; j < *r; j++)
> 					Db_th[j] *= .5; /* since PPt is twice inv Hessian */
1707c2219,2221
<     bt=0;ct=0;mgcv_mmult(eta2,X,b2,&bt,&ct,n,&n_2dCols,r); /* second derivatives of eta */
---
> 		bt = 0;
> 		ct = 0;
> 		mgcv_mmult(eta2, X, b2, &bt, &ct, n, &n_2dCols, r); /* second derivatives of eta */
1710c2224,2226
<   FREE(work);FREE(Db_th);FREE(work1);
---
> 	FREE(work);
> 	FREE(Db_th);
> 	FREE(work1);
1720c2233,2234
< { int k,j,j0,j1;  
---
> {
> 	int k, j, j0, j1;
1722c2236,2237
<   if (n_drop<=0) return;
---
> 	if (n_drop <= 0)
> 		return;
1727,1728c2242,2248
<       if (k<n_drop-1) j1 = drop[k+1]; else j1 = c; /* end of block to copy */
<       for (p=X + j * r,p1=X + j0 * r,p2=X + j1 * r;p1<p2;p++,p1++) *p = *p1;
---
> 			if (k < n_drop - 1)
> 				j1 = drop[k + 1];
> 			else
> 				j1 = c; /* end of block to copy */
> 			for (p = X + j * r, p1 = X + j0 * r, p2 = X + j1 * r; p1 < p2;
> 					p++, p1++)
> 				*p = *p1;
1736c2256,2257
< { int i,j,k;
---
> {
> 	int i, j, k;
1738c2259,2260
<   if (n_drop<=0) return;
---
> 	if (n_drop <= 0)
> 		return;
1741c2263,2264
<     for (i=0;i<drop[0];i++,X++,Xs++) *X = *Xs;  
---
> 		for (i = 0; i < drop[0]; i++, X++, Xs++)
> 			*X = *Xs;
1744c2267,2268
<       for (i=drop[k-1]+1;i<drop[k];i++,X++,Xs++) *X = *Xs;
---
> 			for (i = drop[k - 1] + 1; i < drop[k]; i++, X++, Xs++)
> 				*X = *Xs;
1747c2271,2272
<     for (i=drop[n_drop-1]+1;i<r;i++,X++,Xs++) *X = *Xs;  
---
> 		for (i = drop[n_drop - 1] + 1; i < r; i++, X++, Xs++)
> 			*X = *Xs;
1762c2286,2287
< { double *Xs;
---
> {
> 	double *Xs;
1764c2289,2290
<   if (n_drop <= 0) return;
---
> 	if (n_drop <= 0)
> 		return;
1768,1769c2294,2297
<     for (i=r-1;i>drop[n_drop-1];i--,X--,Xs--) *X = *Xs;
<     *X = 0.0;X--;
---
> 		for (i = r - 1; i > drop[n_drop - 1]; i--, X--, Xs--)
> 			*X = *Xs;
> 		*X = 0.0;
> 		X--;
1771,1772c2299,2302
<       for (i=drop[k]-1;i>drop[k-1];i--,X--,Xs--) *X = *Xs;
<       *X = 0.0;X--;
---
> 			for (i = drop[k] - 1; i > drop[k - 1]; i--, X--, Xs--)
> 				*X = *Xs;
> 			*X = 0.0;
> 			X--;
1774c2304,2305
<     for (i=drop[0]-1;i>=0;i--,X--,Xs--) *X = *Xs;
---
> 		for (i = drop[0] - 1; i >= 0; i--, X--, Xs--)
> 			*X = *Xs;
1778,1784c2309,2312
< 
< 
< 
< double MLpenalty1(double *det1,double *det2,double *Tk,double *Tkm,double *nulli, double *X,
< double *R,double *Q, int *nind,double *sp,double *rS,int *rSncol,int *q,int *n,
< 		  int *Ms,int *M,int *M0,int *neg_w,double *rank_tol,int *deriv,
<                   int *nthreads,int *type) {
---
> double MLpenalty1(double *det1, double *det2, double *Tk, double *Tkm,
> 		double *nulli, double *X, double *R, double *Q, int *nind, double *sp,
> 		double *rS, int *rSncol, int *q, int *n, int *Ms, int *M, int *M0,
> 		int *neg_w, double *rank_tol, int *deriv, int *nthreads, int *type) {
1805,1807c2333,2336
<   double *RU1,*tau,*work,*Ri,*Qb=NULL,*K,*P,*IQ,*IQQ,*Vt,*XU1=NULL,
<          *d,*p0,*p1,*p2,*p3,ldetXWXS,ldetI2D=0.0;
<   int ScS,bt,ct,qM,*pivot,i,j,k,left,tp,n_drop=0,*drop,FALSE=0; 
---
> 	double *RU1, *tau, *work, *Ri, *Qb = NULL, *K, *P, *IQ, *IQQ, *Vt, *XU1 =
> 			NULL, *d, *p0, *p1, *p2, *p3, ldetXWXS, ldetI2D = 0.0;
> 	int ScS, bt, ct, qM, *pivot, i, j, k, left, tp, n_drop = 0, *drop,
> 			FALSE = 0;
1810c2339,2343
<   for (i=0;i < *q;i++) if (nulli[i]>0.0) { drop[n_drop] = i;n_drop++; }
---
> 	for (i = 0; i < *q; i++)
> 		if (nulli[i] > 0.0) {
> 			drop[n_drop] = i;
> 			n_drop++;
> 		}
1812c2345,2346
<   for (ScS=0.0,i=0;i<*M;i++) ScS += rSncol[i]; /* total columns of rS */
---
> 	for (ScS = 0.0, i = 0; i < *M; i++)
> 		ScS += rSncol[i]; /* total columns of rS */
1817c2351,2352
<   for (p1=RU1,p2=R,p3=R+ *q * *q;p2 < p3;p1++,p2++) *p1 = *p2;
---
> 	for (p1 = RU1, p2 = R, p3 = R + *q * *q; p2 < p3; p1++, p2++)
> 		*p1 = *p2;
1835,1836c2370,2374
<     for (i=0;i< qM;i++) Qb[i * *q + i] = 1.0;
<     left=1;tp=0;mgcv_qrqy(Qb,RU1,tau,q,&qM,&qM,&left,&tp); /* Q from the QR decomposition */
---
> 		for (i = 0; i < qM; i++)
> 			Qb[i * *q + i] = 1.0;
> 		left = 1;
> 		tp = 0;
> 		mgcv_qrqy(Qb, RU1, tau, q, &qM, &qM, &left, &tp); /* Q from the QR decomposition */
1839c2377,2378
<     for (p1=XU1,p2=X,p3=X + *n * *q;p2 < p3;p1++,p2++) *p1 = *p2;
---
> 		for (p1 = XU1, p2 = X, p3 = X + *n * *q; p2 < p3; p1++, p2++)
> 			*p1 = *p2;
1848c2387,2390
<     if (*neg_w < *q+1) k = *q+1; else k = *neg_w;
---
> 		if (*neg_w < *q + 1)
> 			k = *q + 1;
> 		else
> 			k = *neg_w;
1851,1852c2393,2396
<       p0 = IQ + i;p1 = Q + nind[i];
<       for (j=0;j<*q;j++,p0+=k,p1+= *n) *p0 = *p1;
---
> 			p0 = IQ + i;
> 			p1 = Q + nind[i];
> 			for (j = 0; j < *q; j++, p0 += k, p1 += *n)
> 				*p0 = *p1;
1856c2400,2402
<     bt=0;ct=0;mgcv_mmult(IQQ,IQ,Qb,&bt,&ct,&k,&qM,q); /* I^-Q_1 \bar Q is k by rank */
---
> 		bt = 0;
> 		ct = 0;
> 		mgcv_mmult(IQQ, IQ, Qb, &bt, &ct, &k, &qM, q); /* I^-Q_1 \bar Q is k by rank */
1866c2412,2413
<       if (d[i]<=0) d[i]=0.0; 
---
> 			if (d[i] <= 0)
> 				d[i] = 0.0;
1874c2421,2422
<     for (p1=d,p2=d+qM;p1<p2;p1++,p0++) *p0 *= *p1;
---
> 			for (p1 = d, p2 = d + qM; p1 < p2; p1++, p0++)
> 				*p0 *= *p1;
1877c2425,2427
<     bt=0;ct=1;mgcv_mmult(P,Ri,Vt,&bt,&ct,&qM,&qM,&qM);
---
> 		bt = 0;
> 		ct = 1;
> 		mgcv_mmult(P, Ri, Vt, &bt, &ct, &qM, &qM, &qM);
1881c2431,2433
<       bt=0;ct=0;mgcv_mmult(K,XU1,P,&bt,&ct,n,&qM,&qM); 
---
> 			bt = 0;
> 			ct = 0;
> 			mgcv_mmult(K, XU1, P, &bt, &ct, n, &qM, &qM);
1884c2436,2438
<       bt=0;ct=1;mgcv_mmult(work,Qb,Vt,&bt,&ct,q,&qM,&qM); /* \bar Q V (I - 2D^2)^.5 */
---
> 			bt = 0;
> 			ct = 1;
> 			mgcv_mmult(work, Qb, Vt, &bt, &ct, q, &qM, &qM); /* \bar Q V (I - 2D^2)^.5 */
1886c2440,2442
<       bt=0;ct=0;mgcv_mmult(K,Q,work,&bt,&ct,n,&qM,q);
---
> 			bt = 0;
> 			ct = 0;
> 			mgcv_mmult(K, Q, work, &bt, &ct, n, &qM, q);
1889c2445,2446
<     FREE(d);FREE(Vt);   
---
> 		FREE(d);
> 		FREE(Vt);
1894c2451,2452
<     for (p0=P,p1=Ri,p2=Ri+ qM * qM;p1<p2;p0++,p1++) *p0 = *p1; /* copy R^{-1} into P */
---
> 		for (p0 = P, p1 = Ri, p2 = Ri + qM * qM; p1 < p2; p0++, p1++)
> 			*p0 = *p1; /* copy R^{-1} into P */
1897c2455,2457
<       bt=0;ct=0;mgcv_mmult(K,XU1,P,&bt,&ct,n,&qM,&qM);
---
> 			bt = 0;
> 			ct = 0;
> 			mgcv_mmult(K, XU1, P, &bt, &ct, n, &qM, &qM);
1899c2459,2461
<       bt=0;ct=0;mgcv_mmult(K,Q,Qb,&bt,&ct,n,&qM,q);
---
> 			bt = 0;
> 			ct = 0;
> 			mgcv_mmult(K, Q, Qb, &bt, &ct, n, &qM, q);
1907c2469,2470
<   for (ldetXWXS=0.0,i=0;i<qM;i++) ldetXWXS += log(fabs(RU1[i + i * *q])); 
---
> 	for (ldetXWXS = 0.0, i = 0; i < qM; i++)
> 		ldetXWXS += log(fabs(RU1[i + i * *q]));
1919c2482,2485
<   if (*type==0||*neg_w) FREE(Qb); else FREE(XU1);
---
> 	if (*type == 0 || *neg_w)
> 		FREE(Qb);
> 	else
> 		FREE(XU1);
1925c2491,2492
<     get_ddetXWXpS(det1,det2,P,K,sp,rS,rSncol,Tk,Tkm,n,&qM,&qM,M,M0,deriv,*nthreads);
---
> 		get_ddetXWXpS(det1, det2, P, K, sp, rS, rSncol, Tk, Tkm, n, &qM, &qM, M,
> 				M0, deriv, *nthreads);
1927c2494,2496
<   FREE(P);FREE(K);FREE(drop);
---
> 	FREE(P);
> 	FREE(K);
> 	FREE(drop);
1938,1944c2506,2511
< 
< 
< void gdiPK(double *work,double *X,double *E,double *Es,double *rS,double *U1,double *z,double *raw,double *R,
<            double *nulli,double *dev_hess,double *P, double *K,double *Vt,double *PKtz,double *Q1,
<            int *nind,int *pivot1,int *drop,
<            int *n,int *q,int *Mp,int neg_w, int *nt,int *Enrow,int *rank,int *n_drop,int deriv2,int ScS, int *REML,
<       double *rank_tol,double *ldetXWXS,int *type)
---
> void gdiPK(double *work, double *X, double *E, double *Es, double *rS,
> 		double *U1, double *z, double *raw, double *R, double *nulli,
> 		double *dev_hess, double *P, double *K, double *Vt, double *PKtz,
> 		double *Q1, int *nind, int *pivot1, int *drop, int *n, int *q, int *Mp,
> 		int neg_w, int *nt, int *Enrow, int *rank, int *n_drop, int deriv2,
> 		int ScS, int *REML, double *rank_tol, double *ldetXWXS, int *type)
1949,1950c2516,2520
< { int i,j,k,*pivot,nt1,nr,left,tp,bt,ct,TRUE=1,FALSE=0,one=1;
<   double *zz=NULL,*WX,*tau,*R1,Rnorm,Enorm,Rcond,*Q=NULL,*tau1,*Ri,ldetI2D,*IQ,*d,*p0,*p1,*p2,*p3,*p4,xx,norm1,norm2;
---
> {
> 	int i, j, k, *pivot, nt1, nr, left, tp, bt, ct, TRUE = 1, FALSE = 0,
> 			one = 1;
> 	double *zz = NULL, *WX, *tau, *R1, Rnorm, Enorm, Rcond, *Q = NULL, *tau1,
> 			*Ri, ldetI2D, *IQ, *d, *p0, *p1, *p2, *p3, *p4, xx, norm1, norm2;
1958c2528,2531
<     for (i=0;i<neg_w;i++) { k=nind[i]; zz[k] = -zz[k];} 
---
> 		for (i = 0; i < neg_w; i++) {
> 			k = nind[i];
> 			zz[k] = -zz[k];
> 		}
1962,1964c2535,2538
<   for (j=0;j<*q;j++) 
<   { for (i=0;i<*n;i++) /* form WX */
<     { k = i + *n * j;
---
> 	for (j = 0; j < *q; j++) {
> 		for (i = 0; i < *n; i++) /* form WX */
> 		{
> 			k = i + *n * j;
1990,1991c2564,2567
<     for (i=0;i< *q;i++) R[i + nr * j] = R1[i + *q * j]/Rnorm;
<     for (i=0;i< *Enrow;i++) R[i + *q + nr * j] = Es[i + *Enrow * j]/Enorm;
---
> 		for (i = 0; i < *q; i++)
> 			R[i + nr * j] = R1[i + *q * j] / Rnorm;
> 		for (i = 0; i < *Enrow; i++)
> 			R[i + *q + nr * j] = Es[i + *Enrow * j] / Enorm;
2003c2579,2582
<   while (*rank_tol * Rcond > 1) { (*rank)--;R_cond(R,&nr,rank,work,&Rcond);}
---
> 	while (*rank_tol * Rcond > 1) {
> 		(*rank)--;
> 		R_cond(R, &nr, rank, work, &Rcond);
> 	}
2010,2012c2589,2592
< 
<   for (i=0;i<*q - *Mp;i++) nulli[i] = -1.0;    /* parameter in penalty range space */
<   for (i= *q - *Mp;i < *q;i++) nulli[i] = 1.0; /* parameter in penalty null space */ 
---
> 	for (i = 0; i < *q - *Mp; i++)
> 		nulli[i] = -1.0; /* parameter in penalty range space */
> 	for (i = *q - *Mp; i < *q; i++)
> 		nulli[i] = 1.0; /* parameter in penalty null space */
2015c2595,2596
<     for (i=0;i < *n_drop;i++) drop[i] = pivot1[*rank+i];
---
> 		for (i = 0; i < *n_drop; i++)
> 			drop[i] = pivot1[*rank + i];
2031,2032c2611,2614
<     for (i=0;i< *q;i++) R[i + nr * j] = R1[i + *q * j];
<       for (i=0;i< *Enrow;i++) R[i + *q + nr * j] = E[i + *Enrow * j];
---
> 		for (i = 0; i < *q; i++)
> 			R[i + nr * j] = R1[i + *q * j];
> 		for (i = 0; i < *Enrow; i++)
> 			R[i + *q + nr * j] = E[i + *Enrow * j];
2037c2619,2620
<   i=1;pivoter(nulli,rank,&i,pivot1,&FALSE,&FALSE); /* pivoting the rows of nulli */
---
> 	i = 1;
> 	pivoter(nulli, rank, &i, pivot1, &FALSE, &FALSE); /* pivoting the rows of nulli */
2048,2049c2631,2635
<     for (i=0;i < *rank;i++) Q[i * nr + i] = 1.0;
<     left=1;tp=0;mgcv_qrqy(Q,R,tau1,&nr,rank,rank,&left,&tp); /* Q from the second QR decomposition */
---
> 		for (i = 0; i < *rank; i++)
> 			Q[i * nr + i] = 1.0;
> 		left = 1;
> 		tp = 0;
> 		mgcv_qrqy(Q, R, tau1, &nr, rank, rank, &left, &tp); /* Q from the second QR decomposition */
2052,2053c2638,2642
<     for (i=0;i<*q;i++) for (j=0;j < *rank;j++) Q1[i + *q * j] = Q[i + nr * j];
<     tp=0;mgcv_pqrqy(Q1,WX,tau,n,q,rank,&tp,&nt1);
---
> 		for (i = 0; i < *q; i++)
> 			for (j = 0; j < *rank; j++)
> 				Q1[i + *q * j] = Q[i + nr * j];
> 		tp = 0;
> 		mgcv_pqrqy(Q1, WX, tau, n, q, rank, &tp, &nt1);
2063c2651,2654
<     if (neg_w < *rank + 1) k = *rank + 1; else k = neg_w;
---
> 		if (neg_w < *rank + 1)
> 			k = *rank + 1;
> 		else
> 			k = neg_w;
2066,2067c2657,2660
<       p0 = IQ + i;p1 = Q1 + nind[i];
<       for (j=0;j < *rank;j++,p0+=k,p1+= *n) *p0 = *p1;
---
> 			p0 = IQ + i;
> 			p1 = Q1 + nind[i];
> 			for (j = 0; j < *rank; j++, p0 += k, p1 += *n)
> 				*p0 = *p1;
2080c2673,2674
<         for (p2=Vt,p3=p1,p4=p1 + *rank;p3<p4;p3++,p2++) *p3 = *p2 * *p0;
---
> 				for (p2 = Vt, p3 = p1, p4 = p1 + *rank; p3 < p4; p3++, p2++)
> 					*p3 = *p2 * *p0;
2083c2677,2678
< 	  for (p3=p1;p3<p4;p3++,p2++) *p3 += *p2 * *p0;
---
> 					for (p3 = p1; p3 < p4; p3++, p2++)
> 						*p3 += *p2 * *p0;
2086c2681,2683
<       for (p0=P,j=0;j < *rank;j++) for (p1=d,p2=d + *rank;p1<p2;p1++,p0++) *p0 *= *p1; 
---
> 			for (p0 = P, j = 0; j < *rank; j++)
> 				for (p1 = d, p2 = d + *rank; p1 < p2; p1++, p0++)
> 					*p0 *= *p1;
2089c2686,2688
<       for (p0=dev_hess,p1=p0+ *rank * *rank,p2=K;p0<p1;p0++,p2++) *p0 += -2 * *p2;
---
> 			for (p0 = dev_hess, p1 = p0 + *rank * *rank, p2 = K; p0 < p1;
> 					p0++, p2++)
> 				*p0 += -2 * *p2;
2094c2693,2694
<       if (d[i]<=0) d[i]=0.0; 
---
> 			if (d[i] <= 0)
> 				d[i] = 0.0;
2102c2702,2703
<     for (p1=d,p2=d + *rank;p1<p2;p1++,p0++) *p0 *= *p1;
---
> 			for (p1 = d, p2 = d + *rank; p1 < p2; p1++, p0++)
> 				*p0 *= *p1;
2105c2706,2708
<     bt=0;ct=1;mgcv_pmmult(P,Ri,Vt,&bt,&ct,rank,rank,rank,nt);
---
> 		bt = 0;
> 		ct = 1;
> 		mgcv_pmmult(P, Ri, Vt, &bt, &ct, rank, rank, rank, nt);
2108c2711,2712
<     if (*type==0) mgcv_pmmult(K,Q1,Vt,&bt,&ct,n,rank,rank,nt);
---
> 		if (*type == 0)
> 			mgcv_pmmult(K, Q1, Vt, &bt, &ct, n, rank, rank, nt);
2114c2718,2719
<       for (p2 = p1,p3=p1 + *n;p2<p3;p0++,p2++) *p0 = *p2;
---
> 				for (p2 = p1, p3 = p1 + *n; p2 < p3; p0++, p2++)
> 					*p0 = *p2;
2118c2723,2724
<     for (p2=p0,p3=p0 + *rank;p2<p3;p1++,p2++) *p2 = *p1;  
---
> 			for (p2 = p0, p3 = p0 + *rank; p2 < p3; p1++, p2++)
> 				*p2 = *p1;
2124c2730,2731
<     for (*ldetXWXS=0.0,i=0;i < *rank;i++) *ldetXWXS += log(fabs(R[i + i * nr])); 
---
> 		for (*ldetXWXS = 0.0, i = 0; i < *rank; i++)
> 			*ldetXWXS += log(fabs(R[i + i * nr]));
2145c2751,2753
<     bt=1;ct=0;mgcv_mmult(work,K,zz,&bt,&ct,rank,&one,n); /* K'z */ 
---
> 		bt = 1;
> 		ct = 0;
> 		mgcv_mmult(work, K, zz, &bt, &ct, rank, &one, n); /* K'z */
2150c2758,2760
<     bt=1;ct=0;mgcv_mmult(work,K,z,&bt,&ct,rank,&one,n); /* K'Wz */
---
> 		bt = 1;
> 		ct = 0;
> 		mgcv_mmult(work, K, z, &bt, &ct, rank, &one, n); /* K'Wz */
2154,2156c2764,2772
<     for (i=0;i<*n;i++) zz[i] = raw[i] * raw[i] * z[i]; 
<     for (i=0;i<neg_w;i++) { k=nind[i]; zz[k] = -zz[k];} 
<     bt=1;ct=0;mgcv_mmult(work + *q,X,zz,&bt,&ct,rank,&one,n); /* X'Wz */
---
> 		for (i = 0; i < *n; i++)
> 			zz[i] = raw[i] * raw[i] * z[i];
> 		for (i = 0; i < neg_w; i++) {
> 			k = nind[i];
> 			zz[k] = -zz[k];
> 		}
> 		bt = 1;
> 		ct = 0;
> 		mgcv_mmult(work + *q, X, zz, &bt, &ct, rank, &one, n); /* X'Wz */
2159c2775,2776
<       for (xx=0,j=0;j<=i;j++) xx += R[j + nr * i] * work[*q * 2 + j];
---
> 			for (xx = 0, j = 0; j <= i; j++)
> 				xx += R[j + nr * i] * work[*q * 2 + j];
2161c2778,2779
<       norm1 += xx*xx; norm2 += work[i + *q] * work[i + *q];   
---
> 			norm1 += xx * xx;
> 			norm2 += work[i + *q] * work[i + *q];
2167c2785,2786
<     } else applyP(PKtz,work,R,Vt,neg_w,nr,*rank,1,0);
---
> 		} else
> 			applyP(PKtz, work, R, Vt, neg_w, nr, *rank, 1, 0);
2170c2789,2792
<   FREE(WX);FREE(tau);FREE(Ri);FREE(R1); 
---
> 	FREE(WX);
> 	FREE(tau);
> 	FREE(Ri);
> 	FREE(R1);
2172c2794,2795
<   if (neg_w || *type==0) FREE(Q); 
---
> 	if (neg_w || *type == 0)
> 		FREE(Q);
2174c2797,2798
<   if (*type==0) FREE(zz);
---
> 	if (*type == 0)
> 		FREE(zz);
2177,2180c2801,2802
< 
< 
< void gdi2(double *X,double *E,double *Es,double *rS,double *U1,
< 	  double *sp,double *theta,double *z,double *w,double *wz,double *wf,
---
> void gdi2(double *X, double *E, double *Es, double *rS, double *U1, double *sp,
> 		double *theta, double *z, double *w, double *wz, double *wf,
2182,2184c2804,2805
<           double *Det2_th,double *Det3,double *Det_th2,
<           double *Det4, double *Det3_th, double *Det2_th2,
<           double *beta,double *b1,double *w1,
---
> 		double *Det2_th, double *Det3, double *Det_th2, double *Det4,
> 		double *Det3_th, double *Det2_th2, double *beta, double *b1, double *w1,
2187,2189c2808,2810
<           double *rank_tol,int *rank_est,
< 	  int *n,int *q, int *M,int *n_theta, int *Mp,int *Enrow,int *rSncol,int *deriv,
< 	  int *fixed_penalty,int *nt,int *type)     
---
> 		double *rank_tol, int *rank_est, int *n, int *q, int *M, int *n_theta,
> 		int *Mp, int *Enrow, int *rSncol, int *deriv, int *fixed_penalty,
> 		int *nt, int *type)
2276,2282c2897,2904
< { double *work,*p0,*p1,*p2,*p3,*p4,*p5,*p6,*p7,*K=NULL,
<     *Vt,*b2=NULL,*P,xx=0.0,*eta1=NULL,*eta2=NULL,
<     *PKtz,*wi=NULL,*w2=NULL,*Tk=NULL,*Tkm=NULL,
<     *dev_hess=NULL,*R,*raw,*Q1,*Q,*nulli,*WX,*tau,*R1;
<   int i,j,k,*pivot1,ScS,*pi,rank,*pivot,
<     ntot,n_2dCols=0,n_drop,*drop,tp,
<     n_work,deriv2,neg_w=0,*nind,nr,TRUE=1,FALSE=0,ML=0; 
---
> {
> 	double *work, *p0, *p1, *p2, *p3, *p4, *p5, *p6, *p7, *K = NULL, *Vt, *b2 =
> 			NULL, *P, xx = 0.0, *eta1 = NULL, *eta2 = NULL, *PKtz, *wi = NULL,
> 			*w2 = NULL, *Tk = NULL, *Tkm = NULL, *dev_hess = NULL, *R, *raw,
> 			*Q1, *Q, *nulli, *WX, *tau, *R1;
> 	int i, j, k, *pivot1, ScS, *pi, rank, *pivot, ntot, n_2dCols = 0, n_drop,
> 			*drop, tp, n_work, deriv2, neg_w = 0, *nind, nr, TRUE = 1,
> 			FALSE = 0, ML = 0;
2293,2295c2915,2916
<   if (*ldet<0) ML=1; /* require ML not REML */ 
< 
<   if (*deriv==2) deriv2=1; else deriv2=0;
---
> 	if (*ldet < 0)
> 		ML = 1; /* require ML not REML */
2297c2918,2925
<   ScS=0;for (pi=rSncol;pi<rSncol + *M;pi++) ScS+= *pi;  /* total columns of input rS */
---
> 	if (*deriv == 2)
> 		deriv2 = 1;
> 	else
> 		deriv2 = 0;
> 
> 	ScS = 0;
> 	for (pi = rSncol; pi < rSncol + *M; pi++)
> 		ScS += *pi; /* total columns of input rS */
2307c2935,2937
<   k = 5 * *q; if (n_work < k) n_work = k;
---
> 	k = 5 * *q;
> 	if (n_work < k)
> 		n_work = k;
2309c2939,2940
<   if (n_work < k) n_work = k;
---
> 	if (n_work < k)
> 		n_work = k;
2314c2945,2948
<   if (deriv2) dev_hess = (double *)CALLOC((size_t) *q * *q,sizeof(double)); else dev_hess=NULL;
---
> 	if (deriv2)
> 		dev_hess = (double *) CALLOC((size_t) *q * *q, sizeof(double));
> 	else
> 		dev_hess = NULL;
2320,2322c2954,2961
<     if (w[i]<0) { neg_w++;raw[i] = sqrt(-w[i]);} 
<     else if (w[i]>0) raw[i] = sqrt(w[i]);
<     else { *type=1; } /* zero weights so we have to use type 1 method */
---
> 		if (w[i] < 0) {
> 			neg_w++;
> 			raw[i] = sqrt(-w[i]);
> 		} else if (w[i] > 0)
> 			raw[i] = sqrt(w[i]);
> 		else {
> 			*type = 1;
> 		} /* zero weights so we have to use type 1 method */
2327,2328c2966,2975
<     k=0;for (i=0;i< *n;i++) if (w[i]<0) { nind[k]=i;k++;}
<   } else { nind = (int *)NULL; Vt = (double *)NULL;}
---
> 		k = 0;
> 		for (i = 0; i < *n; i++)
> 			if (w[i] < 0) {
> 				nind[k] = i;
> 				k++;
> 			}
> 	} else {
> 		nind = (int *) NULL;
> 		Vt = (double *) NULL;
> 	}
2331c2978,2979
<   if (*type==1) z=wz; /* need to pass wz to gdiPK */ 
---
> 	if (*type == 1)
> 		z = wz; /* need to pass wz to gdiPK */
2333,2339c2981,2983
<   gdiPK(work,X,E,Es,rS,U1,z,raw,
<         R,nulli,dev_hess,P,K,Vt,PKtz,Q1,
<         nind,pivot1,drop,
<         n,q,Mp,neg_w,nt,Enrow,
<         &rank,&n_drop,
<         deriv2,ScS,&TRUE,
<       rank_tol,ldet,type);
---
> 	gdiPK(work, X, E, Es, rS, U1, z, raw, R, nulli, dev_hess, P, K, Vt, PKtz,
> 			Q1, nind, pivot1, drop, n, q, Mp, neg_w, nt, Enrow, &rank, &n_drop,
> 			deriv2, ScS, &TRUE, rank_tol, ldet, type);
2353,2356c2997,2999
<     ift2(R,Vt,X,rS,PKtz,sp,theta,
<           Det_th,Det2_th,Det3,Det_th2,
<           b1,b2,eta1,eta2,
<           n,&rank,M,n_theta,rSncol,&deriv2,&neg_w,&nr);
---
> 		ift2(R, Vt, X, rS, PKtz, sp, theta, Det_th, Det2_th, Det3, Det_th2, b1,
> 				b2, eta1, eta2, n, &rank, M, n_theta, rSncol, &deriv2, &neg_w,
> 				&nr);
2360c3003,3004
<       for (*p0=0.0,p2 = Det,p3=Det + *n;p2<p3;p2++,p1++,p4++) *p0 += *p1 * *p2 + *p4;
---
> 			for (*p0 = 0.0, p2 = Det, p3 = Det + *n; p2 < p3; p2++, p1++, p4++)
> 				*p0 += *p1 * *p2 + *p4;
2363c3007,3008
<       for (*p0=0.0,p2 = Det,p3=Det + *n;p2<p3;p2++,p1++) *p0 += *p1 * *p2;
---
> 			for (*p0 = 0.0, p2 = Det, p3 = Det + *n; p2 < p3; p2++, p1++)
> 				*p0 += *p1 * *p2;
2367,2371c3012,3022
<        p0 = eta2;p6 = Dth2;
<        for (i=0;i<ntot;i++) for (k=i;k<ntot;k++) {
<            p1 = eta1 + i * *n; p2 = eta1 + k * *n;
<            p3 = Det2; p4 = Det; p5 = Det + *n;
<            for (xx=0.0;p4<p5;p0++,p1++,p2++,p3++,p4++) xx +=  *p3 * *p1 * *p2 + *p4 * *p0;
---
> 			p0 = eta2;
> 			p6 = Dth2;
> 			for (i = 0; i < ntot; i++)
> 				for (k = i; k < ntot; k++) {
> 					p1 = eta1 + i * *n;
> 					p2 = eta1 + k * *n;
> 					p3 = Det2;
> 					p4 = Det;
> 					p5 = Det + *n;
> 					for (xx = 0.0; p4 < p5; p0++, p1++, p2++, p3++, p4++)
> 						xx += *p3 * *p1 * *p2 + *p4 * *p0;
2373c3024,3025
< 	      for (j=0;j<*n;j++,p6++) xx += *p6; 
---
> 						for (j = 0; j < *n; j++, p6++)
> 							xx += *p6;
2376c3028,3029
<              p1 = Det_th + *n * i;p2 = p1 + *n;
---
> 						p1 = Det_th + *n * i;
> 						p2 = p1 + *n;
2378c3031,3032
<              for (;p1<p2;p1++,p3++) xx += *p1 * *p3;
---
> 						for (; p1 < p2; p1++, p3++)
> 							xx += *p1 * *p3;
2381c3035,3036
<              p1 = Det_th + *n * k;p2 = p1 + *n;
---
> 						p1 = Det_th + *n * k;
> 						p2 = p1 + *n;
2383c3038,3039
<              for (;p1<p2;p1++,p3++) xx += *p1 * *p3;
---
> 						for (; p1 < p2; p1++, p3++)
> 							xx += *p1 * *p3;
2395c3051,3052
<     p3 = Det2_th;p4 = eta1;
---
> 		p3 = Det2_th;
> 		p4 = eta1;
2397c3054,3055
<       p1=Det3;p2 = p1 + *n;
---
> 			p1 = Det3;
> 			p2 = p1 + *n;
2399c3057,3058
< 	for (;p1<p2;p0++,p1++,p3++,p4++) *p0 = (*p1 * *p4 + *p3 ) * .5; 
---
> 				for (; p1 < p2; p0++, p1++, p3++, p4++)
> 					*p0 = (*p1 * *p4 + *p3) * .5;
2401c3060,3061
<         for (;p1<p2;p0++,p1++,p4++) *p0 = *p1 * *p4 * .5;
---
> 				for (; p1 < p2; p0++, p1++, p4++)
> 					*p0 = *p1 * *p4 * .5;
2406,2409c3066,3074
<       p1 = Det2_th2;p2 = eta2;
<       for (i=0;i<ntot;i++) for (k=i;k<ntot;k++) {
<       	p3 = Det3;p4 = Det4; 
<         p5 = eta1 + i * *n;p6 = eta1 + k * *n;p7 = p3 + *n;
---
> 			p1 = Det2_th2;
> 			p2 = eta2;
> 			for (i = 0; i < ntot; i++)
> 				for (k = i; k < ntot; k++) {
> 					p3 = Det3;
> 					p4 = Det4;
> 					p5 = eta1 + i * *n;
> 					p6 = eta1 + k * *n;
> 					p7 = p3 + *n;
2413,2415c3078,3083
<            p0 -= *n;p3 = Det3_th + i * *n;
<            p4 = eta1 + k * *n;p5 = p0 + *n;
<            for (;p0 < p5;p0++,p3++,p4++) *p0 += *p3 * *p4;
---
> 						p0 -= *n;
> 						p3 = Det3_th + i * *n;
> 						p4 = eta1 + k * *n;
> 						p5 = p0 + *n;
> 						for (; p0 < p5; p0++, p3++, p4++)
> 							*p0 += *p3 * *p4;
2418,2420c3086,3091
<            p0 -= *n;p3 = Det3_th + k * *n;
<            p4 = eta1 + i * *n;p5 = p0 + *n;
<            for (;p0 < p5;p0++,p3++,p4++) *p0 += *p3 * *p4;
---
> 						p0 -= *n;
> 						p3 = Det3_th + k * *n;
> 						p4 = eta1 + i * *n;
> 						p5 = p0 + *n;
> 						for (; p0 < p5; p0++, p3++, p4++)
> 							*p0 += *p3 * *p4;
2423c3094,3095
<              for (;p0 < p5;p0++,p1++) *p0 += *p1;
---
> 							for (; p0 < p5; p0++, p1++)
> 								*p0 += *p1;
2426,2427c3098,3101
<         p0 -= *n;p5 = p0 + *n;
<         for (;p0 < p5;p0++) *p0 *= .5;
---
> 					p0 -= *n;
> 					p5 = p0 + *n;
> 					for (; p0 < p5; p0++)
> 						*p0 *= .5;
2434c3108,3110
<       for (i=0;i< *n;i++) { wi[i]=1/fabs(w[i]);}
---
> 			for (i = 0; i < *n; i++) {
> 				wi[i] = 1 / fabs(w[i]);
> 			}
2453,2454c3129,3132
<       for (p2=p1,i=0;i<=j;i++,p0++,p2++) *p0 = *p2;
<       for (i=j+1;i<rank;i++,p0++) *p0 = 0.0; 
---
> 			for (p2 = p1, i = 0; i <= j; i++, p0++, p2++)
> 				*p0 = *p2;
> 			for (i = j + 1; i < rank; i++, p0++)
> 				*p0 = 0.0;
2459c3137,3138
<   get_bSb(P0,P1,P2,sp,E,rS,rSncol,Enrow,&rank,M,n_theta,PKtz,b1,b2,deriv);
---
> 	get_bSb(P0, P1, P2, sp, E, rS, rSncol, Enrow, &rank, M, n_theta, PKtz, b1,
> 			b2, deriv);
2464,2467c3143,3149
<     *ldet = MLpenalty1(ldet1,ldet2,Tk,Tkm,nulli,X,R,Q1,nind,sp,rS,rSncol,
< 		       &rank,n,Mp,M,n_theta,&neg_w,rank_tol,deriv,nt,type);
< 
<   } else get_ddetXWXpS(ldet1,ldet2,P,K,sp,rS,rSncol,Tk,Tkm,n,&rank,&rank,M,n_theta,deriv,*nt); 
---
> 		*ldet = MLpenalty1(ldet1, ldet2, Tk, Tkm, nulli, X, R, Q1, nind, sp, rS,
> 				rSncol, &rank, n, Mp, M, n_theta, &neg_w, rank_tol, deriv, nt,
> 				type);
> 
> 	} else
> 		get_ddetXWXpS(ldet1, ldet2, P, K, sp, rS, rSncol, Tk, Tkm, n, &rank,
> 				&rank, M, n_theta, deriv, *nt);
2473c3155,3156
<       for (i=0;i< rank;i++) beta[pivot1[i]] = p0[i];
---
> 			for (i = 0; i < rank; i++)
> 				beta[pivot1[i]] = p0[i];
2476c3159,3160
<       for (p0=beta,p2=p0 + *q;p0<p2;p0++,p1++) *p1 = *p0;
---
> 			for (p0 = beta, p2 = p0 + *q; p0 < p2; p0++, p1++)
> 				*p1 = *p0;
2480c3164,3165
<   for (i=0;i< rank;i++) beta[pivot1[i]] = PKtz[i];
---
> 	for (i = 0; i < rank; i++)
> 		beta[pivot1[i]] = PKtz[i];
2489c3174,3175
<   for (p0=w,p1=w + *n,p2=wf;p0<p1;p0++,p2++) *p0 = sqrt(*p2);
---
> 	for (p0 = w, p1 = w + *n, p2 = wf; p0 < p1; p0++, p2++)
> 		*p0 = sqrt(*p2);
2491,2492c3177,3180
<     for (p1=w,p2=w+*n;p1<p2;p1++,p0++,p3++) *p0 = *p3 * *p1;
<     for (j=0;j<*Enrow;j++,E++,p0++) *p0 = *E;
---
> 		for (p1 = w, p2 = w + *n; p1 < p2; p1++, p0++, p3++)
> 			*p0 = *p3 * *p1;
> 		for (j = 0; j < *Enrow; j++, E++, p0++)
> 			*p0 = *E;
2503,2506c3191,3200
<   for (i=0;i< rank;i++) Q[i * rank + i] = 1.0;
<   tp=0;mgcv_pqrqy(Q,WX,tau,&nr,&rank,&rank,&tp,nt);
<   for (p1=Q,p0=K,j=0;j<rank;j++,p1 += *Enrow) for (i=0;i<*n;i++,p1++,p0++) *p0 = *p1;
<   FREE(Q);FREE(WX);FREE(tau);
---
> 	for (i = 0; i < rank; i++)
> 		Q[i * rank + i] = 1.0;
> 	tp = 0;
> 	mgcv_pqrqy(Q, WX, tau, &nr, &rank, &rank, &tp, nt);
> 	for (p1 = Q, p0 = K, j = 0; j < rank; j++, p1 += *Enrow)
> 		for (i = 0; i < *n; i++, p1++, p0++)
> 			*p0 = *p1;
> 	FREE(Q);
> 	FREE(WX);
> 	FREE(tau);
2509c3203,3205
<   for (p1=P,i=0;i < rank; i++) for (j=0;j<rank;j++,p1++) rV[pivot1[j] + i * rank] = *p1;
---
> 	for (p1 = P, i = 0; i < rank; i++)
> 		for (j = 0; j < rank; j++, p1++)
> 			rV[pivot1[j] + i * rank] = *p1;
2511,2512c3207,3210
<   p0 = rV + *q * rank;p1 = rV + *q * *q;
<   for (p2=p0;p2<p1;p2++) *p2 = 0.0; /* padding any trailing columns of rV with zeroes */
---
> 	p0 = rV + *q * rank;
> 	p1 = rV + *q * *q;
> 	for (p2 = p0; p2 < p1; p2++)
> 		*p2 = 0.0; /* padding any trailing columns of rV with zeroes */
2515c3213,3214
<   for (p0=X,p1=K,p2=K + rank * *n;p1<p2;p0++,p1++) *p0 = *p1;
---
> 	for (p0 = X, p1 = K, p2 = K + rank * *n; p1 < p2; p0++, p1++)
> 		*p0 = *p1;
2517c3216,3217
<   for (p0 = X + rank * *n,p1 = X + *q * *n;p0<p1;p0++) *p0 = 0.0;
---
> 	for (p0 = X + rank * *n, p1 = X + *q * *n; p0 < p1; p0++)
> 		*p0 = 0.0;
2527c3227,3228
<     if (*type==0) FREE(Tk);
---
> 		if (*type == 0)
> 			FREE(Tk);
2529,2530c3230,3234
<       FREE(b2);FREE(eta2);FREE(w2);
<       if (*type==0) FREE(Tkm);
---
> 			FREE(b2);
> 			FREE(eta2);
> 			FREE(w2);
> 			if (*type == 0)
> 				FREE(Tkm);
2535c3239,3240
<     FREE(Vt);FREE(nind);
---
> 		FREE(Vt);
> 		FREE(nind);
2537,2539c3242,3250
<   FREE(PKtz);FREE(nulli);FREE(drop);
<   FREE(work);FREE(R);FREE(pivot1);FREE(K);
<   FREE(P);FREE(Q1);
---
> 	FREE(PKtz);
> 	FREE(nulli);
> 	FREE(drop);
> 	FREE(work);
> 	FREE(R);
> 	FREE(pivot1);
> 	FREE(K);
> 	FREE(P);
> 	FREE(Q1);
2543,2552c3254,3262
< 
< 
< void gdi1(double *X,double *E,double *Es,double *rS,double *U1,
< 	  double *sp,double *z,double *w,double *wf,double *alpha,double *mu,double *eta, double *y,
< 	 double *p_weights,double *g1,double *g2,double *g3,double *g4,double *V0,
< 	  double *V1,double *V2,double *V3,double *beta,double *b1,double *w1,
<          double *D1,double *D2,double *P0, double *P1,double *P2,double *trA,
<     double *trA1,double *trA2,double *rV,double *rank_tol,double *conv_tol, int *rank_est,
< 	 int *n,int *q, int *M,int *Mp,int *Enrow,int *rSncol,int *deriv,
< 	  int *REML,int *fisher,int *fixed_penalty,int *nt)     
---
> void gdi1(double *X, double *E, double *Es, double *rS, double *U1, double *sp,
> 		double *z, double *w, double *wf, double *alpha, double *mu,
> 		double *eta, double *y, double *p_weights, double *g1, double *g2,
> 		double *g3, double *g4, double *V0, double *V1, double *V2, double *V3,
> 		double *beta, double *b1, double *w1, double *D1, double *D2,
> 		double *P0, double *P1, double *P2, double *trA, double *trA1,
> 		double *trA2, double *rV, double *rank_tol, double *conv_tol,
> 		int *rank_est, int *n, int *q, int *M, int *Mp, int *Enrow, int *rSncol,
> 		int *deriv, int *REML, int *fisher, int *fixed_penalty, int *nt)
2653,2662c3363,3373
< { double *WX,*tau,*work,*p0,*p1,*p2,*p3,*K=NULL,
<     *R1,*Vt,xx,*b2,*P,*Q,
<     *af1=NULL,*af2=NULL,*a1,*a2,*eta1=NULL,*eta2=NULL,
<     *PKtz,*v1,*v2,*wi,*w2,*pw2,*Tk,*Tkm,*Tfk=NULL,*Tfkm=NULL,
<          *pb2, *dev_grad,*dev_hess=NULL,
<          ldetXWXS=0.0,reml_penalty=0.0,bSb=0.0,*R,
<     *alpha1,*alpha2,*raw,*Q1,*nulli;
<   int i,j,k,*pivot=NULL,*pivot1,ScS,*pi,rank,tp,bt,ct,iter=0,m,one=1,
<     n_2dCols=0,n_b2,n_drop,*drop,nt1,
<       n_eta1=0,n_eta2=0,n_work,deriv2,neg_w=0,*nind,nr,TRUE=1,FALSE=0; 
---
> {
> 	double *WX, *tau, *work, *p0, *p1, *p2, *p3, *K = NULL, *R1, *Vt, xx, *b2,
> 			*P, *Q, *af1 = NULL, *af2 = NULL, *a1, *a2, *eta1 = NULL, *eta2 =
> 					NULL, *PKtz, *v1, *v2, *wi, *w2, *pw2, *Tk, *Tkm, *Tfk =
> 					NULL, *Tfkm = NULL, *pb2, *dev_grad, *dev_hess = NULL,
> 			ldetXWXS = 0.0, reml_penalty = 0.0, bSb = 0.0, *R, *alpha1, *alpha2,
> 			*raw, *Q1, *nulli;
> 	int i, j, k, *pivot = NULL, *pivot1, ScS, *pi, rank, tp, bt, ct, iter = 0,
> 			m, one = 1, n_2dCols = 0, n_b2, n_drop, *drop, nt1, n_eta1 = 0,
> 			n_eta2 = 0, n_work, deriv2, neg_w = 0, *nind, nr, TRUE = 1, FALSE =
> 					0;
2673,2675c3384,3391
<   if (*deriv==2) deriv2=1; else deriv2=0;
< 
<   ScS=0;for (pi=rSncol;pi<rSncol + *M;pi++) ScS+= *pi;  /* total columns of input rS */
---
> 	if (*deriv == 2)
> 		deriv2 = 1;
> 	else
> 		deriv2 = 0;
> 
> 	ScS = 0;
> 	for (pi = rSncol; pi < rSncol + *M; pi++)
> 		ScS += *pi; /* total columns of input rS */
2685,2686c3401,3406
<   k = 5 * *q; if (n_work < k) n_work = k;
<   k = (*M * (1 + *M))/2 * *n; if (n_work < k) n_work = k;
---
> 	k = 5 * *q;
> 	if (n_work < k)
> 		n_work = k;
> 	k = (*M * (1 + *M)) / 2 * *n;
> 	if (n_work < k)
> 		n_work = k;
2692c3412,3415
<   if (deriv2) dev_hess = (double *)CALLOC((size_t) *q * *q,sizeof(double)); else dev_hess=NULL;
---
> 	if (deriv2)
> 		dev_hess = (double *) CALLOC((size_t) *q * *q, sizeof(double));
> 	else
> 		dev_hess = NULL;
2698,2699c3421,3425
<     if (w[i]<0) { neg_w++;raw[i] = sqrt(-w[i]);} 
<     else raw[i] = sqrt(w[i]);
---
> 		if (w[i] < 0) {
> 			neg_w++;
> 			raw[i] = sqrt(-w[i]);
> 		} else
> 			raw[i] = sqrt(w[i]);
2704,2705c3430,3439
<     k=0;for (i=0;i< *n;i++) if (w[i]<0) { nind[k]=i;k++;}
<   } else { nind = (int *)NULL; Vt = (double *)NULL;}
---
> 		k = 0;
> 		for (i = 0; i < *n; i++)
> 			if (w[i] < 0) {
> 				nind[k] = i;
> 				k++;
> 			}
> 	} else {
> 		nind = (int *) NULL;
> 		Vt = (double *) NULL;
> 	}
2708,2714c3442,3444
<   gdiPK(work,X,E,Es,rS,U1,z,raw,
<         R,nulli,dev_hess,P,K,Vt,PKtz,Q1,
<         nind,pivot1,drop,
<         n,q,Mp,neg_w,nt,Enrow,
<         &rank,&n_drop,
<         deriv2,ScS,REML,
<         rank_tol,&ldetXWXS,&FALSE);
---
> 	gdiPK(work, X, E, Es, rS, U1, z, raw, R, nulli, dev_hess, P, K, Vt, PKtz,
> 			Q1, nind, pivot1, drop, n, q, Mp, neg_w, nt, Enrow, &rank, &n_drop,
> 			deriv2, ScS, REML, rank_tol, &ldetXWXS, &FALSE);
2744,2745c3474,3475
<  
<     v1 = work;v2=work + *n * *M; /* a couple of working vectors */ 
---
> 		v1 = work;
> 		v2 = work + *n * *M; /* a couple of working vectors */
2756,2757c3486,3487
<       for (i=0;i< *n;i++) a1[i] = -  w[i] *(V1[i] + 2*g2[i])/g1[i];
<      
---
> 			for (i = 0; i < *n; i++)
> 				a1[i] = -w[i] * (V1[i] + 2 * g2[i]) / g1[i];
2761c3491,3494
<         a2[i] = a1[i]*(a1[i]/w[i]-g2[i]/g1[i]) - w[i]*(V2[i]-V1[i]*V1[i] + 2*g3[i]-2*g2[i]*g2[i])/(g1[i]*g1[i]) ;
---
> 				a2[i] = a1[i] * (a1[i] / w[i] - g2[i] / g1[i])
> 						- w[i]
> 								* (V2[i] - V1[i] * V1[i] + 2 * g3[i]
> 										- 2 * g2[i] * g2[i]) / (g1[i] * g1[i]);
2770c3503,3509
<         alpha2[i] = (-2*xx + (y[i]-mu[i])*(V3[i]-3*V1[i]*V2[i]+2*V1[i]*V1[i]*V1[i]+g4[i]-3*g3[i]*g2[i]+2*g2[i]*g2[i]*g2[i]))/alpha[i];
---
> 				alpha2[i] = (-2 * xx
> 						+ (y[i] - mu[i])
> 								* (V3[i] - 3 * V1[i] * V2[i]
> 										+ 2 * V1[i] * V1[i] * V1[i] + g4[i]
> 										- 3 * g3[i] * g2[i]
> 										+ 2 * g2[i] * g2[i] * g2[i]))
> 						/ alpha[i];
2777c3515,3516
<       for (i=0;i<*n;i++) a1[i] = w[i]*(alpha1[i]-V1[i]-2*g2[i])/g1[i];
---
> 			for (i = 0; i < *n; i++)
> 				a1[i] = w[i] * (alpha1[i] - V1[i] - 2 * g2[i]) / g1[i];
2779,2780c3518,3523
<       for (i=0;i<*n;i++) a2[i] = a1[i]*(a1[i]/w[i]-g2[i]/g1[i]) - 
<                                  w[i]*(alpha1[i]*alpha1[i] - alpha2[i] + V2[i]-V1[i]*V1[i] + 2*g3[i]-2*g2[i]*g2[i])/(g1[i]*g1[i]) ;
---
> 			for (i = 0; i < *n; i++)
> 				a2[i] = a1[i] * (a1[i] / w[i] - g2[i] / g1[i])
> 						- w[i]
> 								* (alpha1[i] * alpha1[i] - alpha2[i] + V2[i]
> 										- V1[i] * V1[i] + 2 * g3[i]
> 										- 2 * g2[i] * g2[i]) / (g1[i] * g1[i]);
2786c3529,3530
<         for (i=0;i< *n;i++) af1[i] = -  wf[i] *(V1[i] + 2*g2[i])/g1[i];
---
> 				for (i = 0; i < *n; i++)
> 					af1[i] = -wf[i] * (V1[i] + 2 * g2[i]) / g1[i];
2789c3533,3537
<         af2[i] = af1[i]*(af1[i]/wf[i]-g2[i]/g1[i]) - wf[i]*(V2[i]-V1[i]*V1[i] + 2*g3[i]-2*g2[i]*g2[i])/(g1[i]*g1[i]) ;
---
> 					af2[i] = af1[i] * (af1[i] / wf[i] - g2[i] / g1[i])
> 							- wf[i]
> 									* (V2[i] - V1[i] * V1[i] + 2 * g3[i]
> 											- 2 * g2[i] * g2[i])
> 									/ (g1[i] * g1[i]);
2792,2793c3540,3541
< 
<       FREE(alpha1);FREE(alpha2);
---
> 			FREE(alpha1);
> 			FREE(alpha2);
2798c3546,3547
<     for (i=0;i< *n ;i++) v1[i] = -2*p_weights[i]*(y[i]-mu[i])/(V0[i]*g1[i]);
---
> 		for (i = 0; i < *n; i++)
> 			v1[i] = -2 * p_weights[i] * (y[i] - mu[i]) / (V0[i] * g1[i]);
2800c3549,3551
<     bt=1;ct=0;mgcv_mmult(dev_grad,X,v1,&bt,&ct,&rank,&one,n);
---
> 		bt = 1;
> 		ct = 0;
> 		mgcv_mmult(dev_grad, X, v1, &bt, &ct, &rank, &one, n);
2803c3554,3555
<        for (p0=dev_hess,p1=p0 + rank * rank;p0<p1;p0++) *p0 *= 2.0;      
---
> 			for (p0 = dev_hess, p1 = p0 + rank * rank; p0 < p1; p0++)
> 				*p0 *= 2.0;
2825c3576,3577
<     ift1(R,Vt,X,rS,PKtz,sp,w,a1,b1,b2,eta1,eta2,n,&rank,M,rSncol,&deriv2,&neg_w,&nr);
---
> 		ift1(R, Vt, X, rS, PKtz, sp, w, a1, b1, b2, eta1, eta2, n, &rank, M,
> 				rSncol, &deriv2, &neg_w, &nr);
2833c3585,3586
<       for (pw2=w2,m=0;m < *M;m++) for (k=m;k < *M;k++) {
---
> 			for (pw2 = w2, m = 0; m < *M; m++)
> 				for (k = m; k < *M; k++) {
2837c3590,3591
<         for (p0=v2;p0<p1;p0++,pw2++) *pw2 += *p0;           
---
> 					for (p0 = v2; p0 < p1; p0++, pw2++)
> 						*pw2 += *p0;
2844c3597,3599
<     for (i=0;i< *n;i++) { wi[i]=1/fabs(w[i]);}
---
> 		for (i = 0; i < *n; i++) {
> 			wi[i] = 1 / fabs(w[i]);
> 		}
2849c3604,3605
<     if (deriv2) rc_prod(Tkm,wi,w2,&n_2dCols,n);
---
> 		if (deriv2)
> 			rc_prod(Tkm, wi, w2, &n_2dCols, n);
2857c3613,3614
<         for (pw2=w2,m=0;m < *M;m++) for (k=m;k < *M;k++) {
---
> 				for (pw2 = w2, m = 0; m < *M; m++)
> 					for (k = m; k < *M; k++) {
2861c3618,3619
<           for (p0=v2;p0<p1;p0++,pw2++) *pw2 += *p0;           
---
> 						for (p0 = v2; p0 < p1; p0++, pw2++)
> 							*pw2 += *p0;
2864c3622,3624
<       for (i=0;i< *n;i++) { wi[i]=1/wf[i];}
---
> 			for (i = 0; i < *n; i++) {
> 				wi[i] = 1 / wf[i];
> 			}
2866,2867c3626,3629
<       if (deriv2) rc_prod(Tfkm,wi,w2,&n_2dCols,n);
<       FREE(af1);FREE(af2);
---
> 			if (deriv2)
> 				rc_prod(Tfkm, wi, w2, &n_2dCols, n);
> 			FREE(af1);
> 			FREE(af2);
2869c3631,3633
<     else {Tfk = Tfkm = NULL;}
---
> 		else {
> 			Tfk = Tfkm = NULL;
> 		}
2873c3637,3639
<     bt=1;ct=0;mgcv_mmult(D1,b1,dev_grad,&bt,&ct,M,&one,&rank); /* gradient of deviance is complete */
---
> 		bt = 1;
> 		ct = 0;
> 		mgcv_mmult(D1, b1, dev_grad, &bt, &ct, M, &one, &rank); /* gradient of deviance is complete */
2878c3644,3645
<       for (pb2=b2,m=0;m < *M;m++) for (k=m;k < *M;k++) { /* double sp loop */
---
> 			for (pb2 = b2, m = 0; m < *M; m++)
> 				for (k = m; k < *M; k++) { /* double sp loop */
2880c3647,3648
<           for (xx=0.0,p0=dev_grad;p0<p1;p0++,pb2++) xx += *p0 * *pb2;
---
> 					for (xx = 0.0, p0 = dev_grad; p0 < p1; p0++, pb2++)
> 						xx += *p0 * *pb2;
2886c3654,3656
<   } else {wi=NULL;} /* end of if (*deriv) */
---
> 	} else {
> 		wi = NULL;
> 	} /* end of if (*deriv) */
2893,2894c3663,3666
<       for (p2=p1,i=0;i<=j;i++,p0++,p2++) *p0 = *p2;
<       for (i=j+1;i<rank;i++,p0++) *p0 = 0.0; 
---
> 			for (p2 = p1, i = 0; i <= j; i++, p0++, p2++)
> 				*p0 = *p2;
> 			for (i = j + 1; i < rank; i++, p0++)
> 				*p0 = 0.0;
2896,2897c3668,3672
<   } else { FREE(R);FREE(Q1);FREE(nind); } /* needed later for ML calculation */
< 
---
> 	} else {
> 		FREE(R);
> 		FREE(Q1);
> 		FREE(nind);
> 	} /* needed later for ML calculation */
2903,2904c3678,3681
<     get_bSb(&bSb,trA1,trA2,sp,E,rS,rSncol,Enrow,&rank,M,&FALSE,PKtz,b1,b2,deriv);
<     if (*deriv) for (p2=D2,p1=trA2,i = 0; i< *M;i++) { /* penalized deviance derivs needed */
---
> 		get_bSb(&bSb, trA1, trA2, sp, E, rS, rSncol, Enrow, &rank, M, &FALSE,
> 				PKtz, b1, b2, deriv);
> 		if (*deriv)
> 			for (p2 = D2, p1 = trA2, i = 0; i < *M; i++) { /* penalized deviance derivs needed */
2906c3683,3685
<         if (deriv2) for (j=0;j<*M;j++,p1++,p2++) *p2 += *p1;   
---
> 				if (deriv2)
> 					for (j = 0; j < *M; j++, p1++, p2++)
> 						*p2 += *p1;
2910c3689,3690
<   pearson2(P0,P1,P2,y,mu,V0,V1,V2,g1,g2,p_weights,eta1,eta2,*n,*M,*deriv,deriv2);
---
> 	pearson2(P0, P1, P2, y, mu, V0, V1, V2, g1, g2, p_weights, eta1, eta2, *n,
> 			*M, *deriv, deriv2);
2917,2918c3697,3702
<        if (*deriv) for (p0=trA1,p1 = P1,p2 = P1 + *M;p1<p2;p1++,p0++) *p1 += *p0;
<        if (*deriv>1) for (p0=trA2,p1 = P2,p2 = P2 + *M * *M;p1<p2;p1++,p0++) *p1 += *p0;
---
> 			if (*deriv)
> 				for (p0 = trA1, p1 = P1, p2 = P1 + *M; p1 < p2; p1++, p0++)
> 					*p1 += *p0;
> 			if (*deriv > 1)
> 				for (p0 = trA2, p1 = P2, p2 = P2 + *M * *M; p1 < p2; p1++, p0++)
> 					*p1 += *p0;
2922,2923c3706,3711
<     if (*deriv) for (p1 = P1,p2 = P1 + *M;p1<p2;p1++) *p1 /= j;
<     if (*deriv>1) for (p1 = P2,p2 = P2 + *M * *M;p1<p2;p1++) *p1 /= j;
---
> 		if (*deriv)
> 			for (p1 = P1, p2 = P1 + *M; p1 < p2; p1++)
> 				*p1 /= j;
> 		if (*deriv > 1)
> 			for (p1 = P2, p2 = P2 + *M * *M; p1 < p2; p1++)
> 				*p1 /= j;
2932c3718,3719
<       for (i=0;i< rank;i++) beta[pivot1[i]] = p0[i];
---
> 			for (i = 0; i < rank; i++)
> 				beta[pivot1[i]] = p0[i];
2935c3722,3723
<       for (p0=beta,p2=p0 + *q;p0<p2;p0++,p1++) *p1 = *p0;
---
> 			for (p0 = beta, p2 = p0 + *q; p0 < p2; p0++, p1++)
> 				*p1 = *p0;
2939c3727,3728
<   for (i=0;i< rank;i++) beta[pivot1[i]] = PKtz[i];
---
> 	for (i = 0; i < rank; i++)
> 		beta[pivot1[i]] = PKtz[i];
2949c3736,3737
<     get_ddetXWXpS(trA1,trA2,P,K,sp,rS,rSncol,Tk,Tkm,n,&rank,&rank,M,&FALSE,deriv,*nt); /* trA1/2 really contain det derivs */
---
> 		get_ddetXWXpS(trA1, trA2, P, K, sp, rS, rSncol, Tk, Tkm, n, &rank,
> 				&rank, M, &FALSE, deriv, *nt); /* trA1/2 really contain det derivs */
2956,2957c3744,3746
<     reml_penalty =  MLpenalty1(trA1,trA2,Tk,Tkm,nulli,X,R,Q1,nind,sp,rS,rSncol,
< 			       &rank,n,Mp,M,&FALSE,&neg_w,rank_tol,deriv,nt,&FALSE);
---
> 		reml_penalty = MLpenalty1(trA1, trA2, Tk, Tkm, nulli, X, R, Q1, nind,
> 				sp, rS, rSncol, &rank, n, Mp, M, &FALSE, &neg_w, rank_tol,
> 				deriv, nt, &FALSE);
2959c3748,3750
<     FREE(R);FREE(Q1);FREE(nind);
---
> 		FREE(R);
> 		FREE(Q1);
> 		FREE(nind);
2966,2967c3756,3759
<   if (neg_w) FREE(Vt);   
<   FREE(work);FREE(PKtz);
---
> 	if (neg_w)
> 		FREE(Vt);
> 	FREE(work);
> 	FREE(PKtz);
2973c3765,3768
<     FREE(a1);FREE(a2);FREE(wi);FREE(dev_grad);
---
> 		FREE(a1);
> 		FREE(a2);
> 		FREE(wi);
> 		FREE(dev_grad);
2975c3770,3771
<     FREE(w2);FREE(b2);
---
> 		FREE(w2);
> 		FREE(b2);
2977c3773,3775
<     if (deriv2) { FREE(dev_hess);}
---
> 		if (deriv2) {
> 			FREE(dev_hess);
> 		}
2987c3784,3786
<     wf = w;Tfk=Tk;Tfkm=Tkm;
---
> 		wf = w;
> 		Tfk = Tk;
> 		Tfkm = Tkm;
2992,2993c3791,3794
<     WX = (double *) CALLOC((size_t) ( (nr + *nt * rank) * rank),sizeof(double));
<     for (p0=w,p1=w + *n,p2=wf;p0<p1;p0++,p2++) *p0 = sqrt(*p2);
---
> 		WX = (double *) CALLOC((size_t) ((nr + *nt * rank) * rank),
> 				sizeof(double));
> 		for (p0 = w, p1 = w + *n, p2 = wf; p0 < p1; p0++, p2++)
> 			*p0 = sqrt(*p2);
2995,2996c3796,3799
<       for (p1=w,p2=w+*n;p1<p2;p1++,p0++,p3++) *p0 = *p3 * *p1;
<       for (j=0;j<*Enrow;j++,E++,p0++) *p0 = *E;
---
> 			for (p1 = w, p2 = w + *n; p1 < p2; p1++, p0++, p3++)
> 				*p0 = *p3 * *p1;
> 			for (j = 0; j < *Enrow; j++, E++, p0++)
> 				*p0 = *E;
3017,3022c3820,3832
<     for (i=0;i< rank;i++) Q[i * rank + i] = 1.0;
<     tp=0;mgcv_pqrqy(Q,WX,tau,&nr,&rank,&rank,&tp,&nt1);
< 
<     for (p1=Q,p0=K,j=0;j<rank;j++,p1 += *Enrow) for (i=0;i<*n;i++,p1++,p0++) *p0 = *p1;
<     FREE(Q);FREE(WX);FREE(tau);
<     if (*deriv)  pivoter(rS,&rank,&ScS,pivot,&FALSE,&FALSE); /* apply the latest pivoting to rows of rS */
---
> 		for (i = 0; i < rank; i++)
> 			Q[i * rank + i] = 1.0;
> 		tp = 0;
> 		mgcv_pqrqy(Q, WX, tau, &nr, &rank, &rank, &tp, &nt1);
> 
> 		for (p1 = Q, p0 = K, j = 0; j < rank; j++, p1 += *Enrow)
> 			for (i = 0; i < *n; i++, p1++, p0++)
> 				*p0 = *p1;
> 		FREE(Q);
> 		FREE(WX);
> 		FREE(tau);
> 		if (*deriv)
> 			pivoter(rS, &rank, &ScS, pivot, &FALSE, &FALSE); /* apply the latest pivoting to rows of rS */
3026,3029c3836,3841
<  
<   if (*REML) i=0; else i = *deriv;
<   get_trA2(trA,trA1,trA2,P,K,sp,rS,rSncol,Tfk,Tfkm,wf,n,&rank,&rank,M,&i,nt);
< 
---
> 	if (*REML)
> 		i = 0;
> 	else
> 		i = *deriv;
> 	get_trA2(trA, trA1, trA2, P, K, sp, rS, rSncol, Tfk, Tfkm, wf, n, &rank,
> 			&rank, M, &i, nt);
3039c3851,3853
<   for (p1=P,i=0;i < rank; i++) for (j=0;j<rank;j++,p1++) rV[pivot1[j] + i * rank] = *p1;
---
> 	for (p1 = P, i = 0; i < rank; i++)
> 		for (j = 0; j < rank; j++, p1++)
> 			rV[pivot1[j] + i * rank] = *p1;
3041,3042c3855,3858
<   p0 = rV + *q * rank;p1 = rV + *q * *q;
<   for (p2=p0;p2<p1;p2++) *p2 = 0.0; /* padding any trailing columns of rV with zeroes */
---
> 	p0 = rV + *q * rank;
> 	p1 = rV + *q * *q;
> 	for (p2 = p0; p2 < p1; p2++)
> 		*p2 = 0.0; /* padding any trailing columns of rV with zeroes */
3045c3861,3862
<   for (p0=X,p1=K,p2=K + rank * *n;p1<p2;p0++,p1++) *p0 = *p1;
---
> 	for (p0 = X, p1 = K, p2 = K + rank * *n; p1 < p2; p0++, p1++)
> 		*p0 = *p1;
3047c3864,3865
<   for (p0 = X + rank * *n,p1 = X + *q * *n;p0<p1;p0++) *p0 = 0.0;
---
> 	for (p0 = X + rank * *n, p1 = X + *q * *n; p0 < p1; p0++)
> 		*p0 = 0.0;
3054c3872,3873
<   FREE(P);FREE(K);
---
> 	FREE(P);
> 	FREE(K);
3056,3057c3875,3880
<     FREE(Tk);FREE(Tkm);
<     if (! *REML && ! *fisher) { FREE(Tfk);FREE(Tfkm);}
---
> 		FREE(Tk);
> 		FREE(Tkm);
> 		if (!*REML && !*fisher) {
> 			FREE(Tfk);
> 			FREE(Tfkm);
> 		}
3060c3883,3886
<   if (*REML) {*rank_tol = reml_penalty;*conv_tol = bSb;}
---
> 	if (*REML) {
> 		*rank_tol = reml_penalty;
> 		*conv_tol = bSb;
> 	}
3081c3905,3907
< { double kappa,*pm,*pp,*y,*p,ym,yp,pm_norm,pp_norm,y_inf=0.0,R_inf=0.0;
---
> {
> 	double kappa, *pm, *pp, *y, *p, ym, yp, pm_norm, pp_norm, y_inf = 0.0,
> 			R_inf = 0.0;
3084,3086c3910,3919
<   pp=work;work+= *c;pm=work;work+= *c;
<   y=work;work+= *c;p=work;work+= *c;   
<   for (i=0;i<*c;i++) p[i] = 0.0;
---
> 	pp = work;
> 	work += *c;
> 	pm = work;
> 	work += *c;
> 	y = work;
> 	work += *c;
> 	p = work;
> 	work += *c;
> 	for (i = 0; i < *c; i++)
> 		p[i] = 0.0;
3090,3091c3923,3930
<       for (pp_norm=0.0,i=0;i<k;i++) { pp[i] = p[i] + R[i + *r * k] * yp;pp_norm += fabs(pp[i]);}
<       for (pm_norm=0.0,i=0;i<k;i++) { pm[i] = p[i] + R[i + *r * k] * ym;pm_norm += fabs(pm[i]);}
---
> 		for (pp_norm = 0.0, i = 0; i < k; i++) {
> 			pp[i] = p[i] + R[i + *r * k] * yp;
> 			pp_norm += fabs(pp[i]);
> 		}
> 		for (pm_norm = 0.0, i = 0; i < k; i++) {
> 			pm[i] = p[i] + R[i + *r * k] * ym;
> 			pm_norm += fabs(pm[i]);
> 		}
3094c3933,3934
<           for (i=0;i<k;i++) p[i] = pp[i];
---
> 			for (i = 0; i < k; i++)
> 				p[i] = pp[i];
3097c3937,3938
<           for (i=0;i<k;i++) p[i] = pm[i];
---
> 			for (i = 0; i < k; i++)
> 				p[i] = pm[i];
3100c3941,3942
<       if (kappa>y_inf) y_inf=kappa;
---
> 		if (kappa > y_inf)
> 			y_inf = kappa;
3103,3104c3945,3948
<     for (kappa=0.0,j=i;j<*c;j++) kappa += fabs(R[i + *r * j]);  
<     if (kappa>R_inf) R_inf = kappa;
---
> 		for (kappa = 0.0, j = i; j < *c; j++)
> 			kappa += fabs(R[i + *r * j]);
> 		if (kappa > R_inf)
> 			R_inf = kappa;
3110,3112c3954,3956
< 
< void pls_fit1(double *y,double *X,double *w,double *wy,double *E,double *Es,int *n,int *q,int *rE,double *eta,
<               double *penalty,double *rank_tol,int *nt,int *use_wy)
---
> void pls_fit1(double *y, double *X, double *w, double *wy, double *E,
> 		double *Es, int *n, int *q, int *rE, double *eta, double *penalty,
> 		double *rank_tol, int *nt, int *use_wy)
3147,3149c3991,3995
< { int i,j,k,rank,one=1,*pivot,*pivot1,left,tp,neg_w=0,*nind,bt,ct,nr,n_drop=0,*drop,TRUE=1,FALSE=0,nz;
<   double *z,*WX,*tau,Rcond,xx,zz,zz1,*work,*Q,*Q1,*IQ,*raw,*d,*Vt,*p0,*p1,
<     *R1,*tau1,Rnorm,Enorm,*R,*Xp;
---
> {
> 	int i, j, k, rank, one = 1, *pivot, *pivot1, left, tp, neg_w = 0, *nind, bt,
> 			ct, nr, n_drop = 0, *drop, TRUE = 1, FALSE = 0, nz;
> 	double *z, *WX, *tau, Rcond, xx, zz, zz1, *work, *Q, *Q1, *IQ, *raw, *d,
> 			*Vt, *p0, *p1, *R1, *tau1, Rnorm, Enorm, *R, *Xp;
3160c4006,4008
<   nz = *n; if (nz<nr) nz=nr; /* possible for nr to be more than n */
---
> 	nz = *n;
> 	if (nz < nr)
> 		nz = nr; /* possible for nr to be more than n */
3166,3167c4014,4018
<     if (w[i]<0) { neg_w++;raw[i] = sqrt(-w[i]);} 
<     else raw[i] = sqrt(w[i]);
---
> 		if (w[i] < 0) {
> 			neg_w++;
> 			raw[i] = sqrt(-w[i]);
> 		} else
> 			raw[i] = sqrt(w[i]);
3171,3172c4022,4030
<     k=0;for (i=0;i< *n;i++) if (w[i]<0) { nind[k]=i;k++;}
<   } else { nind = (int *)NULL;}
---
> 		k = 0;
> 		for (i = 0; i < *n; i++)
> 			if (w[i] < 0) {
> 				nind[k] = i;
> 				k++;
> 			}
> 	} else {
> 		nind = (int *) NULL;
> 	}
3178c4036,4039
<   for (i=0;i<neg_w;i++) {k=nind[i];z[k] = -z[k];} 
---
> 	for (i = 0; i < neg_w; i++) {
> 		k = nind[i];
> 		z[k] = -z[k];
> 	}
3213,3214c4074,4077
<     for (i=0;i< *q;i++) R[i + nr * j] = R1[i + *q * j]/Rnorm;
<     for (i=0;i< *rE;i++) R[i + *q + nr * j] = Es[i + *rE * j]/Enorm;
---
> 		for (i = 0; i < *q; i++)
> 			R[i + nr * j] = R1[i + *q * j] / Rnorm;
> 		for (i = 0; i < *rE; i++)
> 			R[i + *q + nr * j] = Es[i + *rE * j] / Enorm;
3227c4090,4093
<   while (*rank_tol * Rcond > 1) { rank--;R_cond(R,&nr,&rank,work,&Rcond);}
---
> 	while (*rank_tol * Rcond > 1) {
> 		rank--;
> 		R_cond(R, &nr, &rank, work, &Rcond);
> 	}
3237c4103,4104
<     for (i=0;i<n_drop;i++) drop[i] = pivot1[rank+i];
---
> 		for (i = 0; i < n_drop; i++)
> 			drop[i] = pivot1[rank + i];
3242c4109,4111
<   } else {drop=NULL;}
---
> 	} else {
> 		drop = NULL;
> 	}
3249,3250c4118,4121
<     for (i=0;i< *q;i++) R[i + nr * j] = R1[i + *q * j];
<       for (i=0;i< *rE;i++) R[i + *q + nr * j] = E[i + *rE * j];
---
> 		for (i = 0; i < *q; i++)
> 			R[i + nr * j] = R1[i + *q * j];
> 		for (i = 0; i < *rE; i++)
> 			R[i + *q + nr * j] = E[i + *rE * j];
3258,3259c4128,4132
<     for (i=0;i< rank;i++) Q[i * nr + i] = 1.0;
<     left=1;tp=0;mgcv_qrqy(Q,R,tau1,&nr,&rank,&rank,&left,&tp); /* Q from the second QR decomposition */
---
> 		for (i = 0; i < rank; i++)
> 			Q[i * nr + i] = 1.0;
> 		left = 1;
> 		tp = 0;
> 		mgcv_qrqy(Q, R, tau1, &nr, &rank, &rank, &left, &tp); /* Q from the second QR decomposition */
3264,3265c4137,4141
<     for (i=0;i<*q;i++) for (j=0;j<rank;j++) Q1[i + *q * j] = Q[i + nr * j];
<     tp=0;mgcv_pqrqy(Q1,WX,tau,n,q,&rank,&tp,nt);/* Q1 = Qb Q[1:q,]  where Qb from first QR decomposition */   
---
> 		for (i = 0; i < *q; i++)
> 			for (j = 0; j < rank; j++)
> 				Q1[i + *q * j] = Q[i + nr * j];
> 		tp = 0;
> 		mgcv_pqrqy(Q1, WX, tau, n, q, &rank, &tp, nt);/* Q1 = Qb Q[1:q,]  where Qb from first QR decomposition */
3269c4145,4148
<     if (neg_w < rank+1) k = rank+1; else k = neg_w;
---
> 		if (neg_w < rank + 1)
> 			k = rank + 1;
> 		else
> 			k = neg_w;
3272,3273c4151,4154
<       p0 = IQ + i;p1 = Q1 + nind[i];
<       for (j=0;j<rank;j++,p0+=k,p1+= *n) *p0 = *p1;
---
> 			p0 = IQ + i;
> 			p1 = Q1 + nind[i];
> 			for (j = 0; j < rank; j++, p0 += k, p1 += *n)
> 				*p0 = *p1;
3285,3287c4166,4179
<         FREE(Vt);FREE(d);FREE(pivot);FREE(tau);
<         FREE(nind);FREE(raw);FREE(z);FREE(work);FREE(WX);
<         FREE(tau1);FREE(pivot1);FREE(R);if (n_drop) FREE(drop);
---
> 				FREE(Vt);
> 				FREE(d);
> 				FREE(pivot);
> 				FREE(tau);
> 				FREE(nind);
> 				FREE(raw);
> 				FREE(z);
> 				FREE(work);
> 				FREE(WX);
> 				FREE(tau1);
> 				FREE(pivot1);
> 				FREE(R);
> 				if (n_drop)
> 					FREE(drop);
3290c4182,4185
<       if (d[i]<=0) d[i]=0.0; else d[i] = 1/d[i];
---
> 			if (d[i] <= 0)
> 				d[i] = 0.0;
> 			else
> 				d[i] = 1 / d[i];
3293c4188,4190
<   } else {Vt = d = (double *)NULL; }
---
> 	} else {
> 		Vt = d = (double *) NULL;
> 	}
3298,3299c4195,4198
<     tp=1;mgcv_pqrqy(z,WX,tau,n,q,&one,&tp,nt);
<     for (i=rank;i<nz;i++) z[i]=0.0;
---
> 		tp = 1;
> 		mgcv_pqrqy(z, WX, tau, n, q, &one, &tp, nt);
> 		for (i = rank; i < nz; i++)
> 			z[i] = 0.0;
3303c4202,4203
<     for (i=rank;i < nz;i++) z[i]=0.0;
---
> 		for (i = rank; i < nz; i++)
> 			z[i] = 0.0;
3305c4205,4206
<     for (i=0;i<rank;i++) y[i] = work[i+*q] = z[i];        /* y = Q'z, or corrected version, for finding beta */ 
---
> 		for (i = 0; i < rank; i++)
> 			y[i] = work[i + *q] = z[i]; /* y = Q'z, or corrected version, for finding beta */
3308,3311c4209,4218
<        bt=0;ct=0;mgcv_mmult(work,Vt,z,&bt,&ct,&rank,&one,&rank); /* V' Q_1' z */
<        for (i=0;i<rank;i++) work[i] *= d[i];
<        bt=1;ct=0;mgcv_mmult(z,Vt,work,&bt,&ct,&rank,&one,&rank); /* V (I-2D^2)^{-1} V' Q1' Q' z */
<        for (i=0;i<rank;i++) y[i] = z[i];
---
> 			bt = 0;
> 			ct = 0;
> 			mgcv_mmult(work, Vt, z, &bt, &ct, &rank, &one, &rank); /* V' Q_1' z */
> 			for (i = 0; i < rank; i++)
> 				work[i] *= d[i];
> 			bt = 1;
> 			ct = 0;
> 			mgcv_mmult(z, Vt, work, &bt, &ct, &rank, &one, &rank); /* V (I-2D^2)^{-1} V' Q1' Q' z */
> 			for (i = 0; i < rank; i++)
> 				y[i] = z[i];
3314c4221,4222
<     left=1,tp=0; mgcv_qrqy(z,R,tau1,&nr,&one,&rank,&left,&tp); /* z = Q1 Q1'Q'z */
---
> 		left = 1, tp = 0;
> 		mgcv_qrqy(z, R, tau1, &nr, &one, &rank, &left, &tp); /* z = Q1 Q1'Q'z */
3316c4224,4225
<     for (*penalty=0.0,i=rank;i<nr;i++) *penalty += z[i]*z[i]; /* the penalty term */
---
> 		for (*penalty = 0.0, i = rank; i < nr; i++)
> 			*penalty += z[i] * z[i]; /* the penalty term */
3318c4227,4228
<     for (i=rank;i < *n;i++) z[i]=0.0;
---
> 		for (i = rank; i < *n; i++)
> 			z[i] = 0.0;
3321c4231,4232
<     tp=0;mgcv_pqrqy(z,WX,tau,n,q,&one,&tp,nt);
---
> 		tp = 0;
> 		mgcv_pqrqy(z, WX, tau, n, q, &one, &tp, nt);
3323c4234,4235
<     for (i=0;i<*n;i++) eta[i] = z[i]/raw[i]; /* the linear predictor */
---
> 		for (i = 0; i < *n; i++)
> 			eta[i] = z[i] / raw[i]; /* the linear predictor */
3331c4242,4244
<   bt=1;ct=0;mgcv_mmult(work,X,wy,&bt,&ct,q,&one,n);     
---
> 	bt = 1;
> 	ct = 0;
> 	mgcv_mmult(work, X, wy, &bt, &ct, q, &one, n);
3337c4250,4251
<       for (xx=0,j=0;j<=i;j++) xx += R[j + nr * i] * work[*q + j];
---
> 			for (xx = 0, j = 0; j <= i; j++)
> 				xx += R[j + nr * i] * work[*q + j];
3340c4254,4255
<       zz1 += xx*xx; zz += work[i]*work[i];   
---
> 			zz1 += xx * xx;
> 			zz += work[i] * work[i];
3350c4265,4266
<       for (xx=0.0,j=0;j < k;j++) xx += R[j + nr * k]*z[j];
---
> 			for (xx = 0.0, j = 0; j < k; j++)
> 				xx += R[j + nr * k] * z[j];
3354,3356c4270,4277
<       bt=0;ct=0;mgcv_mmult(work,Vt,z,&bt,&ct,&rank,&one,&rank); /* V' Q_1' z */
<       for (i=0;i<rank;i++) work[i] *= d[i];
<       bt=1;ct=0;mgcv_mmult(z,Vt,work,&bt,&ct,&rank,&one,&rank); /* V (I-2D^2)^{-1} V' Q1' Q' z */
---
> 			bt = 0;
> 			ct = 0;
> 			mgcv_mmult(work, Vt, z, &bt, &ct, &rank, &one, &rank); /* V' Q_1' z */
> 			for (i = 0; i < rank; i++)
> 				work[i] *= d[i];
> 			bt = 1;
> 			ct = 0;
> 			mgcv_mmult(z, Vt, work, &bt, &ct, &rank, &one, &rank); /* V (I-2D^2)^{-1} V' Q1' Q' z */
3358c4279,4280
<     for (i=0;i<rank;i++) y[i] = z[i];
---
> 		for (i = 0; i < rank; i++)
> 			y[i] = z[i];
3366c4288,4289
<       for (xx=0.0,j=k+1;j < rank;j++) xx += R[k + nr * j]*z[j];
---
> 		for (xx = 0.0, j = k + 1; j < rank; j++)
> 			xx += R[k + nr * j] * z[j];
3370c4293,4294
<   for (i=0;i< rank;i++) y[pivot1[i]] = z[i];
---
> 	for (i = 0; i < rank; i++)
> 		y[pivot1[i]] = z[i];
3376,3378c4300,4307
<     bt=0;ct=0;mgcv_mmult(eta,X,y,&bt,&ct,n,&one,q);
<     bt=0;ct=0;mgcv_mmult(work,E,y,&bt,&ct,rE,&one,q);
<     for (*penalty=0.0,i=0;i < *rE;i++) *penalty += work[i]*work[i]; /* the penalty term */
---
> 		bt = 0;
> 		ct = 0;
> 		mgcv_mmult(eta, X, y, &bt, &ct, n, &one, q);
> 		bt = 0;
> 		ct = 0;
> 		mgcv_mmult(work, E, y, &bt, &ct, rE, &one, q);
> 		for (*penalty = 0.0, i = 0; i < *rE; i++)
> 			*penalty += work[i] * work[i]; /* the penalty term */
3382,3385c4311,4325
<   FREE(WX);FREE(tau);FREE(pivot);FREE(raw);
<   FREE(R);FREE(pivot1);FREE(tau1);  FREE(work);
<   if (n_drop) FREE(drop);
<   if (neg_w) { FREE(nind);FREE(d);FREE(Vt);}
---
> 	FREE(WX);
> 	FREE(tau);
> 	FREE(pivot);
> 	FREE(raw);
> 	FREE(R);
> 	FREE(pivot1);
> 	FREE(tau1);
> 	FREE(work);
> 	if (n_drop)
> 		FREE(drop);
> 	if (neg_w) {
> 		FREE(nind);
> 		FREE(d);
> 		FREE(Vt);
> 	}
diff -rEZbwB '--exclude=*.[lo,d,pdf,mo,po,tgz,gz,save]*' '--exclude=MD5' '--exclude=Makefile*' '--exclude=all.R' '--exclude=Changes' R-recommended/mgcv/src/general.h Recommended/mgcv/src/general.h
3,8d2
< #ifdef ENABLE_NLS
< #include <libintl.h>
< #define _(String) dgettext ("mgcv", String)
< #else
< #define _(String) (String)
< #endif
Only in Recommended/mgcv/src: localization.h
diff -rEZbwB '--exclude=*.[lo,d,pdf,mo,po,tgz,gz,save]*' '--exclude=MD5' '--exclude=Makefile*' '--exclude=all.R' '--exclude=Changes' R-recommended/mgcv/src/magic.c Recommended/mgcv/src/magic.c
28c27
< 
---
> #include "localization.h"
32c31,32
< { double ***a,***p,**p1,*p2;
---
> {
> 	double ***a, ***p, **p1, *p2;
37,40c37,43
<   p2 = **a; p1= *a;p=a;
<   for (p=a;p<a+ni;p++) 
<   { *p = p1; /* a[i]=a[0]+i*nj   */
<     for (j=0;j<nj;j++,p2+=nk,p1++) *p1 = p2; /* a[i][j]= a[0][0]+i*nj*nk+j*nk  */
---
> 	p2 = **a;
> 	p1 = *a;
> 	p = a;
> 	for (p = a; p < a + ni; p++) {
> 		*p = p1; /* a[i]=a[0]+i*nj   */
> 		for (j = 0; j < nj; j++, p2 += nk, p1++)
> 			*p1 = p2; /* a[i][j]= a[0][0]+i*nj*nk+j*nk  */
45,46c48,51
< void free3d(double ***a)
< { FREE(**a);FREE(*a);FREE(a);
---
> void free3d(double ***a) {
> 	FREE(**a);
> 	FREE(*a);
> 	FREE(a);
51c56,57
< { double **a,*p,**dum;
---
> {
> 	double **a, *p, **dum;
54c60,61
<   for (p= *a,dum=a;dum<a+ni;dum++,p+=nj) *dum = p; 
---
> 	for (p = *a, dum = a; dum < a + ni; dum++, p += nj)
> 		*dum = p;
58c65,68
< void free2d(double **a) {FREE(*a);FREE(a);}
---
> void free2d(double **a) {
> 	FREE(*a);
> 	FREE(a);
> }
60,63c70,74
< void fit_magic(double *X,double *sp,double **S,double *H,double *gamma,double *scale,
<                int *control,double rank_tol,double yy,double *y0,double *y1,double *U1,
<                double *V,double *d,double *b,double *score,double *norm,double *delta,int *rank,
<                double *norm_const,int *n_score,int *nt)
---
> void fit_magic(double *X, double *sp, double **S, double *H, double *gamma,
> 		double *scale, int *control, double rank_tol, double yy, double *y0,
> 		double *y1, double *U1, double *V, double *d, double *b, double *score,
> 		double *norm, double *delta, int *rank, double *norm_const,
> 		int *n_score, int *nt)
103c114,115
< { double *St,*p,*p1,xx,*R,*Vt,*a,trA,yAy,yAAy;
---
> {
> 	double *St, *p, *p1, xx, *R, *Vt, *a, trA, yAy, yAAy;
105c117,119
<   m=control[4];n=control[1];q=control[2];
---
> 	m = control[4];
> 	n = control[1];
> 	q = control[2];
109,110c123,129
<   for (p=St;p<St+q*q;p++,H++) *p = *H; 
<   for (k=0;k<m;k++) { xx=exp(sp[k]);for (p=St,p1=S[k];p<St+q*q;p++,p1++) *p += *p1 * xx;}
---
> 		for (p = St; p < St + q * q; p++, H++)
> 			*p = *H;
> 	for (k = 0; k < m; k++) {
> 		xx = exp(sp[k]);
> 		for (p = St, p1 = S[k]; p < St + q * q; p++, p1++)
> 			*p += *p1 * xx;
> 	}
112,113c131,134
<   if (m>0||control[3]) mroot(St,&rank_S,&q); /* St replaced by its square root */
<   else rank_S=0;
---
> 	if (m > 0 || control[3])
> 		mroot(St, &rank_S, &q); /* St replaced by its square root */
> 	else
> 		rank_S = 0;
120c141,143
<   for (j=0;j<q;j++) for (i=q;i<r;i++) R[i+r*j]=St[(i-q)+rank_S*j];
---
> 	for (j = 0; j < q; j++)
> 		for (i = q; i < r; i++)
> 			R[i + r * j] = St[(i - q) + rank_S * j];
126,127c149,152
<   *rank=q;xx=d[0]*rank_tol;
<   while(d[*rank-1]<xx) (*rank)--;
---
> 	*rank = q;
> 	xx = d[0] * rank_tol;
> 	while (d[*rank - 1] < xx)
> 		(*rank)--;
129c154,156
<   for (i=0;i<q;i++) for (j=0;j< *rank;j++) V[i+q*j]=Vt[j+q*i];
---
> 	for (i = 0; i < q; i++)
> 		for (j = 0; j < *rank; j++)
> 			V[i + q * j] = Vt[j + q * i];
131c158,160
<   for (i=0;i<q;i++) for (j=0;j< *rank;j++) U1[i+q*j]=R[i+r*j];
---
> 	for (i = 0; i < q; i++)
> 		for (j = 0; j < *rank; j++)
> 			U1[i + q * j] = R[i + r * j];
133c162,166
<   for (i=0;i< *rank;i++) { for (xx=0.0,j=0;j<q;j++) xx += U1[j + i*q]*y0[j];y1[i]=xx;}
---
> 	for (i = 0; i < *rank; i++) {
> 		for (xx = 0.0, j = 0; j < q; j++)
> 			xx += U1[j + i * q] * y0[j];
> 		y1[i] = xx;
> 	}
135,137c168,176
<   for (yAy=0.0,i=0;i< *rank;i++) yAy += y1[i]*y1[i];
<   for (i=0;i<q;i++) { for (xx=0.0,j=0;j< *rank;j++) xx += U1[i + q*j]*y1[j];b[i]=xx;}
<   for (yAAy=0.0,i=0;i<q;i++) yAAy += b[i]*b[i];
---
> 	for (yAy = 0.0, i = 0; i < *rank; i++)
> 		yAy += y1[i] * y1[i];
> 	for (i = 0; i < q; i++) {
> 		for (xx = 0.0, j = 0; j < *rank; j++)
> 			xx += U1[i + q * j] * y1[j];
> 		b[i] = xx;
> 	}
> 	for (yAAy = 0.0, i = 0; i < q; i++)
> 		yAAy += b[i] * b[i];
139c178,179
<   if (*norm<0.0) *norm=0.0; /* avoid a rounding error -ve */
---
> 	if (*norm < 0.0)
> 		*norm = 0.0; /* avoid a rounding error -ve */
141c181,182
<   for (trA=0.0,i=0;i<q* *rank;i++) trA += U1[i]*U1[i];
---
> 	for (trA = 0.0, i = 0; i < q * *rank; i++)
> 		trA += U1[i] * U1[i];
143,144c184,190
<   for (i=0;i<*rank;i++) a[i]=y1[i]/d[i];
<   for (i=0;i<q;i++) { for (xx=0.0,j=0;j< *rank;j++) xx += V[i + q*j]*a[j];b[i]=xx;} 
---
> 	for (i = 0; i < *rank; i++)
> 		a[i] = y1[i] / d[i];
> 	for (i = 0; i < q; i++) {
> 		for (xx = 0.0, j = 0; j < *rank; j++)
> 			xx += V[i + q * j] * a[j];
> 		b[i] = xx;
> 	}
147,156c193,212
<   xx = n - *gamma * trA;*delta=xx;
<   if (control[0]) {*score = n* (*norm+*norm_const)/(xx*xx);*scale= (*norm + *norm_const)/(n-trA);} /* use GCV */
<   else {*score = (*norm + *norm_const) / n - 2* *scale / n * xx + *scale; } /* UBRE/ approximate AIC */  
<   FREE(a);FREE(Vt);FREE(R);FREE(St);
< }
< 
< double *crude_grad(double *X,double *sp,double **Si,double *H,double *gamma,double *scale,
<                int *control,double rank_tol,double yy,double *y0,double *y1,double *U1,
<                double *V,double *d,double *b,double *score,double *norm,double *delta,int *rank,
< 		   double *norm_const,int *n_score,int *nt)
---
> 	xx = n - *gamma * trA;
> 	*delta = xx;
> 	if (control[0]) {
> 		*score = n * (*norm + *norm_const) / (xx * xx);
> 		*scale = (*norm + *norm_const) / (n - trA);
> 	} /* use GCV */
> 	else {
> 		*score = (*norm + *norm_const) / n - 2 * *scale / n * xx + *scale;
> 	} /* UBRE/ approximate AIC */
> 	FREE(a);
> 	FREE(Vt);
> 	FREE(R);
> 	FREE(St);
> }
> 
> double *crude_grad(double *X, double *sp, double **Si, double *H, double *gamma,
> 		double *scale, int *control, double rank_tol, double yy, double *y0,
> 		double *y1, double *U1, double *V, double *d, double *b, double *score,
> 		double *norm, double *delta, int *rank, double *norm_const,
> 		int *n_score, int *nt)
158c214,215
< { double ftol=1e-6,*grad,sc1,sc0,ds;
---
> {
> 	double ftol = 1e-6, *grad, sc1, sc0, ds;
160c217,218
<   fit_magic(X,sp,Si,H,gamma,scale,control,rank_tol,yy,y0,y1,U1,V,d,b,&sc0,norm,delta,rank,norm_const,n_score,nt);
---
> 	fit_magic(X, sp, Si, H, gamma, scale, control, rank_tol, yy, y0, y1, U1, V,
> 			d, b, &sc0, norm, delta, rank, norm_const, n_score, nt);
162,163c220,221
<   for (i=0;i<control[4];i++)
<   { ds=fabs(sp[i])*ftol;
---
> 	for (i = 0; i < control[4]; i++) {
> 		ds = fabs(sp[i]) * ftol;
165,166c223,226
<     fit_magic(X,sp,Si,H,gamma,scale,control,rank_tol,yy,y0,y1,U1,V,d,b,&sc1,norm,delta,rank,norm_const,n_score,nt);
<     grad[i]=(sc1-sc0)/ds;sp[i] -= ds;
---
> 		fit_magic(X, sp, Si, H, gamma, scale, control, rank_tol, yy, y0, y1, U1,
> 				V, d, b, &sc1, norm, delta, rank, norm_const, n_score, nt);
> 		grad[i] = (sc1 - sc0) / ds;
> 		sp[i] -= ds;
171,173c231,234
< double **crude_hess(double *X,double *sp,double **Si,double *H,double *gamma,double *scale,
<                int *control,double rank_tol,double yy,double *y0,double *y1,double *U1,
<                double *V,double *d,double *b,double *score,double *norm,double *delta,int *rank,
---
> double **crude_hess(double *X, double *sp, double **Si, double *H,
> 		double *gamma, double *scale, int *control, double rank_tol, double yy,
> 		double *y0, double *y1, double *U1, double *V, double *d, double *b,
> 		double *score, double *norm, double *delta, int *rank,
176c237,238
< { int m,i,j;
---
> {
> 	int m, i, j;
180,182c242,245
<   g0=crude_grad(X,sp,Si,H,gamma,scale,control,rank_tol,yy,y0,y1,U1,V,d,b,score,norm,delta,rank,norm_const,n_score,nt);
<   for (i=0;i<m;i++)
<   { ds=fabs(sp[i])*ftol;
---
> 	g0 = crude_grad(X, sp, Si, H, gamma, scale, control, rank_tol, yy, y0, y1,
> 			U1, V, d, b, score, norm, delta, rank, norm_const, n_score, nt);
> 	for (i = 0; i < m; i++) {
> 		ds = fabs(sp[i]) * ftol;
184,185c247,251
<     g1=crude_grad(X,sp,Si,H,gamma,scale,control,rank_tol,yy,y0,y1,U1,V,d,b,score,norm,delta,rank,norm_const,n_score,nt);
<     for (j=0;j<m;j++) hess[i][j] = (g1[j]-g0[j])/ds; 
---
> 		g1 = crude_grad(X, sp, Si, H, gamma, scale, control, rank_tol, yy, y0,
> 				y1, U1, V, d, b, score, norm, delta, rank, norm_const, n_score,
> 				nt);
> 		for (j = 0; j < m; j++)
> 			hess[i][j] = (g1[j] - g0[j]) / ds;
191,193c257,261
< void magic_gH(double *U1U1,double **M,double **K,double *VS,double **My,double **Ky,double **yK,double **hess,
<               double *grad,double *dnorm,double *ddelta,double *sp,double **d2norm,double **d2delta,double *S,
<               double *U1,double *V,double *d,double *y1,int rank,int q,int m,int *cS,int *cucS,int gcv,double *gamma,double *scale,
---
> void magic_gH(double *U1U1, double **M, double **K, double *VS, double **My,
> 		double **Ky, double **yK, double **hess, double *grad, double *dnorm,
> 		double *ddelta, double *sp, double **d2norm, double **d2delta,
> 		double *S, double *U1, double *V, double *d, double *y1, int rank,
> 		int q, int m, int *cS, int *cucS, int gcv, double *gamma, double *scale,
202c270,271
< { double *p,*p1,*p2,*p3,*p4,xx,xx1,x1,x2,*VSi;
---
> {
> 	double *p, *p1, *p2, *p3, *p4, xx, xx1, x1, x2, *VSi;
223c292,295
<       bt=1;ct=0;r=rank;c= *ip;
---
> 			bt = 1;
> 			ct = 0;
> 			r = rank;
> 			c = *ip;
227,228c299,304
<       for (p1=d;p1<d+rank;p1++,p2++) *p2 /= *p1;   /* D^{-1} V' S_i^0.5 */
<       bt=1;ct=0;r= *ip;c= rank;
---
> 				for (p1 = d; p1 < d + rank; p1++, p2++)
> 					*p2 /= *p1; /* D^{-1} V' S_i^0.5 */
> 			bt = 1;
> 			ct = 0;
> 			r = *ip;
> 			c = rank;
230c306,307
<       bt=ct=0;r=c=rank;
---
> 			bt = ct = 0;
> 			r = c = rank;
232c309,311
<       bt=0;ct=1;r=c=rank;
---
> 			bt = 0;
> 			ct = 1;
> 			r = c = rank;
235c314,318
<       { for (xx=0.0,p3=y1;p3<y1+rank;p3++,p2++) xx += *p3 * *p2;*p1 = xx;}
---
> 			{
> 				for (xx = 0.0, p3 = y1; p3 < y1 + rank; p3++, p2++)
> 					xx += *p3 * *p2;
> 				*p1 = xx;
> 			}
237c320,324
<       { for (xx=0.0,p3=y1;p3<y1+rank;p3++,p2++) xx += *p3 * *p2;*p1 = xx;}
---
> 			{
> 				for (xx = 0.0, p3 = y1; p3 < y1 + rank; p3++, p2++)
> 					xx += *p3 * *p2;
> 				*p1 = xx;
> 			}
239c326,331
<       { for (xx=0.0,p4=p2,p3=y1;p3<y1+rank;p3++,p4+=rank) xx += *p3 * *p4;*p1 = xx;}
---
> 			{
> 				for (xx = 0.0, p4 = p2, p3 = y1; p3 < y1 + rank; p3++, p4 +=
> 						rank)
> 					xx += *p3 * *p4;
> 				*p1 = xx;
> 			}
243,247c335,344
<   for (i=0;i<m;i++) 
<   { for (xx=0.0,p=K[i];p<K[i]+rank*rank;p+=rank+1) xx += *p;ddelta[i]= *gamma * xx * exp(sp[i]);
<     for (j=0;j<=i;j++)
<     { for (xx=0.0,p=M[j],p1=K[i];p<M[j]+rank*rank;p++,p1++) xx += *p * *p1;
<       d2delta[j][i]=d2delta[i][j]= - *gamma*2*exp(sp[i]+sp[j])*xx; 
---
> 	for (i = 0; i < m; i++) {
> 		for (xx = 0.0, p = K[i]; p < K[i] + rank * rank; p += rank + 1)
> 			xx += *p;
> 		ddelta[i] = *gamma * xx * exp(sp[i]);
> 		for (j = 0; j <= i; j++) {
> 			for (xx = 0.0, p = M[j], p1 = K[i]; p < M[j] + rank * rank;
> 					p++, p1++)
> 				xx += *p * *p1;
> 			d2delta[j][i] = d2delta[i][j] = -*gamma * 2 * exp(sp[i] + sp[j])
> 					* xx;
251c348,350
<     for (xx=0.0,p=y1,p1=Ky[i],p2=My[i];p<y1+rank;p++,p1++,p2++) xx += *p *( *p2 - *p1);
---
> 		for (xx = 0.0, p = y1, p1 = Ky[i], p2 = My[i]; p < y1 + rank;
> 				p++, p1++, p2++)
> 			xx += *p * (*p2 - *p1);
253,254c352,354
<     for (j=0;j<=i;j++)
<     { for (xx=0.0,p1=My[i],p2=My[j],p3=Ky[i],p4=Ky[j],p=yK[i];p1<My[i]+rank;p++,p1++,p2++,p3++,p4++)
---
> 		for (j = 0; j <= i; j++) {
> 			for (xx = 0.0, p1 = My[i], p2 = My[j], p3 = Ky[i], p4 = Ky[j], p =
> 					yK[i]; p1 < My[i] + rank; p++, p1++, p2++, p3++, p4++)
261,266c361,368
<   if (gcv)
<   { norm += *norm_const; /* inflate the residual sum of squares by the supplied norm constant */
<     xx = n/(delta*delta);xx1= xx*2*norm/delta;
<     x1 = -2*xx/delta;x2=3*xx1/delta;
<     for (i=0;i<m;i++) 
<     { grad[i]=xx*dnorm[i]-xx1*ddelta[i];
---
> 	if (gcv) {
> 		norm += *norm_const; /* inflate the residual sum of squares by the supplied norm constant */
> 		xx = n / (delta * delta);
> 		xx1 = xx * 2 * norm / delta;
> 		x1 = -2 * xx / delta;
> 		x2 = 3 * xx1 / delta;
> 		for (i = 0; i < m; i++) {
> 			grad[i] = xx * dnorm[i] - xx1 * ddelta[i];
268,270c370,373
<       hess[i][j]=hess[j][i]=x1*(ddelta[j]*dnorm[i]+ddelta[i]*dnorm[j])+
<                  xx*d2norm[i][j]+x2*ddelta[i]*ddelta[j] -
<                  xx1*d2delta[i][j];    
---
> 				hess[i][j] = hess[j][i] = x1
> 						* (ddelta[j] * dnorm[i] + ddelta[i] * dnorm[j])
> 						+ xx * d2norm[i][j] + x2 * ddelta[i] * ddelta[j]
> 						- xx1 * d2delta[i][j];
272,275c375,380
<   } else
<   { for (i=0;i<m;i++) 
<     { grad[i]=( dnorm[i] - 2* *scale*ddelta[i])/ n;
<       for (j=0;j<=i;j++) hess[i][j]=hess[j][i]=(d2norm[i][j]-2* *scale*d2delta[i][j])/ n;
---
> 	} else {
> 		for (i = 0; i < m; i++) {
> 			grad[i] = (dnorm[i] - 2 * *scale * ddelta[i]) / n;
> 			for (j = 0; j <= i; j++)
> 				hess[i][j] = hess[j][i] = (d2norm[i][j]
> 						- 2 * *scale * d2delta[i][j]) / n;
283,285c388,390
< 
< void magic(double *y,double *X,double *sp0,double *def_sp,double *S,double *H,double *L,double *lsp0,
<            double *gamma,double *scale,int *control,int *cS,double *rank_tol,double *tol,double *b,
---
> void magic(double *y, double *X, double *sp0, double *def_sp, double *S,
> 		double *H, double *L, double *lsp0, double *gamma, double *scale,
> 		int *control, int *cS, double *rank_tol, double *tol, double *b,
369,373c474,483
< { int *pi,*pivot,q,n,autoinit,ScS,m,mp,i,j,tp,k,use_sd=0,rank,converged,iter=0,ok,*cucS,
<     gcv,try,fit_call=0,step_fail=0,max_half,*spok,def_supplied,use_dsyevd=1,L_exists,TRUE=1,FALSE=0;
<   double *sp=NULL,*p,*p1,*p2,*tau,xx,*y1,*y0,yy,**Si=NULL,*work,score,*sd_step,*n_step,*U1,*V,*d,**M,**K,
<          *VS,*U1U1,**My,**Ky,**yK,*dnorm,*ddelta,**d2norm,**d2delta,norm,delta,*grad,**hess,*nsp,
<     min_score,*step,d_score=1e10,*ev=NULL,*u,msg=0.0,Xms,*rSms,*bag,*bsp,sign,*grad1,*u0,*R;
---
> {
> 	int *pi, *pivot, q, n, autoinit, ScS, m, mp, i, j, tp, k, use_sd = 0, rank,
> 			converged, iter = 0, ok, *cucS, gcv, try, fit_call = 0, step_fail =
> 					0, max_half, *spok, def_supplied, use_dsyevd = 1, L_exists,
> 			TRUE = 1, FALSE = 0;
> 	double *sp = NULL, *p, *p1, *p2, *tau, xx, *y1, *y0, yy, **Si = NULL, *work,
> 			score, *sd_step, *n_step, *U1, *V, *d, **M, **K, *VS, *U1U1, **My,
> 			**Ky, **yK, *dnorm, *ddelta, **d2norm, **d2delta, norm, delta,
> 			*grad, **hess, *nsp, min_score, *step, d_score = 1e10, *ev = NULL,
> 			*u, msg = 0.0, Xms, *rSms, *bag, *bsp, sign, *grad1, *u0, *R;
382c492,497
<   gcv=control[0];q=control[2];n=control[1];m=control[4];max_half=control[5];mp=control[6];
---
> 	gcv = control[0];
> 	q = control[2];
> 	n = control[1];
> 	m = control[4];
> 	max_half = control[5];
> 	mp = control[6];
397,398c512,516
<   for (i=1;i<m;i++) cucS[i] = cucS[i-1] + cS[i-1];
<   ScS=0;for (pi=cS;pi<cS+m;pi++) ScS+= *pi;  /* total columns of input S */
---
> 	for (i = 1; i < m; i++)
> 		cucS[i] = cucS[i - 1] + cS[i - 1];
> 	ScS = 0;
> 	for (pi = cS; pi < cS + m; pi++)
> 		ScS += *pi; /* total columns of input S */
402,403c520,524
<   { for (pi=pivot,p2=work;p2<work+q;pi++,p2++) *p2 = p[*pi];  /* apply pivot into work */
<     for (p1=p,p2=work;p1<p+q;p1++,p2++) *p1 = *p2;  /* copy back into S */
---
> 	{
> 		for (pi = pivot, p2 = work; p2 < work + q; pi++, p2++)
> 			*p2 = p[*pi]; /* apply pivot into work */
> 		for (p1 = p, p2 = work; p1 < p + q; p1++, p2++)
> 			*p1 = *p2; /* copy back into S */
406,410c527,530
<   if (control[3])
<   { for (j=0;j<q;j++)
<      { for (i=0;i<q;i++) work[i]=H[pivot[i]+q*j];
<       for (i=0;i<q;i++) H[i+q*j]=work[i]; 
<     }
---
> 	if (control[3]) {
> 		for (j = 0; j < q; j++) {
> 			for (i = 0; i < q; i++)
> 				work[i] = H[pivot[i] + q * j];
412,413c532,538
<     { for (j=0;j<q;j++) work[j]=H[i+pivot[j]*q];
<       for (j=0;j<q;j++) H[i+q*j]=work[j]; 
---
> 				H[i + q * j] = work[i];
> 		}
> 		for (i = 0; i < q; i++) {
> 			for (j = 0; j < q; j++)
> 				work[j] = H[i + pivot[j] * q];
> 			for (j = 0; j < q; j++)
> 				H[i + q * j] = work[j];
420,421c545,548
<   for (p=y,p1=y0;p<y+n;p++,p1++) *p1 = *p;
<   tp=1;i=1;/*left=1;mgcv_qrqy(y0,X,tau,&n,&i,&q,&left,&tp);*/ /* first q elements are y1 */
---
> 	for (p = y, p1 = y0; p < y + n; p++, p1++)
> 		*p1 = *p;
> 	tp = 1;
> 	i = 1;/*left=1;mgcv_qrqy(y0,X,tau,&n,&i,&q,&left,&tp);*//* first q elements are y1 */
425c552,553
<   for (yy=0.0,p=y;p<y+n;p++) yy += *p * *p;
---
> 	for (yy = 0.0, p = y; p < y + n; p++)
> 		yy += *p * *p;
428,431c556,561
<   if (m>0)
<   { Si=array2d(m,q*q);
<     i=0;j=1;
<     for (p=S,k=0;k<m;p+=cS[k]*q,k++)  mgcv_mmult(Si[k],p,p,&i,&j,&q,&q,cS+k);   
---
> 	if (m > 0) {
> 		Si = array2d(m, q * q);
> 		i = 0;
> 		j = 1;
> 		for (p = S, k = 0; k < m; p += cS[k] * q, k++)
> 			mgcv_mmult(Si[k], p, p, &i, &j, &q, &q, cS + k);
436c566,570
<   if (mp<0) { L_exists=0;mp=m;} else L_exists=1;
---
> 	if (mp < 0) {
> 		L_exists = 0;
> 		mp = m;
> 	} else
> 		L_exists = 1;
438c572,573
<   if (m>0) sp = (double *)CALLOC((size_t)m,sizeof(double)); /* to hold actual log(sp[i]) terms multiplying penalties */
---
> 	if (m > 0)
> 		sp = (double *) CALLOC((size_t) m, sizeof(double)); /* to hold actual log(sp[i]) terms multiplying penalties */
440,441c575,586
<   autoinit=0;for (p=sp0;p<sp0+mp;p++) if (*p <=0.0) { autoinit=1;break;} /* autoinitialize s.p.s? */ 
<   def_supplied=1; for (p=def_sp;p<def_sp+mp;p++) if (*p <=0.0) { def_supplied=0;break;} 
---
> 	autoinit = 0;
> 	for (p = sp0; p < sp0 + mp; p++)
> 		if (*p <= 0.0) {
> 			autoinit = 1;
> 			break;
> 		} /* autoinitialize s.p.s? */
> 	def_supplied = 1;
> 	for (p = def_sp; p < def_sp + mp; p++)
> 		if (*p <= 0.0) {
> 			def_supplied = 0;
> 			break;
> 		}
444c589,591
<     error(_("magic requires smoothing parameter starting values if L supplied"));
---
> 		error(
> 				_(
> 						"magic requires smoothing parameter starting values if L supplied"));
451c598,599
<   { rSms=(double *)CALLOC((size_t)m,sizeof(double));
---
> 	{
> 		rSms = (double *) CALLOC((size_t) m, sizeof(double));
453,456c601,611
<     Xms=0.0;for (j=0;j<q;j++) for (i=0;i<=j;i++) { xx=R[i+q*j];Xms+=xx*xx;}
<     p=S;Xms/=n*q;
<     for (i=0;i<m;i++)
<     { for (xx=0.0,p=Si[i];p<Si[i]+q*q;p+=q+1) xx += *p;
---
> 		Xms = 0.0;
> 		for (j = 0; j < q; j++)
> 			for (i = 0; i <= j; i++) {
> 				xx = R[i + q * j];
> 				Xms += xx * xx;
> 			}
> 		p = S;
> 		Xms /= n * q;
> 		for (i = 0; i < m; i++) {
> 			for (xx = 0.0, p = Si[i]; p < Si[i] + q * q; p += q + 1)
> 				xx += *p;
460c615,618
<   } else { Xms=0.0;rSms=NULL;}
---
> 	} else {
> 		Xms = 0.0;
> 		rSms = NULL;
> 	}
462,463c620,625
<   if (autoinit) for (i=0;i<mp;i++) sp0[i]=log(def_sp[i]);
<   else for (i=0;i<mp;i++) sp0[i]=log(sp0[i]);  
---
> 	if (autoinit)
> 		for (i = 0; i < mp; i++)
> 			sp0[i] = log(def_sp[i]);
> 	else
> 		for (i = 0; i < mp; i++)
> 			sp0[i] = log(sp0[i]);
466,467c628,633
<     i=0;j=1;if (mp) mgcv_mmult(sp,L,sp0,&i,&i,&m,&j,&mp); /* form sp = L sp0  */
<     for (p=sp,p1=lsp0,p2=sp+m;p<p2;p++,p1++) *p += *p1; /* form sp= L sp0 + lsp0 */
---
> 		i = 0;
> 		j = 1;
> 		if (mp)
> 			mgcv_mmult(sp, L, sp0, &i, &i, &m, &j, &mp); /* form sp = L sp0  */
> 		for (p = sp, p1 = lsp0, p2 = sp + m; p < p2; p++, p1++)
> 			*p += *p1; /* form sp= L sp0 + lsp0 */
469c635,636
<     for (i=0;i<m;i++) sp[i]=sp0[i];
---
> 		for (i = 0; i < m; i++)
> 			sp[i] = sp0[i];
478c645,647
<   { M=array2d(m,q*q);K=array2d(m,q*q);
---
> 	{
> 		M = array2d(m, q * q);
> 		K = array2d(m, q * q);
480c649,651
<     My=array2d(m,q);Ky=array2d(m,q);yK=array2d(m,q);
---
> 		My = array2d(m, q);
> 		Ky = array2d(m, q);
> 		yK = array2d(m, q);
487c658,659
<     d2norm=array2d(m,m);d2delta=array2d(m,m);
---
> 		d2norm = array2d(m, m);
> 		d2delta = array2d(m, m);
496,498c668,671
<   } else 
<   { M=K=My=Ky=yK=hess=d2norm=d2delta=NULL;
<     u0=VS=grad1=grad=dnorm=ddelta=nsp=ev=u=U1U1=bsp=bag=NULL;
---
> 	} else {
> 		M = K = My = Ky = yK = hess = d2norm = d2delta = NULL;
> 		u0 = VS = grad1 = grad = dnorm = ddelta = nsp = ev = u = U1U1 = bsp =
> 				bag = NULL;
502c675,676
<   fit_magic(X,sp,Si,H,gamma,scale,control,*rank_tol,yy,y0,y1,U1,V,d,b,&score,&norm,&delta,&rank,norm_const,n_score,nt);
---
> 	fit_magic(X, sp, Si, H, gamma, scale, control, *rank_tol, yy, y0, y1, U1, V,
> 			d, b, &score, &norm, &delta, &rank, norm_const, n_score, nt);
507,509c681,684
<   if (mp>0&&!autoinit)
<   { magic_gH(U1U1,M,K,VS,My,Ky,yK,hess,grad1,dnorm,ddelta,sp,d2norm,d2delta,S,
<              U1,V,d,y1,rank,q,m,cS,cucS,gcv,gamma,scale,norm,delta,*n_score,norm_const);
---
> 	if (mp > 0 && !autoinit) {
> 		magic_gH(U1U1, M, K, VS, My, Ky, yK, hess, grad1, dnorm, ddelta, sp,
> 				d2norm, d2delta, S, U1, V, d, y1, rank, q, m, cS, cucS, gcv,
> 				gamma, scale, norm, delta, *n_score, norm_const);
514c689,691
<       i=0;j=1;mgcv_mmult(grad,L,grad1,&j,&i,&mp,&j,&m);
---
> 			i = 0;
> 			j = 1;
> 			mgcv_mmult(grad, L, grad1, &j, &i, &mp, &j, &m);
516c693,695
<       p = grad;grad=grad1;grad1=p;
---
> 			p = grad;
> 			grad = grad1;
> 			grad1 = p;
519,520c698,701
<     for (i=0;i<mp;i++) if (fabs(grad[i])<xx) 
<     { sp0[i]=log(def_sp[i]);ok=0;
---
> 		for (i = 0; i < mp; i++)
> 			if (fabs(grad[i]) < xx) {
> 				sp0[i] = log(def_sp[i]);
> 				ok = 0;
525,526c706,710
<       i=0;j=1;mgcv_mmult(sp,L,sp0,&i,&i,&m,&j,&mp); /* form sp = L sp0 */
<       for (p=sp,p1=lsp0,p2=sp+m;p<p2;p++,p1++) *p += *p1; /* form sp= L sp0 + lsp0 */
---
> 			i = 0;
> 			j = 1;
> 			mgcv_mmult(sp, L, sp0, &i, &i, &m, &j, &mp); /* form sp = L sp0 */
> 			for (p = sp, p1 = lsp0, p2 = sp + m; p < p2; p++, p1++)
> 				*p += *p1; /* form sp= L sp0 + lsp0 */
528c712,713
<       for (i=0;i<m;i++) sp[i]=sp0[i];
---
> 			for (i = 0; i < m; i++)
> 				sp[i] = sp0[i];
532,533c717,719
<       fit_magic(X,sp,Si,H,gamma,scale,control,*rank_tol,yy,y0,y1,
<       U1,V,d,b,&score,&norm,&delta,&rank,norm_const,n_score,nt);
---
> 			fit_magic(X, sp, Si, H, gamma, scale, control, *rank_tol, yy, y0,
> 					y1, U1, V, d, b, &score, &norm, &delta, &rank, norm_const,
> 					n_score, nt);
545,547c730,733
<     for (p=S,k=0;k<m;k++)
<     { for (j=0;j<cS[k];j++)
<       { for (xx=0.0,i=0;i<q;i++,p++) xx += *p * b[i]; 
---
> 		for (p = S, k = 0; k < m; k++) {
> 			for (j = 0; j < cS[k]; j++) {
> 				for (xx = 0.0, i = 0; i < q; i++, p++)
> 					xx += *p * b[i];
550c736,737
<       for (xx=0.0,j=0;j<cS[k];j++) xx+= d[j]*d[j];
---
> 			for (xx = 0.0, j = 0; j < cS[k]; j++)
> 				xx += d[j] * d[j];
558,564c745,757
<   if (mp>0)
<   { converged=0;iter=0;
<     while (!converged)
<     { iter++;
<       if (iter>400) error(_("magic, the gcv/ubre optimizer, failed to converge after 400 iterations."));
<       if (iter>1||(autoinit&&!def_supplied)) ok=1; /* try out step */
<       else ok=0; /* no step to try yet */
---
> 	if (mp > 0) {
> 		converged = 0;
> 		iter = 0;
> 		while (!converged) {
> 			iter++;
> 			if (iter > 400)
> 				error(
> 						_(
> 								"magic, the gcv/ubre optimizer, failed to converge after 400 iterations."));
> 			if (iter > 1 || (autoinit && !def_supplied))
> 				ok = 1; /* try out step */
> 			else
> 				ok = 0; /* no step to try yet */
566c759,762
<       if (use_sd) step=sd_step; else step=n_step;
---
> 			if (use_sd)
> 				step = sd_step;
> 			else
> 				step = n_step;
568,569c764,771
<       { try++; if (try==4&&!use_sd) {use_sd=1;step=sd_step;}
<         for (i=0;i<mp;i++) nsp[i]=sp0[i]+step[i];
---
> 			{
> 				try++;
> 				if (try == 4 && !use_sd) {
> 					use_sd = 1;
> 					step = sd_step;
> 				}
> 				for (i = 0; i < mp; i++)
> 					nsp[i] = sp0[i] + step[i];
571,572c773,777
<           i=0;j=1;mgcv_mmult(sp,L,nsp,&i,&i,&m,&j,&mp); /* form sp = L nsp */
<           for (p=sp,p1=lsp0,p2=sp+m;p<p2;p++,p1++) *p += *p1; /* form sp= L nsp + lsp0 */
---
> 					i = 0;
> 					j = 1;
> 					mgcv_mmult(sp, L, nsp, &i, &i, &m, &j, &mp); /* form sp = L nsp */
> 					for (p = sp, p1 = lsp0, p2 = sp + m; p < p2; p++, p1++)
> 						*p += *p1; /* form sp= L nsp + lsp0 */
574c779,780
<           for (i=0;i<m;i++) sp[i]=nsp[i];
---
> 					for (i = 0; i < m; i++)
> 						sp[i] = nsp[i];
576,577c782,784
<         fit_magic(X,sp,Si,H,gamma,scale,control,*rank_tol,yy,y0,y1,
<                   U1,V,d,b,&score,&norm,&delta,&rank,norm_const,n_score,nt);
---
> 				fit_magic(X, sp, Si, H, gamma, scale, control, *rank_tol, yy,
> 						y0, y1, U1, V, d, b, &score, &norm, &delta, &rank,
> 						norm_const, n_score, nt);
580c787,788
<         { ok=0;
---
> 				{
> 					ok = 0;
583c791,792
<           for (i=0;i<mp;i++) sp0[i]=nsp[i];
---
> 					for (i = 0; i < mp; i++)
> 						sp0[i] = nsp[i];
585c794,795
<         for (i=0;i<mp;i++) step[i]/=2;
---
> 					for (i = 0; i < mp; i++)
> 						step[i] /= 2;
587,588c797,801
<         for (i=0;i<mp;i++) step[i]=0.0; /* reset sp's to best so far before giving up */
<         if (try==max_half) {ok=0;} /* give up */
---
> 					for (i = 0; i < mp; i++)
> 						step[i] = 0.0; /* reset sp's to best so far before giving up */
> 				if (try == max_half) {
> 					ok = 0;
> 				} /* give up */
591,596c804,819
<       { converged=1;
<         if (d_score> *tol*(1+min_score)) converged=0;
<         for (xx=0.0,i=0;i<mp;i++) xx+=grad[i]*grad[i];xx=sqrt(xx); 
<         if (xx>pow(*tol,1/3.0)*(1+fabs(min_score))) converged=0;
<         if (try==max_half) converged=1; /* can't improve score */
<         if (converged) { msg=sqrt(xx*xx/mp);if (try==max_half) step_fail=1;}
---
> 			{
> 				converged = 1;
> 				if (d_score > *tol * (1 + min_score))
> 					converged = 0;
> 				for (xx = 0.0, i = 0; i < mp; i++)
> 					xx += grad[i] * grad[i];
> 				xx = sqrt(xx);
> 				if (xx > pow(*tol, 1 / 3.0) * (1 + fabs(min_score)))
> 					converged = 0;
> 				if (try == max_half)
> 					converged = 1; /* can't improve score */
> 				if (converged) {
> 					msg = sqrt(xx * xx / mp);
> 					if (try == max_half)
> 						step_fail = 1;
> 				}
601,603c823,829
<       { if (L_exists) {
<           i=0;j=1;mgcv_mmult(sp,L,sp0,&i,&i,&m,&j,&mp); /* form sp = L sp0 */
<           for (p=sp,p1=lsp0,p2=sp+m;p<p2;p++,p1++) *p += *p1; /* form sp= L sp0 + lsp0 */
---
> 			{
> 				if (L_exists) {
> 					i = 0;
> 					j = 1;
> 					mgcv_mmult(sp, L, sp0, &i, &i, &m, &j, &mp); /* form sp = L sp0 */
> 					for (p = sp, p1 = lsp0, p2 = sp + m; p < p2; p++, p1++)
> 						*p += *p1; /* form sp= L sp0 + lsp0 */
605c831,832
<           for (i=0;i<m;i++) sp[i]=sp0[i];
---
> 					for (i = 0; i < m; i++)
> 						sp[i] = sp0[i];
607,608c834,837
<         magic_gH(U1U1,M,K,VS,My,Ky,yK,hess,grad1,dnorm,ddelta,sp,d2norm,d2delta,S,
< 		 U1,V,d,y1,rank,q,m,cS,cucS,gcv,gamma,scale,norm,delta,*n_score,norm_const);
---
> 				magic_gH(U1U1, M, K, VS, My, Ky, yK, hess, grad1, dnorm, ddelta,
> 						sp, d2norm, d2delta, S, U1, V, d, y1, rank, q, m, cS,
> 						cucS, gcv, gamma, scale, norm, delta, *n_score,
> 						norm_const);
610c839,841
<         for (i=0;i<m;i++) for (j=0;j<m;j++) u[i+m*j]=hess[i][j]; 
---
> 				for (i = 0; i < m; i++)
> 					for (j = 0; j < m; j++)
> 						u[i + m * j] = hess[i][j];
612c843,845
<           i=0;j=1;mgcv_mmult(grad,L,grad1,&j,&i,&mp,&j,&m);
---
> 					i = 0;
> 					j = 1;
> 					mgcv_mmult(grad, L, grad1, &j, &i, &mp, &j, &m);
616c849,851
<           p = grad;grad=grad1;grad1=p;
---
> 					p = grad;
> 					grad = grad1;
> 					grad1 = p;
620c855,860
<         use_sd=0;for (p=ev;p<ev+mp;p++) if (*p<0.0) {use_sd=1;break;} /* check hessian +ve def */
---
> 				use_sd = 0;
> 				for (p = ev; p < ev + mp; p++)
> 					if (*p < 0.0) {
> 						use_sd = 1;
> 						break;
> 					} /* check hessian +ve def */
622,624c862,875
<         { for (i=0;i<mp;i++) { for (xx=0.0,j=0;j<mp;j++) xx+=u[j+mp*i]*grad[j];sd_step[i]=xx/ev[i];}
<           for (i=0;i<mp;i++) { for (xx=0.0,j=0;j<mp;j++) xx+=u[i+mp*j]*sd_step[j];n_step[i]= -xx;}
<           for (xx=fabs(n_step[0]),i=1;i<mp;i++) if (fabs(n_step[i])>xx) xx=fabs(n_step[i]);
---
> 				{
> 					for (i = 0; i < mp; i++) {
> 						for (xx = 0.0, j = 0; j < mp; j++)
> 							xx += u[j + mp * i] * grad[j];
> 						sd_step[i] = xx / ev[i];
> 					}
> 					for (i = 0; i < mp; i++) {
> 						for (xx = 0.0, j = 0; j < mp; j++)
> 							xx += u[i + mp * j] * sd_step[j];
> 						n_step[i] = -xx;
> 					}
> 					for (xx = fabs(n_step[0]), i = 1; i < mp; i++)
> 						if (fabs(n_step[i]) > xx)
> 							xx = fabs(n_step[i]);
626c877,881
<           { xx=5.0/xx;for (i=0;i<mp;i++) n_step[i]*=xx;}
---
> 					{
> 						xx = 5.0 / xx;
> 						for (i = 0; i < mp; i++)
> 							n_step[i] *= xx;
> 					}
628,629c883,887
<         for (xx=fabs(grad[0]),i=1;i<mp;i++) if (xx<fabs(grad[i])) xx=fabs(grad[i]);
<         for (i=0;i<mp;i++) sd_step[i]= -grad[i]/xx;     
---
> 				for (xx = fabs(grad[0]), i = 1; i < mp; i++)
> 					if (xx < fabs(grad[i]))
> 						xx = fabs(grad[i]);
> 				for (i = 0; i < mp; i++)
> 					sd_step[i] = -grad[i] / xx;
634,636c892,898
<     for (k=0;k<mp;k++)
<     { ok=5;xx=2.0; 
<       if (grad[k]<0.0) sign=1; else sign=-1;
---
> 		for (k = 0; k < mp; k++) {
> 			ok = 5;
> 			xx = 2.0;
> 			if (grad[k] < 0.0)
> 				sign = 1;
> 			else
> 				sign = -1;
638c900,901
<       { sp0[k] += sign*xx;
---
> 			{
> 				sp0[k] += sign * xx;
640,641c903,907
<           i=0;j=1;mgcv_mmult(sp,L,sp0,&i,&i,&m,&j,&mp); /* form sp = L sp0 */
<           for (p=sp,p1=lsp0,p2=sp+m;p<p2;p++,p1++) *p += *p1; /* form sp= L sp0 + lsp0 */
---
> 					i = 0;
> 					j = 1;
> 					mgcv_mmult(sp, L, sp0, &i, &i, &m, &j, &mp); /* form sp = L sp0 */
> 					for (p = sp, p1 = lsp0, p2 = sp + m; p < p2; p++, p1++)
> 						*p += *p1; /* form sp= L sp0 + lsp0 */
643c909,910
<           for (i=0;i<m;i++) sp[i]=sp0[i];
---
> 					for (i = 0; i < m; i++)
> 						sp[i] = sp0[i];
646,648c913,917
<         fit_magic(X,sp,Si,H,gamma,scale,control,*rank_tol,yy,y0,y1,U1,V,d,b,&score,&norm,&delta,&rank,norm_const,n_score,nt);
<         if (score<min_score)
<         { min_score=score; 
---
> 				fit_magic(X, sp, Si, H, gamma, scale, control, *rank_tol, yy,
> 						y0, y1, U1, V, d, b, &score, &norm, &delta, &rank,
> 						norm_const, n_score, nt);
> 				if (score < min_score) {
> 					min_score = score;
650c919,922
<         { ok=0;sp0[k] += -sign*xx;}
---
> 				{
> 					ok = 0;
> 					sp0[k] += -sign * xx;
> 				}
655,656c927,931
<       i=0;j=1; mgcv_mmult(sp,L,sp0,&i,&i,&m,&j,&mp); /* form sp = L nsp */
<       for (p=sp,p1=lsp0,p2=sp+m;p<p2;p++,p1++) *p += *p1; /* form sp= L sp0 + lsp0 */
---
> 			i = 0;
> 			j = 1;
> 			mgcv_mmult(sp, L, sp0, &i, &i, &m, &j, &mp); /* form sp = L nsp */
> 			for (p = sp, p1 = lsp0, p2 = sp + m; p < p2; p++, p1++)
> 				*p += *p1; /* form sp= L sp0 + lsp0 */
658c933,934
<       for (i=0;i<m;i++) sp[i]=sp0[i];
---
> 			for (i = 0; i < m; i++)
> 				sp[i] = sp0[i];
660c936,938
<     fit_magic(X,sp,Si,H,gamma,scale,control,*rank_tol,yy,y0,y1,U1,V,d,b,&score,&norm,&delta,&rank,norm_const,n_score,nt);
---
> 		fit_magic(X, sp, Si, H, gamma, scale, control, *rank_tol, yy, y0, y1,
> 				U1, V, d, b, &score, &norm, &delta, &rank, norm_const, n_score,
> 				nt);
663,666c941,962
<     free2d(M);free2d(K);free2d(My);free2d(Ky);free2d(yK);free2d(hess);
<     free2d(d2norm);free2d(d2delta);FREE(U1U1);FREE(rSms);FREE(u);
<     FREE(VS);FREE(grad);FREE(dnorm);FREE(ddelta);FREE(nsp);FREE(ev);
<     FREE(bsp);FREE(bag);FREE(spok);FREE(grad1);FREE(u0);
---
> 		free2d(M);
> 		free2d(K);
> 		free2d(My);
> 		free2d(Ky);
> 		free2d(yK);
> 		free2d(hess);
> 		free2d(d2norm);
> 		free2d(d2delta);
> 		FREE(U1U1);
> 		FREE(rSms);
> 		FREE(u);
> 		FREE(VS);
> 		FREE(grad);
> 		FREE(dnorm);
> 		FREE(ddelta);
> 		FREE(nsp);
> 		FREE(ev);
> 		FREE(bsp);
> 		FREE(bag);
> 		FREE(spok);
> 		FREE(grad1);
> 		FREE(u0);
672c968,969
<   for (j=0;j<q;j++,p2++) *p2 /= *p1; /* V now contains VD^{-1} */   
---
> 		for (j = 0; j < q; j++, p2++)
> 			*p2 /= *p1; /* V now contains VD^{-1} */
675c972,973
<   for (pi=pivot;pi<pivot+q;pi++,p1++) p2[*pi] = *p1;
---
> 		for (pi = pivot; pi < pivot + q; pi++, p1++)
> 			p2[*pi] = *p1;
677,678c975,980
<   for (i=0;i<q;i++) d[i]=b[i];for (i=0;i<q;i++) b[pivot[i]]=d[i]; /* unpivot parameters */
<   for (i=0;i<mp;i++) sp0[i]=exp(sp0[i]); /* exponentiate smoothing parameters */
---
> 	for (i = 0; i < q; i++)
> 		d[i] = b[i];
> 	for (i = 0; i < q; i++)
> 		b[pivot[i]] = d[i]; /* unpivot parameters */
> 	for (i = 0; i < mp; i++)
> 		sp0[i] = exp(sp0[i]); /* exponentiate smoothing parameters */
687c989,992
<   if (m>0) {FREE(sp);free2d(Si);}
---
> 	if (m > 0) {
> 		FREE(sp);
> 		free2d(Si);
> 	}
691,692c996,999
<     for (j=0;j<i;j++) V[i + q * j] = 0.0; 
<     for (j=i;j<q;j++) V[i + q * j] = R[i + q * j]; 
---
> 		for (j = 0; j < i; j++)
> 			V[i + q * j] = 0.0;
> 		for (j = i; j < q; j++)
> 			V[i + q * j] = R[i + q * j];
696c1003,1004
<   for (p1=X,p2=V,p=V+q*q;p2<p;p1++,p2++) *p1 = *p2; /* copy back to X */
---
> 	for (p1 = X, p2 = V, p = V + q * q; p2 < p; p1++, p2++)
> 		*p1 = *p2; /* copy back to X */
698,700c1006,1017
<   FREE(tau);FREE(pivot);FREE(work);FREE(y0);FREE(y1);
<   FREE(U1);FREE(V);FREE(d);FREE(sd_step);
<   FREE(n_step);FREE(R);FREE(cucS);
---
> 	FREE(tau);
> 	FREE(pivot);
> 	FREE(work);
> 	FREE(y0);
> 	FREE(y1);
> 	FREE(U1);
> 	FREE(V);
> 	FREE(d);
> 	FREE(sd_step);
> 	FREE(n_step);
> 	FREE(R);
> 	FREE(cucS);
diff -rEZbwB '--exclude=*.[lo,d,pdf,mo,po,tgz,gz,save]*' '--exclude=MD5' '--exclude=Makefile*' '--exclude=all.R' '--exclude=Changes' R-recommended/mgcv/src/mat.c Recommended/mgcv/src/mat.c
31a32
> #include "localization.h"
47c48
<     Rprintf("\nFailed to open file\n");
---
>     Rprintf(_("\nFailed to open file\n"));
69c70
<     Rprintf("\nFailed to open file\n");
---
>     Rprintf(_("\nFailed to open file\n"));
77c78
<    if (j!= *r * *c)  Rprintf("\nfile dim problem\n");
---
>    if (j != *r * *c)  Rprintf(_("\nfile dim problem\n"));
575c575,576
<   for (p0=piv,i=0;i<p;i++,p0++) *p0 = i; /* initialize pivot index */
---
> 	for (p0 = piv, i = 0; i < p; i++, p0++)
> 		*p0 = i; /* initialize pivot index */
581c582,583
<     for (x=0.0,a1 = a0 + n;a0<a1;a0++) x += *a0 * *a0;
---
> 		for (x = 0.0, a1 = a0 + n; a0 < a1; a0++)
> 			x += *a0 * *a0;
584c586,587
<   if (p<nb) nb = p;
---
> 	if (p < nb)
> 		nb = p;
590,591c593,597
<     nb = p-jb;if (nb>nb0) nb = nb0;/* attempted block size */
<     for (a0=F,a1=F+nb*pb;a0<a1;a0++) *a0 = 0.0; /* F[1:pb,1:nb] = 0 - i.e. clear F */
---
> 		nb = p - jb;
> 		if (nb > nb0)
> 			nb = nb0;/* attempted block size */
> 		for (a0 = F, a1 = F + nb * pb; a0 < a1; a0++)
> 			*a0 = 0.0; /* F[1:pb,1:nb] = 0 - i.e. clear F */
594,595c600,608
<       a0 = cn + k;x = *a0;q=k;a0++;
<       for (i=k+1;i<p;i++,a0++) if (*a0>x) { x = *a0;q=i; } /* find pivot col q */
---
> 			a0 = cn + k;
> 			x = *a0;
> 			q = k;
> 			a0++;
> 			for (i = k + 1; i < p; i++, a0++)
> 				if (*a0 > x) {
> 					x = *a0;
> 					q = i;
> 				} /* find pivot col q */
597,603c610,634
<         i = piv[q];piv[q]=piv[k];piv[k] = i;
<         x = cn[q];cn[q]=cn[k];cn[k] = x;
<         x = icn[q];icn[q]=icn[k];icn[k] = x;
<         Aq = A + q * (ptrdiff_t) n;Ak = A + k * (ptrdiff_t) n;a1 = Aq + n;
<         for (;Aq<a1;Aq++,Ak++) { x = *Aq; *Aq = *Ak; *Ak = x;} /* A[:,k] <-> A[:,q] */
<         Aq = F + q - jb;Ak = F + j;a1 = F + nb * (ptrdiff_t) pb;
<         for (;Aq<a1;Aq+=pb,Ak+=pb) { x = *Aq; *Aq = *Ak; *Ak = x;} /* F[q-jb,:] <-> F[j,:] */        
---
> 				i = piv[q];
> 				piv[q] = piv[k];
> 				piv[k] = i;
> 				x = cn[q];
> 				cn[q] = cn[k];
> 				cn[k] = x;
> 				x = icn[q];
> 				icn[q] = icn[k];
> 				icn[k] = x;
> 				Aq = A + q * (ptrdiff_t) n;
> 				Ak = A + k * (ptrdiff_t) n;
> 				a1 = Aq + n;
> 				for (; Aq < a1; Aq++, Ak++) {
> 					x = *Aq;
> 					*Aq = *Ak;
> 					*Ak = x;
> 				} /* A[:,k] <-> A[:,q] */
> 				Aq = F + q - jb;
> 				Ak = F + j;
> 				a1 = F + nb * (ptrdiff_t) pb;
> 				for (; Aq < a1; Aq += pb, Ak += pb) {
> 					x = *Aq;
> 					*Aq = *Ak;
> 					*Ak = x;
> 				} /* F[q-jb,:] <-> F[j,:] */
608c639,640
<       m = n-k;Ak = A + (ptrdiff_t)n * k + k;
---
> 			m = n - k;
> 			Ak = A + (ptrdiff_t) n * k + k;
611,612c643,648
<         rt = q/nt;if (rt*nt < q) rt++; /* rows per thread */
<         nth = nt; while (nth>1&&(nth-1)*rt>q) nth--; /* reduce number of threads if some empty */
---
> 				rt = q / nt;
> 				if (rt * nt < q)
> 					rt++; /* rows per thread */
> 				nth = nt;
> 				while (nth > 1 && (nth - 1) * rt > q)
> 					nth--; /* reduce number of threads if some empty */
614c650,653
<         for (i=0;i<nth-1;i++) { mb[i] = rt;kb[i+1]=kb[i]+rt;}
---
> 				for (i = 0; i < nth - 1; i++) {
> 					mb[i] = rt;
> 					kb[i + 1] = kb[i] + rt;
> 				}
625,626c664,666
<             F77_CALL(dgemv)(&nottrans, mb+i, &j,&dmone,A+jb*(ptrdiff_t)n+kb[i],&n,F+j,&pb,&done,
< 	                    A + (ptrdiff_t)n*k + kb[i], &one);
---
> 						F77_CALL(dgemv)(&nottrans, mb + i, &j, &dmone,
> 								A + jb * (ptrdiff_t) n + kb[i], &n, F + j, &pb,
> 								&done, A + (ptrdiff_t) n * k + kb[i], &one);
636c676,677
<       Ak--;*Ak = 1.0; /* for now, have Ak point to whole of v */
---
> 			Ak--;
> 			*Ak = 1.0; /* for now, have Ak point to whole of v */
642,643c683,688
<         rt = q/nt;if (rt*nt < q) rt++; /* rows per thread */
<         nth = nt; while (nth>1&&(nth-1)*rt>q) nth--; /* reduce number of threads if some empty */
---
> 				rt = q / nt;
> 				if (rt * nt < q)
> 					rt++; /* rows per thread */
> 				nth = nt;
> 				while (nth > 1 && (nth - 1) * rt > q)
> 					nth--; /* reduce number of threads if some empty */
645c690,693
<         for (i=0;i<nth-1;i++) { mb[i] = rt;kb[i+1]=kb[i]+rt;}
---
> 				for (i = 0; i < nth - 1; i++) {
> 					mb[i] = rt;
> 					kb[i + 1] = kb[i] + rt;
> 				}
656,657c704,707
< 	  F77_CALL(dgemv)(&trans, &m, mb+i,tau+k,A+(kb[i]+jb) * (ptrdiff_t) n+k,&n,
<                           Ak,&one,&dzero,F+kb[i]+(ptrdiff_t)j*pb, &one);
---
> 						F77_CALL(dgemv)(&trans, &m, mb + i, tau + k,
> 								A + (kb[i] + jb) * (ptrdiff_t) n + k, &n, Ak,
> 								&one, &dzero, F + kb[i] + (ptrdiff_t) j * pb,
> 								&one);
665,666c715,720
<         rt = q/nt;if (rt*nt < q) rt++; /* rows per thread */
<         nth = nt; while (nth>1&&(nth-1)*rt>q) nth--; /* reduce number of threads if some empty */
---
> 				rt = q / nt;
> 				if (rt * nt < q)
> 					rt++; /* rows per thread */
> 				nth = nt;
> 				while (nth > 1 && (nth - 1) * rt > q)
> 					nth--; /* reduce number of threads if some empty */
668c722,725
<         for (i=0;i<nth-1;i++) { mb[i] = rt;kb[i+1]=kb[i]+rt;}
---
> 				for (i = 0; i < nth - 1; i++) {
> 					mb[i] = rt;
> 					kb[i + 1] = kb[i] + rt;
> 				}
678c735,737
<   	    F77_CALL(dgemv)(&trans, &m, mb+i,&dmone,A+kb[i]* (ptrdiff_t)n+k,&n,Ak,&one,&dzero,work+kb[i]-jb, &one);
---
> 						F77_CALL(dgemv)(&trans, &m, mb + i, &dmone,
> 								A + kb[i] * (ptrdiff_t) n + k, &n, Ak, &one,
> 								&dzero, work + kb[i] - jb, &one);
683,684c742,747
<         rt = q/nt;if (rt*nt < q) rt++; /* rows per thread */
<         nth = nt; while (nth>1&&(nth-1)*rt>q) nth--; /* reduce number of threads if some empty */
---
> 				rt = q / nt;
> 				if (rt * nt < q)
> 					rt++; /* rows per thread */
> 				nth = nt;
> 				while (nth > 1 && (nth - 1) * rt > q)
> 					nth--; /* reduce number of threads if some empty */
686c749,752
<         for (i=0;i<nth-1;i++) { mb[i] = rt;kb[i+1]=kb[i]+rt;}
---
> 				for (i = 0; i < nth - 1; i++) {
> 					mb[i] = rt;
> 					kb[i + 1] = kb[i] + rt;
> 				}
689c755,757
< 	  F77_CALL(dgemv)(&nottrans, mb+i, &j,tau+k,F+kb[i],&pb,work,&one,&done,F+(ptrdiff_t)j*pb+kb[i], &one);
---
> 					F77_CALL(dgemv)(&nottrans, mb + i, &j, tau + k, F + kb[i],
> 							&pb, work, &one, &done,
> 							F + (ptrdiff_t) j * pb + kb[i], &one);
696,697c764,769
<         rt = q/nt;if (rt*nt < q) rt++; /* colss per thread */
<         nth = nt; while (nth>1&&(nth-1)*rt>q) nth--; /* reduce number of threads if some empty */
---
> 				rt = q / nt;
> 				if (rt * nt < q)
> 					rt++; /* colss per thread */
> 				nth = nt;
> 				while (nth > 1 && (nth - 1) * rt > q)
> 					nth--; /* reduce number of threads if some empty */
699c771,774
<         for (i=0;i<nth-1;i++) { mb[i] = rt;kb[i+1]=kb[i]+rt;}
---
> 				for (i = 0; i < nth - 1; i++) {
> 					mb[i] = rt;
> 					kb[i + 1] = kb[i] + rt;
> 				}
710,711c785,788
< 	    F77_CALL(dgemv)(&nottrans, mb+i, &q,&dmone,F+kb[i],&pb,A+(ptrdiff_t)jb*n+k,
< 	                    &n,&done,A+(kb[i]+jb)*(ptrdiff_t)n+k, &n); 
---
> 						F77_CALL(dgemv)(&nottrans, mb + i, &q, &dmone,
> 								F + kb[i], &pb, A + (ptrdiff_t) jb * n + k, &n,
> 								&done, A + (kb[i] + jb) * (ptrdiff_t) n + k,
> 								&n);
722c799,801
<         a0 = cn + k + 1;a1=cn + p;Aq = icn + k + 1;
---
> 				a0 = cn + k + 1;
> 				a1 = cn + p;
> 				Aq = icn + k + 1;
725c804,805
<           if (*a0<*Aq*tol) ok_norm = 0; /* cancellation error problem in downdate */ 
---
> 					if (*a0 < *Aq * tol)
> 						ok_norm = 0; /* cancellation error problem in downdate */
741,742c821,826
<       rt = m/nt;if (rt*nt < m) rt++; /* rows per thread */
<       nth = nt; while (nth>1&&(nth-1)*rt>m) nth--; /* reduce number of threads if some empty */
---
> 			rt = m / nt;
> 			if (rt * nt < m)
> 				rt++; /* rows per thread */
> 			nth = nt;
> 			while (nth > 1 && (nth - 1) * rt > m)
> 				nth--; /* reduce number of threads if some empty */
744c828,831
<       for (i=0;i<nth-1;i++) { mb[i] = rt;kb[i+1]=kb[i]+rt;}
---
> 			for (i = 0; i < nth - 1; i++) {
> 				mb[i] = rt;
> 				kb[i + 1] = kb[i] + rt;
> 			}
756c843,844
<           Ak = A + (k+1)*(ptrdiff_t) n + kb[i];Aq = A + jb * (ptrdiff_t) n + kb[i];
---
> 					Ak = A + (k + 1) * (ptrdiff_t) n + kb[i];
> 					Aq = A + jb * (ptrdiff_t) n + kb[i];
758c846,847
<           F77_CALL(dgemm)(&nottrans,&trans,mb+i,&rt,&nb,&dmone,Aq,&n,F+j+1,&pb,&done,Ak,&n);
---
> 					F77_CALL(dgemm)(&nottrans, &trans, mb + i, &rt, &nb, &dmone,
> 							Aq, &n, F + j + 1, &pb, &done, Ak, &n);
768c857,858
<           x=0.0; Ak = A + i * (ptrdiff_t)n; 
---
> 					x = 0.0;
> 					Ak = A + i * (ptrdiff_t) n;
771c861,862
<           for (;Ak<Aq;Ak++) x += *Ak * *Ak;
---
> 					for (; Ak < Aq; Ak++)
> 						x += *Ak * *Ak;
779c870,872
<   FREE(F); FREE(mb); FREE(kb);
---
> 	FREE(F);
> 	FREE(mb);
> 	FREE(kb);
824c917,919
<     i=piv[r]; piv[r] = piv[k];piv[k] = i;
---
> 		i = piv[r];
> 		piv[r] = piv[k];
> 		piv[k] = i;
826,828c921,928
<     xx = c[r];c[r] = c[k];c[k] = xx;
<     for (p0 = x + n * r, p1 = x + (ptrdiff_t)n * k,p2 = p0 + n;p0<p2;p0++,p1++) {
<           xx = *p0; *p0 = *p1; *p1 = xx;
---
> 		xx = c[r];
> 		c[r] = c[k];
> 		c[k] = xx;
> 		for (p0 = x + n * r, p1 = x + (ptrdiff_t) n * k, p2 = p0 + n; p0 < p2;
> 				p0++, p1++) {
> 			xx = *p0;
> 			*p0 = *p1;
> 			*p1 = xx;
849c949,950
<           if (cpt * nt < j) cpt++; 
---
> 			if (cpt * nt < j)
> 				cpt++;
851c952,953
<           if (nth * cpt < j) nth++;
---
> 			if (nth * cpt < j)
> 				nth++;
853c955,956
<     } else nth=cpf=cpt=0;
---
> 		} else
> 			nth = cpf = cpt = 0;
859c962,963
<     { j = cpt;
---
> 		{
> 			j = cpt;
865c969,972
< 	    if (i == nth-1) j = cpf; else j = cpt;
---
> 					if (i == nth - 1)
> 						j = cpf;
> 					else
> 						j = cpt;
870,871c977,980
<             for (zz=0.0,v=p0,z=p1;z<z1;z++,v++) zz += *z * *v * br;
<             for (z=p1,v=p0;z<z1;z++,v++) *z -= zz * *v;
---
> 						for (zz = 0.0, v = p0, z = p1; z < z1; z++, v++)
> 							zz += *z * *v * br;
> 						for (z = p1, v = p0; z < z1; z++, v++)
> 							*z -= zz * *v;
888c997,998
<      if (r==n-1) tau = 0.0;
---
> 		if (r == n - 1)
> 			tau = 0.0;
892c1002,1003
<   FREE(c); FREE(work); 
---
> 	FREE(c);
> 	FREE(work);
926c1037,1038
< void mgcv_pmmult(double *A,double *B,double *C,int *bt,int *ct,int *r,int *c,int *n,int *nt) {
---
> void mgcv_pmmult(double *A, double *B, double *C, int *bt, int *ct, int *r,
> 		int *c, int *n, int *nt) {
945c1057,1058
<   if (*r<=0||*c<=0||*n<=0) return;
---
> 	if (*r <= 0 || *c <= 0 || *n <= 0)
> 		return;
950,951c1063,1069
<     if (*bt&&(!*ct)&&(*r==*c)) { getXtX(A,B,n,r);return;} 
<     else if (*ct&&(!*bt)&&(*r==*c)) { getXXt(A,B,c,n);return;}
---
> 		if (*bt && (!*ct) && (*r == *c)) {
> 			getXtX(A, B, n, r);
> 			return;
> 		} else if (*ct && (!*bt) && (*r == *c)) {
> 			getXXt(A, B, c, n);
> 			return;
> 		}
963c1081,1082
<   } else  lda = *r; /* B is r by n */
---
> 	} else
> 		lda = *r; /* B is r by n */
968c1087,1088
<   } else ldb = *n; /* C is n by c */
---
> 	} else
> 		ldb = *n; /* C is n by c */
975c1095,1096
<       if (cpt * *nt < *r) cpt++; 
---
> 			if (cpt * *nt < *r)
> 				cpt++;
977c1098,1099
<       if (nth * cpt < *r) nth++;
---
> 			if (nth * cpt < *r)
> 				nth++;
988c1110,1113
<           if (i == nth-1) c1 = cpf; else c1 = cpt;
---
> 					if (i == nth - 1)
> 						c1 = cpf;
> 					else
> 						c1 = cpt;
990,991c1115,1118
<           if (c1>0) F77_CALL(dgemm)(&transa,&transb,&c1,c,n, &alpha,
< 				    B + i * (ptrdiff_t) cpt * *n, n ,C, c,&beta, A + i * (ptrdiff_t) cpt * *c, &c1);
---
> 					if (c1 > 0)
> 						F77_CALL(dgemm)(&transa, &transb, &c1, c, n, &alpha,
> 								B + i * (ptrdiff_t) cpt * *n, n, C, c, &beta,
> 								A + i * (ptrdiff_t) cpt * *c, &c1);
999c1126,1127
<       if (cpt * *nt < *r) cpt++; 
---
> 			if (cpt * *nt < *r)
> 				cpt++;
1001c1129,1130
<       if (nth * cpt < *r) nth++;
---
> 			if (nth * cpt < *r)
> 				nth++;
1014,1016c1143,1150
<           if (i == nth-1) c1 = cpf;else c1=cpt;
<           if (c1>0) F77_CALL(dgemm)(&transa,&transb,&c1,c,n, &alpha,
< 		B + i * (ptrdiff_t) cpt * *n, &c1,C,c,&beta, A + i * (ptrdiff_t) cpt * *c, &c1);
---
> 					if (i == nth - 1)
> 						c1 = cpf;
> 					else
> 						c1 = cpt;
> 					if (c1 > 0)
> 						F77_CALL(dgemm)(&transa, &transb, &c1, c, n, &alpha,
> 								B + i * (ptrdiff_t) cpt * *n, &c1, C, c, &beta,
> 								A + i * (ptrdiff_t) cpt * *c, &c1);
1025c1159,1160
<     if (cpt * *nt < *c) cpt++;
---
> 		if (cpt * *nt < *c)
> 			cpt++;
1027c1162,1163
<     if (nth * cpt < *c) nth++;
---
> 		if (nth * cpt < *c)
> 			nth++;
1038,1040c1174,1181
<         if (i == nth-1) c1 = cpf;else c1=cpt; /* how many columns in this block */
<         if (c1>0) F77_CALL(dgemm)(&transa,&transb,r,&c1,n, &alpha,
< 		B, &lda,C + i * (ptrdiff_t) *n * cpt, &ldb,&beta, A + i * (ptrdiff_t) *r * cpt, &ldc);
---
> 				if (i == nth - 1)
> 					c1 = cpf;
> 				else
> 					c1 = cpt; /* how many columns in this block */
> 				if (c1 > 0)
> 					F77_CALL(dgemm)(&transa, &transb, r, &c1, n, &alpha, B,
> 							&lda, C + i * (ptrdiff_t) *n * cpt, &ldb, &beta,
> 							A + i * (ptrdiff_t) *r * cpt, &ldc);
1071,1072c1212,1222
<       i=kk;r=0;while (i >= M-r) { i -= M - r; r++;}; c = r + i; /* convert kk to row/col */
<       if (r==M-1) bn = nf; else bn = *nb; /* (row) B block size */
---
> 			i = kk;
> 			r = 0;
> 			while (i >= M - r) {
> 				i -= M - r;
> 				r++;
> 			};
> 			c = r + i; /* convert kk to row/col */
> 			if (r == M - 1)
> 				bn = nf;
> 			else
> 				bn = *nb; /* (row) B block size */
1077c1227,1230
<           if (k==N-1) an = nrf; else an = *nb; /* A row block size */ 
---
> 					if (k == N - 1)
> 						an = nrf;
> 					else
> 						an = *nb; /* A row block size */
1079c1232,1235
<           if (k) beta=1.0; else beta = 0.0; /* multiplier for B block */
---
> 					if (k)
> 						beta = 1.0;
> 					else
> 						beta = 0.0; /* multiplier for B block */
1088c1244,1247
<         if (c==M-1) cn = nf; else cn = *nb; /* b col block size */
---
> 				if (c == M - 1)
> 					cn = nf;
> 				else
> 					cn = *nb; /* b col block size */
1091c1250,1253
<           if (k==N-1) an = nrf; else an = *nb; /* A row block size */ 
---
> 					if (k == N - 1)
> 						an = nrf;
> 					else
> 						an = *nb; /* A row block size */
1093,1097c1255,1261
<           if (k) beta=1.0; else beta = 0.0; /* multiplier for B block */
<           F77_CALL(dgemm)(&trans,&ntrans,
<                           &bn,&cn,&an, 
<                           &alpha,A + *R * bs + as, 
<                           R,A + *R * cs + as,R,&beta, B + bs + *C * cs, C);
---
> 					if (k)
> 						beta = 1.0;
> 					else
> 						beta = 0.0; /* multiplier for B block */
> 					F77_CALL(dgemm)(&trans, &ntrans, &bn, &cn, &an, &alpha,
> 							A + *R * bs + as, R, A + *R * cs + as, R, &beta,
> 							B + bs + *C * cs, C);
1103c1267,1269
<   for (r=0; r < *C;r++) for (c=0;c < r;c++) B[r + *C * c] = B[c + *C * r];
---
> 	for (r = 0; r < *C; r++)
> 		for (c = 0; c < r; c++)
> 			B[r + *C * c] = B[c + *C * r];
1159c1325
<   int i,j;
---
> 
1440,1441c1606,1607
< 
< void mgcv_td_qy(double *S,double *tau,int *m,int *n, double *B,int *left,int *transpose)
---
> void mgcv_td_qy(double *S, double *tau, int *m, int *n, double *B, int *left,
> 		int *transpose)
1449c1615,1616
< { char trans='N',side='R',uplo='U';
---
> {
> 	char trans = 'N', side = 'R', uplo = 'U';
1452,1453c1619,1625
<   if (*left) { side = 'L';nq = *m;} else nq = *n;
<   if (*transpose) trans = 'T';
---
> 	if (*left) {
> 		side = 'L';
> 		nq = *m;
> 	} else
> 		nq = *n;
> 	if (*transpose)
> 		trans = 'T';
1455,1456c1627,1631
<   F77_CALL(dormtr)(&side,&uplo,&trans,m,n,S,&nq,tau,B,m,&work1,&lwork,&info);
<   lwork=(int)floor(work1);if (work1-lwork>0.5) lwork++;
---
> 	F77_CALL(dormtr)(&side, &uplo, &trans, m, n, S, &nq, tau, B, m, &work1,
> 			&lwork, &info);
> 	lwork = (int) floor(work1);
> 	if (work1 - lwork > 0.5)
> 		lwork++;
1459c1634,1635
<   F77_CALL(dormtr)(&side,&uplo,&trans,m,n,S,&nq,tau,B,m,work,&lwork,&info);
---
> 	F77_CALL(dormtr)(&side, &uplo, &trans, m, n, S, &nq, tau, B, m, work,
> 			&lwork, &info);
1561,1562c1736,1739
<   if (*nt < 1) *nt = 1;
<   if (*nt > *r) *nt = *r; /* no point having more threads than columns */
---
> 	if (*nt < 1)
> 		*nt = 1;
> 	if (*nt > *r)
> 		*nt = *r; /* no point having more threads than columns */
1565,1566c1742,1745
<   a[0] = 0;a[*nt] = *r;
<   x = (double) *r;x = x*x*x / *nt;
---
> 	a[0] = 0;
> 	a[*nt] = *r;
> 	x = (double) *r;
> 	x = x * x * x / *nt;
1568c1747,1748
<   for (i=1;i < *nt;i++) a[i] = round(pow(x*i,1/3.0));
---
> 	for (i = 1; i < *nt; i++)
> 		a[i] = round(pow(x * i, 1 / 3.0));
1570c1750,1751
<     if (a[i]>=a[i+1]) a[i] = a[i+1]-1;
---
> 		if (a[i] >= a[i + 1])
> 			a[i] = a[i + 1] - 1;
1588c1769,1770
<         for (zz=z,z1 = z+i;zz<z1;zz++,rr++) *zz = *rr * *dk; /* sum_0_{i-1} Rii * zz[i] */
---
> 				for (zz = z, z1 = z + i; zz < z1; zz++, rr++)
> 					*zz = *rr * *dk; /* sum_0_{i-1} Rii * zz[i] */
1593c1775,1776
<           for (zz=z,z1=z+j,rr=Rjj-j;zz<z1;zz++,rr++) *zz += *rr * *dk; 
---
> 					for (zz = z, z1 = z + j, rr = Rjj - j; zz < z1; zz++, rr++)
> 						*zz += *rr * *dk;
1601c1784,1785
<   x = (double) *r;x = x*x / *nt;
---
> 	x = (double) *r;
> 	x = x * x / *nt;
1603c1787,1788
<   for (i=1;i < *nt;i++) a[i] = round(sqrt(x*i));
---
> 	for (i = 1; i < *nt; i++)
> 		a[i] = round(sqrt(x * i));
1605c1790,1791
<     if (a[i]>=a[i+1]) a[i] = a[i+1]-1;
---
> 		if (a[i] >= a[i + 1])
> 			a[i] = a[i + 1] - 1;
1622c1808,1812
<         for (rr = R + k * (ptrdiff_t)*r + k + 1, r2 = rr + i;rr<r2;rr++,zz++) {*zz = *rr;*rr = 0.0;}
---
> 				for (rr = R + k * (ptrdiff_t) *r + k + 1, r2 = rr + i; rr < r2;
> 						rr++, zz++) {
> 					*zz = *rr;
> 					*rr = 0.0;
> 				}
1626c1816,1817
<   FREE(d);FREE(a);
---
> 	FREE(d);
> 	FREE(a);
1655,1656c1843,1846
<   if (*nt < 1) *nt = 1;
<   if (*nt > *r) *nt = *r; /* no point having more threads than columns */
---
> 	if (*nt < 1)
> 		*nt = 1;
> 	if (*nt > *r)
> 		*nt = *r; /* no point having more threads than columns */
1658c1848,1849
<   a[0] = 0;a[*nt] = *r;
---
> 	a[0] = 0;
> 	a[*nt] = *r;
1660c1851,1852
<   x = (double) *r;x = x*x / *nt;
---
> 	x = (double) *r;
> 	x = x * x / *nt;
1662c1854,1855
<   for (i=1;i < *nt;i++) a[i] = round(*r - sqrt(x*(*nt-i)));
---
> 	for (i = 1; i < *nt; i++)
> 		a[i] = round(*r - sqrt(x * (*nt - i)));
1664c1857,1858
<     if (a[i]<=a[i-1]) a[i] = a[i-1]+1;
---
> 		if (a[i] <= a[i - 1])
> 			a[i] = a[i - 1] + 1;
1679c1873,1874
<         for (r1=rl + *r - i,rl++;rl<r1;rl++,ru += *r) *rl = *ru;
---
> 				for (r1 = rl + *r - i, rl++; rl < r1; rl++, ru += *r)
> 					*rl = *ru;
1685c1880,1881
<   x = (double) *r;x = x*x*x / *nt;
---
> 	x = (double) *r;
> 	x = x * x * x / *nt;
1687c1883,1884
<   for (i=1;i < *nt;i++) a[i] = round(*r - pow(x*(*nt-i),1/3.0));
---
> 	for (i = 1; i < *nt; i++)
> 		a[i] = round(*r - pow(x * (*nt - i), 1 / 3.0));
1689c1886,1887
<     if (a[i]<=a[i-1]) a[i] = a[i-1]+1;
---
> 		if (a[i] <= a[i - 1])
> 			a[i] = a[i - 1] + 1;
1707c1905,1906
<           for (x=0.0,rj=rl,ri=ru;ri < r1;rj++,ri++) x += *rj * *ri;
---
> 					for (x = 0.0, rj = rl, ri = ru; ri < r1; rj++, ri++)
> 						x += *rj * *ri;
1714c1913,1914
<   x = (double) *r;x = x*x / *nt;
---
> 	x = (double) *r;
> 	x = x * x / *nt;
1716c1916,1917
<   for (i=1;i < *nt;i++) a[i] = round(*r - sqrt(x*(*nt-i)));
---
> 	for (i = 1; i < *nt; i++)
> 		a[i] = round(*r - sqrt(x * (*nt - i)));
1718c1919,1920
<     if (a[i]<=a[i-1]) a[i] = a[i-1]+1;
---
> 		if (a[i] <= a[i - 1])
> 			a[i] = a[i - 1] + 1;
1731c1933,1934
<         for (r1=rl + *r - i,rl++;rl<r1;rl++) *rl = 0.0;
---
> 				for (r1 = rl + *r - i, rl++; rl < r1; rl++)
> 					*rl = 0.0;
2033c2235,2236
<           if (x0!=x1) *x1 = 0.0; /* clear source */
---
> 					if (x0 != x1)
> 						*x1 = 0.0; /* clear source */
2041c2244,2245
< 	for (j=0;j < *c;j++,x0++,x1++) *x0 = *x1; 
---
> 				for (j = 0; j < *c; j++, x0++, x1++)
> 					*x0 = *x1;
2065c2269,2272
<         if (i == k-1) n = nbf; else n = nb; /* number of rows in this block */
---
> 				if (i == k - 1)
> 					n = nbf;
> 				else
> 					n = nb; /* number of rows in this block */
2067c2274,2275
<         mgcv_qrqy(x1,a + i * nb * *c,tau + i * *c,&n,cb,c,&left,tp);
---
> 				mgcv_qrqy(x1, a + i * nb * *c, tau + i * *c, &n, cb, c, &left,
> 						tp);
2069c2277,2279
<         for (j = 0; j < *c;j++) for (l=0;l< *cb;l++) Qb[j + i * *c + nq * l] = x1[j + n * l];    
---
> 				for (j = 0; j < *c; j++)
> 					for (l = 0; l < *cb; l++)
> 						Qb[j + i * *c + nq * l] = x1[j + n * l];
2078c2288,2289
<       for (j=0;j<*c;j++,x0++,x1++) *x0 = *x1;
---
> 			for (j = 0; j < *c; j++, x0++, x1++)
> 				*x0 = *x1;
2103c2314,2317
<         if (i == k-1) n = nbf; else n = nb; /* number of rows in this block */
---
> 				if (i == k - 1)
> 					n = nbf;
> 				else
> 					n = nb; /* number of rows in this block */
2107c2321,2322
<           for (l=0;l< *c;l++,x0++,x1++) *x0 = *x1;
---
> 					for (l = 0; l < *c; l++, x0++, x1++)
> 						*x0 = *x1;
2112c2327,2328
<         mgcv_qrqy(x1,a + i * nb * *c,tau + i * *c,&n,cb,c,&left,tp);
---
> 				mgcv_qrqy(x1, a + i * nb * *c, tau + i * *c, &n, cb, c, &left,
> 						tp);
2116c2332,2333
<     if (*cb>1) row_block_reorder(b,r,cb,&nb,&TRUE);
---
> 		if (*cb > 1)
> 			row_block_reorder(b, r, cb, &nb, &TRUE);
2202c2418,2420
<   if (*nt==1) mgcv_qr(x,r,c,pivot,tau); else { /* call bpqr */
---
> 	if (*nt == 1)
> 		mgcv_qr(x, r, c, pivot, tau);
> 	else { /* call bpqr */
2230c2447,2449
<   if (k==1) mgcv_qr(x,r,c,pivot,tau); else { /* multi-threaded version */
---
> 	if (k == 1)
> 		mgcv_qr(x, r, c, pivot, tau);
> 	else { /* multi-threaded version */
2246c2465,2468
<         if (i==k-1) n = nbf; else n = nb; 
---
> 				if (i == k - 1)
> 					n = nbf;
> 				else
> 					n = nb;
2251c2473,2475
<         for (l=0;l<*c;l++) for (j=l;j<*c;j++) R1[l + *c * j] = xi[l + n * j]; 
---
> 				for (l = 0; l < *c; l++)
> 					for (j = l; j < *c; j++)
> 						R1[l + *c * j] = xi[l + n * j];
2254c2478,2480
<         for (l=0;l<*c;l++) for (j=0;j<*c;j++) R[i * *c +l + nr *j] = R1[l+ *c * j];
---
> 				for (l = 0; l < *c; l++)
> 					for (j = 0; j < *c; j++)
> 						R[i * *c + l + nr * j] = R1[l + *c * j];
2577c2804
<     if (k) Rprintf("Non orthogonal eigenvectors %d %g\n",k,x/k);
---
>     if (k) Rprintf(_("Non orthogonal eigenvectors %d %g\n"), k, x / k);
2582c2809
<     if (k) Rprintf("Eigenvectors not normalized %d %g\n",k,x/k);
---
>     if (k) Rprintf(_("Eigenvectors not normalized %d %g\n"), k, x / k);
2602c2829,2830
< { char compz;
---
> {
> 	char compz;
2606c2834,2840
<   if (getvec) { compz='I';ldz = *n;} else { compz='N';ldz=0;}
---
> 	if (getvec) {
> 		compz = 'I';
> 		ldz = *n;
> 	} else {
> 		compz = 'N';
> 		ldz = 0;
> 	}
2609,2610c2843
<   F77_CALL(dstedc)(&compz,n,
< 		   d, g, /* lead and su-diag */
---
> 	F77_CALL(dstedc)(&compz, n, d, g, /* lead and su-diag */
2613,2614c2846
< 		   &work1, &lwork,
< 		   &iwork1, &liwork, &info);
---
> 	&work1, &lwork, &iwork1, &liwork, &info);
2616c2848,2850
<    lwork=(int)floor(work1);if (work1-lwork>0.5) lwork++;
---
> 	lwork = (int) floor(work1);
> 	if (work1 - lwork > 0.5)
> 		lwork++;
2622,2623c2856
<    F77_CALL(dstedc)(&compz,n,
< 		   d, g, /* lead and su-diag */
---
> 	F77_CALL(dstedc)(&compz, n, d, g, /* lead and su-diag */
2626,2627c2859
< 		   work, &lwork,
< 		   iwork, &liwork, &info);
---
> 	work, &lwork, iwork, &liwork, &info);
2631,2632c2863,2867
<        x = d[i]; d[i] = d[*n-i-1];d[*n-i-1] = x;
<        dum1 = v + *n * i;dum2 = v + *n * (*n-i-1); /* pointers to heads of cols to exchange */
---
> 			x = d[i];
> 			d[i] = d[*n - i - 1];
> 			d[*n - i - 1] = x;
> 			dum1 = v + *n * i;
> 			dum2 = v + *n * (*n - i - 1); /* pointers to heads of cols to exchange */
2634c2869,2871
<          x = *dum1;*dum1 = *dum2;*dum2 = x;
---
> 				x = *dum1;
> 				*dum1 = *dum2;
> 				*dum2 = x;
2639c2876,2877
<    FREE(work);FREE(iwork);
---
> 	FREE(work);
> 	FREE(iwork);
2643,2645c2881,2882
< 
< 
< void Rlanczos(double *A,double *U,double *D,int *n, int *m, int *lm,double *tol,int *nt) {
---
> void Rlanczos(double *A, double *U, double *D, int *n, int *m, int *lm,
> 		double *tol, int *nt) {
2666,2667c2903,2906
<     int biggest=0,f_check,i,k,kk,ok,l,j,vlength=0,ni,pi,converged,incx=1,ri,ci,cir,one=1;
<   double **q,*v=NULL,bt,xx,yy,*a,*b,*d,*g,*z,*err,*p0,*p1,*zp,*qp,normTj,eps_stop,max_err,alpha=1.0,beta=0.0;
---
> 	int biggest = 0, f_check, i, k, kk, ok, l, j, vlength = 0, ni, pi,
> 			converged, incx = 1, ri, ci, cir, one = 1;
> 	double **q, *v = NULL, bt, xx, yy, *a, *b, *d, *g, *z, *err, *p0, *p1, *zp,
> 			*qp, normTj, eps_stop, max_err, alpha = 1.0, beta = 0.0;
2678c2916,2917
<   if (*nt > *n) *nt = *n; /* don't use more threads than columns! */
---
> 	if (*nt > *n)
> 		*nt = *n; /* don't use more threads than columns! */
2682c2921,2924
<   if (*lm<0) { biggest=1;*lm=0;} /* get m largest magnitude eigen-values */
---
> 	if (*lm < 0) {
> 		biggest = 1;
> 		*lm = 0;
> 	} /* get m largest magnitude eigen-values */
2684,2686c2926,2932
<   if (f_check<10) f_check =10;
<   kk = (int) floor(*n/10); if (kk<1) kk=1;  
<   if (kk<f_check) f_check = kk;
---
> 	if (f_check < 10)
> 		f_check = 10;
> 	kk = (int) floor(*n / 10);
> 	if (kk < 1)
> 		kk = 1;
> 	if (kk < f_check)
> 		f_check = kk;
2692c2938,2939
<   b=q[0];bt=0.0;
---
> 	b = q[0];
> 	bt = 0.0;
2694c2941,2942
<   { jran=(jran*ia+ic) % im;   /* quick and dirty generator to avoid too regular a starting vector */
---
> 	{
> 		jran = (jran * ia + ic) % im; /* quick and dirty generator to avoid too regular a starting vector */
2696c2944,2946
<     b[i]=xx;xx=-xx;bt+=b[i]*b[i];
---
> 		b[i] = xx;
> 		xx = -xx;
> 		bt += b[i] * b[i];
2699c2949,2950
<   for (i=0;i < *n;i++) b[i]/=bt;
---
> 	for (i = 0; i < *n; i++)
> 		b[i] /= bt;
2708c2959,2960
<   for (i=0;i< *n;i++) err[i]=1e300;
---
> 	for (i = 0; i < *n; i++)
> 		err[i] = 1e300;
2718c2970,2973
<     if (cir == 0) { (*nt)--;cir=ci; } /* no cols left for final thread so drop it */
---
> 		if (cir == 0) {
> 			(*nt)--;
> 			cir = ci;
> 		} /* no cols left for final thread so drop it */
2738c2993,2996
<           if (i < *nt-1) ri = ci; else ri = cir; /* number of cols of A to process */
---
> 					if (i < *nt - 1)
> 						ri = ci;
> 					else
> 						ri = cir; /* number of cols of A to process */
2741,2742c2999,3000
<           F77_CALL(dgemv)(&trans,n,&ri,&alpha,A+i * ci * *n,n,q[j],
<                         &one,&beta,z+i*ci,&one);
---
> 					F77_CALL(dgemv)(&trans, n, &ri, &alpha, A + i * ci * *n, n,
> 							q[j], &one, &beta, z + i * ci, &one);
2745,2748c3003,3005
<     } else F77_CALL(dsymv)(&uplo,n,&alpha,
< 		A,n,
< 		q[j],&incx,
< 		&beta,z,&incx);
---
> 		} else
> 			F77_CALL(dsymv)(&uplo, n, &alpha, A, n, q[j], &incx, &beta, z,
> 					&incx);
2750c3007,3008
<     for (xx=0.0,qp=q[j],p0=qp+*n,zp=z;qp<p0;qp++,zp++) xx += *qp * *zp;
---
> 		for (xx = 0.0, qp = q[j], p0 = qp + *n, zp = z; qp < p0; qp++, zp++)
> 			xx += *qp * *zp;
2754,2758c3012,3015
<     if (!j)
<     { /* z <- z - a[j]*q[j] */
<       for (zp=z,p0=zp+*n,qp=q[j];zp<p0;qp++,zp++) *zp -= xx * *qp;
<     } else
<     { /* z <- z - a[j]*q[j] - b[j-1]*q[j-1] */
---
> 		if (!j) { /* z <- z - a[j]*q[j] */
> 			for (zp = z, p0 = zp + *n, qp = q[j]; zp < p0; qp++, zp++)
> 				*zp -= xx * *qp;
> 		} else { /* z <- z - a[j]*q[j] - b[j-1]*q[j-1] */
2760c3017,3019
<       for (zp=z,p0=zp + *n,qp=q[j],p1=q[j-1];zp<p0;zp++,qp++,p1++) *zp -= xx * *qp + yy * *p1;    
---
> 			for (zp = z, p0 = zp + *n, qp = q[j], p1 = q[j - 1]; zp < p0;
> 					zp++, qp++, p1++)
> 				*zp -= xx * *qp + yy * *p1;
2764,2765c3023
<       for (i=0;i<=j;i++) 
<       { /* form xx= z'q[i] */
---
> 			for (i = 0; i <= j; i++) { /* form xx= z'q[i] */
2774,2775c3032
<       for (i=0;i<=j;i++) 
<       { /* form xx= z'q[i] */
---
> 			for (i = 0; i <= j; i++) { /* form xx= z'q[i] */
2787c3043,3045
<     for (xx=0.0,zp=z,p0=zp+*n;zp<p0;zp++) xx += *zp * *zp;b[j]=sqrt(xx); 
---
> 		for (xx = 0.0, zp = z, p0 = zp + *n; zp < p0; zp++)
> 			xx += *zp * *zp;
> 		b[j] = sqrt(xx);
2790,2792c3048,3052
<     if (j < *n-1)
<     { q[j+1]=(double *)CALLOC((size_t) *n,sizeof(double));
<       for (xx=b[j],qp=q[j+1],p0=qp + *n,zp=z;qp<p0;qp++,zp++) *qp = *zp/xx; /* forming q[j+1]=z/b[j] */
---
> 		if (j < *n - 1) {
> 			q[j + 1] = (double *) CALLOC((size_t) *n, sizeof(double));
> 			for (xx = b[j], qp = q[j + 1], p0 = qp + *n, zp = z; qp < p0;
> 					qp++, zp++)
> 				*qp = *zp / xx; /* forming q[j+1]=z/b[j] */
2798,2799c3058,3062
<     { for (i=0;i<j+1;i++) d[i]=a[i]; /* copy leading diagonal of T_j */
<       for (i=0;i<j;i++) g[i]=b[i]; /* copy sub/super diagonal of T_j */   
---
> 		{
> 			for (i = 0; i < j + 1; i++)
> 				d[i] = a[i]; /* copy leading diagonal of T_j */
> 			for (i = 0; i < j; i++)
> 				g[i] = b[i]; /* copy sub/super diagonal of T_j */
2801c3064,3065
<       if (vlength) FREE(v); /* free up first */
---
> 			if (vlength)
> 				FREE(v); /* free up first */
2812c3076,3078
<       normTj=fabs(d[0]);if (fabs(d[j])>normTj) normTj=fabs(d[j]);
---
> 			normTj = fabs(d[0]);
> 			if (fabs(d[j]) > normTj)
> 				normTj = fabs(d[j]);
2815c3081,3082
<       { err[k]=b[j]*v[k * vlength + j]; /* bound on kth e.v. is b[j]* (jth element of kth eigenvector) */
---
> 			{
> 				err[k] = b[j] * v[k * vlength + j]; /* bound on kth e.v. is b[j]* (jth element of kth eigenvector) */
2819,2820c3086,3087
<       if (j >= *m + *lm)
<       { max_err=normTj*eps_stop;
---
> 			if (j >= *m + *lm) {
> 				max_err = normTj * eps_stop;
2826,2828c3093,3101
<           pi=ni=0;converged=1;
<           while (pi+ni < *m) if (fabs(d[pi])>= fabs(d[j-ni])) { /* include d[pi] in largest set */
<               if (err[pi]>max_err) {converged=0;break;} else pi++;
---
> 					pi = ni = 0;
> 					converged = 1;
> 					while (pi + ni < *m)
> 						if (fabs(d[pi]) >= fabs(d[j - ni])) { /* include d[pi] in largest set */
> 							if (err[pi] > max_err) {
> 								converged = 0;
> 								break;
> 							} else
> 								pi++;
2830c3103,3107
<               if (err[ni]>max_err) {converged=0;break;} else ni++;
---
> 							if (err[ni] > max_err) {
> 								converged = 0;
> 								break;
> 							} else
> 								ni++;
2836c3113,3114
<             j++;break;
---
> 						j++;
> 						break;
2839,2843c3117,3128
<         { ok=1;
<           for (i=0;i < *m;i++) if (err[i]>max_err) ok=0;
<           for (i=j;i > j - *lm;i--) if (err[i]>max_err) ok=0;
<           if (ok) 
<           { j++;break;}
---
> 				{
> 					ok = 1;
> 					for (i = 0; i < *m; i++)
> 						if (err[i] > max_err)
> 							ok = 0;
> 					for (i = j; i > j - *lm; i--)
> 						if (err[i] > max_err)
> 							ok = 0;
> 					if (ok) {
> 						j++;
> 						break;
> 					}
2860c3145,3146
<   { D[k]=d[k];
---
> 	{
> 		D[k] = d[k];
2862c3148,3150
<     for (xx=v[l + k * vlength],p0=U + k * *n,p1 = p0 + *n,qp=q[l];p0<p1;p0++,qp++) *p0 += *qp * xx;
---
> 			for (xx = v[l + k * vlength], p0 = U + k * *n, p1 = p0 + *n, qp =
> 					q[l]; p0 < p1; p0++, qp++)
> 				*p0 += *qp * xx;
2866c3154,3155
<   { kk=j-(*lm + *m - k); /* index for d and v */
---
> 	{
> 		kk = j - (*lm + *m - k); /* index for d and v */
2869c3158,3160
<     for (xx=v[l + kk * vlength],p0=U + k * *n,p1 = p0 + *n,qp=q[l];p0<p1;p0++,qp++) *p0 += *qp * xx;
---
> 			for (xx = v[l + kk * vlength], p0 = U + k * *n, p1 = p0 + *n, qp =
> 					q[l]; p0 < p1; p0++, qp++)
> 				*p0 += *qp * xx;
2879,2880c3170,3175
<   if (vlength) FREE(v);
<   for (i=0;i< *n+1;i++) if (q[i]) FREE(q[i]);FREE(q);  
---
> 	if (vlength)
> 		FREE(v);
> 	for (i = 0; i < *n + 1; i++)
> 		if (q[i])
> 			FREE(q[i]);
> 	FREE(q);
diff -rEZbwB '--exclude=*.[lo,d,pdf,mo,po,tgz,gz,save]*' '--exclude=MD5' '--exclude=Makefile*' '--exclude=all.R' '--exclude=Changes' R-recommended/mgcv/src/matrix.c Recommended/mgcv/src/matrix.c
30a31
> #include "localization.h"
47,48c46,47
< struct mrec
< { matrix mat;
---
> struct mrec {
> 	matrix mat;
58c57,59
< { matrix A;int i,j,pad;
---
> {
> 	matrix A;
> 	int i, j, pad;
66,68c67,70
<   if ((cols==1)||(rows==1))
<   { if (A.M)
<     A.M[0]=(double *)CALLOC((size_t)(cols*rows+2*pad),sizeof(double));
---
> 	if ((cols == 1) || (rows == 1)) {
> 		if (A.M)
> 			A.M[0] = (double *) CALLOC((size_t) (cols * rows + 2 * pad),
> 					sizeof(double));
70,72c72,75
<     A.M[i]=A.M[0]+i*cols;A.vec=1;
<   } else
<   { if (A.M)
---
> 			A.M[i] = A.M[0] + i * cols;
> 		A.vec = 1;
> 	} else {
> 		if (A.M)
74c77,78
<     A.M[i]=(double *)CALLOC((size_t)(cols+2*pad),sizeof(double));
---
> 				A.M[i] = (double *) CALLOC((size_t) (cols + 2 * pad),
> 						sizeof(double));
77,80c81,87
<   memused+=A.mem;matrallocd++;
<   A.original_r=A.r=rows;A.original_c=A.c=cols;
<   if (((!A.M)||(!A.M[rows-1+2*pad]))&&(rows*cols>0))
<   { error(_("Failed to initialize memory for matrix."));}
---
> 	memused += A.mem;
> 	matrallocd++;
> 	A.original_r = A.r = rows;
> 	A.original_c = A.c = cols;
> 	if (((!A.M) || (!A.M[rows - 1 + 2 * pad])) && (rows * cols > 0)) {
> 		error(_("Failed to initialize memory for matrix."));
> 	}
83,92c90,108
<   { if (A.vec)
<     { A.V=A.M[0];for (i=0;i<pad;i++) { A.V[i]=PADCON;A.V[i+pad+A.r*A.c]=PADCON;}
<     } else
<     { for (i=0;i<A.r+2*pad;i++)
<       { for (j=0;j<pad;j++) A.M[i][j]=PADCON;
< 	     for (j=A.c+pad;j<A.c+2*pad;j++) A.M[i][j]=PADCON;
<       }
<       for (i=0;i<A.c+2*pad;i++)
<       { for (j=0;j<pad;j++) A.M[j][i]=PADCON;
< 	     for (j=A.r+pad;j<A.r+2*pad;j++) A.M[j][i]=PADCON;
---
> 	{
> 		if (A.vec) {
> 			A.V = A.M[0];
> 			for (i = 0; i < pad; i++) {
> 				A.V[i] = PADCON;
> 				A.V[i + pad + A.r * A.c] = PADCON;
> 			}
> 		} else {
> 			for (i = 0; i < A.r + 2 * pad; i++) {
> 				for (j = 0; j < pad; j++)
> 					A.M[i][j] = PADCON;
> 				for (j = A.c + pad; j < A.c + 2 * pad; j++)
> 					A.M[i][j] = PADCON;
> 			}
> 			for (i = 0; i < A.c + 2 * pad; i++) {
> 				for (j = 0; j < pad; j++)
> 					A.M[j][i] = PADCON;
> 				for (j = A.r + pad; j < A.r + 2 * pad; j++)
> 					A.M[j][i] = PADCON;
96,97c112,116
<     for (j=0;j<pad;j++) A.M[i]++;  /* shifting pointers forward past padding */
<     if (!A.vec) for (j=0;j<pad;j++) A.M++;
---
> 			for (j = 0; j < pad; j++)
> 				A.M[i]++; /* shifting pointers forward past padding */
> 		if (!A.vec)
> 			for (j = 0; j < pad; j++)
> 				A.M++;
101,102c120,124
<     { top=bottom=(MREC *)CALLOC(1,sizeof(MREC));
<       bottom->mat=top->mat=A;top->bp=bottom;bottom->fp=top;
---
> 		{
> 			top = bottom = (MREC *) CALLOC(1, sizeof(MREC));
> 			bottom->mat = top->mat = A;
> 			top->bp = bottom;
> 			bottom->fp = top;
104,105c126,130
<     { top->fp=(MREC *)CALLOC(1,sizeof(MREC));
<       top->fp->mat=A;top->fp->bp=top;top=top->fp; /* crystal clear, no? */
---
> 		{
> 			top->fp = (MREC *) CALLOC(1, sizeof(MREC));
> 			top->fp->mat = A;
> 			top->fp->bp = top;
> 			top = top->fp; /* crystal clear, no? */
114c139,141
< { return(initmat(1,rows));}
---
> {
> 	return (initmat(1, rows));
> }
118c145,147
< { int i,j,pad;int ok=1;
---
> {
> 	int i, j, pad;
> 	int ok = 1;
126,129c155,169
<   { if (pad)
<     { if (A.vec)
<       { for (i=-pad;i<0;i++)
< 	     if ((A.V[i]!=PADCON)||(A.V[i+A.original_r*A.original_c+pad]!=PADCON))
---
> 	{
> 		if (pad) {
> 			if (A.vec) {
> 				for (i = -pad; i < 0; i++)
> 					if ((A.V[i] != PADCON)
> 							|| (A.V[i + A.original_r * A.original_c + pad]
> 									!= PADCON))
> 						ok = 0;
> 			} else {
> 				for (i = -pad; i < A.original_r + pad; i++) {
> 					for (j = A.original_c; j < A.original_c + pad; j++)
> 						if (A.M[i][j] != PADCON)
> 							ok = 0;
> 					for (j = -pad; j < 0; j++)
> 						if (A.M[i][j] != PADCON)
131,134d170
<       } else
<       { for (i=-pad;i<A.original_r+pad;i++)
< 	     { for (j=A.original_c;j<A.original_c+pad;j++) if (A.M[i][j]!=PADCON) ok=0;
< 	       for (j=-pad;j<0;j++) if (A.M[i][j]!=PADCON) ok=0;
136,138c172,178
< 	     for (i=-pad;i<A.original_c+pad;i++)
< 	     { for (j=A.original_r;j<A.original_r+pad;j++) if (A.M[j][i]!=PADCON) ok=0;
< 	       for (j=-pad;j<0;j++) if (A.M[j][i]!=PADCON) ok=0;
---
> 				for (i = -pad; i < A.original_c + pad; i++) {
> 					for (j = A.original_r; j < A.original_r + pad; j++)
> 						if (A.M[j][i] != PADCON)
> 							ok = 0;
> 					for (j = -pad; j < 0; j++)
> 						if (A.M[j][i] != PADCON)
> 							ok = 0;
141,142c181,182
<       if (!ok)
<       { error(_("An out of bound write to matrix has occurred!"),1);
---
> 			if (!ok) {
> 				error(_("An out of bound write to matrix has occurred!"), 1);
145,150c185,194
<       i=0;delet=bottom;
<       while ((i<matrallocd)&&(delet->mat.M!=A.M)) { i++;delet=delet->fp;}
<       if (i==matrallocd)
<       { error(_("INTEGRITY PROBLEM in the extant matrix list."));
<       } else
<       { if (i)
---
> 			i = 0;
> 			delet = bottom;
> 			while ((i < matrallocd) && (delet->mat.M != A.M)) {
> 				i++;
> 				delet = delet->fp;
> 			}
> 			if (i == matrallocd) {
> 				error(_("INTEGRITY PROBLEM in the extant matrix list."));
> 			} else {
> 				if (i)
152c196,197
< 	     else bottom=delet->fp;
---
> 				else
> 					bottom = delet->fp;
155c200,201
< 	     else top=delet->bp;
---
> 				else
> 					top = delet->bp;
159c205,207
<       if (!A.vec) for (i=0;i<pad;i++) A.M--;
---
> 			if (!A.vec)
> 				for (i = 0; i < pad; i++)
> 					A.M--;
161c209,210
<       for (j=0;j<pad;j++) A.M[i]--;
---
> 				for (j = 0; j < pad; j++)
> 					A.M[i]--;
163,166c212,221
<     if (A.vec) FREE(A.M[0]); else
<     for (i=0;i<A.original_r+2*pad;i++) if (A.M[i]) FREE(A.M[i]);
<     if (A.M) FREE(A.M);
<     memused -= A.mem;matrallocd--;
---
> 		if (A.vec)
> 			FREE(A.M[0]);
> 		else
> 			for (i = 0; i < A.original_r + 2 * pad; i++)
> 				if (A.M[i])
> 					FREE(A.M[i]);
> 		if (A.M)
> 			FREE(A.M);
> 		memused -= A.mem;
> 		matrallocd--;
176c231,232
< { MREC *B;
---
> {
> 	MREC *B;
183,187c239,244
<   while (k<matrallocd)
<   { A=B->mat;
<     if (A.vec)
<     { for (i=-pad;i<0;i++)
<       if ((A.V[i]!=PADCON)||(A.V[i+A.original_r*A.original_c+pad]!=PADCON))
---
> 	while (k < matrallocd) {
> 		A = B->mat;
> 		if (A.vec) {
> 			for (i = -pad; i < 0; i++)
> 				if ((A.V[i] != PADCON)
> 						|| (A.V[i + A.original_r * A.original_c + pad] != PADCON))
189,191c246,249
<     } else
<     { for (i=-pad;i<A.original_r+pad;i++)
<       { for (j=A.original_c;j<A.original_c+pad;j++) if (A.M[i][j]!=PADCON)
---
> 		} else {
> 			for (i = -pad; i < A.original_r + pad; i++) {
> 				for (j = A.original_c; j < A.original_c + pad; j++)
> 					if (A.M[i][j] != PADCON)
193c251,252
< 	     for (j=-pad;j<0;j++) if (A.M[i][j]!=PADCON)
---
> 				for (j = -pad; j < 0; j++)
> 					if (A.M[i][j] != PADCON)
196,197c255,257
<       for (i=-pad;i<A.original_c+pad;i++)
<       { for (j=A.original_r;j<A.original_r+pad;j++) if (A.M[j][i]!=PADCON)
---
> 			for (i = -pad; i < A.original_c + pad; i++) {
> 				for (j = A.original_r; j < A.original_r + pad; j++)
> 					if (A.M[j][i] != PADCON)
199c259,260
< 	     for (j=-pad;j<0;j++) if (A.M[j][i]!=PADCON)
---
> 				for (j = -pad; j < 0; j++)
> 					if (A.M[j][i] != PADCON)
203,204c264,265
<     if (!ok)
<     { error(_("An out of bound write to matrix has occurred!"));
---
> 		if (!ok) {
> 			error(_("An out of bound write to matrix has occurred!"));
206c267,268
<     k++;B=B->fp;
---
> 		k++;
> 		B = B->fp;
217c276,277
< { double **AM,*bV,*cV,*p;
---
> {
> 	double **AM, *bV, *cV, *p;
219,220c279,283
<   cr=c->r;br=b->r;
<   AM=A->M;bV=b->V;cV=c->V;
---
> 	cr = c->r;
> 	br = b->r;
> 	AM = A->M;
> 	bV = b->V;
> 	cV = c->V;
222,224c285,288
<   for (i=0;i<cr;i++)
<   { *cV=0.0;
<     for (j=0;j<br;j++) *cV += AM[j][i]*bV[j];
---
> 		for (i = 0; i < cr; i++) {
> 			*cV = 0.0;
> 			for (j = 0; j < br; j++)
> 				*cV += AM[j][i] * bV[j];
226,228c290,293
<   } else
<   for (i=0;i<cr;i++)
<   { *cV=0.0;
---
> 		}
> 	else
> 		for (i = 0; i < cr; i++) {
> 			*cV = 0.0;
240c305,306
< { int Ac;
---
> {
> 	int Ac;
242,246c308,315
<   if (A->r>B->r||A->c>B->c) error(_("Target matrix too small in mcopy"));
<   BM=B->M;Ac=A->c;
<   for (AM=A->M;AM<A->M+A->r;AM++)
<   { pB= *BM;
<     for (pA= *AM;pA< *AM+Ac; pA++) *(pB++) = *pA;
---
> 	if (A->r > B->r || A->c > B->c)
> 		error(_("Target matrix too small in mcopy"));
> 	BM = B->M;
> 	Ac = A->c;
> 	for (AM = A->M; AM < A->M + A->r; AM++) {
> 		pB = *BM;
> 		for (pA = *AM; pA < *AM + Ac; pA++)
> 			*(pB++) = *pA;
251c320,321
< void matmult(C,A,B,tA,tB) matrix C,A,B;int tA,tB;
---
> void matmult(C, A, B, tA, tB)
> 	matrix C, A, B;int tA, tB;
256c326,327
< { int i,j,k;
---
> {
> 	int i, j, k;
258,264c329,341
<   AM=A.M;BM=B.M;CM=C.M; /* Saves address calculation involved in C.M */
<   if (tA)
<   { if (tB)
<     { if ((A.r!=B.c)||(A.c!=C.r)||(B.r!=C.c))
<       { error(_("Incompatible matrices in matmult."));}
<       for (i=0;i<A.c;i++) for (j=0;j<B.r;j++)
<       { p2=CM[i]+j;(*p2)=0.0;p=BM[j];
---
> 	AM = A.M;
> 	BM = B.M;
> 	CM = C.M; /* Saves address calculation involved in C.M */
> 	if (tA) {
> 		if (tB) {
> 			if ((A.r != B.c) || (A.c != C.r) || (B.r != C.c)) {
> 				error(_("Incompatible matrices in matmult."));
> 			}
> 			for (i = 0; i < A.c; i++)
> 				for (j = 0; j < B.r; j++) {
> 					p2 = CM[i] + j;
> 					(*p2) = 0.0;
> 					p = BM[j];
268,270c345,348
<     } else
<     { if ((A.r!=B.r)||(A.c!=C.r)||(B.c!=C.c))
<       { error(_("Incompatible matrices in matmult."));}
---
> 		} else {
> 			if ((A.r != B.r) || (A.c != C.r) || (B.c != C.c)) {
> 				error(_("Incompatible matrices in matmult."));
> 			}
274,275c352,355
<       for (k=0;k<A.r;k++) for (i=0;i<A.c;i++)
<       { temp=AM[k][i];p1=BM[k];
---
> 			for (k = 0; k < A.r; k++)
> 				for (i = 0; i < A.c; i++) {
> 					temp = AM[k][i];
> 					p1 = BM[k];
280,285c360,369
<   } else
<   { if (tB)
<     { if ((A.c!=B.c)||(A.r!=C.r)||(B.r!=C.c))
<       { error(_("Incompatible matrices in matmult."));}
<       for (i=0;i<A.r;i++) for (j=0;j<B.r;j++)
<       { p2=CM[i]+j;*p2=0.0;p1=BM[j];
---
> 	} else {
> 		if (tB) {
> 			if ((A.c != B.c) || (A.r != C.r) || (B.r != C.c)) {
> 				error(_("Incompatible matrices in matmult."));
> 			}
> 			for (i = 0; i < A.r; i++)
> 				for (j = 0; j < B.r; j++) {
> 					p2 = CM[i] + j;
> 					*p2 = 0.0;
> 					p1 = BM[j];
289,294c373,383
<     } else
<     { if ((A.c!=B.r)||(C.r!=A.r)||(C.c!=B.c))
<       { error(_("Incompatible matrices in matmult."));}
<       for (i=0;i<A.r;i++) for (p=CM[i];p<(CM[i]+B.c);p++) *p=0.0;
<       for (k=0;k<A.c;k++) for (i=0;i<A.r;i++)
<       { p1=BM[k];temp=AM[i][k];
---
> 		} else {
> 			if ((A.c != B.r) || (C.r != A.r) || (C.c != B.c)) {
> 				error(_("Incompatible matrices in matmult."));
> 			}
> 			for (i = 0; i < A.r; i++)
> 				for (p = CM[i]; p < (CM[i] + B.c); p++)
> 					*p = 0.0;
> 			for (k = 0; k < A.c; k++)
> 				for (i = 0; i < A.r; i++) {
> 					p1 = BM[k];
> 					temp = AM[i][k];
307c395,396
< { matrix M[1000];
---
> {
> 	matrix M[1000];
309,310c398,399
<   for (i=0;i<n;i++)
<   { M[i]=initmat(30,30);
---
> 	for (i = 0; i < n; i++) {
> 		M[i] = initmat(30, 30);
315c404,405
<   for (i=0;i<n;i++) freemat(M[i]);
---
> 	for (i = 0; i < n; i++)
> 		freemat(M[i]);
329c419,420
< { matrix temp0,temp1,*M;
---
> {
> 	matrix temp0, temp1, *M;
344,348c435,450
<   for (i=0;i<n;i++) M[i]=/*(matrix)*/ va_arg(argptr,matrix);
<   for (i=0;i<n;i++) t[i]=(int) va_arg(argptr,int);
<   if (t[0]) r=M[0].c; else r=M[0].r;
<   if (t[1]) c=M[1].r; else c=M[1].c;
<   if (n>2) temp0=initmat(r,c);else temp0=C;
---
> 	for (i = 0; i < n; i++)
> 		M[i] = /*(matrix)*/va_arg(argptr, matrix);
> 	for (i = 0; i < n; i++)
> 		t[i] = (int) va_arg(argptr, int);
> 	if (t[0])
> 		r = M[0].c;
> 	else
> 		r = M[0].r;
> 	if (t[1])
> 		c = M[1].r;
> 	else
> 		c = M[1].c;
> 	if (n > 2)
> 		temp0 = initmat(r, c);
> 	else
> 		temp0 = C;
350,352c452,457
<   for (i=1;i<n-2;i++)
<   { r=temp0.r;
<     if (t[i+1]) c=M[i+1].r; else c=M[i+1].c;
---
> 	for (i = 1; i < n - 2; i++) {
> 		r = temp0.r;
> 		if (t[i + 1])
> 			c = M[i + 1].r;
> 		else
> 			c = M[i + 1].c;
355c460,461
<     freemat(temp0);temp0=temp1;
---
> 		freemat(temp0);
> 		temp0 = temp1;
357,358c463,464
<   if (n>2)
<   { matmult(C,temp0,M[n-1],0,t[n-1]);
---
> 	if (n > 2) {
> 		matmult(C, temp0, M[n - 1], 0, t[n - 1]);
376c481,482
< { double **AM,*p,*p1,max,x;
---
> {
> 	double **AM, *p, *p1, max, x;
378c484,485
<   if (A->r!=A->c) error(_("Attempt to invert() non-square matrix"));
---
> 	if (A->r != A->c)
> 		error(_("Attempt to invert() non-square matrix"));
383c490,493
<   for (i=0;i<A->c;i++) { c[i]=i;d[i]=i;}
---
> 	for (i = 0; i < A->c; i++) {
> 		c[i] = i;
> 		d[i] = i;
> 	}
386c496,497
<   { max=0.0; 
---
> 	{
> 		max = 0.0;
388c499,500
<     { p=AM[i];
---
> 		{
> 			p = AM[i];
390c502,509
<       { x=p[c[k]];if (fabs(x)>max) { max=fabs(x);pr=i;pc=k;}}
---
> 			{
> 				x = p[c[k]];
> 				if (fabs(x) > max) {
> 					max = fabs(x);
> 					pr = i;
> 					pc = k;
> 				}
> 			}
393,394c512,517
<     p=AM[j];AM[j]=AM[pr];AM[pr]=p; /* rows exchanged */
<     k=c[j];c[j]=c[pc];c[pc]=k;   /* columns exchanged */
---
> 		p = AM[j];
> 		AM[j] = AM[pr];
> 		AM[pr] = p; /* rows exchanged */
> 		k = c[j];
> 		c[j] = c[pc];
> 		c[pc] = k; /* columns exchanged */
400,401c523,526
<     if (x==0.0) error(_("Singular Matrix passed to invert()"));
<     for (p=AM[j];p<AM[j]+A->c;p++) *p/=x; /* divide row j by pivot element */
---
> 		if (x == 0.0)
> 			error(_("Singular Matrix passed to invert()"));
> 		for (p = AM[j]; p < AM[j] + A->c; p++)
> 			*p /= x; /* divide row j by pivot element */
404,406c529,533
<     { p=AM[i];p1=AM[j];
<       if (i!=j)
<       { x = -p[cj]; /* multiplier for this row */
---
> 		{
> 			p = AM[i];
> 			p1 = AM[j];
> 			if (i != j) {
> 				x = -p[cj]; /* multiplier for this row */
408c535,538
<         { ck=c[k];p[ck]+=x*p1[ck];}
---
> 				{
> 					ck = c[k];
> 					p[ck] += x * p1[ck];
> 				}
411c541,544
<         { ck=c[k];p[ck]+=x*p1[ck];}
---
> 				{
> 					ck = c[k];
> 					p[ck] += x * p1[ck];
> 				}
417,418c550,554
<   { if (cp[i]!=i)
<     { p=AM[i];AM[i]=AM[cp[i]];AM[cp[i]]=p; /* row exchange */
---
> 	{
> 		if (cp[i] != i) {
> 			p = AM[i];
> 			AM[i] = AM[cp[i]];
> 			AM[cp[i]] = p; /* row exchange */
423,427c559,571
<   if (c[j]!=j)
<   { if (c[j]<j) k=c[c[j]]; else k=c[j]; 
<     for (i=0;i<A->r;i++)
<     { p=AM[i];x=p[j];p[j]=p[k];p[k]=x;}  
<     d[k]=d[j];d[j]=c[j];
---
> 		if (c[j] != j) {
> 			if (c[j] < j)
> 				k = c[c[j]];
> 			else
> 				k = c[j];
> 			for (i = 0; i < A->r; i++) {
> 				p = AM[i];
> 				x = p[j];
> 				p[j] = p[k];
> 				p[k] = x;
> 			}
> 			d[k] = d[j];
> 			d[j] = c[j];
432,434c576,582
<   if (rp[i]!=i)
<   { for (k=0;k<A->r;k++) 
<     { p=AM[k];x=p[i];p[i]=p[rp[i]];p[rp[i]]=x;} /* column exchange  */
---
> 		if (rp[i] != i) {
> 			for (k = 0; k < A->r; k++) {
> 				p = AM[k];
> 				x = p[i];
> 				p[i] = p[rp[i]];
> 				p[rp[i]] = x;
> 			} /* column exchange  */
437c585,588
<   FREE(c);FREE(rp);FREE(cp);FREE(d);
---
> 	FREE(c);
> 	FREE(rp);
> 	FREE(cp);
> 	FREE(d);
473c624,625
< { double **TM,*l1V,*l0V,z=1.0;
---
> {
> 	double **TM, *l1V, *l0V, z = 1.0;
475c627,629
<   TM=T->M;l0V=l0->V;l1V=l1->V;
---
> 	TM = T->M;
> 	l0V = l0->V;
> 	l1V = l1->V;
477,482c631,640
<   for (k=1;k<T->r;k++)
<   { k1=k-1;
<     if (z>0.0) l1V[k1]=TM[k][k1]/l0V[k1];   /* no problem */
<     else l1V[k1]=0.0; /* assume TM[k][k1]=0, so no problem */
<     z=l1V[k1];z=TM[k][k]-z*z;
<     if (z>0.0) l0V[k]=sqrt(z);
---
> 	for (k = 1; k < T->r; k++) {
> 		k1 = k - 1;
> 		if (z > 0.0)
> 			l1V[k1] = TM[k][k1] / l0V[k1]; /* no problem */
> 		else
> 			l1V[k1] = 0.0; /* assume TM[k][k1]=0, so no problem */
> 		z = l1V[k1];
> 		z = TM[k][k] - z * z;
> 		if (z > 0.0)
> 			l0V[k] = sqrt(z);
487a646,647
> double dot(a, b)
> 	matrix a, b;
489,496c649,661
< 
< double dot(a,b) matrix a,b;
< 
< { int i,k=0;double c=0.0,*p,*p1;
<   if (a.vec) { p1=b.V;for (p=a.V;p<a.V+a.c*a.r;p++) c+=(*p)*(*p1++);}
<   else
<   for (i=0;i<a.r;i++) for (p=a.M[i];p<(a.M[i]+a.c);p++)
<   { c+=(*p)*b.M[k/b.c][k%b.c];k++;}
---
> {
> 	int i, k = 0;
> 	double c = 0.0, *p, *p1;
> 	if (a.vec) {
> 		p1 = b.V;
> 		for (p = a.V; p < a.V + a.c * a.r; p++)
> 			c += (*p) * (*p1++);
> 	} else
> 		for (i = 0; i < a.r; i++)
> 			for (p = a.M[i]; p < (a.M[i] + a.c); p++) {
> 				c += (*p) * b.M[k / b.c][k % b.c];
> 				k++;
> 			}
500c665,666
< double mean(a) matrix a;
---
> double mean(a)
> 	matrix a;
504c670,671
< { int i;
---
> {
> 	int i;
507c674,675
<   for (i=0;i<a.r*a.c;i++) m+=aV[i];
---
> 	for (i = 0; i < a.r * a.c; i++)
> 		m += aV[i];
512,514c680,681
< 
< 
< double enorm(d) matrix d;
---
> double enorm(d)
> 	matrix d;
518c685,686
< { double e=0.0,m=0.0,y,*p;
---
> {
> 	double e = 0.0, m = 0.0, y, *p;
520,527c688,713
<   if (d.vec) for (p=d.V;p<d.V+d.r*d.c;p++) { y=fabs(*p); if (y>m) m=y; }
<   else for (i=0;i<d.r;i++) for (p=d.M[i];p<d.M[i]+d.c;p++) 
<   { y=fabs(*p);if (y>m) m=y;}/* m=max(m,fabs(*p)); */
<   if (!m) return(0.0);
<   if (d.vec) for (p=d.V;p<d.V+d.r*d.c;p++)
<   { y= *p / m; e+=y*y;} else
<   for (i=0;i<d.r;i++) for (p=d.M[i];p<(d.M[i]+d.c);p++)
<   { y= *p / m;e+=y*y;}
---
> 	if (d.vec)
> 		for (p = d.V; p < d.V + d.r * d.c; p++) {
> 			y = fabs(*p);
> 			if (y > m)
> 				m = y;
> 		}
> 	else
> 		for (i = 0; i < d.r; i++)
> 			for (p = d.M[i]; p < d.M[i] + d.c; p++) {
> 				y = fabs(*p);
> 				if (y > m)
> 					m = y;
> 			}/* m=max(m,fabs(*p)); */
> 	if (!m)
> 		return (0.0);
> 	if (d.vec)
> 		for (p = d.V; p < d.V + d.r * d.c; p++) {
> 			y = *p / m;
> 			e += y * y;
> 		}
> 	else
> 		for (i = 0; i < d.r; i++)
> 			for (p = d.M[i]; p < (d.M[i] + d.c); p++) {
> 				y = *p / m;
> 				e += y * y;
> 			}
532,536c718,719
< 
< 
< 
< 
< void householder(u,a,b,t1) matrix *u,a,b;int t1;
---
> void householder(u, a, b, t1)
> 	matrix *u, a, b;int t1;
542,543c725,730
< { int i;double v,*aV,*bV,*uV;
<   aV=a.V;bV=b.V;uV=u->V;
---
> {
> 	int i;
> 	double v, *aV, *bV, *uV;
> 	aV = a.V;
> 	bV = b.V;
> 	uV = u->V;
545c732,733
<   for (i=0;i<u->r;i++) uV[i]=aV[i]-bV[i];
---
> 	for (i = 0; i < u->r; i++)
> 		uV[i] = aV[i] - bV[i];
547c735,736
<   for (i=0;i<u->r;i++) uV[i]/=v;
---
> 	for (i = 0; i < u->r; i++)
> 		uV[i] /= v;
550,552c739,740
< 
< 
< void Hmult(C,u) matrix C,u;
---
> void Hmult(C, u)
> 	matrix C, u;
556c744,745
< { double temp,*p,*p1,*uV,**CuM,**CM;
---
> {
> 	double temp, *p, *p1, *uV, **CuM, **CM;
560,563c749,757
<   uV=u.V;CuM=Cu.M;CM=C.M;
<   for (i=0;i<Cu.r;i++)
<   { p1=CuM[i];(*p1)=0.0;p=CM[i];
<     for (j=0;j<u.r;j++) (*p1)+=(*p++)*uV[j];
---
> 	uV = u.V;
> 	CuM = Cu.M;
> 	CM = C.M;
> 	for (i = 0; i < Cu.r; i++) {
> 		p1 = CuM[i];
> 		(*p1) = 0.0;
> 		p = CM[i];
> 		for (j = 0; j < u.r; j++)
> 			(*p1) += (*p++) * uV[j];
565,566c759,761
<   for (i=0;i<Cu.r;i++)
<   { temp=Cu.V[i];p=CM[i];
---
> 	for (i = 0; i < Cu.r; i++) {
> 		temp = Cu.V[i];
> 		p = CM[i];
573c768,769
< void HQmult(C,U,p,t) matrix C,U;int p,t;
---
> void HQmult(C, U, p, t)
> 	matrix C, U;int p, t;
592c788,789
< { double *u,*CuV,**CM;
---
> {
> 	double *u, *CuV, **CM;
595,596d791
<   if (p) Cu=initmat(C.c,1);else Cu=initmat(C.r,1);
<   CuV=Cu.V;CM=C.M;
598,603c793,806
<   { if (t)
<     { for (k=0;k<U.r;k++) /* loop through the householder matrices */
<       { u=U.M[k];
<         for (i=0;i<C.c;i++)
< 	     { CuV[i]=0.0;
<           for (j=0;j<C.r;j++) CuV[i]+=CM[j][i]*u[j];
---
> 		Cu = initmat(C.c, 1);
> 	else
> 		Cu = initmat(C.r, 1);
> 	CuV = Cu.V;
> 	CM = C.M;
> 	if (p) {
> 		if (t) {
> 			for (k = 0; k < U.r; k++) /* loop through the householder matrices */
> 			{
> 				u = U.M[k];
> 				for (i = 0; i < C.c; i++) {
> 					CuV[i] = 0.0;
> 					for (j = 0; j < C.r; j++)
> 						CuV[i] += CM[j][i] * u[j];
605c808,810
< 	     for (i=0;i<C.r;i++) for (j=0;j<C.c;j++) CM[i][j] -= CuV[j]*u[i];
---
> 				for (i = 0; i < C.r; i++)
> 					for (j = 0; j < C.c; j++)
> 						CM[i][j] -= CuV[j] * u[i];
607,612c812,819
<     }  else
<     { for (k=U.r-1;k>=0;k--) /* loop through the householder matrices */
<       { u=U.M[k];
< 	     for (i=0;i<C.c;i++)
< 	     { CuV[i]=0.0;
< 	       for (j=0;j<C.r;j++) CuV[i]+=CM[j][i]*u[j];
---
> 		} else {
> 			for (k = U.r - 1; k >= 0; k--) /* loop through the householder matrices */
> 			{
> 				u = U.M[k];
> 				for (i = 0; i < C.c; i++) {
> 					CuV[i] = 0.0;
> 					for (j = 0; j < C.r; j++)
> 						CuV[i] += CM[j][i] * u[j];
614c821,823
< 	     for (i=0;i<C.r;i++) for (j=0;j<C.c;j++) CM[i][j] -= CuV[j]*u[i];
---
> 				for (i = 0; i < C.r; i++)
> 					for (j = 0; j < C.c; j++)
> 						CM[i][j] -= CuV[j] * u[i];
618,620c827,836
<   { if (t)
<     { for (k=U.r-1;k>=0;k--) /* loop through the householder matrices */
<       { u=U.M[k];
---
> 	{
> 		if (t) {
> 			for (k = U.r - 1; k >= 0; k--) /* loop through the householder matrices */
> 			{
> 				u = U.M[k];
> 				for (i = 0; i < C.r; i++) {
> 					CuV[i] = 0.0;
> 					for (j = 0; j < C.c; j++)
> 						CuV[i] += CM[i][j] * u[j];
> 				}
622,623c838,839
< 	     { CuV[i]=0.0;
< 	       for (j=0;j<C.c;j++) CuV[i]+=CM[i][j]*u[j];
---
> 					for (j = 0; j < C.c; j++)
> 						CM[i][j] -= CuV[i] * u[j];
625c841,848
< 	     for (i=0;i<C.r;i++) for (j=0;j<C.c;j++) CM[i][j] -= CuV[i]*u[j];
---
> 		} else {
> 			for (k = 0; k < U.r; k++) /* loop through the householder matrices */
> 			{
> 				u = U.M[k];
> 				for (i = 0; i < C.r; i++) {
> 					CuV[i] = 0.0;
> 					for (j = 0; j < C.c; j++)
> 						CuV[i] += CM[i][j] * u[j];
627,629d849
<       } else
<       { for (k=0;k<U.r;k++) /* loop through the householder matrices */
<       { u=U.M[k];
631,634c851,852
< 	     { CuV[i]=0.0;
< 	       for (j=0;j<C.c;j++) CuV[i]+=CM[i][j]*u[j];
< 	     }
< 	     for (i=0;i<C.r;i++) for (j=0;j<C.c;j++) CM[i][j] -= CuV[i]*u[j];
---
> 					for (j = 0; j < C.c; j++)
> 						CM[i][j] -= CuV[i] * u[j];
641,642c859,860
< 
< void QT(Q,A,fullQ) matrix Q,A;int fullQ;
---
> void QT(Q, A, fullQ)
> 	matrix Q, A;int fullQ;
654c872,873
< { int i,j,Ar,Ac,k;
---
> {
> 	int i, j, Ar, Ac, k;
656,664c875,889
<   QM=Q.M;AM=A.M;Ar=A.r;Ac=A.c;
<   if (fullQ) for (i=0;i<Ac;i++) 
<   { p=QM[i];
<     for (j=0;j<Ac;j++) if (i==j)
<     p[j]=1.0; else p[j]=0.0;
<   }
<   if (Ar>0)
<   { for (i=0;i<Ar;i++)
<     { /* rotate elements 0 to A.c-i-1 row i of A into element A.c-i-1 of that row  */
---
> 	QM = Q.M;
> 	AM = A.M;
> 	Ar = A.r;
> 	Ac = A.c;
> 	if (fullQ)
> 		for (i = 0; i < Ac; i++) {
> 			p = QM[i];
> 			for (j = 0; j < Ac; j++)
> 				if (i == j)
> 					p[j] = 1.0;
> 				else
> 					p[j] = 0.0;
> 		}
> 	if (Ar > 0) {
> 		for (i = 0; i < Ar; i++) { /* rotate elements 0 to A.c-i-1 row i of A into element A.c-i-1 of that row  */
666,668c891,903
<       m=0.0;for (j=0;j<Ac-i;j++) { x=p[j];x=fabs(x);if (x>m) m=x;} /* scale factor */
<       if (m) for (j=0;j<Ac-i;j++) p[j]/=m; /* avoid over/underflow */
<       lsq=0.0;for (j=0;j<Ac-i;j++) lsq+=p[j]*p[j];
---
> 			m = 0.0;
> 			for (j = 0; j < Ac - i; j++) {
> 				x = p[j];
> 				x = fabs(x);
> 				if (x > m)
> 					m = x;
> 			} /* scale factor */
> 			if (m)
> 				for (j = 0; j < Ac - i; j++)
> 					p[j] /= m; /* avoid over/underflow */
> 			lsq = 0.0;
> 			for (j = 0; j < Ac - i; j++)
> 				lsq += p[j] * p[j];
670c905,906
<       if (p[Ac-i-1]<0.0) lsq= -lsq;
---
> 			if (p[Ac - i - 1] < 0.0)
> 				lsq = -lsq;
674c910,911
<       else g=0.0;
---
> 			else
> 				g = 0.0;
677,678c914,918
<       { x=0.0;p1=AM[j];
<         for (k=0;k<Ac-i;k++) x+=p[k]*p1[k];
---
> 			{
> 				x = 0.0;
> 				p1 = AM[j];
> 				for (k = 0; k < Ac - i; k++)
> 					x += p[k] * p1[k];
680c920,921
<         for (k=0;k<Ac-i;k++) p1[k] += -x*p[k];
---
> 				for (k = 0; k < Ac - i; k++)
> 					p1[k] += -x * p[k];
684,685c925,930
<       { x=0.0;p=AM[i];p1=QM[j];
<         for (k=0;k<Ac-i;k++) x+=p[k]*p1[k];
---
> 				{
> 					x = 0.0;
> 					p = AM[i];
> 					p1 = QM[j];
> 					for (k = 0; k < Ac - i; k++)
> 						x += p[k] * p1[k];
687,692c932,942
<         for (k=0;k<Ac-i;k++) p1[k] += -x*p[k];
<       } else
<       { g=sqrt(g);
<         p=QM[i];p1=AM[i]; /* address saving */
<         for (j=0;j<Ac-i;j++) p[j]=p1[j]*g;
<         for (j=Ac-i;j<Ac;j++) p[j]=0.0;  
---
> 					for (k = 0; k < Ac - i; k++)
> 						p1[k] += -x * p[k];
> 				}
> 			else {
> 				g = sqrt(g);
> 				p = QM[i];
> 				p1 = AM[i]; /* address saving */
> 				for (j = 0; j < Ac - i; j++)
> 					p[j] = p1[j] * g;
> 				for (j = Ac - i; j < Ac; j++)
> 					p[j] = 0.0;
695c945,946
<       for (j=0;j<Ac-i-1;j++) AM[i][j]=0.0;
---
> 			for (j = 0; j < Ac - i - 1; j++)
> 				AM[i][j] = 0.0;
700,701c951,952
< 
< void OrthoMult(matrix *Q,matrix *A,int off,int rows,int t,int pre,int o_pre)
---
> void OrthoMult(matrix *Q, matrix *A, int off, int rows, int t, int pre,
> 		int o_pre)
714c965,966
< { double au,*u,*a,**AtM=NULL,**AM,**QM;
---
> {
> 	double au, *u, *a, **AtM = NULL, **AM, **QM;
717c969,970
<   if (o_pre) t=1-t; /* default assumption is that creation was for post mult. */
---
> 	if (o_pre)
> 		t = 1 - t; /* default assumption is that creation was for post mult. */
719,721c972,978
<   { At=initmat(A->c,A->r);
<     AM=A->M;AtM=At.M;
<     for (i=0;i<A->r;i++) for (j=0;j<A->c;j++) AtM[j][i]=AM[i][j];
---
> 	{
> 		At = initmat(A->c, A->r);
> 		AM = A->M;
> 		AtM = At.M;
> 		for (i = 0; i < A->r; i++)
> 			for (j = 0; j < A->c; j++)
> 				AtM[j][i] = AM[i][j];
723,726c980,990
<   } else At=*A;
<   AM=At.M;QM=Q->M;Ar=At.r;Qc=Q->c;
<   for (kk=0;kk<rows;kk++)
<   { if (t) k=rows-1-kk; else k=kk;
---
> 	} else
> 		At = *A;
> 	AM = At.M;
> 	QM = Q->M;
> 	Ar = At.r;
> 	Qc = Q->c;
> 	for (kk = 0; kk < rows; kk++) {
> 		if (t)
> 			k = rows - 1 - kk;
> 		else
> 			k = kk;
728,731c992,998
<     for (i=0;i<Ar;i++)
<     { a=AM[i];au=0.0;
<       for (j=off+k;j<Qc;j++) au+=a[j]*u[j];
<       for (j=off+k;j<Qc;j++) a[j] -= au*u[j];
---
> 		for (i = 0; i < Ar; i++) {
> 			a = AM[i];
> 			au = 0.0;
> 			for (j = off + k; j < Qc; j++)
> 				au += a[j] * u[j];
> 			for (j = off + k; j < Qc; j++)
> 				a[j] -= au * u[j];
734,736c1001,1005
<   if (pre)
<   { AM=A->M;
<     for (i=0;i<At.r;i++) for (j=0;j<At.c;j++) AM[j][i]=AtM[i][j];
---
> 	if (pre) {
> 		AM = A->M;
> 		for (i = 0; i < At.r; i++)
> 			for (j = 0; j < At.c; j++)
> 				AM[j][i] = AtM[i][j];
750c1018,1019
< { int i,j,k;
---
> {
> 	int i, j, k;
752c1021,1022
<   pV=p->V;yV=y->V;
---
> 	pV = p->V;
> 	yV = y->V;
754,757c1024,1034
<   { if (transpose) /* solve R'p=y for p */
<     { RM=R->M;
<       for (i=0;i<R->r;i++)
<       { x=0.0;dum=pV;for (j=0;j<i;j++) { x+=RM[j][i] * *dum;dum++;}
---
> 	{
> 		if (transpose) /* solve R'p=y for p */
> 		{
> 			RM = R->M;
> 			for (i = 0; i < R->r; i++) {
> 				x = 0.0;
> 				dum = pV;
> 				for (j = 0; j < i; j++) {
> 					x += RM[j][i] * *dum;
> 					dum++;
> 				}
760,763c1037,1043
<     } else /* solve Rp=y for p */
<     for (i=R->r-1;i>=0;i--) 
<     { RMi=R->M[i];
<       x=0.0;for (j=i+1;j<R->r;j++) x+=RMi[j]*pV[j];
---
> 		} else
> 			/* solve Rp=y for p */
> 			for (i = R->r - 1; i >= 0; i--) {
> 				RMi = R->M[i];
> 				x = 0.0;
> 				for (j = i + 1; j < R->r; j++)
> 					x += RMi[j] * pV[j];
767c1047,1049
<   { pM=p->M;yM=y->M;
---
> 	{
> 		pM = p->M;
> 		yM = y->M;
769c1051,1052
<     { RM=R->M;
---
> 		{
> 			RM = R->M;
771,772c1054,1057
<       for (i=0;i<R->r;i++)
<       { x=0.0;for (j=0;j<i;j++) x+=RM[j][i] * pM[j][k];
---
> 				for (i = 0; i < R->r; i++) {
> 					x = 0.0;
> 					for (j = 0; j < i; j++)
> 						x += RM[j][i] * pM[j][k];
775c1060,1061
<     } else /* solve Rp=y for p */
---
> 		} else
> 			/* solve Rp=y for p */
777,779c1063,1067
<     for (i=R->r-1;i>=0;i--) 
<     { RMi=R->M[i];
<       x=0.0;for (j=i+1;j<R->r;j++) x+=RMi[j]*pM[j][k];
---
> 				for (i = R->r - 1; i >= 0; i--) {
> 					RMi = R->M[i];
> 					x = 0.0;
> 					for (j = i + 1; j < R->r; j++)
> 						x += RMi[j] * pM[j][k];
803c1090,1091
< { int i,j,k,n,Rr;
---
> {
> 	int i, j, k, n, Rr;
805,806c1093,1098
<   RM=R->M;Rr=R->r;
<   if (Rr<R->c) n=Rr; else n=R->c;
---
> 	RM = R->M;
> 	Rr = R->r;
> 	if (Rr < R->c)
> 		n = Rr;
> 	else
> 		n = R->c;
808,813c1100,1123
<   for (k=0;k<n;k++)
<   { m=0.0;for (i=k;i<Rr;i++) { z=RM[i][k];z=fabs(z);if (z>m) m=z;}
<     if (m) for (i=k;i<Rr;i++) RM[i][k]/=m; /* avoid over/underflow problems */
<     t=0.0;for (i=k;i<Rr;i++) { z=RM[i][k];t+=z*z;} /* get euclidean length of column */
<     if (RM[k][k]>0.0) t = -sqrt(t);else t= sqrt(t);  /* value of new RM[k][k] (stable) */
<     for (i=k+1;i<Rr;i++) { u[i]=RM[i][k];RM[i][k]=0.0;}
---
> 	for (k = 0; k < n; k++) {
> 		m = 0.0;
> 		for (i = k; i < Rr; i++) {
> 			z = RM[i][k];
> 			z = fabs(z);
> 			if (z > m)
> 				m = z;
> 		}
> 		if (m)
> 			for (i = k; i < Rr; i++)
> 				RM[i][k] /= m; /* avoid over/underflow problems */
> 		t = 0.0;
> 		for (i = k; i < Rr; i++) {
> 			z = RM[i][k];
> 			t += z * z;
> 		} /* get euclidean length of column */
> 		if (RM[k][k] > 0.0)
> 			t = -sqrt(t);
> 		else
> 			t = sqrt(t); /* value of new RM[k][k] (stable) */
> 		for (i = k + 1; i < Rr; i++) {
> 			u[i] = RM[i][k];
> 			RM[i][k] = 0.0;
> 		}
815,816c1125,1128
<     u[k]=RM[k][k]-t;RM[k][k]=t*m;
<     t=t*t;t+=u[k]*u[k]-z*z; /* efficient t calculation */
---
> 		u[k] = RM[k][k] - t;
> 		RM[k][k] = t * m;
> 		t = t * t;
> 		t += u[k] * u[k] - z * z; /* efficient t calculation */
819,823c1131,1142
<     if (t==0.0) {FREE(u);return(0);} /* singular matrix */
<     for (p=u+k;p<u+Rr;p++) *p /= t;
<     for (j=k+1;j<R->c;j++)
<     { t=0.0;for (i=k;i<Rr;i++) t+=u[i]*RM[i][j];
<       for (i=k;i<Rr;i++) RM[i][j]-=u[i]*t;
---
> 		if (t == 0.0) {
> 			FREE(u);
> 			return (0);
> 		} /* singular matrix */
> 		for (p = u + k; p < u + Rr; p++)
> 			*p /= t;
> 		for (j = k + 1; j < R->c; j++) {
> 			t = 0.0;
> 			for (i = k; i < Rr; i++)
> 				t += u[i] * RM[i][j];
> 			for (i = k; i < Rr; i++)
> 				RM[i][j] -= u[i] * t;
826,827c1145,1148
<     { p=Q->M[k];
<       for (i=k;i<Rr;i++) p[i]=u[i];
---
> 		{
> 			p = Q->M[k];
> 			for (i = k; i < Rr; i++)
> 				p[i] = u[i];
839c1159,1160
< { int k;
---
> {
> 	int k;
843c1164,1168
<   for (k=0;k<M->r;k++) { t=MM[k][i];MM[k][i]=MM[k][j];MM[k][j]=t;}
---
> 		for (k = 0; k < M->r; k++) {
> 			t = MM[k][i];
> 			MM[k][i] = MM[k][j];
> 			MM[k][j] = t;
> 		}
845c1170,1174
<   for (k=0;k<M->c;k++) { t=MM[i][k];MM[i][k]=MM[j][k];MM[j][k]=t;}
---
> 		for (k = 0; k < M->c; k++) {
> 			t = MM[i][k];
> 			MM[i][k] = MM[j][k];
> 			MM[j][k] = t;
> 		}
866c1195,1196
< { int i,j,k;
---
> {
> 	int i, j, k;
868,873c1198,1216
<   for (i=0;i<T->r-2;i++)
<   { u=U->M[i];t=T->M[i];lt=0.0;
<     m=0.0;for (j=i+1;j<T->c;j++) { x=fabs(t[j]); if (m<x) m=x;} /* find max_j(|t_j|) for scaling */
<     if (m) for (j=i+1;j<T->c;j++) t[j]/=m; /* avoid over/underflow */
<     for (j=i+1;j<T->c;j++) lt+=t[j]*t[j];
<     if (t[i+1]>0.0) lt= -sqrt(lt);else lt=sqrt(lt);  /* ensures stability (by maximising element i+1 of u) */
---
> 	for (i = 0; i < T->r - 2; i++) {
> 		u = U->M[i];
> 		t = T->M[i];
> 		lt = 0.0;
> 		m = 0.0;
> 		for (j = i + 1; j < T->c; j++) {
> 			x = fabs(t[j]);
> 			if (m < x)
> 				m = x;
> 		} /* find max_j(|t_j|) for scaling */
> 		if (m)
> 			for (j = i + 1; j < T->c; j++)
> 				t[j] /= m; /* avoid over/underflow */
> 		for (j = i + 1; j < T->c; j++)
> 			lt += t[j] * t[j];
> 		if (t[i + 1] > 0.0)
> 			lt = -sqrt(lt);
> 		else
> 			lt = sqrt(lt); /* ensures stability (by maximising element i+1 of u) */
875,878c1218,1225
<     u[i+1]=lt-t[i+1];T->M[i+1][i]=t[i+1]=lt*m;
<     lt*=lt;lt+= -x*x+u[i+1]*u[i+1];
<     for (j=i+2;j<T->c;j++)
<     { u[j]= -t[j];T->M[j][i]=t[j]=0.0;}
---
> 		u[i + 1] = lt - t[i + 1];
> 		T->M[i + 1][i] = t[i + 1] = lt * m;
> 		lt *= lt;
> 		lt += -x * x + u[i + 1] * u[i + 1];
> 		for (j = i + 2; j < T->c; j++) {
> 			u[j] = -t[j];
> 			T->M[j][i] = t[j] = 0.0;
> 		}
880,881c1227,1230
<     { lt=sqrt(0.5*lt);
<       for (j=i+1;j<T->c;j++) u[j]/=lt;
---
> 		{
> 			lt = sqrt(0.5 * lt);
> 			for (j = i + 1; j < T->c; j++)
> 				u[j] /= lt;
884,886c1233,1239
<     { t=T->M[j];lt=0.0;
<       for (k=i+1;k<T->c;k++) lt+=u[k]*t[k];
<       for (k=i+1;k<T->c;k++) t[k] -= u[k]*lt;
---
> 		{
> 			t = T->M[j];
> 			lt = 0.0;
> 			for (k = i + 1; k < T->c; k++)
> 				lt += u[k] * t[k];
> 			for (k = i + 1; k < T->c; k++)
> 				t[k] -= u[k] * lt;
889,892c1242,1247
<     for (j=i+1;j<T->c;j++)
<     { lt=0.0;
<       for (k=i+1;k<T->c;k++) lt+=u[k]*T->M[k][j];
<       for (k=i+1;k<T->c;k++) T->M[k][j] -= u[k]*lt;
---
> 		for (j = i + 1; j < T->c; j++) {
> 			lt = 0.0;
> 			for (k = i + 1; k < T->c; k++)
> 				lt += u[k] * T->M[k][j];
> 			for (k = i + 1; k < T->c; k++)
> 				T->M[k][j] -= u[k] * lt;
924c1276,1277
< { matrix T,U,u0,u1;
---
> {
> 	matrix T, U, u0, u1;
930c1283,1285
<   for (i=0;i<T.r;i++) for (j=0;j<T.c;j++) T.M[i][j]=M->M[i][j];
---
> 	for (i = 0; i < T.r; i++)
> 		for (j = 0; j < T.c; j++)
> 			T.M[i][j] = M->M[i][j];
933c1288,1289
<   for (i=0;i<T.r-1;i++) T.M[i][i+1]=T.M[i+1][i]=(T.M[i+1][i]+T.M[i][i+1])*0.5;
---
> 	for (i = 0; i < T.r - 1; i++)
> 		T.M[i][i + 1] = T.M[i + 1][i] = (T.M[i + 1][i] + T.M[i][i + 1]) * 0.5;
935,936c1291,1294
<   u0=initmat(T.r,1);u1=initmat(T.r-1,1);
<   u0.r=T.c=T.r=rows;u1.r=rows-1;
---
> 	u0 = initmat(T.r, 1);
> 	u1 = initmat(T.r - 1, 1);
> 	u0.r = T.c = T.r = rows;
> 	u1.r = rows - 1;
940,952c1298,1328
<   max=0.0;for (i=0;i<u0.r;i++) if (fabs(T.M[i][i])>max) max=fabs(T.M[i][i]);
<   ok=1;x=u0.V[0]*u0.V[0]-T.M[0][0];m=0.0;
<   if (x>m) m=x;
<   for (i=1;i<T.r;i++) 
<   { x=u1.V[i-1]*u0.V[i-1]-T.M[i][i-1];x=fabs(x);
<     if (x>m) { m=x;k=i;}
<     x=u1.V[i-1]*u1.V[i-1]+u0.V[i]*u0.V[i]-T.M[i][i];x=fabs(x);
<     if (x>m) { m=x;k=i;}
<   }
<   if (m>10.0*DOUBLE_EPS*max) ok=0;
<   if (!ok)
<   { (*C)=svdroot(*M,tol);
<     freemat(U);freemat(T);freemat(u0);freemat(u1);
---
> 	max = 0.0;
> 	for (i = 0; i < u0.r; i++)
> 		if (fabs(T.M[i][i]) > max)
> 			max = fabs(T.M[i][i]);
> 	ok = 1;
> 	x = u0.V[0] * u0.V[0] - T.M[0][0];
> 	m = 0.0;
> 	if (x > m)
> 		m = x;
> 	for (i = 1; i < T.r; i++) {
> 		x = u1.V[i - 1] * u0.V[i - 1] - T.M[i][i - 1];
> 		x = fabs(x);
> 		if (x > m) {
> 			m = x;
> 			k = i;
> 		}
> 		x = u1.V[i - 1] * u1.V[i - 1] + u0.V[i] * u0.V[i] - T.M[i][i];
> 		x = fabs(x);
> 		if (x > m) {
> 			m = x;
> 			k = i;
> 		}
> 	}
> 	if (m > 10.0 * DOUBLE_EPS * max)
> 		ok = 0;
> 	if (!ok) {
> 		(*C) = svdroot(*M, tol);
> 		freemat(U);
> 		freemat(T);
> 		freemat(u0);
> 		freemat(u1);
960,967c1336,1348
<   { T.M[i][i]=u0.V[i];
<     if (i<u0.r-1) T.M[i+1][i]=u1.V[i];
<   }
<   for (i=U.r-3;i>=0;i--)
<   { u=U.M[i]; /* first i+1 elements of u are zero */
<     for (j=0;j<T.c;j++)
<     { uc=0.0;for (k=i+1;k<U.c;k++) uc += u[k]*T.M[k][j];
<       for (k=i+1;k<U.c;k++) T.M[k][j] -= u[k]*uc;
---
> 	{
> 		T.M[i][i] = u0.V[i];
> 		if (i < u0.r - 1)
> 			T.M[i + 1][i] = u1.V[i];
> 	}
> 	for (i = U.r - 3; i >= 0; i--) {
> 		u = U.M[i]; /* first i+1 elements of u are zero */
> 		for (j = 0; j < T.c; j++) {
> 			uc = 0.0;
> 			for (k = i + 1; k < U.c; k++)
> 				uc += u[k] * T.M[k][j];
> 			for (k = i + 1; k < U.c; k++)
> 				T.M[k][j] -= u[k] * uc;
973,974c1354,1355
<   for (j=0;j<T.c;j++)
<   { ok=0;
---
> 	for (j = 0; j < T.c; j++) {
> 		ok = 0;
976,979c1357,1368
<     if (tol<=0.0) 
<     { if ((T.M[i][j]+max!=max)||(T.M[i][j]+max!=max)) {ok=1;break;}}
<     else
<     { if ((fabs(T.M[i][j])>tol*max)||(fabs(T.M[i][j])>tol*max)) {ok=1;break;}}
---
> 			if (tol <= 0.0) {
> 				if ((T.M[i][j] + max != max) || (T.M[i][j] + max != max)) {
> 					ok = 1;
> 					break;
> 				}
> 			} else {
> 				if ((fabs(T.M[i][j]) > tol * max)
> 						|| (fabs(T.M[i][j]) > tol * max)) {
> 					ok = 1;
> 					break;
> 				}
> 			}
981c1370,1372
<     { for (i=0;i<C->r;i++) C->M[i][k]=T.M[i][j]; 
---
> 		{
> 			for (i = 0; i < C->r; i++)
> 				C->M[i][k] = T.M[i][j];
986,988c1377,1383
<   if (fswap)
<   { interchange(C,1,0,0);}
<   freemat(T);freemat(U);freemat(u0);freemat(u1);
---
> 	if (fswap) {
> 		interchange(C, 1, 0, 0);
> 	}
> 	freemat(T);
> 	freemat(U);
> 	freemat(u0);
> 	freemat(u1);
1019c1412,1413
< { double m,s=0.0,g,temp,**AM,**VM,*p,*p1;
---
> {
> 	double m, s = 0.0, g, temp, **AM, **VM, *p, *p1;
1022,1024c1416,1421
<   AM=A->M;VM=V->M;
<   for (i=0;i<A->c;i++)
<   { wl->V[i]=0.0;if (i<A->c-1) ws->V[i]=0.0;
---
> 	AM = A->M;
> 	VM = V->M;
> 	for (i = 0; i < A->c; i++) {
> 		wl->V[i] = 0.0;
> 		if (i < A->c - 1)
> 			ws->V[i] = 0.0;
1026,1027c1423,1431
< 	{ m=0.0;for (j=i;j<A->r;j++) { s=fabs(AM[j][i]); if (s>m) m=s;} /* max of column for scaling  */
<       if (m==0.0) g=0.0; 
---
> 		{
> 			m = 0.0;
> 			for (j = i; j < A->r; j++) {
> 				s = fabs(AM[j][i]);
> 				if (s > m)
> 					m = s;
> 			} /* max of column for scaling  */
> 			if (m == 0.0)
> 				g = 0.0;
1029c1433,1438
< 	  { s=0.0;for (j=i;j<A->r;j++) { AM[j][i]/=m;s+=AM[j][i]*AM[j][i];} /* scale reflector etc.  */
---
> 			{
> 				s = 0.0;
> 				for (j = i; j < A->r; j++) {
> 					AM[j][i] /= m;
> 					s += AM[j][i] * AM[j][i];
> 				} /* scale reflector etc.  */
1031c1440,1441
< 	    if (AM[i][i]<0.0) s = -s; /* avoid cancellation error */
---
> 				if (AM[i][i] < 0.0)
> 					s = -s; /* avoid cancellation error */
1039,1041c1449,1455
<       for (j=i+1;j<A->c;j++)
<       { s=0.0;for (k=i;k<A->r;k++) s+=AM[k][i]*AM[k][j];
< 	    s*=g;for (k=i;k<A->r;k++) AM[k][j] += -s*AM[k][i];
---
> 			for (j = i + 1; j < A->c; j++) {
> 				s = 0.0;
> 				for (k = i; k < A->r; k++)
> 					s += AM[k][i] * AM[k][j];
> 				s *= g;
> 				for (k = i; k < A->r; k++)
> 					AM[k][j] += -s * AM[k][i];
1046,1052c1460,1474
<     if ((i<A->r) && (i<A->c-1))
<     { m=0.0;/*for (j=i+1;j<A->c;j++) { s=fabs(AM[i][j]); if (s>m) m=s;} */ /* max for scaling */
<       for (p=AM[i]+i+1;p<AM[i]+A->c;p++) { s=fabs(*p);if (s>m) m=s;} /* max for scaling */
<       if (m==0.0) g=0.0;
<       else
<       { s=0.0;/*for (j=i+1;j<A->c;j++) { AM[i][j]/=m;s+=AM[i][j]*AM[i][j];} */
<         for (p=AM[i]+i+1;p<AM[i]+A->c;p++) { *p/=m;s+=(*p)*(*p);}
---
> 		if ((i < A->r) && (i < A->c - 1)) {
> 			m = 0.0;/*for (j=i+1;j<A->c;j++) { s=fabs(AM[i][j]); if (s>m) m=s;} *//* max for scaling */
> 			for (p = AM[i] + i + 1; p < AM[i] + A->c; p++) {
> 				s = fabs(*p);
> 				if (s > m)
> 					m = s;
> 			} /* max for scaling */
> 			if (m == 0.0)
> 				g = 0.0;
> 			else {
> 				s = 0.0;/*for (j=i+1;j<A->c;j++) { AM[i][j]/=m;s+=AM[i][j]*AM[i][j];} */
> 				for (p = AM[i] + i + 1; p < AM[i] + A->c; p++) {
> 					*p /= m;
> 					s += (*p) * (*p);
> 				}
1054c1476,1477
<         if (AM[i][i+1]<0.0) s = -s; /* avoid cancellation error */
---
> 				if (AM[i][i + 1] < 0.0)
> 					s = -s; /* avoid cancellation error */
1062,1064c1485,1491
<       for (j=i+1;j<A->r;j++)
<       { s=0.0;/*for (k=i+1;k<A->c;k++) s+=AM[i][k]*AM[j][k]; */
<         p1=AM[j]+i+1;for (p=AM[i]+i+1;p<AM[i]+A->c;p++) { s+=(*p)*(*p1);p1++;}
---
> 			for (j = i + 1; j < A->r; j++) {
> 				s = 0.0;/*for (k=i+1;k<A->c;k++) s+=AM[i][k]*AM[j][k]; */
> 				p1 = AM[j] + i + 1;
> 				for (p = AM[i] + i + 1; p < AM[i] + A->c; p++) {
> 					s += (*p) * (*p1);
> 					p1++;
> 				}
1066c1493,1497
<         p1=AM[j]+i+1;for (p=AM[i]+i+1;p<AM[i]+A->c;p++) { *p1 += -s*(*p);p1++;}
---
> 				p1 = AM[j] + i + 1;
> 				for (p = AM[i] + i + 1; p < AM[i] + A->c; p++) {
> 					*p1 += -s * (*p);
> 					p1++;
> 				}
1082c1513,1515
<   nu=A->c; if (A->r<nu) nu=A->r; /* number of U_i's */
---
> 	nu = A->c;
> 	if (A->r < nu)
> 		nu = A->r; /* number of U_i's */
1084,1085c1517,1523
<   for (p=VM[i];p<VM[i]+A->c;p++) *p=0.0;
<   for (i=A->c-1;i>nv;i--) { if (i<nu) AM[i-1][i]=VM[i][i];VM[i][i]=1.0;}
---
> 		for (p = VM[i]; p < VM[i] + A->c; p++)
> 			*p = 0.0;
> 	for (i = A->c - 1; i > nv; i--) {
> 		if (i < nu)
> 			AM[i - 1][i] = VM[i][i];
> 		VM[i][i] = 1.0;
> 	}
1087c1525,1526
<   { temp=VM[i+1][i+1];
---
> 	{
> 		temp = VM[i + 1][i + 1];
1089c1528,1529
<     for (p=VM[i+1];p<VM[i+1]+A->c;p++) *p=0.0;
---
> 		for (p = VM[i + 1]; p < VM[i + 1] + A->c; p++)
> 			*p = 0.0;
1092c1532,1538
<     { s=0.0;p=AM[i]+i+1;for (k=i+1;k<A->c;k++) { s+=VM[k][j]*(*p);p++;}
---
> 		{
> 			s = 0.0;
> 			p = AM[i] + i + 1;
> 			for (k = i + 1; k < A->c; k++) {
> 				s += VM[k][j] * (*p);
> 				p++;
> 			}
1094c1540,1544
<       p=AM[i]+i+1;for (k=i+1;k<A->c;k++) { VM[k][j] += -s*(*p);p++;}
---
> 			p = AM[i] + i + 1;
> 			for (k = i + 1; k < A->c; k++) {
> 				VM[k][j] += -s * (*p);
> 				p++;
> 			}
1102,1103c1552,1558
<   { if (i>0) g=AM[i-1][i]; else g=VM[0][0];
<     for (j=0;j<i;j++) AM[j][i]=0.0; /* zeroing column above the diagonal */
---
> 	{
> 		if (i > 0)
> 			g = AM[i - 1][i];
> 		else
> 			g = VM[0][0];
> 		for (j = 0; j < i; j++)
> 			AM[j][i] = 0.0; /* zeroing column above the diagonal */
1105c1560,1563
<     { s=0.0;for (k=i;k<A->r;k++) s+= AM[k][i]*AM[k][j];
---
> 		{
> 			s = 0.0;
> 			for (k = i; k < A->r; k++)
> 				s += AM[k][i] * AM[k][j];
1107c1565,1566
<       for (k=i;k<A->r;k++) AM[k][j] += -s*AM[k][i]; 
---
> 			for (k = i; k < A->r; k++)
> 				AM[k][j] += -s * AM[k][i];
1110c1569,1570
<     for (j=A->r-1;j>i;j--) AM[j][i]*= -g*AM[i][i];
---
> 		for (j = A->r - 1; j > i; j--)
> 			AM[j][i] *= -g * AM[i][i];
1114c1574,1578
<   p=VM[0];for (i=0;i<A->c;i++) { *p=VM[i][0]=0.0;p++;}
---
> 	p = VM[0];
> 	for (i = 0; i < A->c; i++) {
> 		*p = VM[i][0] = 0.0;
> 		p++;
> 	}
1161c1623,1625
< { double wnorm=0.0,x,y,s,c,m,r,a,b,sig,**VM,**UM,*wV,*wsV,*p1,*p2,tol; 
---
> {
> 	double wnorm = 0.0, x, y, s, c, m, r, a, b, sig, **VM, **UM, *wV, *wsV, *p1,
> 			*p2, tol;
1164c1628,1631
<   VM=V->M;UM=U->M;wV=w->V;wsV=ws->V;
---
> 	VM = V->M;
> 	UM = U->M;
> 	wV = w->V;
> 	wsV = ws->V;
1166c1633,1640
<   { x=fabs(wV[i]);y=fabs(wsV[i]);if (x<y) x=y;if (wnorm<x) wnorm=x;}
---
> 	{
> 		x = fabs(wV[i]);
> 		y = fabs(wsV[i]);
> 		if (x < y)
> 			x = y;
> 		if (wnorm < x)
> 			wnorm = x;
> 	}
1168,1169c1642,1643
<   while (!finished)
<   { for (k=0;k<maxreps;k++) /* QR iteration loop */
---
> 	while (!finished) {
> 		for (k = 0; k < maxreps; k++) /* QR iteration loop */
1171,1175c1645,1648
<       if (fabs(wV[end])<=tol*wnorm)
<       { /*if (wsV[end-1]+wnorm!=wnorm)*/ /* need to zero wsV[end-1] before deflating */
<         if (fabs(wsV[end-1])>tol*wnorm)
<         { /* Series of rotators (Givens rotations from right) zero this element */
<           y=wsV[end-1];wsV[end-1]=0.0;
---
> 			if (fabs(wV[end]) <= tol * wnorm) { /*if (wsV[end-1]+wnorm!=wnorm)*//* need to zero wsV[end-1] before deflating */
> 				if (fabs(wsV[end - 1]) > tol * wnorm) { /* Series of rotators (Givens rotations from right) zero this element */
> 					y = wsV[end - 1];
> 					wsV[end - 1] = 0.0;
1177c1650,1654
<           { m=fabs(y);x=fabs(wV[i]); if (x>m) m=x;
---
> 					{
> 						m = fabs(y);
> 						x = fabs(wV[i]);
> 						if (x > m)
> 							m = x;
1179,1180c1656,1658
<             if (m>0.0) 
<             { y/=m;x/=m; /* now rotate y into x */
---
> 						if (m > 0.0) {
> 							y /= m;
> 							x /= m; /* now rotate y into x */
1182,1183c1660,1666
<               c=x/r;s=y/r;
<             } else {r=0.0;c=1.0;s=0.0;}
---
> 							c = x / r;
> 							s = y / r;
> 						} else {
> 							r = 0.0;
> 							c = 1.0;
> 							s = 0.0;
> 						}
1186c1669,1670
<             { y= -wsV[i-1]*s;
---
> 						{
> 							y = -wsV[i - 1] * s;
1191c1675,1678
<             { p2=VM[j]+end;p1=VM[j]+i;x=*p1; /*x=VM[j][i]; */
---
> 						{
> 							p2 = VM[j] + end;
> 							p1 = VM[j] + i;
> 							x = *p1; /*x=VM[j][i]; */
1195c1682,1683
<               *p2 *= c; *p2 += -s*x;
---
> 							*p2 *= c;
> 							*p2 += -s * x;
1201c1689,1690
<         if (end<=0) finished=1;
---
> 				if (end <= 0)
> 					finished = 1;
1203,1204c1692
<       } else 
<       if (fabs(wsV[end-1])<=tol*wnorm)  /* inelegant condition needed because below can fail in R because of register optimizations */
---
> 			} else if (fabs(wsV[end - 1]) <= tol * wnorm) /* inelegant condition needed because below can fail in R because of register optimizations */
1206,1207c1694,1697
<       { end--;
<         if (end==0) finished=1; /* all elements of ws are zeroed so we're done */
---
> 			{
> 				end--;
> 				if (end == 0)
> 					finished = 1; /* all elements of ws are zeroed so we're done */
1210c1700,1701
<       { start=end-1;
---
> 			{
> 				start = end - 1;
1212c1703,1705
<         while ((fabs(wV[start])>tol*wnorm)&&(fabs(wsV[start])>tol*wnorm)&&(start>=0)) start--;
---
> 				while ((fabs(wV[start]) > tol * wnorm)
> 						&& (fabs(wsV[start]) > tol * wnorm) && (start >= 0))
> 					start--;
1215,1217c1708,1711
<         if ((start>0)&&(fabs(wV[start-1])<=tol*wnorm)&&(fabs(wsV[start-1])>tol*wnorm)) 
<         { /* ws.V[start-1] must be zeroed.... */
<           y=wsV[start-1];wsV[start-1]=0.0;
---
> 				if ((start > 0) && (fabs(wV[start - 1]) <= tol * wnorm)
> 						&& (fabs(wsV[start - 1]) > tol * wnorm)) { /* ws.V[start-1] must be zeroed.... */
> 					y = wsV[start - 1];
> 					wsV[start - 1] = 0.0;
1219c1713,1717
<           { m=fabs(y);x=fabs(wV[i]); if (x>m) m=x;
---
> 					{
> 						m = fabs(y);
> 						x = fabs(wV[i]);
> 						if (x > m)
> 							m = x;
1221,1222c1719,1721
<             if (m>0.0)
<             { x/=m;y/=m;
---
> 						if (m > 0.0) {
> 							x /= m;
> 							y /= m;
1224,1225c1723,1729
<               c=x/r;s=y/r;
<             } else {r=1.0;c=1.0;s=0.0;}
---
> 							c = x / r;
> 							s = y / r;
> 						} else {
> 							r = 1.0;
> 							c = 1.0;
> 							s = 0.0;
> 						}
1228c1732,1733
<             { y= -s*wsV[i];
---
> 						{
> 							y = -s * wsV[i];
1233c1738,1741
<             { p1=UM[j]+start-1;x = *p1;p2=UM[j]+i;/*x=UM[j][start-1]; */
---
> 						{
> 							p1 = UM[j] + start - 1;
> 							x = *p1;
> 							p2 = UM[j] + i;/*x=UM[j][start-1]; */
1237c1745,1746
<               *p2 *= c; *p2 += s*x; 
---
> 							*p2 *= c;
> 							*p2 += s * x;
1248c1757,1759
<       a=wV[end-1]*wV[end-1]+wsV[end-1]*wsV[end-1];b=wV[end];b*=b;
---
> 			a = wV[end - 1] * wV[end - 1] + wsV[end - 1] * wsV[end - 1];
> 			b = wV[end];
> 			b *= b;
1251,1252c1762,1767
<       x=(a+b)/2+y;y=(a+b)/2-y; /* x and y are the eigenvalues */
<       if (fabs(x-b)<fabs(y-b)) sig=x; else sig=y;
---
> 			x = (a + b) / 2 + y;
> 			y = (a + b) / 2 - y; /* x and y are the eigenvalues */
> 			if (fabs(x - b) < fabs(y - b))
> 				sig = x;
> 			else
> 				sig = y;
1260,1262c1775,1780
<       m=fabs(x);if (fabs(y)>m) m=fabs(y);
<       if (m>0.0)
<       { y/=m;x/=m; /* avoid over/underflow */
---
> 			m = fabs(x);
> 			if (fabs(y) > m)
> 				m = fabs(y);
> 			if (m > 0.0) {
> 				y /= m;
> 				x /= m; /* avoid over/underflow */
1264,1267c1782,1789
<         c=x/r;s=y/r; /* elements of rotator to apply from right operating in start,start+1 plane */
<       } else { r=1.0;c=1.0;s=0.0;}
<       for (i=start;i<end;i++) 
<       { /* start with post-multiplication */
---
> 				c = x / r;
> 				s = y / r; /* elements of rotator to apply from right operating in start,start+1 plane */
> 			} else {
> 				r = 1.0;
> 				c = 1.0;
> 				s = 0.0;
> 			}
> 			for (i = start; i < end; i++) { /* start with post-multiplication */
1269,1272c1791,1798
<         { x=wsV[i-1]; /* location y rotated into */
<           m=fabs(y);if (fabs(x)>m) m=fabs(x);
<           if (m>0.0)
<           { x/=m;y/=m;   /* avoiding overflow */
---
> 				{
> 					x = wsV[i - 1]; /* location y rotated into */
> 					m = fabs(y);
> 					if (fabs(x) > m)
> 						m = fabs(x);
> 					if (m > 0.0) {
> 						x /= m;
> 						y /= m; /* avoiding overflow */
1274,1276c1800,1808
<             c=x/r;s=y/r;
<           } else {r=1.0;c=1.0;s=0.0;} /* rotator for zeroing y (at i-1,i+1) int x at (i-1,i) */
<           wsV[i-1]=r*m;y=0.0;
---
> 						c = x / r;
> 						s = y / r;
> 					} else {
> 						r = 1.0;
> 						c = 1.0;
> 						s = 0.0;
> 					} /* rotator for zeroing y (at i-1,i+1) int x at (i-1,i) */
> 					wsV[i - 1] = r * m;
> 					y = 0.0;
1282c1814,1815
<         y=s*wV[i+1];wV[i+1]*=c; /* y contains the bulge at (i+1,i) */
---
> 				y = s * wV[i + 1];
> 				wV[i + 1] *= c; /* y contains the bulge at (i+1,i) */
1285c1818,1821
<         { p1=VM[j]+i;x= *p1;p2=VM[j]+i+1; /*x=VM[j][i]; */
---
> 				{
> 					p1 = VM[j] + i;
> 					x = *p1;
> 					p2 = VM[j] + i + 1; /*x=VM[j][i]; */
1289c1825,1826
<           *p2 *= c; *p2 += -s*x;
---
> 					*p2 *= c;
> 					*p2 += -s * x;
1294,1296c1831,1836
<         m=fabs(y);if (fabs(x)>m) m = fabs(x);
<         if (m>0.0)
<         { x/=m;y/=m; /* avoid overflow */
---
> 				m = fabs(y);
> 				if (fabs(x) > m)
> 					m = fabs(x);
> 				if (m > 0.0) {
> 					x /= m;
> 					y /= m; /* avoid overflow */
1298,1300c1838,1846
<           c=x/r;s=y/r;
<         } else {r=1.0;c=1.0;s=0.0;} /* transform to zero y into x (i+1,i) into (i,i) */
<         wV[i]=r*m;y=0.0; 
---
> 					c = x / r;
> 					s = y / r;
> 				} else {
> 					r = 1.0;
> 					c = 1.0;
> 					s = 0.0;
> 				} /* transform to zero y into x (i+1,i) into (i,i) */
> 				wV[i] = r * m;
> 				y = 0.0;
1305,1306c1851,1852
<         if (i<end-1)
<         { y=wsV[i+1]*s;
---
> 				if (i < end - 1) {
> 					y = wsV[i + 1] * s;
1311c1857,1860
<         { p1=UM[j]+i;x= *p1;p2=UM[j]+i+1;/*x=UM[j][i]; */
---
> 				{
> 					p1 = UM[j] + i;
> 					x = *p1;
> 					p2 = UM[j] + i + 1;/*x=UM[j][i]; */
1315c1864,1865
<           *p2 *= c; *p2 += -s*x;
---
> 					*p2 *= c;
> 					*p2 += -s * x;
1320c1870
<     error(_("svd() not converged"));
---
> 			error(_("'svd()' not converged"));
1324,1326c1874,1877
<   if (wV[i]<0.0)
<   { wV[i]= -wV[i];
<     for (j=0;j<V->r;j++) VM[j][i]= -VM[j][i];
---
> 		if (wV[i] < 0.0) {
> 			wV[i] = -wV[i];
> 			for (j = 0; j < V->r; j++)
> 				VM[j][i] = -VM[j][i];
1350c1898,1899
< { matrix *U,ws;
---
> {
> 	matrix *U, ws;
1353,1354c1902,1905
<   { w->V[0]=0.0;
<     for (i=0;i<A->r;i++) w->V[0]+=A->M[i][0]*A->M[i][0];
---
> 	{
> 		w->V[0] = 0.0;
> 		for (i = 0; i < A->r; i++)
> 			w->V[0] += A->M[i][0] * A->M[i][0];
1356c1907,1908
<     for (i=0;i<A->r;i++) A->M[i][0]/=w->V[0]; 
---
> 		for (i = 0; i < A->r; i++)
> 			A->M[i][0] /= w->V[0];
1381c1926,1927
< { int k=0l,i,j;
---
> {
> 	int k = 0l, i, j;
1385c1931,1932
<   a=initmat(A.r,A.c);mcopy(&A,&a);
---
> 	a = initmat(A.r, A.c);
> 	mcopy(&A, &a);
1389c1936,1940
<   for (i=0;i<w.r;i++) { w.V[i]=sqrt(w.V[i]);if (w.V[i]>tol) tol=w.V[i];}
---
> 	for (i = 0; i < w.r; i++) {
> 		w.V[i] = sqrt(w.V[i]);
> 		if (w.V[i] > tol)
> 			tol = w.V[i];
> 	}
1391,1396c1942,1952
<   for (i=0;i<w.r;i++)
<   { if (w.V[i]>tol)
<     { for (j=0;j<a.c;j++) v.M[j][k]=a.M[j][i]*w.V[i];k++;
<       prod=0.0;for (j=0;j<a.r;j++) prod+=a.M[j][i]*v.M[j][i];
<       if (prod<0.0) 
< 	  { sprintf(err,_("svdroot matrix not +ve semi def. %g"),w.V[i]*w.V[i]);
---
> 	for (i = 0; i < w.r; i++) {
> 		if (w.V[i] > tol) {
> 			for (j = 0; j < a.c; j++)
> 				v.M[j][k] = a.M[j][i] * w.V[i];
> 			k++;
> 			prod = 0.0;
> 			for (j = 0; j < a.r; j++)
> 				prod += a.M[j][i] * v.M[j][i];
> 			if (prod < 0.0) {
> 				sprintf(err, _("svdroot matrix not +ve semi def. %g"),
> 						w.V[i] * w.V[i]);
1402c1958,1959
<   freemat(a);freemat(w);
---
> 	freemat(a);
> 	freemat(w);
1411,1412c1966,1969
<   if (*(double *)a<*(double *)b) return(-1);
<   if (*(double *)a>*(double *)b) return(1);
---
> 	if (*(double *) a < *(double *) b)
> 		return (-1);
> 	if (*(double *) a > *(double *) b)
> 		return (1);
1421c1977,1978
< { int i;
---
> {
> 	int i;
1423c1980,1981
<   for (i=0;i<a.r*a.c-1;i++) if (a.V[i]>a.V[i+1])
---
> 	for (i = 0; i < a.r * a.c - 1; i++)
> 		if (a.V[i] > a.V[i + 1])
1434c1988,1989
< { static int k=0;
---
> {
> 	static int k = 0;
1436,1437c1991,1996
<   if (el>0) { k=el;return(0);}
<   na=(*(double **)a);nb=(*(double **)b);
---
> 	if (el > 0) {
> 		k = el;
> 		return (0);
> 	}
> 	na = (*(double **) a);
> 	nb = (*(double **) b);
1440,1441c1999,2002
<     if (*na < *nb) return(-1);
<     if (*na > *nb) return(1);
---
> 		if (*na < *nb)
> 			return (-1);
> 		if (*na > *nb)
> 			return (1);
1448c2009,2010
< { return(real_elemcmp(a,b,-1));
---
> {
> 	return (real_elemcmp(a, b, -1));
1460c2021,2022
< { double z=0.0;
---
> {
> 	double z = 0.0;
1470,1471c2032,2036
< { int i,j;
<   for (i=0;i<M->r;i++) for (j=0;j<M->c;j++) a[i+r*j]=M->M[i][j];
---
> {
> 	int i, j;
> 	for (i = 0; i < M->r; i++)
> 		for (j = 0; j < M->c; j++)
> 			a[i + r * j] = M->M[i][j];
1480c2044,2045
< { int i,j;
---
> {
> 	int i, j;
1483c2048,2050
<   for (i=0;i<r;i++) for (j=0;j<c;j++) M.M[i][j]=A[i+j*r];
---
> 	for (i = 0; i < r; i++)
> 		for (j = 0; j < c; j++)
> 			M.M[i][j] = A[i + j * r];
diff -rEZbwB '--exclude=*.[lo,d,pdf,mo,po,tgz,gz,save]*' '--exclude=MD5' '--exclude=Makefile*' '--exclude=all.R' '--exclude=Changes' R-recommended/mgcv/src/matrix.h Recommended/mgcv/src/matrix.h
9,10c9,13
< typedef struct
< { int vec, r,c,original_r,original_c;long mem;double **M,*V;} matrix;
---
> typedef struct {
> 	int vec, r, c, original_r, original_c;
> 	long mem;
> 	double **M, *V;
> } matrix;
38c41,42
< void OrthoMult(matrix *Q,matrix *A,int off,int rows,int t,int pre,int o_pre);
---
> void OrthoMult(matrix *Q, matrix *A, int off, int rows, int t, int pre,
> 		int o_pre);
diff -rEZbwB '--exclude=*.[lo,d,pdf,mo,po,tgz,gz,save]*' '--exclude=MD5' '--exclude=Makefile*' '--exclude=all.R' '--exclude=Changes' R-recommended/mgcv/src/mgcv.c Recommended/mgcv/src/mgcv.c
47c47,48
< { int start,i,j,k;
---
> {
> 	int start, i, j, k;
49,50c50,53
<   for (k=0;k<m;k++)
<   { for (i=0;i<S[k].r;i++) for (j=0;j<S[k].c;j++) S[k].M[i][j]=RS[start+i+S[k].r*j];
---
> 	for (k = 0; k < m; k++) {
> 		for (i = 0; i < S[k].r; i++)
> 			for (j = 0; j < S[k].c; j++)
> 				S[k].M[i][j] = RS[start + i + S[k].r * j];
58c61,62
< { int start,i,j,k;
---
> {
> 	int start, i, j, k;
60,61c64,67
<   for (k=0;k<m;k++)
<   { for (i=0;i<S[k].r;i++) for (j=0;j<S[k].c;j++) RS[start+i+S[k].r*j]=S[k].M[i][j];
---
> 	for (k = 0; k < m; k++) {
> 		for (i = 0; i < S[k].r; i++)
> 			for (j = 0; j < S[k].c; j++)
> 				RS[start + i + S[k].r * j] = S[k].M[i][j];
67,68c73,74
< 
< matrix getD(h,nak) matrix h;int nak;
---
> matrix getD(h, nak)
> 	matrix h;int nak;
75c81,82
< { long i,j,n;
---
> {
> 	long i, j, n;
78,85c85,96
<   T=initmat(n,n);D=initmat(n,n);Res=initmat(n,n);
<   for (i=0;i<n;i++) for (j=0;j<n;j++)
<   { T.M[i][j]=0.0;D.M[i][j]=0.0;}
<   if (n==1L)
<   { Res.M[0][0]=0.0;
<   } else
<   if (n==2L)
<   { Res.M[0][0]=Res.M[1][0]=-1.0/h.V[0];
---
> 	T = initmat(n, n);
> 	D = initmat(n, n);
> 	Res = initmat(n, n);
> 	for (i = 0; i < n; i++)
> 		for (j = 0; j < n; j++) {
> 			T.M[i][j] = 0.0;
> 			D.M[i][j] = 0.0;
> 		}
> 	if (n == 1L) {
> 		Res.M[0][0] = 0.0;
> 	} else if (n == 2L) {
> 		Res.M[0][0] = Res.M[1][0] = -1.0 / h.V[0];
87,90c98,102
<   } else
<   { for (i=0;i<n;i++) T.M[i][i]=2.0;
<     for (i=1;i<n-1;i++)
<     { T.M[i][i-1]=h.V[i]/(h.V[i]+h.V[i-1]);
---
> 	} else {
> 		for (i = 0; i < n; i++)
> 			T.M[i][i] = 2.0;
> 		for (i = 1; i < n - 1; i++) {
> 			T.M[i][i - 1] = h.V[i] / (h.V[i] + h.V[i - 1]);
96,103c108,117
<     if (!nak)
<     { T.M[0][1]=1.0;D.M[0][0]= -3.0/h.V[0];D.M[0][1]= -D.M[0][0];}
<     else
<     { T.M[0][1]=2.0*(h.V[0]+h.V[1])/h.V[1];
<       D.M[0][0]= -2.0*(3.0*h.V[0]+2.0*h.V[1])/
< 		(h.V[0]*(h.V[0]+h.V[1]));
<       D.M[0][2]=2.0*h.V[0]*h.V[0]/
<       (h.V[1]*h.V[1]*(h.V[0]+h.V[1]));
---
> 		if (!nak) {
> 			T.M[0][1] = 1.0;
> 			D.M[0][0] = -3.0 / h.V[0];
> 			D.M[0][1] = -D.M[0][0];
> 		} else {
> 			T.M[0][1] = 2.0 * (h.V[0] + h.V[1]) / h.V[1];
> 			D.M[0][0] = -2.0 * (3.0 * h.V[0] + 2.0 * h.V[1])
> 					/ (h.V[0] * (h.V[0] + h.V[1]));
> 			D.M[0][2] = 2.0 * h.V[0] * h.V[0]
> 					/ (h.V[1] * h.V[1] * (h.V[0] + h.V[1]));
106c120,121
<     T.M[n-1][n-2]=1.0;D.M[n-1][n-2]= -3.0/h.V[n-2];
---
> 		T.M[n - 1][n - 2] = 1.0;
> 		D.M[n - 1][n - 2] = -3.0 / h.V[n - 2];
111c126,127
<   freemat(T);freemat(D);
---
> 	freemat(T);
> 	freemat(D);
115c131,132
< void MonoCon(matrix *A,matrix *b,matrix *x,int control,double lower,double upper ) 
---
> void MonoCon(matrix *A, matrix *b, matrix *x, int control, double lower,
> 		double upper)
127c144,145
< { long i,j,n;
---
> {
> 	long i, j, n;
133c151,152
<   for (i=0;i<n;i++) h.V[i]=x->V[i+1]-x->V[i];
---
> 	for (i = 0; i < n; i++)
> 		h.V[i] = x->V[i + 1] - x->V[i];
135,136c154,157
<   up=control/4;control=control%4;
<   lo=control/2;control=control%2;
---
> 	up = control / 4;
> 	control = control % 4;
> 	lo = control / 2;
> 	control = control % 2;
138c159,162
<   if (up) m= -1.0; else m=1.0; 
---
> 	if (up)
> 		m = -1.0;
> 	else
> 		m = 1.0;
140,143c164,167
<   for (i=0;i<n;i++)
<   { for (j=0;j<n+1;j++)
<     { if (j==i)
<       { A->M[i][j]=(D.M[i][j]+3.0/h.V[i])*m;   /**not certain of d.M update**/
---
> 	for (i = 0; i < n; i++) {
> 		for (j = 0; j < n + 1; j++) {
> 			if (j == i) {
> 				A->M[i][j] = (D.M[i][j] + 3.0 / h.V[i]) * m; /**not certain of d.M update**/
147,149c171,172
<       } else
<       if (j==(i+1))
<       { A->M[i][j]=(D.M[i][j]-3.0/h.V[i])*m;
---
> 			} else if (j == (i + 1)) {
> 				A->M[i][j] = (D.M[i][j] - 3.0 / h.V[i]) * m;
153,154c176,177
<       } else
<       { A->M[i][j]=D.M[i][j]*m;
---
> 			} else {
> 				A->M[i][j] = D.M[i][j] * m;
162,164c185,191
<   if (lo)
<   { for (j=0;j<n+1;j++) A->M[4*n][j]=0.0;
<     if (up) A->M[4*n][0]=1.0; else A->M[4*n][n]=1.0;
---
> 	if (lo) {
> 		for (j = 0; j < n + 1; j++)
> 			A->M[4 * n][j] = 0.0;
> 		if (up)
> 			A->M[4 * n][0] = 1.0;
> 		else
> 			A->M[4 * n][n] = 1.0;
167,169c194,200
<   if (hi)
<   { for (j=0;j<n+1;j++) A->M[4*n][j]=0.0;
<     if (up) A->M[4*n+lo][n]=-1.0; else A->M[4*n+lo][0]=-1.0;
---
> 	if (hi) {
> 		for (j = 0; j < n + 1; j++)
> 			A->M[4 * n][j] = 0.0;
> 		if (up)
> 			A->M[4 * n + lo][n] = -1.0;
> 		else
> 			A->M[4 * n + lo][0] = -1.0;
187c217,218
<   for (i=1;i<n;i++) h[i-1] = x[i]-x[i-1];
---
> 	for (i = 1; i < n; i++)
> 		h[i - 1] = x[i] - x[i - 1];
192,194c223,229
<   n1 = n-1;n2=n-2;
<   for (Di=D,Di1=D+n2,Di2=Di1+n2,i=0;i<n2;i++,Di+=n1,Di1+=n1,Di2+=n1) {
<     *Di = 1/h[i];*Di2 = 1/h[i+1];*Di1 = - *Di - *Di2;
---
> 	n1 = n - 1;
> 	n2 = n - 2;
> 	for (Di = D, Di1 = D + n2, Di2 = Di1 + n2, i = 0; i < n2;
> 			i++, Di += n1, Di1 += n1, Di2 += n1) {
> 		*Di = 1 / h[i];
> 		*Di2 = 1 / h[i + 1];
> 		*Di1 = -*Di - *Di2;
198c233,234
<   for (i=0;i<n2;i++) ldB[i] = (h[i]+h[i+1])/3;
---
> 	for (i = 0; i < n2; i++)
> 		ldB[i] = (h[i] + h[i + 1]) / 3;
200c236,237
<   for (i=1;i<n2;i++) sdB[i-1] = h[i]/6;
---
> 	for (i = 1; i < n2; i++)
> 		sdB[i - 1] = h[i] / 6;
208c245,246
<     *Fp=0.0;Fp+=n;
---
> 		*Fp = 0.0;
> 		Fp += n;
210c248,249
<     for (j=0;j<n2;j++,Fp+=n,Di++) *Fp = *Di; 
---
> 		for (j = 0; j < n2; j++, Fp += n, Di++)
> 			*Fp = *Di;
216c255,256
<   for (Sp=S,Di=D,i=0;i<n;i++,Sp+=n,Di+=n2) *Sp = *Di * a;
---
> 	for (Sp = S, Di = D, i = 0; i < n; i++, Sp += n, Di += n2)
> 		*Sp = *Di * a;
218,219c258,262
<     a = -1/h[0] - 1/h[1];b = 1/h[1]; /* row 1 */
<     for (Sp=S+1,Di1=D+1,Di=D,i=0;i<n;i++,Sp+=n,Di+=n2,Di1+=n2) *Sp = *Di * a + *Di1 * b;
---
> 		a = -1 / h[0] - 1 / h[1];
> 		b = 1 / h[1]; /* row 1 */
> 		for (Sp = S + 1, Di1 = D + 1, Di = D, i = 0; i < n; i++, Sp += n, Di +=
> 				n2, Di1 += n2)
> 			*Sp = *Di * a + *Di1 * b;
221,222c264,268
<       a = 1/h[j-1];c = 1/h[j];b = -a -c; 
<       for (Sp=S+j,Di=D+j-2,Di1 = D +j-1,Di2=D + j,i=0;i<n;i++,Sp+=n,Di+=n2,Di1+=n2,Di2+=n2) 
---
> 			a = 1 / h[j - 1];
> 			c = 1 / h[j];
> 			b = -a - c;
> 			for (Sp = S + j, Di = D + j - 2, Di1 = D + j - 1, Di2 = D + j, i = 0;
> 					i < n; i++, Sp += n, Di += n2, Di1 += n2, Di2 += n2)
226,227c272,276
<     a = 1/h[j-1]; b = -1/h[j-1] - 1/h[j]; /* row n-2 */
<     for (Sp=S+n2,Di1=D+n2-1,Di=D+n2-2,i=0;i<n;i++,Sp+=n,Di+=n2,Di1+=n2) *Sp = *Di * a + *Di1 * b;
---
> 		a = 1 / h[j - 1];
> 		b = -1 / h[j - 1] - 1 / h[j]; /* row n-2 */
> 		for (Sp = S + n2, Di1 = D + n2 - 1, Di = D + n2 - 2, i = 0; i < n;
> 				i++, Sp += n, Di += n2, Di1 += n2)
> 			*Sp = *Di * a + *Di1 * b;
230c279,280
<     for (Sp=S+1,Di=D,i=0;i<n;i++,Sp+=n,Di+=n2) *Sp = *Di * a;
---
> 		for (Sp = S + 1, Di = D, i = 0; i < n; i++, Sp += n, Di += n2)
> 			*Sp = *Di * a;
234c284,285
<   for (Sp=S+n1,Di=D+n2-1,i=0;i<n;i++,Sp+=n,Di+=n2) *Sp = *Di * a;
---
> 	for (Sp = S + n1, Di = D + n2 - 1, i = 0; i < n; i++, Sp += n, Di += n2)
> 		*Sp = *Di * a;
236c287,290
<   FREE(ldB);FREE(sdB);FREE(h);FREE(D);
---
> 	FREE(ldB);
> 	FREE(sdB);
> 	FREE(h);
> 	FREE(D);
239,240c293,294
< 
< void crspl(double *x,int *n,double *xk, int *nk,double *X,double *S, double *F,int *Fsupplied) {
---
> void crspl(double *x, int *n, double *xk, int *nk, double *X, double *S,
> 		double *F, int *Fsupplied) {
248,250c302,307
<   double xlast=0.0,h=0.0,xi,kmax,kmin,ajm,ajp,cjm,cjp,*Fp,*Fp1,*Xp,xj,xj1,xik;
<   if (! *Fsupplied) getFS(xk,*nk,S,F);
<   kmax = xk[*nk-1];kmin = xk[0];
---
> 	double xlast = 0.0, h = 0.0, xi, kmax, kmin, ajm, ajp, cjm, cjp, *Fp, *Fp1,
> 			*Xp, xj, xj1, xik;
> 	if (!*Fsupplied)
> 		getFS(xk, *nk, S, F);
> 	kmax = xk[*nk - 1];
> 	kmin = xk[0];
252c309,310
<     xi = x[i];extrapolate=0;
---
> 		xi = x[i];
> 		extrapolate = 0;
257,258c315,318
<       while (xi <= xk[j] && j > 0) j--;
<       while (xi > xk[j+1] && j < *nk-2) j++;
---
> 			while (xi <= xk[j] && j > 0)
> 				j--;
> 			while (xi > xk[j + 1] && j < *nk - 2)
> 				j++;
261c321,324
<       if (j<0) j=0;if (j > *nk-2) j = *nk - 2; 
---
> 			if (j < 0)
> 				j = 0;
> 			if (j > *nk - 2)
> 				j = *nk - 2;
264c327,328
<       j=0;jup=*nk-1;
---
> 			j = 0;
> 			jup = *nk - 1;
267c331,334
<         if (xi > xk[jmid]) j = jmid; else jup = jmid;
---
> 				if (xi > xk[jmid])
> 					j = jmid;
> 				else
> 					jup = jmid;
281c348,350
<         for (Fp = F,Fp1 = F + *nk,k=0;k < *nk;k++,Xp += *n,Fp++,Fp1++) *Xp = cjm * *Fp + cjp * *Fp1 ;
---
> 				for (Fp = F, Fp1 = F + *nk, k = 0; k < *nk;
> 						k++, Xp += *n, Fp++, Fp1++)
> 					*Xp = cjm * *Fp + cjp * *Fp1;
291c360,361
<         for (Fp1 = F+ j * *nk,Fp = Fp1 - *nk,k=0;k < *nk;k++,Xp += *n,Fp++) 
---
> 				for (Fp1 = F + j * *nk, Fp = Fp1 - *nk, k = 0; k < *nk;
> 						k++, Xp += *n, Fp++)
297c367,368
<       xj = xk[j];xj1=xk[j+1];
---
> 			xj = xk[j];
> 			xj1 = xk[j + 1];
299c370,371
<       ajm = (xj1 - xi);ajp = (xi-xj);
---
> 			ajm = (xj1 - xi);
> 			ajp = (xi - xj);
302c374,375
<       ajm /= h;ajp /= h;
---
> 			ajm /= h;
> 			ajp /= h;
306c379,380
<       for (Fp = F+ j * *nk, Fp1 = F+(j+1)* *nk,k=0;k < *nk;k++,Xp += *n,Fp++,Fp1++) 
---
> 			for (Fp = F + j * *nk, Fp1 = F + (j + 1) * *nk, k = 0; k < *nk;
> 					k++, Xp += *n, Fp++, Fp1++)
310c384,386
<       *Xp += ajm; Xp += *n; *Xp += ajp;
---
> 			*Xp += ajm;
> 			Xp += *n;
> 			*Xp += ajp;
318,320c394,395
< 
< 
< void MinimumSeparation(double *x,int *n, int *d,double *t,int *m,double *dist) {
---
> void MinimumSeparation(double *x, int *n, int *d, double *t, int *m,
> 		double *dist) {
337c412,413
< void MinimumSeparation_old(double *gx,double *gy,int *gn,double *dx,double *dy, int *dn,double *dist)
---
> void MinimumSeparation_old(double *gx, double *gy, int *gn, double *dx,
> 		double *dy, int *dn, double *dist)
346,351c422,433
<   n = *gn;m = *dn;
<   for (dum=dist;dum < dist + n; dum++,gx++,gy++)
<   { xx= *gx - *dx;yy = *gy - *dy;*dum = xx*xx + yy*yy; /* first separation */
<     for (xdum=dx+1,ydum=dy+1;xdum < dx + m;xdum++,ydum++)
<     { xx= *gx - *xdum;yy = *gy - *ydum;sep = xx*xx + yy*yy; /* subsequent separations */
<       if (sep < *dum) *dum = sep;
---
> 	n = *gn;
> 	m = *dn;
> 	for (dum = dist; dum < dist + n; dum++, gx++, gy++) {
> 		xx = *gx - *dx;
> 		yy = *gy - *dy;
> 		*dum = xx * xx + yy * yy; /* first separation */
> 		for (xdum = dx + 1, ydum = dy + 1; xdum < dx + m; xdum++, ydum++) {
> 			xx = *gx - *xdum;
> 			yy = *gy - *ydum;
> 			sep = xx * xx + yy * yy; /* subsequent separations */
> 			if (sep < *dum)
> 				*dum = sep;
365c445,446
< { matrix B,Xd;
---
> {
> 	matrix B, Xd;
369,370c450,455
<   Xd.c--;mcopy(&B,&Xd);freemat(B);Xd.c++;
<   for (i=0;i<Xd.r;i++) Xd.M[i][Xd.c-1]=(double)i;
---
> 	Xd.c--;
> 	mcopy(&B, &Xd);
> 	freemat(B);
> 	Xd.c++;
> 	for (i = 0; i < Xd.r; i++)
> 		Xd.M[i][Xd.c - 1] = (double) i;
372c457,458
<   for (i=0;i<*r;i++) ind[i] = ind1[i]; /* copy index for return */
---
> 	for (i = 0; i < *r; i++)
> 		ind[i] = ind1[i]; /* copy index for return */
376c462,463
<   freemat(Xd);FREE(ind1);
---
> 	freemat(Xd);
> 	FREE(ind1);
380c467,468
< void RMonoCon(double *Ad,double *bd,double *xd,int *control,double *lower,double *upper,int *n)
---
> void RMonoCon(double *Ad, double *bd, double *xd, int *control, double *lower,
> 		double *upper, int *n)
398c486,487
< { int i;
---
> {
> 	int i;
401c490,491
<   for (i=0;i<x.r;i++) x.V[i]=xd[i];
---
> 	for (i = 0; i < x.r; i++)
> 		x.V[i] = xd[i];
406c496,498
<   freemat(x);freemat(A);freemat(b);  
---
> 	freemat(x);
> 	freemat(A);
> 	freemat(b);
410,413c502,504
< 
< void  RPCLS(double *Xd,double *pd,double *yd, double *wd,double *Aind,double *bd,
<             double *Afd,double *Hd,double *Sd,
<             int *off,int *dim,double *theta, int *m,int *nar)
---
> void RPCLS(double *Xd, double *pd, double *yd, double *wd, double *Aind,
> 		double *bd, double *Afd, double *Hd, double *Sd, int *off, int *dim,
> 		double *theta, int *m, int *nar)
440c531,532
< { matrix y,X,p,w,Ain,Af,b,H,*S;
---
> {
> 	matrix y, X, p, w, Ain, Af, b, H, *S;
443c535,536
<   np=nar[1];n=nar[0];
---
> 	np = nar[1];
> 	n = nar[0];
449,455c542,560
<   if (nar[2]>0) Ain=Rmatrix(Aind,(long)nar[2],(long)np); else Ain.r=0L;
<   if (nar[3]>0) Af=Rmatrix(Afd,(long)nar[3],(long)np); else Af.r=0L;
<   if (nar[2]>0) b=Rmatrix(bd,(long)nar[2],1L);else b.r=0L;
<  
<   if (*m) S=(matrix *)CALLOC((size_t) *m,sizeof(matrix));
<   else S=&H; /* avoid spurious compiler warning */
<   for (i=0;i< *m;i++) S[i]=initmat((long)dim[i],(long)dim[i]);
---
> 	if (nar[2] > 0)
> 		Ain = Rmatrix(Aind, (long) nar[2], (long) np);
> 	else
> 		Ain.r = 0L;
> 	if (nar[3] > 0)
> 		Af = Rmatrix(Afd, (long) nar[3], (long) np);
> 	else
> 		Af.r = 0L;
> 	if (nar[2] > 0)
> 		b = Rmatrix(bd, (long) nar[2], 1L);
> 	else
> 		b.r = 0L;
> 
> 	if (*m)
> 		S = (matrix *) CALLOC((size_t) *m, sizeof(matrix));
> 	else
> 		S = &H; /* avoid spurious compiler warning */
> 	for (i = 0; i < *m; i++)
> 		S[i] = initmat((long) dim[i], (long) dim[i]);
458c563,566
<   if (nar[4]) H=initmat(y.r,y.r); else H.r=H.c=0L;
---
> 	if (nar[4])
> 		H = initmat(y.r, y.r);
> 	else
> 		H.r = H.c = 0L;
465c573,574
<   for (i=0;i<p.r;i++) pd[i]=p.V[i];
---
> 	for (i = 0; i < p.r; i++)
> 		pd[i] = p.V[i];
467c576,577
<   if (H.r) RArrayFromMatrix(Hd,H.r,&H);
---
> 	if (H.r)
> 		RArrayFromMatrix(Hd, H.r, &H);
471,478c581,597
<   for (i=0;i< *m;i++) freemat(S[i]);
<   if (*m) FREE(S);
<  
<   freemat(X);freemat(p);freemat(y);freemat(w);
<   if (H.r) freemat(H);
<   if (Ain.r) freemat(Ain);
<   if (Af.r) freemat(Af);
<   if (b.r) freemat(b);
---
> 	for (i = 0; i < *m; i++)
> 		freemat(S[i]);
> 	if (*m)
> 		FREE(S);
> 
> 	freemat(X);
> 	freemat(p);
> 	freemat(y);
> 	freemat(w);
> 	if (H.r)
> 		freemat(H);
> 	if (Ain.r)
> 		freemat(Ain);
> 	if (Af.r)
> 		freemat(Af);
> 	if (b.r)
> 		freemat(b);
diff -rEZbwB '--exclude=*.[lo,d,pdf,mo,po,tgz,gz,save]*' '--exclude=MD5' '--exclude=Makefile*' '--exclude=all.R' '--exclude=Changes' R-recommended/mgcv/src/misc.c Recommended/mgcv/src/misc.c
40c40,41
<       if (xi < -1) xi = -1;
---
> 			if (xi < -1)
> 				xi = -1;
47c48,49
< 	if (xx < *eps) break;
---
> 				if (xx < *eps)
> 					break;
50,51c52,56
<       if (xi>1) xi=1;
<       if (xi/2>=.5) rk=1.0; else
---
> 			if (xi > 1)
> 				xi = 1;
> 			if (xi / 2 >= .5)
> 				rk = 1.0;
> 			else
58c63,64
< 	if (xk < *eps) break;
---
> 				if (xk < *eps)
> 					break;
68c73,74
< void in_out(double *bx, double *by, double *break_code, double *x,double *y,int *in, int *nb, int *n)
---
> void in_out(double *bx, double *by, double *break_code, double *x, double *y,
> 		int *in, int *nb, int *n)
76c82,83
< { double xx,yy,dum,x0,x1,y0,y1;
---
> {
> 	double xx, yy, dum, x0, x1, y0, y1;
79c86,87
<       xx=x[i];yy=y[i]; /* the current test point */
---
> 		xx = x[i];
> 		yy = y[i]; /* the current test point */
83c91,92
<         if (x0 <= *break_code) start=j+1; /* next segment start */
---
> 			if (x0 <= *break_code)
> 				start = j + 1; /* next segment start */
85,86c94,99
<           if (j==*nb-1) x1=bx[start]; else x1 = bx[j+1];  /* end node */
<           if (x1 <= *break_code) x1 = bx[start]; /* must join up segment end */
---
> 				if (j == *nb - 1)
> 					x1 = bx[start];
> 				else
> 					x1 = bx[j + 1]; /* end node */
> 				if (x1 <= *break_code)
> 					x1 = bx[start]; /* must join up segment end */
88c101,107
< 	    if (x1<x0) { dum=x0;x0=x1;x1=dum;swap=1;} else swap=0; /* ordered */
---
> 					if (x1 < x0) {
> 						dum = x0;
> 						x0 = x1;
> 						x1 = dum;
> 						swap = 1;
> 					} else
> 						swap = 0; /* ordered */
91c110,112
<               if (j==*nb-1) y1=by[start]; else
---
> 						if (j == *nb - 1)
> 							y1 = by[start];
> 						else
93,94c114,117
<               if (y1 <= *break_code) y1=by[start]; /* must join up */
<               if (y0<=yy&&y1<=yy) count++; /* definite crossing */
---
> 						if (y1 <= *break_code)
> 							y1 = by[start]; /* must join up */
> 						if (y0 <= yy && y1 <= yy)
> 							count++; /* definite crossing */
97c120,124
<                   if (swap) {dum=y0;y0=y1;y1=dum;}
---
> 								if (swap) {
> 									dum = y0;
> 									y0 = y1;
> 									y1 = dum;
> 								}
99c126,127
<                   if (yy>=dum) count++; /* it's a crossing */
---
> 								if (yy >= dum)
> 									count++; /* it's a crossing */
106c134,137
<      if (count%2) in[i]=1;else in[i]=0; /* record result */
---
> 		if (count % 2)
> 			in[i] = 1;
> 		else
> 			in[i] = 0; /* record result */
130c159,160
< { double *buf2,*p,*p1,*p2;
---
> {
> 	double *buf2, *p, *p1, *p2;
133c163,164
<   for (p=buf,p1=buf + *jal,p2=buf2;p<p1;p++,p2++) *p2 = *p;
---
> 	for (p = buf, p1 = buf + *jal, p2 = buf2; p < p1; p++, p2++)
> 		*p2 = *p;
135c166,167
<   if (update) *jal += n;
---
> 	if (update)
> 		*jal += n;
139,140c171,172
< 
< double *backward_buf(double *buf,int *jal,int *j0,int *j_lo,int *j_hi,int update)
---
> double *backward_buf(double *buf, int *jal, int *j0, int *j_lo, int *j_hi,
> 		int update)
142c174,175
< { int n=1000;
---
> {
> 	int n = 1000;
144,145c177,180
<   if (n > *j0-1) n = *j0 - 1; /* only extend back to j=1 */
<   if (n==0) return(buf);
---
> 	if (n > *j0 - 1)
> 		n = *j0 - 1; /* only extend back to j=1 */
> 	if (n == 0)
> 		return (buf);
147c182,183
<   for (p=buf,p1=buf + *jal,p2=buf2 + n;p<p1;p++,p2++) *p2 = *p;  
---
> 	for (p = buf, p1 = buf + *jal, p2 = buf2 + n; p < p1; p++, p2++)
> 		*p2 = *p;
160,161c195,196
< 	       double *w2pp,double *y,double *eps,int *n,
<                double *th,double *rho,double *a, double *b)
---
> 		double *w2pp, double *y, double *eps, int *n, double *th, double *rho,
> 		double *a, double *b)
186c221,222
< { int j_max,i,j_lo,j_hi,jb,jal,j0,j,ok;
---
> {
> 	int j_max, i, j_lo, j_hi, jb, jal, j0, j, ok;
188,189c224,227
<     *wb,*wb1,//*wb2,
<     *wp1,*wp2,*wpp,dpth1=0,dpth2=0,//xmax,x1max,x2max,
---
> 			*wb,
> 			*wb1, //*wb2,
> 			*wp1, *wp2, *wpp, dpth1 = 0,
> 			dpth2 = 0, //xmax,x1max,x2max,
191,193c229
<     wdW2d2W,dWpp,exp_th,
<     wmax,wmin,
<     wi,w1i,w2i,//drho_const,
---
> 			wdW2d2W, dWpp, exp_th, wmax, wmin, wi, w1i, w2i, //drho_const,
202,203c238,241
<       x = 1 + exp_th;p = (*b + *a * exp_th)/x;
<       x1 = x*x;dpth1 = exp_th*(*b - *a)/x1;
---
> 		x = 1 + exp_th;
> 		p = (*b + *a * exp_th) / x;
> 		x1 = x * x;
> 		dpth1 = exp_th * (*b - *a) / x1;
208,209c246,249
<       x = exp_th+1;p = (*b * exp_th + *a)/x;
<       x1 = x*x;dpth1 = exp_th*(*b - *a)/x1;
---
> 		x = exp_th + 1;
> 		p = (*b * exp_th + *a) / x;
> 		x1 = x * x;
> 		dpth1 = exp_th * (*b - *a) / x1;
214c254,255
<   onep = 1 - p;onep2 = onep * onep;
---
> 	onep = 1 - p;
> 	onep2 = onep * onep;
219c260,261
<   wp2_base= 2*(log(-onep) + *rho)/(onep2*onep) - (3*alpha-2)/(onep2) + 1/((2 - p)*(2 - p));
---
> 	wp2_base = 2 * (log(-onep) + *rho) / (onep2 * onep)
> 			- (3 * alpha - 2) / (onep2) + 1 / ((2 - p) * (2 - p));
233c275,276
<   for (p1=y+1,p2=y+ *n,p3=alogy+1,p4=logy1p2+1,p5=logy1p3+1;p1<p2;p1++,p3++,p4++,p5++) {
---
> 	for (p1 = y + 1, p2 = y + *n, p3 = alogy + 1, p4 = logy1p2 + 1, p5 = logy1p3
> 			+ 1; p1 < p2; p1++, p3++, p4++, p5++) {
238c281,284
<     if (*p1 > ymax) ymax = *p1; else if (*p1 < ymin) ymin = *p1;
---
> 		if (*p1 > ymax)
> 			ymax = *p1;
> 		else if (*p1 < ymin)
> 			ymin = *p1;
242c288,290
<   j_lo = (int) floor(x);if (j_lo<1) j_lo = 1;
---
> 	j_lo = (int) floor(x);
> 	if (j_lo < 1)
> 		j_lo = 1;
245,247c293,299
<   j_hi = (int) ceil(x);if (j_hi<j_lo) j_hi = j_lo;
< 
<   j0 = j_lo - 1000;if (j0<1) j0=1;
---
> 	j_hi = (int) ceil(x);
> 	if (j_hi < j_lo)
> 		j_hi = j_lo;
> 
> 	j0 = j_lo - 1000;
> 	if (j0 < 1)
> 		j0 = 1;
292c343,344
<     if (x - j_max  > .5||j_max<1) j_max++; 
---
> 		if (x - j_max > .5 || j_max < 1)
> 			j_max++;
299c351,352
<     wmax = wb[j_max] - jalogy;wmin = wmax + log_eps; 
---
> 		wmax = wb[j_max] - jalogy;
> 		wmin = wmax + log_eps;
334c387,390
<       if (wj < wmin) { ok=1;break;}
---
> 			if (wj < wmin) {
> 				ok = 1;
> 				break;
> 			}
341c397,398
<         wb[jb] = j * w_base - lgamma((double)j+1) - lgamma(-j * alpha);
---
> 				wb[jb] = j * w_base - lgamma((double) j + 1)
> 						- lgamma(-j * alpha);
374c431,434
<         if (wj < wmin) { ok=1;break;} /* converged on upsweep */
---
> 				if (wj < wmin) {
> 					ok = 1;
> 					break;
> 				} /* converged on upsweep */
377c437,439
<       j_hi = jb; if (j_hi > jal-1) j_hi = jal-1; /* set j_hi to last element filled */
---
> 			j_hi = jb;
> 			if (j_hi > jal - 1)
> 				j_hi = jal - 1; /* set j_hi to last element filled */
416c478,481
<       if (wj < wmin) { ok=1;break;} /* converged on downsweep */
---
> 			if (wj < wmin) {
> 				ok = 1;
> 				break;
> 			} /* converged on downsweep */
419c484,485
<     if (j<=1&&j_lo==0) ok=1; /* don't care about element size if reached base */
---
> 		if (j <= 1 && j_lo == 0)
> 			ok = 1; /* don't care about element size if reached base */
423c489,490
<         wb[jb] = j * w_base - lgamma((double)j+1) - lgamma(-j * alpha);
---
> 				wb[jb] = j * w_base - lgamma((double) j + 1)
> 						- lgamma(-j * alpha);
456c523,526
<         if (wj < wmin) { ok=1;break;} /* converged on upsweep */
---
> 				if (wj < wmin) {
> 					ok = 1;
> 					break;
> 				} /* converged on upsweep */
459,461c529,534
<       if (j<=1) ok=1; /* don't care about element size if reached base */
< 
<       j_lo = jb; if (j_lo<0) j_lo=0; /* set j_lo to first element filled */
---
> 			if (j <= 1)
> 				ok = 1; /* don't care about element size if reached base */
> 
> 			j_lo = jb;
> 			if (j_lo < 0)
> 				j_lo = 0; /* set j_lo to first element filled */
482,483c555,562
<   FREE(alogy);FREE(wb);FREE(wb1);//FREE(wb2);
<   FREE(logy1p2);FREE(logy1p3);FREE(wp1);FREE(wp2);FREE(wpp);
---
> 	FREE(alogy);
> 	FREE(wb);
> 	FREE(wb1);      //FREE(wb2);
> 	FREE(logy1p2);
> 	FREE(logy1p3);
> 	FREE(wp1);
> 	FREE(wp2);
> 	FREE(wpp);
533c608,609
< void rwMatrix(int *stop,int *row,double *w,double *X,int *n,int *p,int *trans,double *work) {
---
> void rwMatrix(int *stop, int *row, double *w, double *X, int *n, int *p,
> 		int *trans, double *work) {
553c629,630
<   for (X1p=X1,Xpe=X1p+off;X1p<Xpe;X1p++) *X1p = 0.0;
---
> 	for (X1p = X1, Xpe = X1p + off; X1p < Xpe; X1p++)
> 		*X1p = 0.0;
565c642,643
<       for (Xpe=Xp+off;Xp<Xpe;Xp+=jump,X1p+=jump) *X1p += weight * *Xp;
---
> 			for (Xpe = Xp + off; Xp < Xpe; Xp += jump, X1p += jump)
> 				*X1p += weight * *Xp;
570c648,649
<   for (Xp=X,X1p=X1,Xpe=Xp+off;Xp<Xpe;Xp++,X1p++) *Xp = *X1p;
---
> 	for (Xp = X, X1p = X1, Xpe = Xp + off; Xp < Xpe; Xp++, X1p++)
> 		*Xp = *X1p;
diff -rEZbwB '--exclude=*.[lo,d,pdf,mo,po,tgz,gz,save]*' '--exclude=MD5' '--exclude=Makefile*' '--exclude=all.R' '--exclude=Changes' R-recommended/mgcv/src/mvn.c Recommended/mgcv/src/mvn.c
15,16c15,16
<             int *m,double *ll,double *lb,double *lbb,double *dbeta,
<             double *dH,int *deriv,int *nsp,int *nt) {
---
> int *m, double *ll, double *lb, double *lbb, double *dbeta, double *dH,
> 		int *deriv, int *nsp, int *nt) {
31,33c31,35
<   double *R,*theta,ldetR,*Xl,*bl,oned=1.0,zerod=0.0,*p,*p1,*p2,*p3,xx,zz,yy,*yty,
<     *mu,*Rymu,rip,*dtheta,*db,*deriv_theta,*yX,*yRX;
<   int i,j,k,l,pl,one=1,bt,ct,nb,*din,ntheta,ncoef,*rri,*rci,ri,rj,ril,rjl,rik,rjk,rij,rjj,q,r;
---
> 	double *R, *theta, ldetR, *Xl, *bl, oned = 1.0, zerod = 0.0, *p, *p1, *p2,
> 			*p3, xx, zz, yy, *yty, *mu, *Rymu, rip, *dtheta, *db, *deriv_theta,
> 			*yX, *yRX;
> 	int i, j, k, l, pl, one = 1, bt, ct, nb, *din, ntheta, ncoef, *rri, *rci,
> 			ri, rj, ril, rjl, rik, rjk, rij, rjj, q, r;
35c37,38
<   ntheta = *m * (*m+1)/2;ncoef = lpi[*m-1];
---
> 	ntheta = *m * (*m + 1) / 2;
> 	ncoef = lpi[*m - 1];
47,48c50,53
<     R[i + *m * i] = deriv_theta[k];ldetR += theta[k];
<     rri[k]=rci[k]=i;k++; 
---
> 		R[i + *m * i] = deriv_theta[k];
> 		ldetR += theta[k];
> 		rri[k] = rci[k] = i;
> 		k++;
52c57,59
<       rri[k]=i;rci[k]=j;k++;
---
> 			rri[k] = i;
> 			rci[k] = j;
> 			k++;
58,60c65,76
<     if (l==0) { Xl = X;pl = lpi[0];bl=beta;} /* Xl is lth model matrix with pl columns, coef vec bl */ 
<     else { Xl = X + *n * lpi[l-1];pl = lpi[l]-lpi[l-1];bl = beta + lpi[l-1];}   
<     F77_CALL(dgemv)(&not_trans,n,&pl,&oned,Xl,n, bl, &one,&zerod, mu, &one); /* BLAS call for mu = Xl bl */
---
> 		if (l == 0) {
> 			Xl = X;
> 			pl = lpi[0];
> 			bl = beta;
> 		} /* Xl is lth model matrix with pl columns, coef vec bl */
> 		else {
> 			Xl = X + *n * lpi[l - 1];
> 			pl = lpi[l] - lpi[l - 1];
> 			bl = beta + lpi[l - 1];
> 		}
> 		F77_CALL(dgemv)(&not_trans, n, &pl, &oned, Xl, n, bl, &one, &zerod, mu,
> 				&one); /* BLAS call for mu = Xl bl */
62c78,79
<     for (p=mu,p1= mu + *n,p2=y+l;p<p1;p++,p2 += *m) *p2 -= *p;
---
> 		for (p = mu, p1 = mu + *n, p2 = y + l; p < p1; p++, p2 += *m)
> 			*p2 -= *p;
69c86,88
<   bt=0;ct=0;mgcv_pmmult(Rymu,R,y,&bt,&ct,m,n,m,nt);  
---
> 	bt = 0;
> 	ct = 0;
> 	mgcv_pmmult(Rymu, R, y, &bt, &ct, m, n, m, nt);
71c90,91
<   for (*ll=0.0,p=Rymu,p1=p + *n * *m;p<p1;p++) *ll += *p * *p;
---
> 	for (*ll = 0.0, p = Rymu, p1 = p + *n * *m; p < p1; p++)
> 		*ll += *p * *p;
79,80c99,106
<     if (l==0) { Xl = X;pl = lpi[0];} /* Xl is lth model matrix with pl columns */ 
<     else { Xl = X + *n * lpi[l-1];pl = lpi[l]-lpi[l-1];} 
---
> 		if (l == 0) {
> 			Xl = X;
> 			pl = lpi[0];
> 		} /* Xl is lth model matrix with pl columns */
> 		else {
> 			Xl = X + *n * lpi[l - 1];
> 			pl = lpi[l] - lpi[l - 1];
> 		}
85c111,113
<         for (p1=R + l * *m,p2 = p1 + l,p3 = Rymu + *m *j;p1<=p2;p1++,p3++) *p += xx * *p1 * *p3; 
---
> 				for (p1 = R + l * *m, p2 = p1 + l, p3 = Rymu + *m * j; p1 <= p2;
> 						p1++, p3++)
> 					*p += xx * *p1 * *p3;
94c122,123
<     xx = deriv_theta[k]; /* the non-zero element of R_theta^i at i,i */;
---
> 		xx = deriv_theta[k]; /* the non-zero element of R_theta^i at i,i */
> 		;
98c127,129
<     for (zz=0.0,l=0,p1 = Rymu+i,p2=y+i;l<*n;l++,p1 += *m,p2 += *m) zz += *p1 * *p2 * xx;
---
> 		for (zz = 0.0, l = 0, p1 = Rymu + i, p2 = y + i; l < *n;
> 				l++, p1 += *m, p2 += *m)
> 			zz += *p1 * *p2 * xx;
103c134,136
<       for (zz=0.0,l=0,p1 = Rymu+i,p2=y+j;l<*n;l++,p1 += *m,p2 += *m) zz += *p1 * *p2;
---
> 			for (zz = 0.0, l = 0, p1 = Rymu + i, p2 = y + j; l < *n; l++, p1 +=
> 					*m, p2 += *m)
> 				zz += *p1 * *p2;
113c146,147
<     if (i==lpi[k]) k++; 
---
> 		if (i == lpi[k])
> 			k++;
117,118c151,154
<   for (i=0;i<ncoef;i++) for (j=0;j<=i;j++) {
<      l=din[i];k=din[j]; /* note l>=k */
---
> 	for (i = 0; i < ncoef; i++)
> 		for (j = 0; j <= i; j++) {
> 			l = din[i];
> 			k = din[j]; /* note l>=k */
120c156,158
<      for (p=R+l * *m,p1=R+k * *m,rip=0.0,p2=p1+k;p1<=p2;p++,p1++) rip += *p * *p1;
---
> 			for (p = R + l * *m, p1 = R + k * *m, rip = 0.0, p2 = p1 + k;
> 					p1 <= p2; p++, p1++)
> 				rip += *p * *p1;
124c162,163
<   for (i=0;i<ncoef;i++) for (j=0;j<ntheta;j++) {
---
> 	for (i = 0; i < ncoef; i++)
> 		for (j = 0; j < ntheta; j++) {
131c170,173
<      if (l==rj) for (p = X + i* *n,p1=Rymu+ri,p2=p + *n;p<p2;p++,p1 += *m) xx += *p * *p1;
---
> 			if (l == rj)
> 				for (p = X + i * *n, p1 = Rymu + ri, p2 = p + *n; p < p2;
> 						p++, p1 += *m)
> 					xx += *p * *p1;
135c177,179
<        for (yy=0.0,p = X + i* *n,p1=y+rj,p2=p + *n;p<p2;p++,p1 += *m) yy += *p * *p1;
---
> 				for (yy = 0.0, p = X + i * *n, p1 = y + rj, p2 = p + *n; p < p2;
> 						p++, p1 += *m)
> 					yy += *p * *p1;
141c185,186
<   for (k=0;k<ntheta;k++) for (l=0;l<=k;l++) {
---
> 	for (k = 0; k < ntheta; k++)
> 		for (l = 0; l <= k; l++) {
144c189,190
<         ri=rri[k];rj=rci[k];
---
> 				ri = rri[k];
> 				rj = rci[k];
147c193,195
<           for (zz=0.0,i=0,p=Rymu+ri,p2=y+ri;i<*n;i++,p += *m,p2+= *m) zz += *p * *p2;
---
> 					for (zz = 0.0, i = 0, p = Rymu + ri, p2 = y + ri; i < *n;
> 							i++, p += *m, p2 += *m)
> 						zz += *p * *p2;
152c200,201
<       ri=rri[k];rj=rci[k];
---
> 			ri = rri[k];
> 			rj = rci[k];
155,156c204,207
<       ril=rri[l];rjl=rci[l];
<       rik=rri[k];rjk=rci[k];
---
> 			ril = rri[l];
> 			rjl = rci[l];
> 			rik = rri[k];
> 			rjk = rci[k];
158c209,211
< 	for (yy=0.0,i=0,p=y+rjl,p1=y+rjk;i<*n;i++,p+= *m, p1+= *m) yy += *p * *p1;
---
> 				for (yy = 0.0, i = 0, p = y + rjl, p1 = y + rjk; i < *n;
> 						i++, p += *m, p1 += *m)
> 					yy += *p * *p1;
160c213,214
<         if (ril==rjl) yy *= deriv_theta[l];
---
> 				if (ril == rjl)
> 					yy *= deriv_theta[l];
163c217,218
<       lbb[k + ncoef + nb * (l+ncoef)] = lbb[l + ncoef + nb * (k+ncoef)] = xx;
---
> 			lbb[k + ncoef + nb * (l + ncoef)] =
> 					lbb[l + ncoef + nb * (k + ncoef)] = xx;
170c225,227
<     bt=0;ct=0;mgcv_pmmult(yX,y,X,&bt,&ct,m,&ncoef,n,nt); /* rows, dim, cols coef */   
---
> 		bt = 0;
> 		ct = 0;
> 		mgcv_pmmult(yX, y, X, &bt, &ct, m, &ncoef, n, nt); /* rows, dim, cols coef */
172c229,231
<     bt=0;ct=0;mgcv_pmmult(yRX,Rymu,X,&bt,&ct,m,&ncoef,n,nt); /* rows, dim, cols coef */  
---
> 		bt = 0;
> 		ct = 0;
> 		mgcv_pmmult(yRX, Rymu, X, &bt, &ct, m, &ncoef, n, nt); /* rows, dim, cols coef */
174c233,235
<     bt=0;ct=1;mgcv_pmmult(yty,y,y,&bt,&ct,m,m,n,nt); /* rows, cols dim */  
---
> 		bt = 0;
> 		ct = 1;
> 		mgcv_pmmult(yty, y, y, &bt, &ct, m, m, n, nt); /* rows, cols dim */
181,183c242,248
<       for (i=0;i<ncoef;i++) for (j=0;j<=i;j++) {
< 	l = din[i];k = din[j]; /* dimensions for these elements */
< 	xx=0.0;p=R+l* *m;p1=R+k* *m;
---
> 			for (i = 0; i < ncoef; i++)
> 				for (j = 0; j <= i; j++) {
> 					l = din[i];
> 					k = din[j]; /* dimensions for these elements */
> 					xx = 0.0;
> 					p = R + l * *m;
> 					p1 = R + k * *m;
185,187c250,255
<           ri=rri[q];rj=rci[q]; /* row and col of non zero element of deriv of R wrt theta_q */
<           if (rj==l) xx += p1[ri]*deriv_theta[q]*dtheta[q];
<           if (rj==k) xx += p[ri]*deriv_theta[q]*dtheta[q];
---
> 						ri = rri[q];
> 						rj = rci[q]; /* row and col of non zero element of deriv of R wrt theta_q */
> 						if (rj == l)
> 							xx += p1[ri] * deriv_theta[q] * dtheta[q];
> 						if (rj == k)
> 							xx += p[ri] * deriv_theta[q] * dtheta[q];
194c262,263
<       for (i=0;i<ncoef;i++) for (j=0;j<ntheta;j++) {  
---
> 			for (i = 0; i < ncoef; i++)
> 				for (j = 0; j < ntheta; j++) {
199c268,269
<           ri=rri[j];rj=rci[j]; /* row and col of non zero element of deriv of R wrt theta_j */
---
> 						ri = rri[j];
> 						rj = rci[j]; /* row and col of non zero element of deriv of R wrt theta_j */
201,202c271,276
<           if (rj==l) xx += -R[ri + *m * k]*zz*XX[i + ncoef * q] * db[q];
<           if (rj==k) xx += -R[ri + *m * l]*zz*XX[i + ncoef * q] * db[q];
---
> 						if (rj == l)
> 							xx += -R[ri + *m * k] * zz * XX[i + ncoef * q]
> 									* db[q];
> 						if (rj == k)
> 							xx += -R[ri + *m * l] * zz * XX[i + ncoef * q]
> 									* db[q];
205c279,280
<         rij=rri[j];rjj=rci[j]; /* row and col of non zero element of deriv of R wrt theta_j */
---
> 					rij = rri[j];
> 					rjj = rci[j]; /* row and col of non zero element of deriv of R wrt theta_j */
208c283,284
<           rik=rri[k];rjk=rci[k]; /* row and col of non zero element of deriv of R wrt theta_k */
---
> 						rik = rri[k];
> 						rjk = rci[k]; /* row and col of non zero element of deriv of R wrt theta_k */
210,211c286,291
<             if (l==rjj) zz +=  yX[rjk + i * *m] * deriv_theta[j] * deriv_theta[k];
<             if (l==rjk) zz +=  yX[rjj + i * *m] * deriv_theta[j] * deriv_theta[k];
---
> 							if (l == rjj)
> 								zz += yX[rjk + i * *m] * deriv_theta[j]
> 										* deriv_theta[k];
> 							if (l == rjk)
> 								zz += yX[rjj + i * *m] * deriv_theta[j]
> 										* deriv_theta[k];
217c297,299
<           if (k==j&&rik==rjk) xx += dtheta[k]* deriv_theta[k] * R[rjj + *m * l] * yX[rjj + *m * i];/* x_i^l'R'R_tt^jk(y-mu) */
---
> 						if (k == j && rik == rjk)
> 							xx += dtheta[k] * deriv_theta[k] * R[rjj + *m * l]
> 									* yX[rjj + *m * i];/* x_i^l'R'R_tt^jk(y-mu) */
223,224c305,310
<       for (j=0;j<ntheta;j++) for (k=j;k<ntheta;k++) {
<         rij=rri[j];rjj=rci[j];rik=rri[k];rjk=rci[k];
---
> 			for (j = 0; j < ntheta; j++)
> 				for (k = j; k < ntheta; k++) {
> 					rij = rri[j];
> 					rjj = rci[j];
> 					rik = rri[k];
> 					rjk = rci[k];
228c314,315
< 	  zz=0.0;l=din[i];
---
> 						zz = 0.0;
> 						l = din[i];
230,231c317,322
<             if (l==rjj) zz +=  yX[rjk + i * *m] * deriv_theta[j] * deriv_theta[k];
<             if (l==rjk) zz +=  yX[rjj + i * *m] * deriv_theta[j] * deriv_theta[k];
---
> 							if (l == rjj)
> 								zz += yX[rjk + i * *m] * deriv_theta[j]
> 										* deriv_theta[k];
> 							if (l == rjk)
> 								zz += yX[rjj + i * *m] * deriv_theta[j]
> 										* deriv_theta[k];
236c327,328
<               if (l==rjj) zz +=  deriv_theta[k] * yRX[rjj + *m * i];  /* x_i^l'R_tt^jk R(y-mu) */
---
> 								if (l == rjj)
> 									zz += deriv_theta[k] * yRX[rjj + *m * i]; /* x_i^l'R_tt^jk R(y-mu) */
240c332,334
<           if (k==j&&rij==rjj) xx +=  db[i]*deriv_theta[k] * R[rjj + *m * l] * yX[rjj + *m * i]; /* x_i^l'R'R_tt^jk(y-mu) */
---
> 						if (k == j && rij == rjj)
> 							xx += db[i] * deriv_theta[k] * R[rjj + *m * l]
> 									* yX[rjj + *m * i]; /* x_i^l'R'R_tt^jk(y-mu) */
243,246c337,348
< 	  ri = rri[i];rj=rci[i];zz=0.0;
<           if (j==k&&ri==rij&&rjk==rik) zz += deriv_theta[j]*deriv_theta[i]*yty[rj * *m + rjj];  /* row rjj, col rj */ 
<           if (i==k&&rik==rij&&rj==ri) zz += deriv_theta[j]*deriv_theta[i]*yty[rjk * *m + rjj];  /* row rjj, col rjk */ 
<           if (i==j&&rik==rij&&rj==ri) zz += deriv_theta[k]*deriv_theta[i]*yty[rjk * *m + rj];  /* row rjk, col rj */ 
---
> 						ri = rri[i];
> 						rj = rci[i];
> 						zz = 0.0;
> 						if (j == k && ri == rij && rjk == rik)
> 							zz += deriv_theta[j] * deriv_theta[i]
> 									* yty[rj * *m + rjj]; /* row rjj, col rj */
> 						if (i == k && rik == rij && rj == ri)
> 							zz += deriv_theta[j] * deriv_theta[i]
> 									* yty[rjk * *m + rjj]; /* row rjj, col rjk */
> 						if (i == j && rik == rij && rj == ri)
> 							zz += deriv_theta[k] * deriv_theta[i]
> 									* yty[rjk * *m + rj]; /* row rjk, col rj */
249c351,353
<             for (yy=0.0,p=Rymu+ri,p1=y+ri,q=0;q<*n;p+= *m,p1+= *m,q++) yy += *p * *p1;           
---
> 							for (yy = 0.0, p = Rymu + ri, p1 = y + ri, q = 0;
> 									q < *n; p += *m, p1 += *m, q++)
> 								yy += *p * *p1;
254c358,359
< 	dH[k + ncoef + (j+ncoef) * nb] = dH[j+ncoef + (k+ncoef) * nb] = xx;
---
> 					dH[k + ncoef + (j + ncoef) * nb] = dH[j + ncoef
> 							+ (k + ncoef) * nb] = xx;
259c364,366
<     FREE(yX);FREE(yRX);FREE(yty);
---
> 		FREE(yX);
> 		FREE(yRX);
> 		FREE(yty);
262,265c369,375
< 
<   FREE(din); FREE(rri); FREE(rci);
<   
<   FREE(R);FREE(Rymu);FREE(deriv_theta);
---
> 	FREE(din);
> 	FREE(rri);
> 	FREE(rci);
> 
> 	FREE(R);
> 	FREE(Rymu);
> 	FREE(deriv_theta);
diff -rEZbwB '--exclude=*.[lo,d,pdf,mo,po,tgz,gz,save]*' '--exclude=MD5' '--exclude=Makefile*' '--exclude=all.R' '--exclude=Changes' R-recommended/mgcv/src/qp.c Recommended/mgcv/src/qp.c
29a29,30
> #include "localization.h"
> #include <R_ext/Minmax.h>
33,36d33
< 
< #define max(a,b)    (((a) > (b)) ? (a) : (b))
< #define min(a,b)    (((a) < (b)) ? (a) : (b))
< 
39,42c36,37
< 
< 
< 
< matrix addconQT(Q,T,a,u) matrix *Q,T,a,*u;
---
> matrix addconQT(Q, T, a, u)
> 	matrix *Q, T, a, *u;
48c43,44
< { int q,i,j;
---
> {
> 	int q, i, j;
51,52c47,52
<   c=initmat(Q->r,1);b=initmat(Q->r,1);(*u)=initmat(Q->r,1);
<   for (i=0;i<c.r;i++) for (j=0;j<a.c;j++) c.V[i]+=a.V[j]*Q->M[j][i];
---
> 	c = initmat(Q->r, 1);
> 	b = initmat(Q->r, 1);
> 	(*u) = initmat(Q->r, 1);
> 	for (i = 0; i < c.r; i++)
> 		for (j = 0; j < a.c; j++)
> 			c.V[i] += a.V[j] * Q->M[j][i];
54c54,55
<   cV=c.V;bV=b.V;
---
> 	cV = c.V;
> 	bV = b.V;
56,60c57,64
<   if (q!=0)
<   { for (i=q+1;i<a.c;i++) { ra+=cV[i]*cV[i];bV[i]=cV[i];}
<     if ((la-ra)<0.0)
<     { error(_("ERROR in addconQT."));}
<     else
---
> 	if (q != 0) {
> 		for (i = q + 1; i < a.c; i++) {
> 			ra += cV[i] * cV[i];
> 			bV[i] = cV[i];
> 		}
> 		if ((la - ra) < 0.0) {
> 			error(_("ERROR in 'addconQT()'"));
> 		} else
62c66,67
<     if (cV[q]>0.0) bV[q]= -bV[q];
---
> 		if (cV[q] > 0.0)
> 			bV[q] = -bV[q];
66,68c71,76
<   for (i=0;i<a.c;i++) bV[i]=cV[i];
<   T1V=T.M[T.r];T.r++;
<   for (j=0;j<T.c;j++) T1V[j]=bV[j];
---
> 		for (i = 0; i < a.c; i++)
> 			bV[i] = cV[i];
> 	T1V = T.M[T.r];
> 	T.r++;
> 	for (j = 0; j < T.c; j++)
> 		T1V[j] = bV[j];
87c95,96
< { int q,i,j;
---
> {
> 	int q, i, j;
90,92c99,106
<   b.V=T->M[T->r]; b.r=Q->r;b.c=1;
<   for (i=0;i<T->c;i++) b.V[i]=0.0;
<   for (i=0;i<b.r;i++) for (j=0;j<Q->r;j++) b.V[i]+=Q->M[j][i]*a->V[j];
---
> 	b.V = T->M[T->r];
> 	b.r = Q->r;
> 	b.c = 1;
> 	for (i = 0; i < T->c; i++)
> 		b.V[i] = 0.0;
> 	for (i = 0; i < b.r; i++)
> 		for (j = 0; j < Q->r; j++)
> 			b.V[i] += Q->M[j][i] * a->V[j];
95c109,112
<   bV=b.V;cV=c->V;sV=s->V;QM=Q->M;
---
> 	bV = b.V;
> 	cV = c->V;
> 	sV = s->V;
> 	QM = Q->M;
97,102c114,124
<   for (i=0;i<q;i++)
<   { /* first calculate the Givens transformation */
<     bb=bV[i];bb1=bV[i+1];
<     r=bb*bb+bb1*bb1;r=sqrt(r);
<     if (r==0.0) { ss=sV[i]=0.0;cc=cV[i]=1.0;} else
<     { ss=sV[i]=bb/r;cc=cV[i]= -bb1/r;
---
> 	for (i = 0; i < q; i++) { /* first calculate the Givens transformation */
> 		bb = bV[i];
> 		bb1 = bV[i + 1];
> 		r = bb * bb + bb1 * bb1;
> 		r = sqrt(r);
> 		if (r == 0.0) {
> 			ss = sV[i] = 0.0;
> 			cc = cV[i] = 1.0;
> 		} else {
> 			ss = sV[i] = bb / r;
> 			cc = cV[i] = -bb1 / r;
107,108c129,130
<     for (j=0;j<Q->r;j++)
<     { QV=QM[j];
---
> 		for (j = 0; j < Q->r; j++) {
> 			QV = QM[j];
117,120c139,140
< 
< 
< void LSQPaddcon(matrix *Ain,matrix *Q,matrix *T,matrix *Rf,matrix *Py,matrix *PX,
<                 matrix *s,matrix *c,int sth)
---
> void LSQPaddcon(matrix *Ain, matrix *Q, matrix *T, matrix *Rf, matrix *Py,
> 		matrix *PX, matrix *s, matrix *c, int sth)
130c150,151
< { matrix a;
---
> {
> 	matrix a;
133c154,156
<   a.V=Ain->M[sth];a.r=Ain->c;a.c=1; /* vector containing sth constraint */
---
> 	a.V = Ain->M[sth];
> 	a.r = Ain->c;
> 	a.c = 1; /* vector containing sth constraint */
138,142c161,168
<   for (i=0;i<s->r;i++)
<   { cc=c->V[i];ss=s->V[i];
<     k=i+2;if (k>Rf->r) k--;
<     for (j=0;j<k;j++)
<     { RfV=Rf->M[j];
---
> 	for (i = 0; i < s->r; i++) {
> 		cc = c->V[i];
> 		ss = s->V[i];
> 		k = i + 2;
> 		if (k > Rf->r)
> 			k--;
> 		for (j = 0; j < k; j++) {
> 			RfV = Rf->M[j];
152,155c178,186
<     RfV=Rf->M[i];RfV1=Rf->M[i+1];
<     x1=RfV[i];x2=RfV1[i];
<     r=sqrt(x1*x1+x2*x2);ss=x2/r;cc=x1/r;
<     Rf->M[i][i]=r;Rf->M[i+1][i]=0.0;
---
> 		RfV = Rf->M[i];
> 		RfV1 = Rf->M[i + 1];
> 		x1 = RfV[i];
> 		x2 = RfV1[i];
> 		r = sqrt(x1 * x1 + x2 * x2);
> 		ss = x2 / r;
> 		cc = x1 / r;
> 		Rf->M[i][i] = r;
> 		Rf->M[i + 1][i] = 0.0;
157c188,190
<     { x1=RfV[j];x2=RfV1[j];
---
> 		{
> 			x1 = RfV[j];
> 			x2 = RfV1[j];
162c195,196
<     x1=Py->V[i];x2=Py->V[i+1];
---
> 		x1 = Py->V[i];
> 		x2 = Py->V[i + 1];
167c201,203
<     { x1=PX->M[i][j];x2=PX->M[i+1][j];
---
> 		{
> 			x1 = PX->M[i][j];
> 			x2 = PX->M[i + 1][j];
174,175c210,211
< 
< int LSQPstep(int *ignore,matrix *Ain,matrix *b,matrix *p1,matrix *p,matrix *pk)
---
> int LSQPstep(int *ignore, matrix *Ain, matrix *b, matrix *p1, matrix *p,
> 		matrix *pk)
191c227,228
< { double Ap1,ap,apk,alpha,alphamin,*AV,*pV,*p1V,*pkV;
---
> {
> 	double Ap1, ap, apk, alpha, alphamin, *AV, *pV, *p1V, *pkV;
193,195c230,236
<   alphamin=1.0;imin= -1;
<   p1V=p1->V;pV=p->V;pkV=pk->V;
<   for (i=0;i<p->r;i++) p1V[i]=pV[i]+pkV[i]; /* step all the way to minimum */
---
> 	alphamin = 1.0;
> 	imin = -1;
> 	p1V = p1->V;
> 	pV = p->V;
> 	pkV = pk->V;
> 	for (i = 0; i < p->r; i++)
> 		p1V[i] = pV[i] + pkV[i]; /* step all the way to minimum */
197c238,239
<   { AV=Ain->M[i];
---
> 	{
> 		AV = Ain->M[i];
199,202c241,242
<     { Ap1=0.0;
<       for (j=0;j<Ain->c;j++) Ap1+=AV[j]*p1V[j]; /* form  A p1 = A(p+pk) */
<       if ((b->V[i]-Ap1)>0.0) /* does p+pk violate the ith constraint? */
<       { ap=0.0;apk=0.0;        /* working out quantities needed to find distance to constraint from p */
---
> 		{
> 			Ap1 = 0.0;
204c244,250
< 	{ ap+=AV[j]*pV[j];
---
> 				Ap1 += AV[j] * p1V[j]; /* form  A p1 = A(p+pk) */
> 			if ((b->V[i] - Ap1) > 0.0) /* does p+pk violate the ith constraint? */
> 			{
> 				ap = 0.0;
> 				apk = 0.0; /* working out quantities needed to find distance to constraint from p */
> 				for (j = 0; j < Ain->c; j++) {
> 					ap += AV[j] * pV[j];
207,208c253,254
< 	if (fabs(apk)>0.0)
< 	{ alpha=(b->V[i]-ap)/apk; /* p + alpha*pk is on the ith constraint */
---
> 				if (fabs(apk) > 0.0) {
> 					alpha = (b->V[i] - ap) / apk; /* p + alpha*pk is on the ith constraint */
210,211c256,260
< 	  { alphamin=max(0.0,alpha);imin=i;
<             for (j=0;j<p->r;j++) p1V[j]=pV[j]+alphamin*pkV[j]; /* 2/2/97 - avoids distance calc for all that would violate full step */
---
> 					{
> 						alphamin = max(0.0, alpha);
> 						imin = i;
> 						for (j = 0; j < p->r; j++)
> 							p1V[j] = pV[j] + alphamin * pkV[j]; /* 2/2/97 - avoids distance calc for all that would violate full step */
221,222c270,271
< 
< void LSQPdelcon(matrix *Q,matrix *T,matrix *Rf,matrix *Py,matrix *PX,int sth)
---
> void LSQPdelcon(matrix *Q, matrix *T, matrix *Rf, matrix *Py, matrix *PX,
> 		int sth)
239c288,289
< { int i,j,colj,coli,k,Tr,Tc,Qr,T1r,T1c;
---
> {
> 	int i, j, colj, coli, k, Tr, Tc, Qr, T1r, T1c;
241c291,295
<   Tr=T->r;TM=T->M;QM=Q->M;Tc=T->c;Qr=Q->r;
---
> 	Tr = T->r;
> 	TM = T->M;
> 	QM = Q->M;
> 	Tc = T->c;
> 	Qr = Q->r;
243,244c297,301
<   { coli=Tc-i-1;colj=Tc-i;    /* coli is zeroed - colj=coli+1 */
<     xi=TM[i][coli];xj=TM[i][colj];
---
> 	{
> 		coli = Tc - i - 1;
> 		colj = Tc - i; /* coli is zeroed - colj=coli+1 */
> 		xi = TM[i][coli];
> 		xj = TM[i][colj];
247c304,305
<     s=xi/r;c=xj/r;         /* Givens coefficients */
---
> 		s = xi / r;
> 		c = xj / r; /* Givens coefficients */
249c307,308
<     { TV=TM[j];
---
> 		{
> 			TV = TM[j];
255c314,315
<     { QV=QM[j];
---
> 		{
> 			QV = QM[j];
262c322,323
<     { RfV=Rf->M[j];       /* row to apply rotation to */
---
> 		{
> 			RfV = Rf->M[j]; /* row to apply rotation to */
268c329,330
<     xi=Rf->M[coli][coli];xj=Rf->M[colj][coli]; /* xj to be zeroed */
---
> 		xi = Rf->M[coli][coli];
> 		xj = Rf->M[colj][coli]; /* xj to be zeroed */
270,271c332,335
<     s=xj/r;c=xi/r;         /* Givens coefficients to zero xj into xi */
<     Rf->M[coli][coli]=r;Rf->M[colj][coli]=0.0;
---
> 		s = xj / r;
> 		c = xi / r; /* Givens coefficients to zero xj into xi */
> 		Rf->M[coli][coli] = r;
> 		Rf->M[colj][coli] = 0.0;
273,275c337,341
<     RfV=Rf->M[coli];RfV1=Rf->M[colj];
<     for (j=colj;j<Rf->c;j++)
<     { xi=RfV[j];xj=RfV1[j];
---
> 		RfV = Rf->M[coli];
> 		RfV1 = Rf->M[colj];
> 		for (j = colj; j < Rf->c; j++) {
> 			xi = RfV[j];
> 			xj = RfV1[j];
281c347,348
<     xi=Py->V[coli];xj=Py->V[colj];
---
> 		xi = Py->V[coli];
> 		xj = Py->V[colj];
286c353,355
<     { xi=PX->M[coli][j];xj=PX->M[colj][j];
---
> 		{
> 			xi = PX->M[coli][j];
> 			xj = PX->M[colj][j];
293,296c362,369
<   T->r--;T1r=T->r;T1c=T->c;
<   for (k=0;k<T1r;k++)
<   { T1V=TM[k];TV=TM[k];
<     for (j=0;j<T1c-k-1;j++) T1V[j]=0.0;
---
> 	T->r--;
> 	T1r = T->r;
> 	T1c = T->c;
> 	for (k = 0; k < T1r; k++) {
> 		T1V = TM[k];
> 		TV = TM[k];
> 		for (j = 0; j < T1c - k - 1; j++)
> 			T1V[j] = 0.0;
298,299c371,374
<     if (k<sth) T1V[j]=TV[j];
<     else T1V[j]=TM[k+1][j];
---
> 			if (k < sth)
> 				T1V[j] = TV[j];
> 			else
> 				T1V[j] = TM[k + 1][j];
303,306c378,379
< 
< 
< int LSQPlagrange(matrix *X,matrix *Q,matrix *T,matrix *p,matrix *Xy,matrix *p1,
<                  matrix *y1,int *fixed, int fixed_cons)
---
> int LSQPlagrange(matrix *X, matrix *Q, matrix *T, matrix *p, matrix *Xy,
> 		matrix *p1, matrix *y1, int *fixed, int fixed_cons)
332c405,406
< { int i,j,tk;
---
> {
> 	int i, j, tk;
337c411,412
<   for (i=0;i<p1->r;i++) p1->V[i]+= -Xy->V[i]; /* form p1 = g = X'Xp - X'y */
---
> 	for (i = 0; i < p1->r; i++)
> 		p1->V[i] += -Xy->V[i]; /* form p1 = g = X'Xp - X'y */
339,341c414,417
<   for (i=0;i<tk;i++)
<   { y1->V[i]=0.0;
<     for (j=0;j<Q->r;j++) y1->V[i]+=p1->V[j]*Q->M[j][Q->c-tk+i];
---
> 	for (i = 0; i < tk; i++) {
> 		y1->V[i] = 0.0;
> 		for (j = 0; j < Q->r; j++)
> 			y1->V[i] += p1->V[j] * Q->M[j][Q->c - tk + i];
345,346c421,428
<   { x=0.0;for (j=i+1;j<tk;j++) x+=p1->V[j]*T->M[j][T->c-i-1];
<     if (T->M[i][T->c-i-1]!=0.0) p1->V[i]=(y1->V[tk-i-1]-x)/T->M[i][T->c-i-1];else p1->V[i]=0.0;
---
> 	{
> 		x = 0.0;
> 		for (j = i + 1; j < tk; j++)
> 			x += p1->V[j] * T->M[j][T->c - i - 1];
> 		if (T->M[i][T->c - i - 1] != 0.0)
> 			p1->V[i] = (y1->V[tk - i - 1] - x) / T->M[i][T->c - i - 1];
> 		else
> 			p1->V[i] = 0.0;
349c431,432
<   x=0.0;j=-1;
---
> 	x = 0.0;
> 	j = -1;
351c434,437
<   if ((!fixed[i-fixed_cons])&&(p1->V[i]<x)) { j=i;x=p1->V[i];}
---
> 		if ((!fixed[i - fixed_cons]) && (p1->V[i] < x)) {
> 			j = i;
> 			x = p1->V[i];
> 		}
353c439,440
<   if (j!=-1) j -= fixed_cons;
---
> 	if (j != -1)
> 		j -= fixed_cons;
362c448,449
< void QPCLS(matrix *Z,matrix *X, matrix *p, matrix *y,matrix *Ain,matrix *b,matrix *Af,int *active)
---
> void QPCLS(matrix *Z, matrix *X, matrix *p, matrix *y, matrix *Ain, matrix *b,
> 		matrix *Af, int *active)
421c508,509
< { matrix Q,T,Rf,PX,Py,a,P,p1,s,c,Xy,y1,u,Pd,pz,pk;
---
> {
> 	matrix Q, T, Rf, PX, Py, a, P, p1, s, c, Xy, y1, u, Pd, pz, pk;
430c518,519
<   s=initmat(p->r,1);c=initmat(p->r,1); /* working space vectors for Givens rotation */
---
> 	s = initmat(p->r, 1);
> 	c = initmat(p->r, 1); /* working space vectors for Givens rotation */
438,442c527,536
<   for (i=0;i<p->r;i++) for (j=0;j<p->r;j++) Q.M[i][j]=0.0;
<   for (i=0;i<p->r;i++) Q.M[i][i]=1.0;
<   T.r=0;a.r=1;a.c=Af->c;
<   for (i=0;i<Af->r;i++)
<   { a.V=Af->M[i];
---
> 	for (i = 0; i < p->r; i++)
> 		for (j = 0; j < p->r; j++)
> 			Q.M[i][j] = 0.0;
> 	for (i = 0; i < p->r; i++)
> 		Q.M[i][i] = 1.0;
> 	T.r = 0;
> 	a.r = 1;
> 	a.c = Af->c;
> 	for (i = 0; i < Af->r; i++) {
> 		a.V = Af->M[i];
450c544,545
<   Py=initmat(y->r,1);mcopy(y,&Py);
---
> 	Py = initmat(y->r, 1);
> 	mcopy(y, &Py);
452c547,548
<   PX=initmat(X->r,X->c);mcopy(X,&PX);
---
> 	PX = initmat(X->r, X->c);
> 	mcopy(X, &PX);
456c552,554
<   Pd=initmat(y->r,1);pz=initmat(p->r,1);pk=initmat(p->r,1);
---
> 	Pd = initmat(y->r, 1);
> 	pz = initmat(p->r, 1);
> 	pk = initmat(p->r, 1);
459,460c557,558
<   while(1)
<   { iter++;
---
> 	while (1) {
> 		iter++;
463c561,562
<     for (i=0;i<Pd.r;i++) Pd.V[i] = Py.V[i]-Pd.V[i]; /* Pd=P(y-Xp) */
---
> 		for (i = 0; i < Pd.r; i++)
> 			Pd.V[i] = Py.V[i] - Pd.V[i]; /* Pd=P(y-Xp) */
465c564,566
<     for (i=0;i<Rf.c;i++) if (Rf.M[i][i]==0.0) error(_("QPCLS - Rank deficiency in model"));
---
> 		for (i = 0; i < Rf.c; i++)
> 			if (Rf.M[i][i] == 0.0)
> 				error(_("QPCLS - Rank deficiency in model"));
467c568,569
<     Rf.r=X->r;Rf.c=X->c; /* Restore Rf */
---
> 		Rf.r = X->r;
> 		Rf.c = X->c; /* Restore Rf */
470,471c572,576
<     for (i=0;i<pk.r;i++)
<     { pk.V[i]=0.0; for (j=0;j<pz.r;j++) pk.V[i]+=Q.M[i][j]*pz.V[j];}
---
> 		for (i = 0; i < pk.r; i++) {
> 			pk.V[i] = 0.0;
> 			for (j = 0; j < pz.r; j++)
> 				pk.V[i] += Q.M[i][j] * pz.V[j];
> 		}
476,477c581,585
<     { I[tk]=k;ignore[k]=1; /* keeping track of what's in working set */
<       LSQPaddcon(Ain,&Q,&T,&Rf,&Py,&PX,&s,&c,k);tk++;
---
> 		{
> 			I[tk] = k;
> 			ignore[k] = 1; /* keeping track of what's in working set */
> 			LSQPaddcon(Ain, &Q, &T, &Rf, &Py, &PX, &s, &c, k);
> 			tk++;
482c590,591
<     { k=LSQPlagrange(X,&Q,&T,p,&Xy,&p1,&y1,fixed,(int)Af->r);
---
> 		{
> 			k = LSQPlagrange(X, &Q, &T, p, &Xy, &p1, &y1, fixed, (int) Af->r);
484c593,594
<       { LSQPdelcon(&Q,&T,&Rf,&Py,&PX,k+(int)Af->r);  /* the Af.r added to k ensures that correct row of T deleted */
---
> 			{
> 				LSQPdelcon(&Q, &T, &Rf, &Py, &PX, k + (int) Af->r); /* the Af.r added to k ensures that correct row of T deleted */
487c597,598
<         { for (i=k;i<tk-1;i++)
---
> 				{
> 					for (i = k; i < tk - 1; i++)
492c603,604
<         { ignore[I[k]]=0;
---
> 				{
> 					ignore[I[k]] = 0;
494c606,607
<           for (i=k;i<tk;i++) I[i]=I[i+1];
---
> 					for (i = k; i < tk; i++)
> 						I[i] = I[i + 1];
499c612,615
<         x=0.0;for (i=0;i<c.r;i++) if (P.V[i]-b->V[i]<x) x=P.V[i]-b->V[i];
---
> 				x = 0.0;
> 				for (i = 0; i < c.r; i++)
> 					if (P.V[i] - b->V[i] < x)
> 						x = P.V[i] - b->V[i];
502c618,619
<         *Z=Q; Z->c -= tk;
---
> 				*Z = Q;
> 				Z->c -= tk;
505c622,623
<         for (i=0;i<tk;i++) active[i+1]=I[i]; 
---
> 				for (i = 0; i < tk; i++)
> 					active[i + 1] = I[i];
507,509c625,641
<         freemat(T);freemat(Rf);freemat(PX);freemat(Py);freemat(p1);freemat(y1);
<         freemat(s);freemat(c);freemat(Xy);freemat(Pd);freemat(pz);freemat(pk);
<         FREE(I);FREE(ignore);freemat(P);FREE(fixed);FREE(delog);
---
> 				freemat(T);
> 				freemat(Rf);
> 				freemat(PX);
> 				freemat(Py);
> 				freemat(p1);
> 				freemat(y1);
> 				freemat(s);
> 				freemat(c);
> 				freemat(Xy);
> 				freemat(Pd);
> 				freemat(pz);
> 				freemat(pk);
> 				FREE(I);
> 				FREE(ignore);
> 				freemat(P);
> 				FREE(fixed);
> 				FREE(delog);
519c650,651
<           matrix *Af,matrix *H,matrix *S,int *off,double *theta,int m,int *active)
---
> 		matrix *Af, matrix *H, matrix *S, int *off, double *theta, int m,
> 		int *active)
551c683,684
< { int i,j,k;
---
> {
> 	int i, j, k;
556c689,692
<   if (m>0) z=initmat(y->r+p->r,1);else z=initmat(y->r,1);
---
> 	if (m > 0)
> 		z = initmat(y->r + p->r, 1);
> 	else
> 		z = initmat(y->r, 1);
558c694,697
<   for (i=0;i<y->r;i++) { W.V[i]=sqrt(w->V[i]);z.V[i]=W.V[i]*y->V[i];}
---
> 	for (i = 0; i < y->r; i++) {
> 		W.V[i] = sqrt(w->V[i]);
> 		z.V[i] = W.V[i] * y->V[i];
> 	}
562c701,703
<   for (i=0;i<X->r;i++) for (j=0;j<X->c;j++) F.M[i][j]=W.V[i]*X->M[i][j];
---
> 	for (i = 0; i < X->r; i++)
> 		for (j = 0; j < X->c; j++)
> 			F.M[i][j] = W.V[i] * X->M[i][j];
565,567c706,710
<   if (m>0)
<   { B=initmat(p->r,p->r);
<     for (k=0;k<m;k++) for (i=0;i<S[k].r;i++) for (j=0;j<S[k].c;j++)
---
> 	if (m > 0) {
> 		B = initmat(p->r, p->r);
> 		for (k = 0; k < m; k++)
> 			for (i = 0; i < S[k].r; i++)
> 				for (j = 0; j < S[k].c; j++)
574,575c717,721
<     for (i=0;i<C.r;i++) for (j=0;j<C.c;j++) F.M[j+X->r][i]=C.M[i][j];
<     freemat(B);freemat(C);
---
> 		for (i = 0; i < C.r; i++)
> 			for (j = 0; j < C.c; j++)
> 				F.M[j + X->r][i] = C.M[i][j];
> 		freemat(B);
> 		freemat(C);
581,582c727,731
<   { freemat(W);W=initmat(Z.c,Z.c);
<     multi(4,W,Z,F,F,Z,1,1,0,0);invert(&W); /* Wildly inefficient!! */
---
> 	{
> 		freemat(W);
> 		W = initmat(Z.c, Z.c);
> 		multi(4, W, Z, F, F, Z, 1, 1, 0, 0);
> 		invert(&W); /* Wildly inefficient!! */
584c733,735
<     for (i=0;i<H->r;i++) for (j=0;j<H->c;j++) H->M[i][j]*=w->V[j];
---
> 		for (i = 0; i < H->r; i++)
> 			for (j = 0; j < H->c; j++)
> 				H->M[i][j] *= w->V[j];
587,588c738,744
<   B=initmat(z.r,1);matmult(B,F,*p,0,0);
<   xx=0.0;for (i=0;i<z.r;i++) { x=B.V[i]-z.V[i];xx+=x*x;}
---
> 	B = initmat(z.r, 1);
> 	matmult(B, F, *p, 0, 0);
> 	xx = 0.0;
> 	for (i = 0; i < z.r; i++) {
> 		x = B.V[i] - z.V[i];
> 		xx += x * x;
> 	}
591c747,750
<   freemat(F);freemat(z);freemat(W);freemat(Z);
---
> 	freemat(F);
> 	freemat(z);
> 	freemat(W);
> 	freemat(Z);
diff -rEZbwB '--exclude=*.[lo,d,pdf,mo,po,tgz,gz,save]*' '--exclude=MD5' '--exclude=Makefile*' '--exclude=all.R' '--exclude=Changes' R-recommended/mgcv/src/qp.h Recommended/mgcv/src/qp.h
7c7,8
< void QPCLS(matrix *Z,matrix *X, matrix *p, matrix *y,matrix *Ain,matrix *b,matrix *Af,int *active);
---
> void QPCLS(matrix *Z, matrix *X, matrix *p, matrix *y, matrix *Ain, matrix *b,
> 		matrix *Af, int *active);
9,10c10,11
<           matrix *Af,matrix *H,matrix *S,int *off,double *theta,int m, int *active);
< 
---
> 		matrix *Af, matrix *H, matrix *S, int *off, double *theta, int m,
> 		int *active);
14,15c15,16
< typedef struct
< { long constraints;
---
> typedef struct {
> 	long constraints;
diff -rEZbwB '--exclude=*.[lo,d,pdf,mo,po,tgz,gz,save]*' '--exclude=MD5' '--exclude=Makefile*' '--exclude=all.R' '--exclude=Changes' R-recommended/mgcv/src/soap.c Recommended/mgcv/src/soap.c
16,18c16,18
< 
< void boundary(int *G, double *d, double *dto, double *x0, double *y0, double *dx, double *dy,
<               int *nx, int *ny, double *x, double *y,double *break_code, int *n, int *nb)
---
> void boundary(int *G, double *d, double *dto, double *x0, double *y0,
> 		double *dx, double *dy, int *nx, int *ny, double *x, double *y,
> 		double *break_code, int *n, int *nb)
56,57c56,60
< { int segi,j,j0,j1,k,kk,i,reversed,*inb,*ip,*ip1,*ip2,bnd_count,ii,out_lim;
<   double x1,y1,x2,y2,xb0,yb0,xl,yl,xc,yc,dist,dist_to,grad=0.0,b,len2,*p1,*p2;
---
> {
> 	int segi, j, j0, j1, k, kk, i, reversed, *inb, *ip, *ip1, *ip2, bnd_count,
> 			ii, out_lim;
> 	double x1, y1, x2, y2, xb0, yb0, xl, yl, xc, yc, dist, dist_to, grad = 0.0,
> 			b, len2, *p1, *p2;
61c64,65
<   p1 = d;p2 = dto;
---
> 	p1 = d;
> 	p2 = dto;
64c68,69
<       *p1 = x1;*p2 = y1; /* cell centres */
---
> 			*p1 = x1;
> 			*p2 = y1; /* cell centres */
72,73c77,82
<   for (ip = inb,ip1 = G,p2 = dto,ip2=G+k;ip1<ip2;ip1++,p2++,ip++) {
<     if (!*ip) *ip1 = j; else *ip1 = 1; /* set outside/inside in G */
---
> 	for (ip = inb, ip1 = G, p2 = dto, ip2 = G + k; ip1 < ip2;
> 			ip1++, p2++, ip++) {
> 		if (!*ip)
> 			*ip1 = j;
> 		else
> 			*ip1 = 1; /* set outside/inside in G */
78c87,88
<   xb0 = *x0 - *dx/2;yb0 = *y0 - *dx/2; /* Refers to boundary lines lower left */ 
---
> 	xb0 = *x0 - *dx / 2;
> 	yb0 = *y0 - *dx / 2; /* Refers to boundary lines lower left */
88,89c98,101
<       x1=x[segi-1];x2=x[segi]; 
<       y1=y[segi-1];y2=y[segi];
---
> 			x1 = x[segi - 1];
> 			x2 = x[segi];
> 			y1 = y[segi - 1];
> 			y2 = y[segi];
92,93c104,107
<       x1=x[segi];x2=x[segi-1]; 
<       y1=y[segi];y2=y[segi-1]; 
---
> 			x1 = x[segi];
> 			x2 = x[segi - 1];
> 			y1 = y[segi];
> 			y2 = y[segi - 1];
100c114,117
<     if (x2-x1>0) grad = (y2-y1)/(x2-x1); else j1=j0-1;
---
> 		if (x2 - x1 > 0)
> 			grad = (y2 - y1) / (x2 - x1);
> 		else
> 			j1 = j0 - 1;
123c140,141
<         xl = x2-x1;yl=y2-y1; 
---
> 				xl = x2 - x1;
> 				yl = y2 - y1;
126c144,145
<         xc -= x1;yc -= y1;   /* cell centre done */
---
> 				xc -= x1;
> 				yc -= y1; /* cell centre done */
129c148,149
<         xl = xl*b+x1;yl = yl * b + y1; /* location of projection from node to line */
---
> 				xl = xl * b + x1;
> 				yl = yl * b + y1; /* location of projection from node to line */
131,132c151,158
<         if (xl < x1) {xl = x1;yl = y1;}
<         if (xl > x2) {xl = x2;yl = y2;} /* constrained to *within* segment */
---
> 				if (xl < x1) {
> 					xl = x1;
> 					yl = y1;
> 				}
> 				if (xl > x2) {
> 					xl = x2;
> 					yl = y2;
> 				} /* constrained to *within* segment */
139c165,166
<           xl -= x1; yl -= y1;
---
> 					xl -= x1;
> 					yl -= y1;
152,153c179,182
<       x1=x[segi-1];x2=x[segi]; 
<       y1=y[segi-1];y2=y[segi];
---
> 			x1 = x[segi - 1];
> 			x2 = x[segi];
> 			y1 = y[segi - 1];
> 			y2 = y[segi];
156,157c185,188
<       x1=x[segi];x2=x[segi-1]; 
<       y1=y[segi];y2=y[segi-1];  
---
> 			x1 = x[segi];
> 			x2 = x[segi - 1];
> 			y1 = y[segi];
> 			y2 = y[segi - 1];
164c195,198
<     if (y2-y1>0) grad = (x2-x1)/(y2-y1); else j1=j0-1;
---
> 		if (y2 - y1 > 0)
> 			grad = (x2 - x1) / (y2 - y1);
> 		else
> 			j1 = j0 - 1;
173c207,211
<       if (G[kk]>0||G[kk]< out_lim) {G[kk] = -ii;ii++;nb[bnd_count]++;} /* otherwise already a boundary cell */
---
> 			if (G[kk] > 0 || G[kk] < out_lim) {
> 				G[kk] = -ii;
> 				ii++;
> 				nb[bnd_count]++;
> 			} /* otherwise already a boundary cell */
175c213,217
<       if (G[kk]>0||G[kk]< out_lim) {G[kk] = -ii;ii++;nb[bnd_count]++;} /* otherwise already a boundary cell */
---
> 			if (G[kk] > 0 || G[kk] < out_lim) {
> 				G[kk] = -ii;
> 				ii++;
> 				nb[bnd_count]++;
> 			} /* otherwise already a boundary cell */
180c222,223
<         xl = x2-x1;yl=y2-y1;
---
> 				xl = x2 - x1;
> 				yl = y2 - y1;
183c226,227
<         xc -= x1;yc -= y1;   /* cell centre done */
---
> 				xc -= x1;
> 				yc -= y1; /* cell centre done */
186c230,231
<         xl = xl*b+x1;yl = yl * b + y1; /* location of projection from node to line */
---
> 				xl = xl * b + x1;
> 				yl = yl * b + y1; /* location of projection from node to line */
188,189c233,240
<         if (yl < y1) {xl = x1;yl = y1;}
<         if (yl > y2) {xl = x2;yl = y2;} /* constrained to *within* segment */
---
> 				if (yl < y1) {
> 					xl = x1;
> 					yl = y1;
> 				}
> 				if (yl > y2) {
> 					xl = x2;
> 					yl = y2;
> 				} /* constrained to *within* segment */
196c247,248
<           xl -= x1; yl -= y1;
---
> 					xl -= x1;
> 					yl -= y1;
207c259,260
<     x2 = x2-x1;y2=y2-y1;
---
> 		x2 = x2 - x1;
> 		y2 = y2 - y1;
212c265,266
<       segi++;segi++; /* move past the break */
---
> 			segi++;
> 			segi++; /* move past the break */
214c268,269
<       if (segi < *n) nb[bnd_count] = 0; /* set cell counter for this loop */
---
> 			if (segi < *n)
> 				nb[bnd_count] = 0; /* set cell counter for this loop */
219c274,276
<   k = *nx * *ny;for (i=ii;i<k;i++) d[i] = -1;
---
> 	k = *nx * *ny;
> 	for (i = ii; i < k; i++)
> 		d[i] = -1;
222c279,283
<   for (ip1 = G,ip2 = G + k;ip1<ip2;ip1++) if (*ip1 > 0) {*ip1 = ii;ii++;} 
---
> 	for (ip1 = G, ip2 = G + k; ip1 < ip2; ip1++)
> 		if (*ip1 > 0) {
> 			*ip1 = ii;
> 			ii++;
> 		}
226c287,288
< void pde_coeffs(int *G,double *x,int *ii,int *jj,int *n,int *nx,int *ny,double *dx,double *dy) {
---
> void pde_coeffs(int *G, double *x, int *ii, int *jj, int *n, int *nx, int *ny,
> 		double *dx, double *dy) {
235,236c297,301
<   thresh = dx2= 1.0/(*dx * *dx);dy2 = 1.0/(*dy * *dy);
<   if (dy2 < thresh) thresh = dy2;thresh *= .5;
---
> 	thresh = dx2 = 1.0 / (*dx * *dx);
> 	dy2 = 1.0 / (*dy * *dy);
> 	if (dy2 < thresh)
> 		thresh = dy2;
> 	thresh *= .5;
239c304,306
<   for (ip=G,i=0;i<*nx;i++) for (j=0;j<*ny;j++,ip++) if (*ip > outside){
---
> 	for (ip = G, i = 0; i < *nx; i++)
> 		for (j = 0; j < *ny; j++, ip++)
> 			if (*ip > outside) {
241,242c308,313
<       *x=1.0;*jj = *ii= - *ip;
<       x++;ii++;jj++;*n += 1;
---
> 					*x = 1.0;
> 					*jj = *ii = -*ip;
> 					x++;
> 					ii++;
> 					jj++;
> 					*n += 1;
248c319,320
<          Gk0 = G[k0];Gk1 = G[k1];
---
> 						Gk0 = G[k0];
> 						Gk1 = G[k1];
251,256c323,340
<            if (Gk0<0) Gk0 = -Gk0;
<            *x = -dx2;*ii = *ip;*jj = Gk0;
<            x++;ii++;jj++;*n += 1;
<            if (Gk1<0) Gk1 = -Gk1; 
<            *x = -dx2;*ii = *ip;*jj = Gk1;
<            x++;ii++;jj++;*n += 1;
---
> 							if (Gk0 < 0)
> 								Gk0 = -Gk0;
> 							*x = -dx2;
> 							*ii = *ip;
> 							*jj = Gk0;
> 							x++;
> 							ii++;
> 							jj++;
> 							*n += 1;
> 							if (Gk1 < 0)
> 								Gk1 = -Gk1;
> 							*x = -dx2;
> 							*ii = *ip;
> 							*jj = Gk1;
> 							x++;
> 							ii++;
> 							jj++;
> 							*n += 1;
262c346,347
<          Gk0 = G[k0];Gk1 = G[k1];
---
> 						Gk0 = G[k0];
> 						Gk1 = G[k1];
265,270c350,367
<            if (Gk0<0) Gk0 = -Gk0;
<            *x = -dy2;*ii = *ip;*jj = Gk0;
<            x++;ii++;jj++;*n += 1;
<            if (Gk1<0) Gk1 = -Gk1; 
<            *x = -dy2;*ii = *ip;*jj = Gk1;
<            x++;ii++;jj++;*n += 1;
---
> 							if (Gk0 < 0)
> 								Gk0 = -Gk0;
> 							*x = -dy2;
> 							*ii = *ip;
> 							*jj = Gk0;
> 							x++;
> 							ii++;
> 							jj++;
> 							*n += 1;
> 							if (Gk1 < 0)
> 								Gk1 = -Gk1;
> 							*x = -dy2;
> 							*ii = *ip;
> 							*jj = Gk1;
> 							x++;
> 							ii++;
> 							jj++;
> 							*n += 1;
273,274c370,375
<            *x = xc;*ii = *jj = *ip;
<            x++;ii++;jj++;*n += 1;
---
> 							*x = xc;
> 							*ii = *jj = *ip;
> 							x++;
> 							ii++;
> 							jj++;
> 							*n += 1;
281,283c382,384
< 
< void gridder(double *z,double *x,double *y,int *n,double *g, int *G,int *nx, int *ny,double *x0, 
<              double *y0,double *dx,double *dy,double NA_code) {
---
> void gridder(double *z, double *x, double *y, int *n, double *g, int *G,
> 		int *nx, int *ny, double *x0, double *y0, double *dx, double *dy,
> 		double NA_code) {
292c393,394
<   double xx,yy,xx0,yy0,dmax,xa,ya,g00=0.0,g01=0.0,g10=0.0,g11=0.0,b0,b1,b2,b3,dist,d1;
---
> 	double xx, yy, xx0, yy0, dmax, xa, ya, g00 = 0.0, g01 = 0.0, g10 = 0.0,
> 			g11 = 0.0, b0, b1, b2, b3, dist, d1;
294c396,397
<   xx0 = *x0;yy0 = *y0;
---
> 	xx0 = *x0;
> 	yy0 = *y0;
297c400,401
<     xx = x[i];yy = y[i];
---
> 		xx = x[i];
> 		yy = y[i];
303c407,409
<     if (ix<0||ix>=*nx||iy<0||iy>=*ny) ok00 = 0; else { 
---
> 		if (ix < 0 || ix >= *nx || iy < 0 || iy >= *ny)
> 			ok00 = 0;
> 		else {
305,307c411,417
<       if (Gk < Gthresh) ok00 = 0; else {
< 	ok00 = 1; ok++;
< 	if (Gk < 0) Gk = -Gk;
---
> 			if (Gk < Gthresh)
> 				ok00 = 0;
> 			else {
> 				ok00 = 1;
> 				ok++;
> 				if (Gk < 0)
> 					Gk = -Gk;
311,312c421,425
<     iy++;k++; /* node 01 */   
<     if (ix<0||ix>=*nx||iy<0||iy>=*ny) ok01 = 0; else { 
---
> 		iy++;
> 		k++; /* node 01 */
> 		if (ix < 0 || ix >= *nx || iy < 0 || iy >= *ny)
> 			ok01 = 0;
> 		else {
314,316c427,433
<       if (Gk < Gthresh) ok01 = 0; else {
< 	ok01 = 1; ok++;
< 	if (Gk < 0) Gk = -Gk;
---
> 			if (Gk < Gthresh)
> 				ok01 = 0;
> 			else {
> 				ok01 = 1;
> 				ok++;
> 				if (Gk < 0)
> 					Gk = -Gk;
320,321c437,441
<     ix++; k += *ny; /* node 11 */
<     if (ix<0||ix>=*nx||iy<0||iy>=*ny) ok11 = 0; else { 
---
> 		ix++;
> 		k += *ny; /* node 11 */
> 		if (ix < 0 || ix >= *nx || iy < 0 || iy >= *ny)
> 			ok11 = 0;
> 		else {
323,325c443,449
<       if (Gk < Gthresh) ok11 = 0; else {
< 	ok11 = 1; ok++;
< 	if (Gk < 0) Gk = -Gk;
---
> 			if (Gk < Gthresh)
> 				ok11 = 0;
> 			else {
> 				ok11 = 1;
> 				ok++;
> 				if (Gk < 0)
> 					Gk = -Gk;
329,330c453,457
<     iy--;k--; /* node 10 */
<     if (ix<0||ix>=*nx||iy<0||iy>=*ny) ok10 = 0; else { 
---
> 		iy--;
> 		k--; /* node 10 */
> 		if (ix < 0 || ix >= *nx || iy < 0 || iy >= *ny)
> 			ok10 = 0;
> 		else {
332,334c459,465
<       if (Gk < Gthresh) ok10 = 0; else {
< 	ok10 = 1; ok++;
< 	if (Gk < 0) Gk = -Gk;
---
> 			if (Gk < Gthresh)
> 				ok10 = 0;
> 			else {
> 				ok10 = 1;
> 				ok++;
> 				if (Gk < 0)
> 					Gk = -Gk;
diff -rEZbwB '--exclude=*.[lo,d,pdf,mo,po,tgz,gz,save]*' '--exclude=MD5' '--exclude=Makefile*' '--exclude=all.R' '--exclude=Changes' R-recommended/mgcv/src/sparse-smooth.c Recommended/mgcv/src/sparse-smooth.c
23a24
> #include "localization.h"
75c74,75
<   *ddat = kd.huge;ddat++;
---
> 	*ddat = kd.huge;
> 	ddat++;
77c77,78
<   for (p=idat+3,p0=kd.ind,p1=p0+n;p0<p1;p++,p0++) *p = *p0;
---
> 	for (p = idat + 3, p0 = kd.ind, p1 = p0 + n; p0 < p1; p++, p0++)
> 		*p = *p0;
79c80,81
<   for (p0=kd.rind,p1=p0+n;p0<p1;p++,p0++) *p = *p0;
---
> 	for (p0 = kd.rind, p1 = p0 + n; p0 < p1; p++, p0++)
> 		*p = *p0;
88c90,91
<     for (pd=kd.box[i].lo,pd1=pd+d;pd<pd1;pd++,ddat++) *ddat = *pd;
---
> 		for (pd = kd.box[i].lo, pd1 = pd + d; pd < pd1; pd++, ddat++)
> 			*ddat = *pd;
90,95c93,104
<     for (pd=kd.box[i].hi,pd1=pd+d;pd<pd1;pd++,ddat++) *ddat = *pd;
<     *pp = kd.box[i].parent;pp++;
<     *pc1 = kd.box[i].child1;pc1++;
<     *pc2 = kd.box[i].child2;pc2++;
<     *p0 = kd.box[i].p0;p0++;
<     *p1 = kd.box[i].p1;p1++;
---
> 		for (pd = kd.box[i].hi, pd1 = pd + d; pd < pd1; pd++, ddat++)
> 			*ddat = *pd;
> 		*pp = kd.box[i].parent;
> 		pp++;
> 		*pc1 = kd.box[i].child1;
> 		pc1++;
> 		*pc2 = kd.box[i].child2;
> 		pc2++;
> 		*p0 = kd.box[i].p0;
> 		p0++;
> 		*p1 = kd.box[i].p1;
> 		p1++;
115c124,125
<   kd->huge = *ddat;ddat++;
---
> 	kd->huge = *ddat;
> 	ddat++;
126,132c136,149
<     box->lo = ddat;ddat += d;
<     box->hi = ddat;ddat += d;
<     box->parent = *pp;pp++;
<     box->child1 = *pc1;pc1++;
<     box->child2 = *pc2;pc2++;
<     box->p0 = *p0;p0++;
<     box->p1 = *p1;p1++;
---
> 		box->lo = ddat;
> 		ddat += d;
> 		box->hi = ddat;
> 		ddat += d;
> 		box->parent = *pp;
> 		pp++;
> 		box->child1 = *pc1;
> 		pc1++;
> 		box->child2 = *pc2;
> 		pc2++;
> 		box->p0 = *p0;
> 		p0++;
> 		box->p1 = *p1;
> 		p1++;
139c155,157
<   for (i=0;i<kd.n_box;i++) if (kd.box[i].p1>n) n = kd.box[i].p1;
---
> 	for (i = 0; i < kd.n_box; i++)
> 		if (kd.box[i].p1 > n)
> 			n = kd.box[i].p1;
141,142c159,164
<   for (i=0;i<kd.n_box;i++) if (!kd.box[i].child1) { /* terminal node */
<     if (kd.box[i].p1-kd.box[i].p0>1) { Rprintf("More than 2 points in a box!!\n");ok=0;}
---
> 	for (i = 0; i < kd.n_box; i++)
> 		if (!kd.box[i].child1) { /* terminal node */
> 			if (kd.box[i].p1 - kd.box[i].p0 > 1) {
> 				Rprintf(_("More than 2 points in a box!!\n"));
> 				ok = 0;
> 			}
144c166,167
<     if (kd.box[i].p1!=kd.box[i].p0) count[kd.box[i].p1]++;
---
> 			if (kd.box[i].p1 != kd.box[i].p0)
> 				count[kd.box[i].p1]++;
147c170,172
<     if (count[i]!=1) { Rprintf("point %d in %d boxes!\n",i,count[i]);ok=0;}
---
> 		if (count[i] != 1) {
> 			Rprintf(_("point %d in %d boxes!\n"), i, count[i]);
> 			ok = 0;
149c174,176
<   if (ok) Rprintf("kd tree sanity checks\n");
---
> 	}
> 	if (ok)
> 		Rprintf("kd tree sanity checks\n");
191c218,220
<       dum = ind[l+1];ind[l+1] = ind[m];ind[m] = dum; /* swap points m and l+1 */
---
> 			dum = ind[l + 1];
> 			ind[l + 1] = ind[m];
> 			ind[m] = dum; /* swap points m and l+1 */
194c223,225
<         dum = ind[r];ind[r] = ind[l];ind[l] = dum;
---
> 				dum = ind[r];
> 				ind[r] = ind[l];
> 				ind[l] = dum;
197,200c228,234
<         dum = ind[l];ind[l] = ind[l+1];ind[l+1] = dum;
<       } 
<       else if (x[ind[l+1]] > x[ind[r]]) { /* swap l+1 and r */
<         dum = ind[l+1];ind[l+1] = ind[r];ind[r] = dum;
---
> 				dum = ind[l];
> 				ind[l] = ind[l + 1];
> 				ind[l + 1] = dum;
> 			} else if (x[ind[l + 1]] > x[ind[r]]) { /* swap l+1 and r */
> 				dum = ind[l + 1];
> 				ind[l + 1] = ind[r];
> 				ind[r] = dum;
214,220c248,262
<         li++;ri--; /* always move by one, or you can get stuck */
<         while(x[ind[li]] < xp) li++; /* move up until value on wrong side (or equal) found */
<         while(x[ind[ri]] > xp) ri--; /* move down until value on wrong side (or equal) found */
<         if (ri < 0) Rprintf("ri<0!!\n");
<         if (li >= *n) Rprintf("li >= n!!\n");       
<         if (ri<li) break; /* partitions correct now */
<         dum = ind[ri];ind[ri] = ind[li];ind[li] = dum; /* swap ri and li (to correct sides) */
---
> 				li++;
> 				ri--; /* always move by one, or you can get stuck */
> 				while (x[ind[li]] < xp)
> 					li++; /* move up until value on wrong side (or equal) found */
> 				while (x[ind[ri]] > xp)
> 					ri--; /* move down until value on wrong side (or equal) found */
> 				if (ri < 0)
> 					Rprintf("ri<0!!\n");
> 				if (li >= *n)
> 					Rprintf("li >= n!!\n");
> 				if (ri < li)
> 					break; /* partitions correct now */
> 				dum = ind[ri];
> 				ind[ri] = ind[li];
> 				ind[li] = dum; /* swap ri and li (to correct sides) */
226,227c268,271
<       if (ri >= *k ) r = ri - 1; /*else l=li;*/ /* if (ri <= *k + 1)  l = li;*/ /* had else l=li; here */
<       if (ri <= *k ) l = li; 
---
> 			if (ri >= *k)
> 				r = ri - 1; /*else l=li;*//* if (ri <= *k + 1)  l = li;*//* had else l=li; here */
> 			if (ri <= *k)
> 				l = li;
230c274,276
<          dum = ind[r];ind[r] = ind[l];ind[l] = dum; /* so swap indices */
---
> 				dum = ind[r];
> 				ind[r] = ind[l];
> 				ind[l] = dum; /* so swap indices */
241c287,288
<   FREE(kd.ind);FREE(kd.rind);
---
> 	FREE(kd.ind);
> 	FREE(kd.rind);
257c304,305
<   int *ind,*rind,*p,i,m,todo[50],todo_d[50],item,bi,nb,np,k,dim,b,p0,p1;
---
> 	int *ind, *rind, *p, i, m, todo[50], todo_d[50], item, bi, nb, np, k, dim,
> 			b, p0, p1;
262c310,311
<   for (i=0,p=ind;i < *n;i++,p++) *p = i; 
---
> 	for (i = 0, p = ind; i < *n; i++, p++)
> 		*p = i;
264c313,315
<   m=2;while (m < *n) m *= 2;
---
> 	m = 2;
> 	while (m < *n)
> 		m *= 2;
266c317,318
<   if (nb > m-1) nb = m - 1; 
---
> 	if (nb > m - 1)
> 		nb = m - 1;
272,273c324,327
<     box[i].lo = pd;pd += *d;
<     box[i].hi = pd;pd += *d;
---
> 		box[i].lo = pd;
> 		pd += *d;
> 		box[i].hi = pd;
> 		pd += *d;
278c332,333
<     box[0].lo[i] = -huge;box[0].hi[i] = huge;
---
> 		box[0].lo[i] = -huge;
> 		box[0].hi[i] = huge;
293c348,349
<     p0 = box[b].p0;p1=box[b].p1; 
---
> 		p0 = box[b].p0;
> 		p1 = box[b].p1;
309c365,366
<     if (bi>nb-1) Rprintf("too many boxes!!");
---
> 		if (bi > nb - 1)
> 			Rprintf(_("too many boxes!!"));
312,313c369,374
<     for (dum1=box[bi].lo,dum2=dum1 + *d,dum3=box[b].lo;dum1<dum2;dum1++,dum3++) *dum1 = *dum3;
<     for (dum1=box[bi].hi,dum2=dum1 + *d,dum3=box[b].hi;dum1<dum2;dum1++,dum3++) *dum1 = *dum3;
---
> 		for (dum1 = box[bi].lo, dum2 = dum1 + *d, dum3 = box[b].lo; dum1 < dum2;
> 				dum1++, dum3++)
> 			*dum1 = *dum3;
> 		for (dum1 = box[bi].hi, dum2 = dum1 + *d, dum3 = box[b].hi; dum1 < dum2;
> 				dum1++, dum3++)
> 			*dum1 = *dum3;
322c383,384
<       if (todo_d[item] == *d) todo_d[item] = 0;
---
> 			if (todo_d[item] == *d)
> 				todo_d[item] = 0;
325c387,388
<     if (bi>nb-1) Rprintf("too many boxes!!");
---
> 		if (bi > nb - 1)
> 			Rprintf(_("too many boxes!!"));
328,329c391,396
<     for (dum1=box[bi].lo,dum2=dum1 + *d,dum3=box[b].lo;dum1<dum2;dum1++,dum3++) *dum1 = *dum3;
<     for (dum1=box[bi].hi,dum2=dum1 + *d,dum3=box[b].hi;dum1<dum2;dum1++,dum3++) *dum1 = *dum3;
---
> 		for (dum1 = box[bi].lo, dum2 = dum1 + *d, dum3 = box[b].lo; dum1 < dum2;
> 				dum1++, dum3++)
> 			*dum1 = *dum3;
> 		for (dum1 = box[bi].hi, dum2 = dum1 + *d, dum3 = box[b].hi; dum1 < dum2;
> 				dum1++, dum3++)
> 			*dum1 = *dum3;
338c405,406
<       if (todo_d[item] == *d) todo_d[item] = 0;
---
> 			if (todo_d[item] == *d)
> 				todo_d[item] = 0;
341c409,410
<   if (bi!=nb-1) Rprintf("bi not equal to nb-1 %d %d\n",bi,nb-1);
---
> 	if (bi != nb - 1)
> 		Rprintf(_("bi not equal to nb-1 %d %d\n"), bi, nb - 1);
344c413,414
<   for (i=0;i<*n;i++) rind[ind[i]]=i; 
---
> 	for (i = 0; i < *n; i++)
> 		rind[ind[i]] = i;
346,347c416,422
<   kd->box = box;kd->ind = ind;kd->rind = rind;kd->n_box = nb;kd->huge = huge;
<   kd->d = *d;kd->n = *n;
---
> 	kd->box = box;
> 	kd->ind = ind;
> 	kd->rind = rind;
> 	kd->n_box = nb;
> 	kd->huge = huge;
> 	kd->d = *d;
> 	kd->n = *n;
387,388c460,463
<     if (i < n-1&&h[i]<h[i+1]) i++; /* i indexes largest of i0's child nodes */ 
<     if (h0 > h[i]) break; /* h0 should be at h[i0] */
---
> 		if (i < n - 1 && h[i] < h[i + 1])
> 			i++; /* i indexes largest of i0's child nodes */
> 		if (h0 > h[i])
> 			break; /* h0 should be at h[i0] */
404,405c479,486
<     if (*x < *bl) { z = *x - *bl;d2 += z*z;}
<     if (*x > *bh) { z = *x - *bh;d2 += z*z;}
---
> 		if (*x < *bl) {
> 			z = *x - *bl;
> 			d2 += z * z;
> 		}
> 		if (*x > *bh) {
> 			z = *x - *bh;
> 			d2 += z * z;
> 		}
421,422c501,504
<     if (kd->box[b1].p1>=i) bi = b1; /* point is in child1 */
<     else bi = kd->box[bi].child2; /* kd->box[bi].child1 must be in child2 */
---
> 		if (kd->box[b1].p1 >= i)
> 			bi = b1; /* point is in child1 */
> 		else
> 			bi = kd->box[bi].child2; /* kd->box[bi].child1 must be in child2 */
441c522,523
<     if (box[b1].hi[d]!=box[box[bi].child2].lo[d]) Rprintf("child boundary problem\n");
---
> 		if (box[b1].hi[d] != box[box[bi].child2].lo[d])
> 			Rprintf(_("child boundary problem\n"));
443c525,527
<     if (x[d] <= box[b1].hi[d]) bi = b1; else 
---
> 		if (x[d] <= box[b1].hi[d])
> 			bi = b1;
> 		else
445c529,531
<     d++; if (d == kd->d) d=0;
---
> 		d++;
> 		if (d == kd->d)
> 			d = 0;
455c540,543
<   for (pi=X+i,pil=pi+n*d,pj=X+j;pi<pil;pi+=n,pj+=n) {x = *pi - *pj;dist += x*x;} 
---
> 	for (pi = X + i, pil = pi + n * d, pj = X + j; pi < pil; pi += n, pj += n) {
> 		x = *pi - *pj;
> 		dist += x * x;
> 	}
481c568,569
<   if (nex<0) nex=0;  
---
> 	if (nex < 0)
> 		nex = 0;
493c581,586
<       ok = 1;for (i=0;i<nex;i++) if (k == ex[i]) {ok = 0;break;}
---
> 			ok = 1;
> 			for (i = 0; i < nex; i++)
> 				if (k == ex[i]) {
> 					ok = 0;
> 					break;
> 				}
496c589,592
<         if (d1<nd) { nd=d1;ni=k;}
---
> 				if (d1 < nd) {
> 					nd = d1;
> 					ni = k;
> 				}
499c595,596
<     if (ni < 0&& bx!=0) bx = box[bx].parent; /* still need bigger box */
---
> 		if (ni < 0 && bx != 0)
> 			bx = box[bx].parent; /* still need bigger box */
522c619,624
<             ok = 1;for (i=0;i<nex;i++) if (k == ex[i]) {ok = 0;break;}
---
> 						ok = 1;
> 						for (i = 0; i < nex; i++)
> 							if (k == ex[i]) {
> 								ok = 0;
> 								break;
> 							}
550c650,651
<   if (kd->d!=2) Rprintf("\n star only useful in 2D\n");
---
> 	if (kd->d != 2)
> 		Rprintf(_("\n 'star()' function is useful only in 2D\n"));
552c653,654
<   x0[0] = X[i0];x0[1] = X[i0 + n];
---
> 	x0[0] = X[i0];
> 	x0[1] = X[i0 + n];
555,556c657,660
<     dx = dist*sin(pi25*i);dy = dist*cos(pi25*i);
<     x[0] = x0[0] + dx;x[1] = x0[1] + dy; /* current star point */
---
> 		dx = dist * sin(pi25 * i);
> 		dy = dist * cos(pi25 * i);
> 		x[0] = x0[0] + dx;
> 		x[1] = x0[1] + dy; /* current star point */
582c686,687
<         count[j]++; wa[j] += kd.box[bi].hi[j] - kd.box[bi].lo[j];
---
> 				count[j]++;
> 				wa[j] += kd.box[bi].hi[j] - kd.box[bi].lo[j];
586c691,692
<   for (j=0;j<d;j++) wa[j] /= count[j];
---
> 	for (j = 0; j < d; j++)
> 		wa[j] /= count[j];
592c698,699
<       if (lo[j]==-kd.huge) ok = 0;
---
> 			if (lo[j] == -kd.huge)
> 				ok = 0;
594c701,702
<       if (hi[j]==kd.huge) ok = 0;
---
> 			if (hi[j] == kd.huge)
> 				ok = 0;
600,601c708,711
<       if (k==i) check=1;
<       for (j=0;j<d;j++) x0[j] = X[k + j * n];
---
> 			if (k == i)
> 				check = 1;
> 			for (j = 0; j < d; j++)
> 				x0[j] = X[k + j * n];
604,605c714,717
<         if (k==i) check=1;
<         for (j=0;j<d;j++) x1[j] = X[k + j * n];
---
> 				if (k == i)
> 					check = 1;
> 				for (j = 0; j < d; j++)
> 					x1[j] = X[k + j * n];
607c719,720
<       if (!check) Rprintf("indexing error in p_area!\n");
---
> 			if (!check)
> 				Rprintf(_("indexing error in 'p_area()' function!\n"));
610c723,724
<       ok=1; min_w = -1.0;
---
> 			ok = 1;
> 			min_w = -1.0;
613,615c727,733
<            x = x0[j]; if (np>1 && x1[j]<x) x = x1[j];  
<            if (x < hi[j]) lo[j] = x; /* sorted! */
<            else ok=0; /* not sorted! */
---
> 					x = x0[j];
> 					if (np > 1 && x1[j] < x)
> 						x = x1[j];
> 					if (x < hi[j])
> 						lo[j] = x; /* sorted! */
> 					else
> 						ok = 0; /* not sorted! */
618,620c736,742
<            x = x0[j]; if (np>1 && x1[j]>x) x = x1[j];  
<            if (x > lo[j]) hi[j] = x; /* sorted! */
<            else ok=0; /* not sorted! */
---
> 					x = x0[j];
> 					if (np > 1 && x1[j] > x)
> 						x = x1[j];
> 					if (x > lo[j])
> 						hi[j] = x; /* sorted! */
> 					else
> 						ok = 0; /* not sorted! */
624c746,747
<            if (min_w < 0 || x < min_w) min_w = x;
---
> 					if (min_w < 0 || x < min_w)
> 						min_w = x;
630,631c753,759
<             x = x0[j]; if (np>1 && x1[j]<x) x = x1[j]; 
<             if (min_w>0) x -= min_w; else x -= wa[j];
---
> 						x = x0[j];
> 						if (np > 1 && x1[j] < x)
> 							x = x1[j];
> 						if (min_w > 0)
> 							x -= min_w;
> 						else
> 							x -= wa[j];
635,636c763,769
<             x = x0[j]; if (np>1 && x1[j]>x) x = x1[j];  
<             if (min_w>0) x += min_w; else x += wa[j];
---
> 						x = x0[j];
> 						if (np > 1 && x1[j] > x)
> 							x = x1[j];
> 						if (min_w > 0)
> 							x += min_w;
> 						else
> 							x += wa[j];
643c776,777
<     for (x=1.0,j=0;j<d;j++) x*= hi[j]-lo[j];
---
> 		for (x = 1.0, j = 0; j < d; j++)
> 			x *= hi[j] - lo[j];
648c782,786
<   FREE(x0);FREE(x1);FREE(lo);FREE(hi);FREE(wa);
---
> 	FREE(x0);
> 	FREE(x1);
> 	FREE(lo);
> 	FREE(hi);
> 	FREE(wa);
651,652c789,790
< 
< void k_radius(double r, kdtree_type kd, double *X,double *x,int *list,int *nlist) {
---
> void k_radius(double r, kdtree_type kd, double *X, double *x, int *list,
> 		int *nlist) {
671c809,810
<     c1 = box[bi].child1;c2 = box[bi].child2;
---
> 		c1 = box[bi].child1;
> 		c2 = box[bi].child2;
675,678c814,822
<     if (x[dim]+r <= box[c1].hi[dim]) bi = c1; /* r-ball is completely inside child 1 */     
<     else if (x[dim]-2 >= box[c2].lo[dim]) bi = c2; /* r-ball completely in child 2 */
<     dim++; if (dim==d) dim = 0;
<     if (bi==bi_old) break; /* neither child contained whole r-ball, so use box[bi] */
---
> 		if (x[dim] + r <= box[c1].hi[dim])
> 			bi = c1; /* r-ball is completely inside child 1 */
> 		else if (x[dim] - 2 >= box[c2].lo[dim])
> 			bi = c2; /* r-ball completely in child 2 */
> 		dim++;
> 		if (dim == d)
> 			dim = 0;
> 		if (bi == bi_old)
> 			break; /* neither child contained whole r-ball, so use box[bi] */
685c829,830
<     bi = todo[item];item--;
---
> 		bi = todo[item];
> 		item--;
688,689c833,836
<         item++;todo[item] = box[bi].child1;
<         item++;todo[item] = box[bi].child2;
---
> 				item++;
> 				todo[item] = box[bi].child1;
> 				item++;
> 				todo[item] = box[bi].child2;
693c840,841
<             list[*nlist] = ind[i]; (*nlist)++;             
---
> 						list[*nlist] = ind[i];
> 						(*nlist)++;
701,702c849,850
< 
< void Rkradius(double *r,int *idat,double *ddat,double *X,double *x,int *m,int *off,int *ni,int *op) {
---
> void Rkradius(double *r, int *idat, double *ddat, double *X, double *x, int *m,
> 		int *off, int *ni, int *op) {
717,718c865,868
<     for (i=0;i<nn;i++) ni[i]=nei[i];
<     FREE(nei);nn=0;
---
> 		for (i = 0; i < nn; i++)
> 			ni[i] = nei[i];
> 		FREE(nei);
> 		nn = 0;
727c877,879
<   xx=x;nn=0;off[0]=0;
---
> 	xx = x;
> 	nn = 0;
> 	off[0] = 0;
734c886,887
<     for (j=nn;j<nn+nlist;j++) nei[j] = list[j-nn];
---
> 		for (j = nn; j < nn + nlist; j++)
> 			nei[j] = list[j - nn];
743c896,897
< void k_newn_work(double *Xm,kdtree_type kd,double *X,double *dist,int *ni,int*m,int *n,int *d,int *k) {
---
> void k_newn_work(double *Xm, kdtree_type kd, double *X, double *dist, int *ni,
> 		int*m, int *n, int *d, int *k) {
769,770c923,926
<     for (p=Xm+i,p1=x,p2=p1 + *d;p1<p2;p1++, p+= *m) *p1 = *p; /* copy ith point (ith row of Xm) to x */
<     for (p=dk,p1=dk + *k;p<p1;p++) *p = huge; /* initialize distances to huge */
---
> 		for (p = Xm + i, p1 = x, p2 = p1 + *d; p1 < p2; p1++, p += *m)
> 			*p1 = *p; /* copy ith point (ith row of Xm) to x */
> 		for (p = dk, p1 = dk + *k; p < p1; p++)
> 			*p = huge; /* initialize distances to huge */
779c935,936
<     while (box[bi].p1-box[bi].p0 < *k) bi = box[bi].parent; /* note k does not include self */    
---
> 		while (box[bi].p1 - box[bi].p0 < *k)
> 			bi = box[bi].parent; /* note k does not include self */
791c948,949
<         if (*k>1) update_heap(dk,ik,*k); /* update heap so it still obeys heap ordering */  
---
> 				if (*k > 1)
> 					update_heap(dk, ik, *k); /* update heap so it still obeys heap ordering */
822c980,981
<                 if (*k>1) update_heap(dk,ik,*k); /* update heap so it still obeys heap ordering */  
---
> 								if (*k > 1)
> 									update_heap(dk, ik, *k); /* update heap so it still obeys heap ordering */
842c1001,1002
< void Rkdnearest(double *X,int *idat,double *ddat,int *n,double *x, int *m, int *ni, double *dist,int *k) {
---
> void Rkdnearest(double *X, int *idat, double *ddat, int *n, double *x, int *m,
> 		int *ni, double *dist, int *k) {
858,859c1018,1019
< 
< void k_nn_work(kdtree_type kd,double *X,double *dist,int *ni,int *n,int *d,int *k) {
---
> void k_nn_work(kdtree_type kd, double *X, double *dist, int *ni, int *n, int *d,
> 		int *k) {
876,877c1036,1039
<     for (p=X+i,p1=x,p2=p1 + *d;p1<p2;p1++, p+= *n) *p1 = *p; /* copy ith point (ith row of X) to x */
<     for (p=dk,p1=dk + *k;p<p1;p++) *p = huge; /* initialize distances to huge */
---
> 		for (p = X + i, p1 = x, p2 = p1 + *d; p1 < p2; p1++, p += *n)
> 			*p1 = *p; /* copy ith point (ith row of X) to x */
> 		for (p = dk, p1 = dk + *k; p < p1; p++)
> 			*p = huge; /* initialize distances to huge */
897c1058,1059
<     while (box[bi].p1-box[bi].p0 < *k) bi = box[bi].parent; /* note k does not include self */    
---
> 		while (box[bi].p1 - box[bi].p0 < *k)
> 			bi = box[bi].parent; /* note k does not include self */
909c1071,1072
<         if (*k>1) update_heap(dk,ik,*k); /* update heap so it still obeys heap ordering */  
---
> 					if (*k > 1)
> 						update_heap(dk, ik, *k); /* update heap so it still obeys heap ordering */
939c1102,1103
<                 if (*k>1) update_heap(dk,ik,*k); /* update heap so it still obeys heap ordering */  
---
> 								if (*k > 1)
> 									update_heap(dk, ik, *k); /* update heap so it still obeys heap ordering */
959c1123,1124
< void k_nn(double *X,double *dist,double *a,int *ni,int *n,int *d,int *k,int *get_a) {
---
> void k_nn(double *X, double *dist, double *a, int *ni, int *n, int *d, int *k,
> 		int *get_a) {
1004c1169,1170
<   if (*get_a) p_area(a,X,kd,*n,*d);
---
> 	if (*get_a)
> 		p_area(a, X, kd, *n, *d);
1027c1192,1193
<   if (*get_a) p_area(a,X,kd,*n,*d);
---
> 	if (*get_a)
> 		p_area(a, X, kd, *n, *d);
1033c1199,1201
<   for (d0=0.0,p=dist,p1=dist+ *n * d2k;p<p1;p++) d0 += *p;d0 /= *n * d2k;
---
> 	for (d0 = 0.0, p = dist, p1 = dist + *n * d2k; p < p1; p++)
> 		d0 += *p;
> 	d0 /= *n * d2k;
1048c1216,1217
<     if (db[j]==0.0) db[j]=1.0;
---
> 		if (db[j] == 0.0)
> 			db[j] = 1.0;
1053c1222
<       Rprintf("hello\n");
---
> 			Rprintf(_("hello\n"));
1062c1231,1233
<        	x[j] = (kd.box[bi].hi[j] + kd.huge && kd.box[bi].lo[j])*0.5; else
---
> 					x[j] = (kd.box[bi].hi[j] + kd.huge && kd.box[bi].lo[j])
> 							* 0.5;
> 				else
1066c1237,1238
<      for (j=0;j<*d;j++) x[j] = X[i + j * *n];
---
> 			for (j = 0; j < *d; j++)
> 				x[j] = X[i + j * *n];
1076,1077c1248,1251
<           else dx = db[j]*1e-6;
<           if (dx <=0) dx = db[j]*1e-6;
---
> 					else
> 						dx = db[j] * 1e-6;
> 					if (dx <= 0)
> 						dx = db[j] * 1e-6;
1081c1255,1256
<           if (x[j] <= kd.box[bi].hi[j]) x[j] = kd.box[bi].hi[j] + d0;
---
> 					if (x[j] <= kd.box[bi].hi[j])
> 						x[j] = kd.box[bi].hi[j] + d0;
1085c1260,1261
<           Rprintf("%d upper neighbour claimed to be self d=%d!\n",i,j);
---
> 					Rprintf(_("%d upper neighbour claimed to be self d=%d!\n"),
> 							i, j);
1087c1263,1264
<             Rprintf("%g  %g  %g\n",kd.box[bi].lo[q],x[q],kd.box[bi].hi[q]);
---
> 						Rprintf("%g  %g  %g\n", kd.box[bi].lo[q], x[q],
> 								kd.box[bi].hi[q]);
1098c1275,1278
<           if (d2<d1) { d1=d2;n1=n2;}
---
> 					if (d2 < d1) {
> 						d1 = d2;
> 						n1 = n2;
> 					}
1109c1289,1290
<           if (dist[ii] > maxnd) maxnd = dist[ii];
---
> 					if (dist[ii] > maxnd)
> 						maxnd = dist[ii];
1124c1305,1306
<             max_dist = dist[ii];max_i=ii;
---
> 						max_dist = dist[ii];
> 						max_i = ii;
1138,1139c1320,1323
<           else dx = db[j]*1e-6;
<           if (dx <=0) dx = db[j]*1e-6;
---
> 					else
> 						dx = db[j] * 1e-6;
> 					if (dx <= 0)
> 						dx = db[j] * 1e-6;
1144c1328,1329
<           if (x[j] >= kd.box[bi].lo[j]) x[j] = kd.box[bi].lo[j] - d0;
---
> 					if (x[j] >= kd.box[bi].lo[j])
> 						x[j] = kd.box[bi].lo[j] - d0;
1148c1333
<           Rprintf("lower neighbour claimed to be self!\n");
---
> 					Rprintf(_("lower neighbour claimed to be self!\n"));
1159c1344,1347
<           if (d2<d1) { d1=d2;n1=n2;}
---
> 					if (d2 < d1) {
> 						d1 = d2;
> 						n1 = n2;
> 					}
1170c1358,1359
<           if (dist[ii]>maxnd) maxnd = dist[ii];
---
> 					if (dist[ii] > maxnd)
> 						maxnd = dist[ii];
1181c1370,1371
<             max_dist = dist[ii];max_i=ii;
---
> 						max_dist = dist[ii];
> 						max_i = ii;
1194c1384,1385
<        if (ni[ii]<0) ni[ii] = -ni[ii] - 1; 
---
> 			if (ni[ii] < 0)
> 				ni[ii] = -ni[ii] - 1;
1197c1388,1391
<   FREE(x); free_kdtree(kd);FREE(db);FREE(count);
---
> 	FREE(x);
> 	free_kdtree(kd);
> 	FREE(db);
> 	FREE(count);
1212,1213c1405,1408
<   for (p=off,p1=off + *n;p<p1;p++) *p = 0;
<   for (p=t,p1=t + *nt * (*d+1);p<p1;p++) off[*p] += *d; /* at most *d neighbours */ 
---
> 	for (p = off, p1 = off + *n; p < p1; p++)
> 		*p = 0;
> 	for (p = t, p1 = t + *nt * (*d + 1); p < p1; p++)
> 		off[*p] += *d; /* at most *d neighbours */
1215c1410,1411
<   for (i=1;i< *n ;i++) off[i] += off[i-1]; 
---
> 	for (i = 1; i < *n; i++)
> 		off[i] += off[i - 1];
1218c1414,1415
<   for (p=nn,p1 = nn + off[*n-1];p<p1;p++) *p = -1; /* -1 codes unused space */
---
> 	for (p = nn, p1 = nn + off[*n - 1]; p < p1; p++)
> 		*p = -1; /* -1 codes unused space */
1223c1420,1423
<       if (ii==0) k0=0; else k0=off[ii-1];
---
> 			if (ii == 0)
> 				k0 = 0;
> 			else
> 				k0 = off[ii - 1];
1227c1427,1428
<       for (l=0;l<*d+1;l++) if (l!=j) {
---
> 			for (l = 0; l < *d + 1; l++)
> 				if (l != j) {
1230,1231c1431,1436
<           if (nn[k]<0) { nn[k] = jj;break;} /* added to list */
<           if (nn[k]==jj) break; /* already listed */
---
> 						if (nn[k] < 0) {
> 							nn[k] = jj;
> 							break;
> 						} /* added to list */
> 						if (nn[k] == jj)
> 							break; /* already listed */
1242,1243c1447,1450
<       if (nn[k]<0) break;
<       t[j] = nn[k];j++;
---
> 			if (nn[k] < 0)
> 				break;
> 			t[j] = nn[k];
> 			j++;
1286c1493,1494
< 	ni[k] = ni[i];k++;
---
> 				ni[k] = ni[i];
> 				k++;
1295,1296c1503,1504
< void nei_penalty(double *X,int *n,int *d,double *D,int *ni,int *ii,int *off,
<                                   int *m,int *a_weight,double *kappa) {
---
> void nei_penalty(double *X, int *n, int *d, double *D, int *ni, int *ii,
> 		int *off, int *m, int *a_weight, double *kappa) {
1333c1541,1542
<     if (i1-i0>max_nn) max_nn = i1-i0; /* maximum number of neighbours */
---
> 		if (i1 - i0 > max_nn)
> 			max_nn = i1 - i0; /* maximum number of neighbours */
1337c1546,1547
<   if (max_nn<6) max_nn=6;
---
> 	if (max_nn < 6)
> 		max_nn = 6;
1352c1562,1563
<       for (i=0;i<6*kk;i++) M[i]=0.0;
---
> 			for (i = 0; i < 6 * kk; i++)
> 				M[i] = 0.0;
1356c1567,1569
<     M[0] = 1.0;for (i=1;i<6;i++) M[i*kk] = 0.0; /* self row */
---
> 		M[0] = 1.0;
> 		for (i = 1; i < 6; i++)
> 			M[i * kk] = 0.0; /* self row */
1378c1591,1593
<     jj = k; if (jj>6) jj=6;
---
> 		jj = k;
> 		if (jj > 6)
> 			jj = 6;
1381c1596,1600
<     for (i=0;i<jj;i++) if (sv[i]>sv[0]*1e-10) sv[i] = 1/sv[i]; else sv[i]=0.0; 
---
> 		for (i = 0; i < jj; i++)
> 			if (sv[i] > sv[0] * 1e-10)
> 				sv[i] = 1 / sv[i];
> 			else
> 				sv[i] = 0.0;
1385,1386c1604,1611
<       for (i=0;i<6;i++) for (l=0;l<kk;l++)  if (l < k) { M[jj] = M[l + kk * i];jj++;}
<       for (i=k;i<kk;i++) sv[i] = 0.0; /* set machine zeroes to zero */
---
> 			for (i = 0; i < 6; i++)
> 				for (l = 0; l < kk; l++)
> 					if (l < k) {
> 						M[jj] = M[l + kk * i];
> 						jj++;
> 					}
> 			for (i = k; i < kk; i++)
> 				sv[i] = 0.0; /* set machine zeroes to zero */
1392c1617,1618
<       for (l=0;l<k;l++) M[l+i*k] *= x;
---
> 			for (l = 0; l < k; l++)
> 				M[l + i * k] *= x;
1415c1640,1641
<       for (l=0;l<3;l++) D[di + doff * l + *n] = Mi[3 + l + 6 * i];
---
> 			for (l = 0; l < 3; l++)
> 				D[di + doff * l + *n] = Mi[3 + l + 6 * i];
1448,1450c1671,1675
<   if (a==0.0) { *c=1.0;*s=0.0;} else
<   if (fabs(a)<=fabs(b))
<   { t=a/b;
---
> 	if (a == 0.0) {
> 		*c = 1.0;
> 		*s = 0.0;
> 	} else if (fabs(a) <= fabs(b)) {
> 		t = a / b;
1453,1454c1678,1679
<   } else
<   { t=b/a;
---
> 	} else {
> 		t = b / a;
1468,1470c1693,1698
<   for (i=0;i< *n-1;i++) h[i]=x[i+1]-x[i];
<   for (i=0;i< *n-2;i++) hh[i]=2.0*(h[i]+h[i+1])/3.0;
<   for (i=0;i< *n-3;i++) hh1[i]=h[i+1]/3.0;
---
> 	for (i = 0; i < *n - 1; i++)
> 		h[i] = x[i + 1] - x[i];
> 	for (i = 0; i < *n - 2; i++)
> 		hh[i] = 2.0 * (h[i] + h[i + 1]) / 3.0;
> 	for (i = 0; i < *n - 3; i++)
> 		hh1[i] = h[i + 1] / 3.0;
1475,1476c1703,1704
<   for (i=1;i< *n-3;i++)
<   { lb[i]= sqrt(hh[i]-lb1[i-1]*lb1[i-1]);
---
> 	for (i = 1; i < *n - 3; i++) {
> 		lb[i] = sqrt(hh[i] - lb1[i - 1] * lb1[i - 1]);
1480,1482c1708,1711
<   ub1 = ub + *n;ub2 = ub1 + *n; 
<   for (i=0;i< *n-2;i++)
<   { ub[i] = w[i]/h[i];
---
> 	ub1 = ub + *n;
> 	ub2 = ub1 + *n;
> 	for (i = 0; i < *n - 2; i++) {
> 		ub[i] = w[i] / h[i];
1486c1715,1717
<   FREE(h);FREE(hh);FREE(hh1);
---
> 	FREE(h);
> 	FREE(hh);
> 	FREE(hh1);
1516,1517c1745,1746
<     *V0s,*V0c,*V1s,*V1c,upper,w2=0.0,
<     L11=0.0,L12=0.0,L13,L21,L22,L23,L31,L32,L33,X1,X2,X3,Lt,temp;
---
> 			*V0s, *V0c, *V1s, *V1c, upper, w2 = 0.0, L11 = 0.0, L12 = 0.0, L13,
> 			L21, L22, L23, L31, L32, L33, X1, X2, X3, Lt, temp;
1520,1522c1749,1755
<   k=0;ok=1;
<   for (i=1;i<*n;i++) if (x[k] + *tol < x[i]) { 
<      if (!ok) { w[k] = sqrt(w2);}
---
> 	k = 0;
> 	ok = 1;
> 	for (i = 1; i < *n; i++)
> 		if (x[k] + *tol < x[i]) {
> 			if (!ok) {
> 				w[k] = sqrt(w2);
> 			}
1525c1758,1759
<      w[k] = w[i];ok=1;
---
> 			w[k] = w[i];
> 			ok = 1;
1527c1761,1763
<      if (ok) { w2 = w[k]*w[k];}
---
> 			if (ok) {
> 				w2 = w[k] * w[k];
> 			}
1531c1767,1769
<   if (!ok) { w[k] = sqrt(w2);} 
---
> 	if (!ok) {
> 		w[k] = sqrt(w2);
> 	}
1534c1772,1773
<   for (i=0;i<*n;i++) w[i] = 1/w[i];  /* convert to H and de H convention */
---
> 	for (i = 0; i < *n; i++)
> 		w[i] = 1 / w[i]; /* convert to H and de H convention */
1540c1779,1780
<   for (p = ub,p1 = ub + *n * 3;p < p1;p++) *p *= rho;
---
> 	for (p = ub, p1 = ub + *n * 3; p < p1; p++)
> 		*p *= rho;
1542c1782,1783
<   ub1 = ub + *n;ub2 = ub1 + *n;
---
> 	ub1 = ub + *n;
> 	ub2 = ub1 + *n;
1544,1549c1785,1794
<   U0s = U;U0c = U + *n;
<   U1s = U + *n * 2;U1c = U + *n *3;
<   V0s = V;V0c = V + *n;
<   V1s = V + *n * 2;V1c = V + *n *3;
<   for (i=0;i<*n-3;i++)
<   { givens(ub[i+1],lb1[i],&c,&s);
---
> 	U0s = U;
> 	U0c = U + *n;
> 	U1s = U + *n * 2;
> 	U1c = U + *n * 3;
> 	V0s = V;
> 	V0c = V + *n;
> 	V1s = V + *n * 2;
> 	V1c = V + *n * 3;
> 	for (i = 0; i < *n - 3; i++) {
> 		givens(ub[i + 1], lb1[i], &c, &s);
1554c1799,1800
<     U1s[i] = -s; U1c[i] = c; 
---
> 		U1s[i] = -s;
> 		U1c[i] = c;
1558c1804,1805
<     U0s[i] = -s; U0c[i] = c; 
---
> 		U0s[i] = -s;
> 		U0c[i] = c;
1564c1811,1812
<     V0s[i] = -s;V0c[i] = c;
---
> 		V0s[i] = -s;
> 		V0c[i] = c;
1568,1569c1816,1819
<     if (i!=(*n-4)) ub[i+2]=c*ub[i+2];
<     V1s[i] = -s; V1c[i] = c;
---
> 		if (i != (*n - 4))
> 			ub[i + 2] = c * ub[i + 2];
> 		V1s[i] = -s;
> 		V1c[i] = c;
1575c1825,1826
<   U0s[i] = -s; U0c[i] = c; 
---
> 	U0s[i] = -s;
> 	U0c[i] = c;
1579c1830,1831
<   V0s[i] = -s;V0c[i] = c;
---
> 	V0s[i] = -s;
> 	V0c[i] = c;
1583c1835,1836
<   V1s[i] = -s; V1c[i] = c;
---
> 	V1s[i] = -s;
> 	V1c[i] = c;
1587,1593c1840,1852
<   V0c += *n-3;V0s += *n-3;
<   V1c += *n-3;V1s += *n-3;
<   U0c += *n-3;U0s += *n-3;
<   U1c += *n-3;U1s += *n-3;
< 
<   L31 = *V1c;L33 = - *V1s;
<   L32 = -L31 * *V0s;L31 = L31 * *V0c;
---
> 	V0c += *n - 3;
> 	V0s += *n - 3;
> 	V1c += *n - 3;
> 	V1s += *n - 3;
> 	U0c += *n - 3;
> 	U0s += *n - 3;
> 	U1c += *n - 3;
> 	U1s += *n - 3;
> 
> 	L31 = *V1c;
> 	L33 = -*V1s;
> 	L32 = -L31 * *V0s;
> 	L31 = L31 * *V0c;
1600c1859,1860
<   L33 = L32;L32=L31;
---
> 	L33 = L32;
> 	L32 = L31;
1602c1862,1869
<   V0c--;V0s--;V1c--;V1s--;U0c--;U0s--;U1c--;U1s--;
---
> 	V0c--;
> 	V0s--;
> 	V1c--;
> 	V1s--;
> 	U0c--;
> 	U0s--;
> 	U1c--;
> 	U1s--;
1604c1871,1872
<   L21 = *V1c;L23 = - *V1s;
---
> 	L21 = *V1c;
> 	L23 = -*V1s;
1613,1614c1881,1884
<   X2 = -L21 * *U0s;L21 = L21 * *U0c;
<   X3 = -L31 * *U0s;L31 = L31 * *U0c;
---
> 	X2 = -L21 * *U0s;
> 	L21 = L21 * *U0c;
> 	X3 = -L31 * *U0s;
> 	L31 = L31 * *U0c;
1623,1632c1893,1915
<   L32=L32*c-L22*s;L22=Lt;
<   L33=L32;L23=L22;L22=L21;
< 
<  
<   for (i = *n-5;i>=0;i--)
<   { V0c--;V0s--;V1c--;V1s--;U0c--;U0s--;U1c--;U1s--;
<     L13 = - *V1s;L11 = *V1c;
<     L21 = L23 * *V1s;L23 *=  *V1c;
<     L31 = L33 * *V1s;L33 *=  *V1c;
<     givens(L11,L31,&c,&s);s = -s; /** Rotation to remove upper
---
> 	L32 = L32 * c - L22 * s;
> 	L22 = Lt;
> 	L33 = L32;
> 	L23 = L22;
> 	L22 = L21;
> 
> 	for (i = *n - 5; i >= 0; i--) {
> 		V0c--;
> 		V0s--;
> 		V1c--;
> 		V1s--;
> 		U0c--;
> 		U0s--;
> 		U1c--;
> 		U1s--;
> 		L13 = -*V1s;
> 		L11 = *V1c;
> 		L21 = L23 * *V1s;
> 		L23 *= *V1c;
> 		L31 = L33 * *V1s;
> 		L33 *= *V1c;
> 		givens(L11, L31, &c, &s);
> 		s = -s; /** Rotation to remove upper
1653c1936,1937
<     L22 = L22*c-L12*s;L12=Lt;
---
> 		L22 = L22 * c - L12 * s;
> 		L12 = Lt;
1656,1657c1940,1943
<     if (i!=0)
<     { L33=L22;L23=L12;L22=L11;
---
> 		if (i != 0) {
> 			L33 = L22;
> 			L23 = L12;
> 			L22 = L11;
1662c1948,1949
<   for (i=0;i<*n;i++) diagA[i] = 1.0 - diagA[i];
---
> 	for (i = 0; i < *n; i++)
> 		diagA[i] = 1.0 - diagA[i];
1666,1667c1953,1954
< 
< void sspl_apply(double *y,double *x,double *w,double *U,double *V,int *n,int *nf,double *tol) {
---
> void sspl_apply(double *y, double *x, double *w, double *U, double *V, int *n,
> 		int *nf, double *tol) {
1677,1678c1964,1965
<   double *Wy,*U0s,*U0c,*U1s,*U1c,
<     *V0s,*V0c,*V1s,*V1c,*p,*p1,*p2,w2,*xx;
---
> 	double *Wy, *U0s, *U0c, *U1s, *U1c, *V0s, *V0c, *V1s, *V1c, *p, *p1, *p2,
> 			w2, *xx;
1681,1684c1968,1977
<    for (p=x,p1=x + *nf,p2=xx;p<p1;p++,p2++) *p2 = *p;
<    k=0;ok=1;
<    for (i=1;i<*nf;i++) if (xx[k] + *tol < xx[i]) { 
<      if (!ok) { w[k] = sqrt(w2);y[k] /= w2;}
---
> 		for (p = x, p1 = x + *nf, p2 = xx; p < p1; p++, p2++)
> 			*p2 = *p;
> 		k = 0;
> 		ok = 1;
> 		for (i = 1; i < *nf; i++)
> 			if (xx[k] + *tol < xx[i]) {
> 				if (!ok) {
> 					w[k] = sqrt(w2);
> 					y[k] /= w2;
> 				}
1686,1687c1979,1982
<      xx[k] = xx[i];y[k] = y[i];
<      w[k] = w[i];ok=1;
---
> 				xx[k] = xx[i];
> 				y[k] = y[i];
> 				w[k] = w[i];
> 				ok = 1;
1689c1984,1987
<      if (ok) { w2 = w[k]*w[k];y[k] *= w[k]*w[k];}
---
> 				if (ok) {
> 					w2 = w[k] * w[k];
> 					y[k] *= w[k] * w[k];
> 				}
1694c1992,1995
<    if (!ok) { w[k] = sqrt(w2);y[k]/=w2;}
---
> 		if (!ok) {
> 			w[k] = sqrt(w2);
> 			y[k] /= w2;
> 		}
1698c1999,2000
<   for (i=0;i<*n;i++) w[i] = 1/w[i];  /* convert to H and de H convention */
---
> 	for (i = 0; i < *n; i++)
> 		w[i] = 1 / w[i]; /* convert to H and de H convention */
1703c2005,2006
<   for (i=0;i < *n;i++) Wy[i] = y[i]/w[i];
---
> 	for (i = 0; i < *n; i++)
> 		Wy[i] = y[i] / w[i];
1705,1710c2008,2017
<   U0s = U;U0c = U + *n;
<   U1s = U + *n * 2;U1c = U + *n *3;
<   V0s = V;V0c = V + *n;
<   V1s = V + *n * 2;V1c = V + *n *3;
<   for (i=0;i<*n-3;i++)
<   { QTz(i+1,*n+i,U1c[i],-U1s[i],Wy);
---
> 	U0s = U;
> 	U0c = U + *n;
> 	U1s = U + *n * 2;
> 	U1c = U + *n * 3;
> 	V0s = V;
> 	V0c = V + *n;
> 	V1s = V + *n * 2;
> 	V1c = V + *n * 3;
> 	for (i = 0; i < *n - 3; i++) {
> 		QTz(i + 1, *n + i, U1c[i], -U1s[i], Wy);
1727c2034,2035
<   for (i = *n-2;i<2 * *n ;i++) Wy[i]=0.0;
---
> 	for (i = *n - 2; i < 2 * *n; i++)
> 		Wy[i] = 0.0;
1729,1730c2037,2038
<   for (i= *n-3;i>=0;i--)
<   { QTz(i,i+2,V1c[i],V1s[i],Wy);
---
> 	for (i = *n - 3; i >= 0; i--) {
> 		QTz(i, i + 2, V1c[i], V1s[i], Wy);
1733c2041,2042
<     if (i != *n-3) QTz(i+1,*n+i,U1c[i],U1s[i],Wy);
---
> 		if (i != *n - 3)
> 			QTz(i + 1, *n + i, U1c[i], U1s[i], Wy);
1737c2046,2047
<   for (i=0;i<*n;i++) Wy[i] = y[i] - Wy[i]*w[i];
---
> 	for (i = 0; i < *n; i++)
> 		Wy[i] = y[i] - Wy[i] * w[i];
1740c2050,2051
<    k=0;ok=1;
---
> 		k = 0;
> 		ok = 1;
1742,1743c2053,2057
<    for (i=1;i<*nf;i++) if (x[k] + *tol < x[i]) { /* distinct */
<      k++;x[k] = x[i]; y[i] = Wy[k];
---
> 		for (i = 1; i < *nf; i++)
> 			if (x[k] + *tol < x[i]) { /* distinct */
> 				k++;
> 				x[k] = x[i];
> 				y[i] = Wy[k];
1748c2062,2063
<     for (i=0;i<*n;i++) y[i] = Wy[i];
---
> 		for (i = 0; i < *n; i++)
> 			y[i] = Wy[i];
1753c2068,2069
< void sspl_mapply(double *y,double *x,double *w,double *U,double *V,int *n,int *nf,double *tol,int *m) {
---
> void sspl_mapply(double *y, double *x, double *w, double *U, double *V, int *n,
> 		int *nf, double *tol, int *m) {
1757c2073,2074
<   if (*m > 1 && *nf != *n) xw_store=1;
---
> 	if (*m > 1 && *nf != *n)
> 		xw_store = 1;
1761,1762c2078,2081
<     for (p=xx,p1=xx + *nf,p2=x;p<p1;p++,p2++) *p = *p2;
<     for (p=ww,p1=ww + *nf,p2=w;p<p1;p++,p2++) *p = *p2;
---
> 		for (p = xx, p1 = xx + *nf, p2 = x; p < p1; p++, p2++)
> 			*p = *p2;
> 		for (p = ww, p1 = ww + *nf, p2 = w; p < p1; p++, p2++)
> 			*p = *p2;
1766,1767c2085,2088
<       for (p=xx,p1=xx + *nf,p2=x;p<p1;p++,p2++) *p2 = *p;
<       for (p=ww,p1=ww + *nf,p2=w;p<p1;p++,p2++) *p2 = *p;
---
> 			for (p = xx, p1 = xx + *nf, p2 = x; p < p1; p++, p2++)
> 				*p2 = *p;
> 			for (p = ww, p1 = ww + *nf, p2 = w; p < p1; p++, p2++)
> 				*p2 = *p;
1772c2093,2096
<   if (xw_store) {FREE(xx);FREE(ww);}
---
> 	if (xw_store) {
> 		FREE(xx);
> 		FREE(ww);
> 	}
1775c2099,2100
< void ss_coeffs(double *lb,double *a,double *b,double *c,double *d,double *x, int *n) { 
---
> void ss_coeffs(double *lb, double *a, double *b, double *c, double *d,
> 		double *x, int *n) {
1788c2113,2114
<   for (i=0;i<*n-1;i++) h[i]=x[i+1]-x[i];
---
> 	for (i = 0; i < *n - 1; i++)
> 		h[i] = x[i + 1] - x[i];
1790c2116,2117
<   GTA[i]=a[i]/h[i]-a[i+1]*(1/h[i]+1/h[i+1])+a[i+2]/h[i+1];
---
> 		GTA[i] = a[i] / h[i] - a[i + 1] * (1 / h[i] + 1 / h[i + 1])
> 				+ a[i + 2] / h[i + 1];
1793,1794c2120,2124
<   for (i=1;i<*n-2;i++) z[i]=(GTA[i]-lb1[i-1]*z[i-1])/lb[i];
<   c[*n-2]=z[*n-3]/lb[*n-3];c[*n-1]=0.0;c[0]=0.0;
---
> 	for (i = 1; i < *n - 2; i++)
> 		z[i] = (GTA[i] - lb1[i - 1] * z[i - 1]) / lb[i];
> 	c[*n - 2] = z[*n - 3] / lb[*n - 3];
> 	c[*n - 1] = 0.0;
> 	c[0] = 0.0;
1798,1799c2128,2129
<   for (i=0;i<*n-1;i++)
<   { d[i]=(c[i+1]-c[i])/(3*h[i]);
---
> 	for (i = 0; i < *n - 1; i++) {
> 		d[i] = (c[i + 1] - c[i]) / (3 * h[i]);
1802c2132,2134
<   FREE(GTA);FREE(z);FREE(h);
---
> 	FREE(GTA);
> 	FREE(z);
> 	FREE(h);
diff -rEZbwB '--exclude=*.[lo,d,pdf,mo,po,tgz,gz,save]*' '--exclude=MD5' '--exclude=Makefile*' '--exclude=all.R' '--exclude=Changes' R-recommended/mgcv/src/tprs.c Recommended/mgcv/src/tprs.c
25a26
> #include "localization.h"
39,40c38,41
<   d2 = d/2;m2 = 2*m;
<   if (m2 <= d) error(_("You must have 2m>d for a thin plate spline."));
---
> 	d2 = d / 2;
> 	m2 = 2 * m;
> 	if (m2 <= d)
> 		error(_("You must have 2m>d for a thin plate spline."));
42,46c43,55
<   { if ((m+1+d2)%2) f= -1.0; else f=1.0; /* finding (-1)^{m+1+d/2} */
<     for (i=0;i<m2-1;i++) f/=2;  /* dividing by 2^{2m-1} */
<     for (i=0;i<d2;i++) f/=pi;  /* dividing by pi^{d/2} */
<     for (i=2;i<m;i++) f/=i; /* dividing by (m-1)! */
<     for (i=2;i<=m-d2;i++) f/=i; /* dividing by (m-d/2)! */
---
> 	{
> 		if ((m + 1 + d2) % 2)
> 			f = -1.0;
> 		else
> 			f = 1.0; /* finding (-1)^{m+1+d/2} */
> 		for (i = 0; i < m2 - 1; i++)
> 			f /= 2; /* dividing by 2^{2m-1} */
> 		for (i = 0; i < d2; i++)
> 			f /= pi; /* dividing by pi^{d/2} */
> 		for (i = 2; i < m; i++)
> 			f /= i; /* dividing by (m-1)! */
> 		for (i = 2; i <= m - d2; i++)
> 			f /= i; /* dividing by (m-d/2)! */
48c57,58
<   { f=Ghalf;
---
> 	{
> 		f = Ghalf;
50,52c60,65
<     for (i=0;i<k;i++) f/= -0.5-i; /* f = gamma function of d/2-m */
<     for (i=0;i<m;i++) f/= 4; /* divide by 2^{2m} */
<     for (i=0;i<d2;i++) f/=pi;
---
> 		for (i = 0; i < k; i++)
> 			f /= -0.5 - i; /* f = gamma function of d/2-m */
> 		for (i = 0; i < m; i++)
> 			f /= 4; /* divide by 2^{2m} */
> 		for (i = 0; i < d2; i++)
> 			f /= pi;
54c67,68
<     for (i=2;i<m;i++) f/=i;  /* divide by (m-1)! */
---
> 		for (i = 2; i < m; i++)
> 			f /= i; /* divide by (m-1)! */
63c77,78
<   if (r<=0.0) return(0.0); /* this is safe: even if eta() gets inlined so that r comes in in an fp register! */
---
> 	if (r <= 0.0)
> 		return (0.0); /* this is safe: even if eta() gets inlined so that r comes in in an fp register! */
66c81,82
<     for (i=0;i<m-d2;i++) f *= r; /* r^2m-d (noting r is really r^2) */
---
> 		for (i = 0; i < m - d2; i++)
> 			f *= r; /* r^2m-d (noting r is really r^2) */
68c84,85
<     for (i=0;i<m-d2-1 ;i++) f *= r; /* note r really r^2 */
---
> 		for (i = 0; i < m - d2 - 1; i++)
> 			f *= r; /* note r really r^2 */
79c96,97
< { int i,j,k,Xr,Xc;
---
> {
> 	int i, j, k, Xr, Xc;
84,86c102,107
<   XMi = X->M;Xr = X->r;Xc = X->c;
<   for (i=0;i<Xr;i++,XMi++) for (XMj = X->M,j=0;j<i;j++,XMj++)
<   { r=0.0;
---
> 	XMi = X->M;
> 	Xr = X->r;
> 	Xc = X->c;
> 	for (i = 0; i < Xr; i++, XMi++)
> 		for (XMj = X->M, j = 0; j < i; j++, XMj++) {
> 			r = 0.0;
107c127,128
< { int *index,i,j,sum;
---
> {
> 	int *index, i, j, sum;
109,110c130
<   for (i=0;i < *M;i++)
<   { /* copy index to pi */
---
> 	for (i = 0; i < *M; i++) { /* copy index to pi */
112c132,133
<     for (j=0;j< *d;j++) pi[i + *M * j]=index[j];
---
> 		for (j = 0; j < *d; j++)
> 			pi[i + *M * j] = index[j];
114c135,137
<     sum=0;for (j=0;j< *d;j++) sum += index[j];
---
> 		sum = 0;
> 		for (j = 0; j < *d; j++)
> 			sum += index[j];
118c141,142
<     { sum -= index[0];
---
> 		{
> 			sum -= index[0];
120,123c144,151
<       for (j=1;j< *d;j++)
<       { index[j]++;sum++;
<         if (sum== *m) { sum-=index[j];index[j]=0;}
<         else break; /* problem resolved! */
---
> 			for (j = 1; j < *d; j++) {
> 				index[j]++;
> 				sum++;
> 				if (sum == *m) {
> 					sum -= index[j];
> 					index[j] = 0;
> 				} else
> 					break; /* problem resolved! */
138c165,166
< { int M,i,j,k,*pin,z;
---
> {
> 	int M, i, j, k, *pin, z;
141,142c169,172
<   for (i=0;i<d;i++) M*=d+m-1-i;
<   for (i=2;i<=d;i++) M/=i;     /* M = (m+d+1)!/(d!(m-d!) */
---
> 	for (i = 0; i < d; i++)
> 		M *= d + m - 1 - i;
> 	for (i = 2; i <= d; i++)
> 		M /= i; /* M = (m+d+1)!/(d!(m-d!) */
152,154c182,186
<   for (j=0;j<M;j++)
<   { x=1.0;/* for (k=0;k<d;k++) for (z=0;z<pin[j][k];z++) x *= X->M[i][k]; */
<     for (k=0;k<d;k++) for (z=0;z<pin[j + M * k];z++) x *= X->M[i][k];
---
> 		for (j = 0; j < M; j++) {
> 			x = 1.0;/* for (k=0;k<d;k++) for (z=0;z<pin[j][k];z++) x *= X->M[i][k]; */
> 			for (k = 0; k < d; k++)
> 				for (z = 0; z < pin[j + M * k]; z++)
> 					x *= X->M[i][k];
169,170c200,206
< { int M,i;
<   if (2*m<=d) {m=1;while (2*m<d+2) m++;} 
---
> {
> 	int M, i;
> 	if (2 * m <= d) {
> 		m = 1;
> 		while (2 * m < d + 2)
> 			m++;
> 	}
172,173c208,211
<   for (i=0;i<d;i++) M*=d+m-1-i;/* get (m+d-1)!/(m-1)! = (m+d-1)*(m+d-2) ... *(m) -- d terms */ 
<   for (i=2;i<=d;i++) M/=i;     /* M = (m+d-1)!/(d!(m-1)!) */
---
> 	for (i = 0; i < d; i++)
> 		M *= d + m - 1 - i;/* get (m+d-1)!/(m-1)! = (m+d-1)*(m+d-2) ... *(m) -- d terms */
> 	for (i = 2; i <= d; i++)
> 		M /= i; /* M = (m+d-1)!/(d!(m-1)!) */
177,178c215,216
< 
< double tps_g(matrix *X,matrix *p,double *x,int d,int m,double *b,int constant)
---
> double tps_g(matrix *X, matrix *p, double *x, int d, int m, double *b,
> 		int constant)
200c238,239
< { static int sd=0,sm=0,*pin,M;
---
> {
> 	static int sd = 0, sm = 0, *pin, M;
204,205c243,249
<   if (sd==0&&d==0) return(0.0); /* There is nothing to clear up and nothing to calculate */
<   if (2*m<=d&&d>0) { m=0;while (2*m<d+2) m++;} 
---
> 	if (sd == 0 && d == 0)
> 		return (0.0); /* There is nothing to clear up and nothing to calculate */
> 	if (2 * m <= d && d > 0) {
> 		m = 0;
> 		while (2 * m < d + 2)
> 			m++;
> 	}
207,209c251,256
<   { if (sd>0&&sm>0) 
<     { /*for (i=0;i<M;i++) FREE(pin[i]);*/ FREE(pin);}
<     sd=d;sm=m;
---
> 	{
> 		if (sd > 0 && sm > 0) { /*for (i=0;i<M;i++) FREE(pin[i]);*/
> 			FREE(pin);
> 		}
> 		sd = d;
> 		sm = m;
211,213c258,263
<     { M=1;     /* dimension of penalty null space */
<       for (i=0;i<d;i++) M*=d+m-1-i;
<       for (i=2;i<=d;i++) M/=i;     /* M = (m+d+1)!/(d!(m-d!) */
---
> 		{
> 			M = 1; /* dimension of penalty null space */
> 			for (i = 0; i < d; i++)
> 				M *= d + m - 1 - i;
> 			for (i = 2; i <= d; i++)
> 				M /= i; /* M = (m+d+1)!/(d!(m-d!) */
219c269,270
<     } else return(0.0);
---
> 		} else
> 			return (0.0);
221,224c272,282
<   g=0.0;XM=X->M;n = X->r;
<   for (pb=b,i=0;i<n;i++,pb++)
<   { r=0.0;XMi=XM[i];
<     for (dum=x;dum<x+d;dum++) { z= *XMi - *dum;XMi++;r+=z*z;}
---
> 	g = 0.0;
> 	XM = X->M;
> 	n = X->r;
> 	for (pb = b, i = 0; i < n; i++, pb++) {
> 		r = 0.0;
> 		XMi = XM[i];
> 		for (dum = x; dum < x + d; dum++) {
> 			z = *XMi - *dum;
> 			XMi++;
> 			r += z * z;
> 		}
227c285,286
<     if (p->r) g += *pb *p->V[i];
---
> 		if (p->r)
> 			g += *pb * p->V[i];
231c290,291
<   { r=1.0;
---
> 	{
> 		r = 1.0;
234c294,296
<     for (j=0;j<d;j++) for (k=0;k<pin[i+M*j];k++)  r*=x[j];
---
> 		for (j = 0; j < d; j++)
> 			for (k = 0; k < pin[i + M * j]; k++)
> 				r *= x[j];
236c298,299
<     if (p->r) g+=p->V[i+n-off]*r;
---
> 		if (p->r)
> 			g += p->V[i + n - off] * r;
245,246c308,312
< { int i;
<   for (i=0;i<k;i++) if (a[i]!=b[i]) return(0);
---
> {
> 	int i;
> 	for (i = 0; i < k; i++)
> 		if (a[i] != b[i])
> 			return (0);
267c333,334
< { int *yxindex,start,stop,ok,i;
---
> {
> 	int *yxindex, start, stop, ok, i;
272,276c339,343
<   start=stop=0;ok=1;
<   while(ok)
<   { /* look for start of run of equal rows ..... */
<     while(start<Xd->r-1&&!Xd_row_comp(Xd->M[start],Xd->M[start+1],Xd->c-1)) 
<     { /* Xd->M[start] not tied with anything, nothing to erase.... */
---
> 	start = stop = 0;
> 	ok = 1;
> 	while (ok) { /* look for start of run of equal rows ..... */
> 		while (start < Xd->r - 1
> 				&& !Xd_row_comp(Xd->M[start], Xd->M[start + 1], Xd->c - 1)) { /* Xd->M[start] not tied with anything, nothing to erase.... */
281,282c348,349
<     if (start==Xd->r-1) 
<     { ok=0; /* reached end with no more ties */
---
> 		if (start == Xd->r - 1) {
> 			ok = 0; /* reached end with no more ties */
287,288c354,358
<     { stop=start+1;
<       while(stop<Xd->r-1&&Xd_row_comp(Xd->M[stop],Xd->M[stop+1],Xd->c-1)) stop++;
---
> 		{
> 			stop = start + 1;
> 			while (stop < Xd->r - 1
> 					&& Xd_row_comp(Xd->M[stop], Xd->M[stop + 1], Xd->c - 1))
> 				stop++;
290c360,361
<       { xi=Xd->M[i][Xd->c-1];
---
> 			{
> 				xi = Xd->M[i][Xd->c - 1];
294,295c365,367
<       for (i=stop+1;i<Xd->r;i++)
<       { Xd->M[i-stop+start]=Xd->M[i];}
---
> 			for (i = stop + 1; i < Xd->r; i++) {
> 				Xd->M[i - stop + start] = Xd->M[i];
> 			}
297,298c369,371
<       for (i=1;i<=stop-start;i++)
<       { Xd->M[Xd->r-1+i]=dum[i];}
---
> 			for (i = 1; i <= stop - start; i++) {
> 				Xd->M[Xd->r - 1 + i] = dum[i];
> 			}
305,306c378,379
< void tprs_setup(double **x,double **knt,int m,int d,int n,int k,int constant,matrix *X,matrix *S,
<                 matrix *UZ,matrix *Xu,int n_knots)
---
> void tprs_setup(double **x, double **knt, int m, int d, int n, int k,
> 		int constant, matrix *X, matrix *S, matrix *UZ, matrix *Xu, int n_knots)
355c428,429
< { matrix X1,E,U,v,TU,T,Z,p;
---
> {
> 	matrix X1, E, U, v, TU, T, Z, p;
358c432,433
<   double w,*xc,*XMi,*Ea,*Ua,tol=DOUBLE_EPS,*b,*a,*uz,alpha=1.0,beta=0.0,*p0,*p1;
---
> 	double w, *xc, *XMi, *Ea, *Ua, tol = DOUBLE_EPS, *b, *a, *uz, alpha = 1.0,
> 			beta = 0.0, *p0, *p1;
362,363c437,443
<   { *Xu=initmat(n,d+1);
<     for (i=0;i<n;i++) { for (j=0;j<d;j++) Xu->M[i][j]=x[j][i];Xu->M[i][d]=(double)i;}
---
> 	{
> 		*Xu = initmat(n, d + 1);
> 		for (i = 0; i < n; i++) {
> 			for (j = 0; j < d; j++)
> 				Xu->M[i][j] = x[j][i];
> 			Xu->M[i][d] = (double) i;
> 		}
365,366c445,451
<   { *Xu=initmat(n_knots,d+1);
<     for (i=0;i<n_knots;i++) { for (j=0;j<d;j++) Xu->M[i][j]=knt[j][i];Xu->M[i][d]=(double)i;}
---
> 	{
> 		*Xu = initmat(n_knots, d + 1);
> 		for (i = 0; i < n_knots; i++) {
> 			for (j = 0; j < d; j++)
> 				Xu->M[i][j] = knt[j][i];
> 			Xu->M[i][d] = (double) i;
> 		}
375,376c459,466
<   error(_("A term has fewer unique covariate combinations than specified maximum degrees of freedom"));
<   if (2*m<=d) { m=0;while (2*m<d+2) m++;} 
---
> 		error(
> 				_(
> 						"A term has fewer unique covariate combinations than specified maximum degrees of freedom"));
> 	if (2 * m <= d) {
> 		m = 0;
> 		while (2 * m < d + 2)
> 			m++;
> 	}
382,383c472,477
<   {  k=M+1;
<      if (Xu->r<k) error(_("A term has fewer unique covariate combinations than specified maximum degrees of freedom"));
---
> 	{
> 		k = M + 1;
> 		if (Xu->r < k)
> 			error(
> 					_(
> 							"A term has fewer unique covariate combinations than specified maximum degrees of freedom"));
385c479,480
<   if (Xu->r==k) pure_knot=1; /* basis dimension is number of knots - don't need eigen step */
---
> 	if (Xu->r == k)
> 		pure_knot = 1; /* basis dimension is number of knots - don't need eigen step */
388c483,484
<   { *UZ=initmat(T.r+M-1+constant,T.r);
---
> 	{
> 		*UZ = initmat(T.r + M - 1 + constant, T.r);
391c487,489
<     for (i=0;i<T.r;i++) for (j=0;j<T.c;j++) TU.M[j][i]=T.M[i][j];
---
> 		for (i = 0; i < T.r; i++)
> 			for (j = 0; j < T.c; j++)
> 				TU.M[j][i] = T.M[i][j];
393c491,493
<     for (i=0;i<T.r;i++) for (j=0;j<T.c;j++) TU.M[j][i]=T.M[i][j];
---
> 		for (i = 0; i < T.r; i++)
> 			for (j = 0; j < T.c; j++)
> 				TU.M[j][i] = T.M[i][j];
396,398c496,497
<   } else
<   { v=initmat(k,1);    /* eigen-value matrix for E */
< 
---
> 	} else {
> 		v = initmat(k, 1); /* eigen-value matrix for E */
404c503,504
<       minus = -1;kk=k; 
---
> 		minus = -1;
> 		kk = k;
408,409c508,510
<       U = Rmatrix(Ua,E.r,k);FREE(Ea);FREE(Ua);
<     
---
> 		U = Rmatrix(Ua, E.r, k);
> 		FREE(Ea);
> 		FREE(Ua);
419c520,521
<     *UZ=initmat(U.r+M-1+constant,U.c);UZ->r=U.r;
---
> 		*UZ = initmat(U.r + M - 1 + constant, U.c);
> 		UZ->r = U.r;
421c523,524
<     HQmult(*UZ,Z,0,0);UZ->c -= M;      /* Now UZ multiplied by truncated delta gives full delta */
---
> 		HQmult(*UZ, Z, 0, 0);
> 		UZ->c -= M; /* Now UZ multiplied by truncated delta gives full delta */
426,427c529,533
<   for (i=0;i<E.r;i++) for (j=k-M;j<UZ->c;j++) UZ->M[i][j]=0.0;
<   for (i=0;i<M-1+constant;i++) UZ->M[UZ->r-i-1][UZ->c-i-1]=1.0;
---
> 	for (i = 0; i < E.r; i++)
> 		for (j = k - M; j < UZ->c; j++)
> 			UZ->M[i][j] = 0.0;
> 	for (i = 0; i < M - 1 + constant; i++)
> 		UZ->M[UZ->r - i - 1][UZ->c - i - 1] = 1.0;
431c537,538
<   { X1=initmat(U.r,k);
---
> 	{
> 		X1 = initmat(U.r, k);
433c540,542
<     for (i=0;i<X1.r;i++) for (j=0;j<X1.c;j++) X1.M[i][j]*=v.V[j];
---
> 		for (i = 0; i < X1.r; i++)
> 			for (j = 0; j < X1.c; j++)
> 				X1.M[i][j] *= v.V[j];
435c544,546
<     for (i=0;i<X1.r;i++) for (j=X1.c-M;j<X1.c;j++) X1.M[i][j]=0.0;
---
> 		for (i = 0; i < X1.r; i++)
> 			for (j = X1.c - M; j < X1.c; j++)
> 				X1.M[i][j] = 0.0;
438,440c549,557
<     for (i=0;i<X1.r;i++) for (j=0;j<T.c;j++) X1.M[i][X1.c-M+j]=T.M[i][j];
<     else 
<     { for (i=0;i<X1.r;i++) for (j=1;j<T.c;j++) X1.M[i][X1.c-M+j-1]=T.M[i][j];X1.c--;}
---
> 			for (i = 0; i < X1.r; i++)
> 				for (j = 0; j < T.c; j++)
> 					X1.M[i][X1.c - M + j] = T.M[i][j];
> 		else {
> 			for (i = 0; i < X1.r; i++)
> 				for (j = 1; j < T.c; j++)
> 					X1.M[i][X1.c - M + j - 1] = T.M[i][j];
> 			X1.c--;
> 		}
444,446c561,564
<     for (i=0;i<n;i++)
<     { l=yxindex[i];
<       for (j=0;j<X1.c;j++) X->M[i][j]=X1.M[l][j];
---
> 		for (i = 0; i < n; i++) {
> 			l = yxindex[i];
> 			for (j = 0; j < X1.c; j++)
> 				X->M[i][j] = X1.M[l][j];
450c568,569
<   { p.r=0; /* don't want a value from tps_g() */
---
> 	{
> 		p.r = 0; /* don't want a value from tps_g() */
461c580,581
<       for (j=0;j<d;j++) xc[j]=x[j][i];
---
> 			for (j = 0; j < d; j++)
> 				xc[j] = x[j][i];
466c586,587
<       F77_CALL(dgemv)(&trans,&kk,&k,&alpha,uz,&kk, b, &one,&beta, a, &one); /* BLAS call for (UZ)'b */
---
> 			F77_CALL(dgemv)(&trans, &kk, &k, &alpha, uz, &kk, b, &one, &beta, a,
> 					&one); /* BLAS call for (UZ)'b */
468c589,590
<       for (p0=a,p1=a+k;p0<p1;p0++,XMi++) *XMi = *p0;
---
> 			for (p0 = a, p1 = a + k; p0 < p1; p0++, XMi++)
> 				*XMi = *p0;
477c599,602
<     FREE(xc);FREE(b);FREE(a);FREE(uz);
---
> 		FREE(xc);
> 		FREE(b);
> 		FREE(a);
> 		FREE(uz);
481,485c606,619
<   if (pure_knot) mcopy(&E,S);
<   else for (i=0;i<v.r;i++) S->M[i][i]=v.V[i];
<   HQmult(*S,Z,0,0);HQmult(*S,Z,1,1);
<   for (i=0;i<S->r;i++) for (j=S->r-M;j<S->r;j++) S->M[i][j]=S->M[j][i]=0.0;
<   if (!constant) {S->r--;S->c--;}
---
> 	if (pure_knot)
> 		mcopy(&E, S);
> 	else
> 		for (i = 0; i < v.r; i++)
> 			S->M[i][i] = v.V[i];
> 	HQmult(*S, Z, 0, 0);
> 	HQmult(*S, Z, 1, 1);
> 	for (i = 0; i < S->r; i++)
> 		for (j = S->r - M; j < S->r; j++)
> 			S->M[i][j] = S->M[j][i] = 0.0;
> 	if (!constant) {
> 		S->r--;
> 		S->c--;
> 	}
491,496c625,646
<   for (i=0;i<X->c;i++)
<   { w=0; for (j=0;j<X->r;j++) w+=X->M[j][i]*X->M[j][i]; w=sqrt(w/X->r);
<     for (j=0;j<X->r;j++) X->M[j][i]/=w;
<     for (j=0;j<UZ->r;j++) UZ->M[j][i]/=w;
<     for (j=0;j<S->r;j++) S->M[i][j]/=w;
<     for (j=0;j<S->r;j++) S->M[j][i]/=w;
---
> 	for (i = 0; i < X->c; i++) {
> 		w = 0;
> 		for (j = 0; j < X->r; j++)
> 			w += X->M[j][i] * X->M[j][i];
> 		w = sqrt(w / X->r);
> 		for (j = 0; j < X->r; j++)
> 			X->M[j][i] /= w;
> 		for (j = 0; j < UZ->r; j++)
> 			UZ->M[j][i] /= w;
> 		for (j = 0; j < S->r; j++)
> 			S->M[i][j] /= w;
> 		for (j = 0; j < S->r; j++)
> 			S->M[j][i] /= w;
> 	}
> 	FREE(yxindex);
> 	freemat(Z);
> 	freemat(TU);
> 	freemat(E);
> 	freemat(T);
> 	if (!pure_knot) {
> 		freemat(U);
> 		freemat(v);
498,499d647
<   FREE(yxindex);freemat(Z);freemat(TU);freemat(E);freemat(T);
<   if (!pure_knot) {freemat(U);freemat(v);}
502,504c650,652
< 
< void construct_tprs(double *x,int *d,int *n,double *knt,int *nk,int *m,int *k,double *X,double *S,
<                     double *UZ,double *Xu,int *nXu,double *C)
---
> void construct_tprs(double *x, int *d, int *n, double *knt, int *nk, int *m,
> 		int *k, double *X, double *S, double *UZ, double *Xu, int *nXu,
> 		double *C)
520c668,669
< { double **xx,**kk=NULL,*dum,**XM;
---
> {
> 	double **xx, **kk = NULL, *dum, **XM;
524,527c673,678
<   for (i=0;i<*d;i++) xx[i]=x + i * *n;
<   if (*nk)
<   { kk=(double **)CALLOC((size_t)(*d),sizeof(double*));
<     for (i=0;i<*d;i++) kk[i]=knt + i * *nk;
---
> 	for (i = 0; i < *d; i++)
> 		xx[i] = x + i * *n;
> 	if (*nk) {
> 		kk = (double **) CALLOC((size_t) (*d), sizeof(double*));
> 		for (i = 0; i < *d; i++)
> 			kk[i] = knt + i * *nk;
536,539c687,693
<   dum=C;XM=Xm.M;Xr=Xm.r;
<   for (i=0;i< *k;i++)
<   { *dum = 0.0;
<     for (j=0;j<Xr;j++) *dum += XM[j][i];
---
> 	dum = C;
> 	XM = Xm.M;
> 	Xr = Xm.r;
> 	for (i = 0; i < *k; i++) {
> 		*dum = 0.0;
> 		for (j = 0; j < Xr; j++)
> 			*dum += XM[j][i];
542,543c696,702
<   freemat(Xm);freemat(Sm);freemat(UZm);freemat(Xum);
<   FREE(xx);if(*nk) FREE(kk);
---
> 	freemat(Xm);
> 	freemat(Sm);
> 	freemat(UZm);
> 	freemat(Xum);
> 	FREE(xx);
> 	if (*nk)
> 		FREE(kk);
546,547c705,706
< void predict_tprs(double *x, int *d,int *n,int *m,int *k,int *M,double *Xu,int *nXu,
<                   double *UZ,double *by,int *by_exists,double *X)
---
> void predict_tprs(double *x, int *d, int *n, int *m, int *k, int *M, double *Xu,
> 		int *nXu, double *UZ, double *by, int *by_exists, double *X)
558,559c717,719
< { double *b,by_mult,*xx,*a,*xp,*xxp,*xxp1,*xp1,*Xp,alpha=1.0,beta=0.0,*Xup,*Xup1,r,z,*pb,
<          eta0;
---
> {
> 	double *b, by_mult, *xx, *a, *xp, *xxp, *xxp1, *xp1, *Xp, alpha = 1.0,
> 			beta = 0.0, *Xup, *Xup1, r, z, *pb, eta0;
563c723,727
<   if (2 * *m <= *d && *d > 0) { *m = 0;while ( 2 * *m < *d+2) (*m)++;} 
---
> 	if (2 * *m <= *d && *d > 0) {
> 		*m = 0;
> 		while (2 * *m < *d + 2)
> 			(*m)++;
> 	}
576,577c740,744
<   for (Xp=X,xp=x,i=0;i< *n;i++,xp++,Xp++) 
<   { if (*by_exists) by_mult=by[i]; else by_mult=1.0;
---
> 	for (Xp = X, xp = x, i = 0; i < *n; i++, xp++, Xp++) {
> 		if (*by_exists)
> 			by_mult = by[i];
> 		else
> 			by_mult = 1.0;
580c747,748
<       for (xxp=Xp,j=0;j < *k;j++,xxp+= *n) *xxp = 0.0; 
---
> 			for (xxp = Xp, j = 0; j < *k; j++, xxp += *n)
> 				*xxp = 0.0;
582c750,752
<       for (xxp=xx,xxp1=xx + *d,xp1=xp;xxp < xxp1;xxp++,xp1 += *n) *xxp = *xp1; /*xx[j]=x[j * *n + i];*/
---
> 			for (xxp = xx, xxp1 = xx + *d, xp1 = xp; xxp < xxp1; xxp++, xp1 +=
> 					*n)
> 				*xxp = *xp1; /*xx[j]=x[j * *n + i];*/
586c756,760
<         for (xxp=xx,xxp1=xx + *d,xp1=Xup;xxp<xxp1;xxp++,xp1+= *nXu) { z = *xp1 - *xxp;r += z*z;}
---
> 				for (xxp = xx, xxp1 = xx + *d, xp1 = Xup; xxp < xxp1;
> 						xxp++, xp1 += *nXu) {
> 					z = *xp1 - *xxp;
> 					r += z * z;
> 				}
593c767,769
<         for (j=0;j<*d;j++) for (kk=0;kk<pin[l + *M * j];kk++)  r *= xx[j];
---
> 				for (j = 0; j < *d; j++)
> 					for (kk = 0; kk < pin[l + *M * j]; kk++)
> 						r *= xx[j];
599c775,776
<       F77_CALL(dgemv)(&trans,&nobsM,k,&alpha,UZ,&nobsM, b, &one,&beta, a, &one); /* BLAS call for (UZ)'b */
---
> 			F77_CALL(dgemv)(&trans, &nobsM, k, &alpha, UZ, &nobsM, b, &one,
> 					&beta, a, &one); /* BLAS call for (UZ)'b */
601c778,780
<       for (xp1=Xp,xxp=a,xxp1=a + *k;xxp<xxp1;xxp++,xp1+= *n) *xp1 = *xxp * by_mult; 
---
> 				for (xp1 = Xp, xxp = a, xxp1 = a + *k; xxp < xxp1; xxp++, xp1 +=
> 						*n)
> 					*xp1 = *xxp * by_mult;
603c782,784
<       for (xp1=Xp,xxp=a,xxp1=a + *k;xxp<xxp1;xxp++,xp1+= *n) *xp1 = *xxp;
---
> 				for (xp1 = Xp, xxp = a, xxp1 = a + *k; xxp < xxp1; xxp++, xp1 +=
> 						*n)
> 					*xp1 = *xxp;
617,618c798,801
<   FREE(b);FREE(a);
<   FREE(xx);FREE(pin);
---
> 	FREE(b);
> 	FREE(a);
> 	FREE(xx);
> 	FREE(pin);
diff -rEZbwB '--exclude=*.[lo,d,pdf,mo,po,tgz,gz,save]*' '--exclude=MD5' '--exclude=Makefile*' '--exclude=all.R' '--exclude=Changes' R-recommended/mgcv/src/tprs.h Recommended/mgcv/src/tprs.h
10,12c10,14
< double tps_g(matrix *X,matrix *p,double *x,int d,int m,double *b,int constant);
< void tprs_setup(double **x,double **knt,int m,int d,int n,int k,int constant,matrix *X,matrix *S,
<                 matrix *UZ,matrix *Xu,int n_knots);
---
> double tps_g(matrix *X, matrix *p, double *x, int d, int m, double *b,
> 		int constant);
> void tprs_setup(double **x, double **knt, int m, int d, int n, int k,
> 		int constant, matrix *X, matrix *S, matrix *UZ, matrix *Xu,
> 		int n_knots);
18,21c20,22
< void tprs_setup(double **x,double **knt,int m,int d,int n,int k,int constant,matrix *X,matrix *S,
<                 matrix *UZ,matrix *Xu,int n_knots);
< 
< 
---
> void tprs_setup(double **x, double **knt, int m, int d, int n, int k,
> 		int constant, matrix *X, matrix *S, matrix *UZ, matrix *Xu,
> 		int n_knots);
