diff -rEZbwB '--exclude=*.[lo,d,pdf,mo,po,tgz,gz,save]*' '--exclude=MD5' '--exclude=Makefile*' '--exclude=all.R' '--exclude=Changes' R-recommended/mgcv/R/bam.r Recommended/mgcv/R/bam.r
13c13
<  for (i in 1:n) sz[i] <- object.size(x[[i]])
---
>  for (i in seq_len(n)) sz[i] <- object.size(x[[i]])
38,39c38,39
<   ipiv <- piv <- attr(R,"pivot");ipiv[piv] <- 1:p
<   rank <- attr(R,"rank");ind <- 1:rank
---
>   ipiv <- piv <- attr(R,"pivot");ipiv[piv] <- seq_len(p)
>   rank <- attr(R,"rank");ind <- seq_len(rank)
71,72c71,72
<     fn <- qr.qty(qrx,yn)[1:p]
<     rp <- qrx$pivot;rp[rp] <- 1:p # reverse pivot
---
>     fn <- qr.qty(qrx,yn)[seq_len(p)]
>     rp <- qrx$pivot;rp[rp] <- seq_len(p) # reverse pivot
83c83
<   for (b in 1:arg$n.block) {
---
>   for (b in seq_len(arg$n.block)) {
120c120
<   for (i in 1:d) if (is.factor(dat[,i])) {  
---
>   for (i in seq_len(d)) if (is.factor(dat[,i])) {  
128c128
<     for (i in 1:d) if (!is.factor(dat[,i])) { ## round the metric variables
---
>     for (i in seq_len(d)) if (!is.factor(dat[,i])) { ## round the metric variables
150c150
<   ii <- sample(1:nrow(xu),nrow(xu),replace=FALSE) ## shuffling index
---
>   ii <- sample(seq_len(nrow(xu)),nrow(xu),replace=FALSE) ## shuffling index
191c191
<   for (i in 1:length(gp$smooth.spec)) nk <- nk + as.numeric(gp$smooth.spec[[i]]$by!="NA") +
---
>   for (i in seq_len(length(gp$smooth.spec))) nk <- nk + as.numeric(gp$smooth.spec[[i]]$by!="NA") +
201c201
<   for (i in 1:length(gp$smooth.spec)) {
---
>   for (i in seq_len(length(gp$smooth.spec))) {
227c227
<       for (j in 1:length(gp$smooth.spec[[i]]$margin)) { ## loop through margins
---
>       for (j in seq_len(length(gp$smooth.spec[[i]]$margin))) { ## loop through margins
272c272
<   for (i in 1:length(mf0)) {
---
>   for (i in seq_len(length(mf0))) {
284c284
<   mf <- mf[1:maxr,]
---
>   mf <- mf[seq_len(maxr),]
302c302
<           ii0 <- if (ik>1) 1:(ik-1) else rep(0,0) ## earlier
---
>           ii0 <- if (ik>1) seq_len(ik-1) else rep(0,0) ## earlier
319c319
<   for (j in 1:length(mf)) mn <- mn + if (is.factor(mf[[j]])) length(levels(mf[[j]])) else 2
---
>   for (j in seq_len(length(mf))) mn <- mn + if (is.factor(mf[[j]])) length(levels(mf[[j]])) else 2
333c333
<   ind <- sample(1:n,chunk.size)
---
>   ind <- sample(seq_len(n),chunk.size)
341c341
<   ind <- sample(1:n,n,replace=FALSE) ## randomized index for stratified sampling w.r.t. factor levels
---
>   ind <- sample(seq_len(n),n,replace=FALSE) ## randomized index for stratified sampling w.r.t. factor levels
344c344
<   for (j in 1:length(mf)) if (is.numeric(mf0[[j]])) {
---
>   for (j in seq_len(length(mf))) if (is.numeric(mf0[[j]])) {
346,347c346,347
<       j.min <- min((1:n)[as.logical(rowSums(mf[[j]]==min(mf[[j]])))])
<       j.max <- min((1:n)[as.logical(rowSums(mf[[j]]==max(mf[[j]])))])
---
>       j.min <- min((seq_len(n))[as.logical(rowSums(mf[[j]]==min(mf[[j]])))])
>       j.max <- min((seq_len(n))[as.logical(rowSums(mf[[j]]==max(mf[[j]])))])
394c394
<       ar.row <- c(1,rep(1:N,rep(2,N))[-c(1,2*N)]) ## index of rows to reweight
---
>       ar.row <- c(1,rep(seq_len(N),rep(2,N))[-c(1,2*N)]) ## index of rows to reweight
396c396
<       ar.stop <- c(1,1:(N-1)*2+1)    ## (stop[i-1]+1):stop[i] are the rows to reweight to get ith row
---
>       ar.stop <- c(1,seq_len(N-1)*2+1)    ## (stop[i-1]+1):stop[i] are the rows to reweight to get ith row
543c543
<           warning(gettextf("non-finite coefficients at iteration %d",
---
>           warning(gettextf("Non-finite coefficients at iteration %d",
550c550
<        warning("algorithm did not converge")
---
>        warning("Algorithm did not converge")
668c668
<         warning("Too many cluster nodes to use all efficiently")
---
>         warning("too many cluster nodes to use all efficiently")
678c678
<       for (i in 1:n.threads) {
---
>       for (i in seq_len(n.threads)) {
726c726
<     for (iter in 1L:control$maxit) { ## main fitting loop
---
>     for (iter in seq_len(control$maxit)) { ## main fitting loop
732c732
<          for (b in 1:n.block) {
---
>          for (b in seq_len(n.block)) {
758c758
<          for (i in 1:length(arg)) arg[[i]]$coef <- coef
---
>          for (i in seq_len(length(arg))) arg[[i]]$coef <- coef
762c762
<          #for (i in 1:length(arg)) {
---
>          #for (i in seq_len(length(arg))) {
894c894
<           warning(gettextf("non-finite coefficients at iteration %d",
---
>           warning(gettextf("Non-finite coefficients at iteration %d",
913c913
<        warning("algorithm did not converge")
---
>        warning("Algorithm did not converge")
988c988
<     for (iter in 1L:control$maxit) { ## main fitting loop
---
>     for (iter in seq_len(control$maxit)) { ## main fitting loop
1017c1017
<          message(gettextf("Deviance = %s Iterations - %d\n", dev, iter, domain = "R-mgcv"))
---
>          message(gettextf("Deviance = %s Iterations - %d", dev, iter, domain = "R-mgcv"))
1074,1075c1074
<           warning("non-finite coefficients at iteration ",
<                   iter)
---
>           warning(gettextf("Non-finite coefficients at iteration %d", iter))
1081c1080
<        warning("algorithm did not converge")
---
>        warning("Algorithm did not converge")
1109c1108
<   for (i in 1:arg$n.block) {
---
>   for (i in seq_len(arg$n.block)) {
1189c1188
<     for (i in 1:n.threads) { 
---
>     for (i in seq_len(n.threads)) { 
1255c1254
<          warning("Too many cluster nodes to use all efficiently")
---
>          warning("too many cluster nodes to use all efficiently")
1268c1267
<        for (i in 1:n.threads) { 
---
>        for (i in seq_len(n.threads)) { 
1315c1314
<        for (i in 1:n.block) {
---
>        for (i in seq_len(n.block)) {
1362c1361
<        # for (i in 1:length(arg)) {
---
>        # for (i in seq_len(length(arg))) {
1541c1540
<   for (b in 1:n.block) {    
---
>   for (b in seq_len(n.block)) {    
1575c1574
<   ar.row <- c(1,rep(1:N,rep(2,N))[-c(1,2*N)]) ## index of rows to reweight
---
>   ar.row <- c(1,rep(seq_len(N),rep(2,N))[-c(1,2*N)]) ## index of rows to reweight
1577c1576
<   ar.stop <- c(1,1:(N-1)*2+1)    ## (stop[i-1]+1):stop[i] are the rows to reweight to get ith row
---
>   ar.stop <- c(1,seq_len(N-1)*2+1)    ## (stop[i-1]+1):stop[i] are the rows to reweight to get ith row
1615,1616c1614
<     if (!method%in%c("fREML","GCV.Cp","REML",
<                     "ML","P-REML","P-ML")) stop("un-supported smoothness selection method")
---
>     if (!method%in%c("fREML","GCV.Cp","REML", "ML","P-REML","P-ML")) stop("unsupported smoothness selection method")
1653c1651
<           for (j in 1:gp$smooth.spec[[i]]$dim) gp$smooth.spec[[i]]$margin[[j]] <- list(term=gp$smooth.spec[[i]]$term[j])
---
>           for (j in seq_len(gp$smooth.spec[[i]]$dim)) gp$smooth.spec[[i]]$margin[[j]] <- list(term=gp$smooth.spec[[i]]$term[j])
1677c1675
<     if (rho!=0&&!is.null(mf$"(AR.start)")) if (!is.logical(mf$"(AR.start)")) stop("AR.start must be logical")
---
>     if (rho!=0&&!is.null(mf$"(AR.start)")) if (!is.logical(mf$"(AR.start)")) stop("'AR.start' argument must be logical")
1778c1776
<           for (j in 1:nmar) {
---
>           for (j in seq_len(nmar)) {
1801c1799
<           G$Xd[[k]] <- G$X[1:dk$nr[k],G$smooth[[i]]$first.para:G$smooth[[i]]$last.para]
---
>           G$Xd[[k]] <- G$X[seq_len(dk$nr[k]),G$smooth[[i]]$first.para:G$smooth[[i]]$last.para]
1844c1842
<     if (G$m) for (i in 1:G$m) G$min.edf<-G$min.edf+G$smooth[[i]]$null.space.dim
---
>     if (G$m) for (i in seq_len(G$m)) G$min.edf<-G$min.edf+G$smooth[[i]]$null.space.dim
1874c1872
<   if (control$trace) cat("Setup complete. Calling fit\n")
---
>   if (control$trace) cat(gettext("Setup complete. Calling fit", domain = "R-mgcv"), "\n", sep = "")
1879c1877
<     warning("sparse=TRUE is deprecated")
---
>     warning("'sparse=TRUE' option is deprecated")
1900c1898
<       if (length(ind)<2*ncol(G$X)) warning("samfrac too small - ignored") else {
---
>       if (length(ind)<2*ncol(G$X)) warning("value of 'samfrac' argument is too small - ignored") else {
1922c1920
<   if (control$trace) cat("Fit complete. Finishing gam object.\n")
---
>   if (control$trace) cat(gettext("Fit complete. Finishing gam object.", domain = "R-mgcv"), "\n", sep = "")
diff -rEZbwB '--exclude=*.[lo,d,pdf,mo,po,tgz,gz,save]*' '--exclude=MD5' '--exclude=Makefile*' '--exclude=all.R' '--exclude=Changes' R-recommended/mgcv/R/coxph.r Recommended/mgcv/R/coxph.r
18c18
<         else stop(linktemp, " link not available for coxph family; available link is \"identity\" ")
---
>         else stop(gettextf("\"%s\" link not available for coxph family; available link is \"identity\"", linktemp))
161c161
<         ind <- 1:(p^2)
---
>         ind <- seq_len(p^2)
163c163
<         for (i in 1:M) { 
---
>         for (i in seq_len(M)) { 
diff -rEZbwB '--exclude=*.[lo,d,pdf,mo,po,tgz,gz,save]*' '--exclude=MD5' '--exclude=Makefile*' '--exclude=all.R' '--exclude=Changes' R-recommended/mgcv/R/efam.r Recommended/mgcv/R/efam.r
57c57
<     } else stop(linktemp, " link not available for ordered categorical family; available links are \"identity\"")
---
>     } else stop(gettextf("\"%s\" link not available for ordered categorical family; available links are \"identity\"", linktemp))
93c93,94
<     paste("Ordered Categorical(",paste(round(object$family$getTheta(TRUE),2),collapse=","),")",sep="")
---
>     gettextf("Ordered Categorical(%s)", paste(round(object$family$getTheta(TRUE),2), collapse = ","), domain = "R-mgcv")
>     #paste("Ordered Categorical(",paste(round(object$family$getTheta(TRUE),2),collapse=","),")",sep="")
609c610
<         else stop(linktemp, " link not available for negative binomial family; available links are \"identity\", \"log\" and \"sqrt\"")
---
>         else stop(gettextf("\"%s\" link not available for negative binomial family; available links are \"identity\", \"log\" and \"sqrt\"", linktemp))
709c710,711
<       paste("Negative Binomial(",round(object$family$getTheta(TRUE),3),")",sep="")
---
>       gettextf("Negative Binomial(%s)", paste(round(object$family$getTheta(TRUE),3), sep = ", ", collapse = ""), domain = "R-mgcv")
>       #paste("Negative Binomial(",round(object$family$getTheta(TRUE),3),")",sep="")
758,759c760
<         else  stop(gettextf("link \"%s\" not available for Tweedie family.", 
<                 linktemp, collapse = ""), domain = NA)
---
>         else  stop(gettextf("link \"%s\" is not available for Tweedie family",  linktemp, collapse = ""), domain = "R-mgcv")
881c882
<       paste("Tweedie(p=",round(object$family$getTheta(TRUE),3),")",sep="")
---
>       gettextf("Tweedie(p=%s)", round(object$family$getTheta(TRUE),3), domain = "R-mgcv")
927c928
<         else stop(linktemp, " link not available for beta regression; available links are  \"logit\", \"probit\", \"cloglog\" and \"cauchit\"")
---
>         else stop(gettextf("\"%s\" link not available for beta regression; available links are  \"logit\", \"probit\", \"cloglog\" and \"cauchit\"", linktemp))
1122c1123
<       paste("Beta regression(",round(theta,3),")",sep="")
---
>       gettextf("Beta regression(%s)",round(theta,3), domain = "R-mgcv")
1208c1209
<         else stop(linktemp, " link not available for scaled t distribution; available links are \"identity\", \"log\",  and \"inverse\"")
---
>         else stop(gettextf("\"%s\" link not available for scaled t distribution; available links are \"identity\", \"log\",  and \"inverse\"", linktemp))
1362c1363
<       paste("Scaled t(",paste(round(object$family$getTheta(TRUE),3),collapse=","),")",sep="")
---
>       gettextf("Scaled t(%s)",paste(round(object$family$getTheta(TRUE),3), collapse=","), domain = "R-mgcv")
1470c1471
<   } else  stop(linktemp, " link not available for zero inflated; available link for `lambda' is only  \"loga\"")
---
>   } else  stop(gettextf("\"%s\" link not available for zero inflated; available link for `lambda' is only  \"loga\"", linktemp))
diff -rEZbwB '--exclude=*.[lo,d,pdf,mo,po,tgz,gz,save]*' '--exclude=MD5' '--exclude=Makefile*' '--exclude=all.R' '--exclude=Changes' R-recommended/mgcv/R/fast-REML.r Recommended/mgcv/R/fast-REML.r
32,34c32,34
<     off <- unique(G$off[1:G$n.paraPen]) ## unique offset lists relating to paraPen
<     for (i in 1:length(off)) { ## loop over blocks
<       ind <- (1:G$n.paraPen)[G$off[1:G$n.paraPen]%in%off[i]] ## terms in same block
---
>     off <- unique(G$off[seq_len(G$n.paraPen)]) ## unique offset lists relating to paraPen
>     for (i in seq_len(length(off))) { ## loop over blocks
>       ind <- seq_len(G$n.paraPen)[G$off[seq_len(G$n.paraPen)]%in%off[i]] ## terms in same block
36c36
<         nr <- 0;for (k in 1:length(ind)) nr <- max(nr,nrow(G$S[[ind[k]]])) ## get block size
---
>         nr <- 0;for (k in seq_len(length(ind))) nr <- max(nr,nrow(G$S[[ind[k]]])) ## get block size
41c41
<         for (k in 1:length(ind)) { ## work through all penalties for this block
---
>         for (k in seq_len(length(ind))) { ## work through all penalties for this block
45c45
<             Sl[[b]]$S[[k]][1:nk,1:nk] <- G$S[[ind[k]]]
---
>             Sl[[b]]$S[[k]][seq_len(nk),seq_len(nk)] <- G$S[[ind[k]]]
61c61
<   if (length(G$smooth)) for (i in 1:length(G$smooth)) {
---
>   if (length(G$smooth)) for (i in seq_len(length(G$smooth))) {
87c87
<       for (j in 1:m) { ## get block range for each S[[j]]
---
>       for (j in seq_len(m)) { ## get block range for each S[[j]]
89c89
<         ir <- range((1:nb)[rowSums(abs(Sl[[b]]$S[[j]]))>0])
---
>         ir <- range(seq_len(nb)[rowSums(abs(Sl[[b]]$S[[j]]))>0])
93c93
<       for (j in 1:m) { ## test for overlap
---
>       for (j in seq_len(m)) { ## test for overlap
96c96
<           for (k in 1:m) if (j!=k) itot[diag(Sl[[b]]$S[[k]])!=0] <- TRUE
---
>           for (k in seq_len(m)) if (j!=k) itot[diag(Sl[[b]]$S[[k]])!=0] <- TRUE
101c101
<           for (k in 1:m) if (j!=k) itot[sbStart[k]:sbStop[k]] <- TRUE
---
>           for (k in seq_len(m)) if (j!=k) itot[sbStart[k]:sbStop[k]] <- TRUE
108c108
<         for (j in 1:m) {
---
>         for (j in seq_len(m)) {
135c135
<   for (b in 1:length(Sl)) { ## once more into the blocks, dear friends...
---
>   for (b in seq_len(length(Sl))) { ## once more into the blocks, dear friends...
152c152
<         ind[1:Sl[[b]]$rank] <- TRUE ## index penalized elements
---
>         ind[seq_len(Sl[[b]]$rank)] <- TRUE ## index penalized elements
173,174c173,174
<       ind <- 1:Sl[[b]]$rank
<       for (j in 1:length(Sl[[b]]$S)) { ## project penalties into range space of total penalty
---
>       ind <- seq_len(Sl[[b]]$rank)
>       for (j in seq_len(length(Sl[[b]]$S))) { ## project penalties into range space of total penalty
212c212
<         for (b in 1:length(Sl)) { 
---
>         for (b in seq_len(length(Sl))) { 
225c225
<          for (b in 1:length(Sl)) { 
---
>          for (b in seq_len(length(Sl))) { 
241c241
<       for (b in 1:length(Sl)) { 
---
>       for (b in seq_len(length(Sl))) { 
247c247
<   } else for (b in 1:length(Sl)) { ## model matrix re-para
---
>   } else for (b in seq_len(length(Sl))) { ## model matrix re-para
330c330
<   for (b in 1:length(Sl)) { ## work through blocks
---
>   for (b in seq_len(length(Sl))) { ## work through blocks
367c367
<         for (i in 1:m) {
---
>         for (i in seq_len(m)) {
419c419
<       for (i in 1:nr) {
---
>       for (i in seq_len(nr)) {
426c426
<      for (i in 1:nr) X[rp[[i]]$ind]  <- rp[[i]]$Qs %*% X[rp[[i]]$ind]
---
>      for (i in seq_len(nr)) X[rp[[i]]$ind]  <- rp[[i]]$Qs %*% X[rp[[i]]$ind]
430c430
<       for (i in 1:nr) X[,rp[[i]]$ind]  <- X[,rp[[i]]$ind]%*%rp[[i]]$Qs
---
>       for (i in seq_len(nr)) X[,rp[[i]]$ind]  <- X[,rp[[i]]$ind]%*%rp[[i]]$Qs
432c432
<       for (i in 1:nr) X[rp[[i]]$ind]  <- t(rp[[i]]$Qs) %*% X[rp[[i]]$ind]
---
>       for (i in seq_len(nr)) X[rp[[i]]$ind]  <- t(rp[[i]]$Qs) %*% X[rp[[i]]$ind]
448c448
<     for (b in 1:nb) { ## block loop
---
>     for (b in seq_len(nb)) { ## block loop
462,463c462,463
<     for (b in 1:nb) { ## block loop
<       for (i in 1:length(Sl[[b]]$S)) { ## S loop within blocks
---
>     for (b in seq_len(nb)) { ## block loop
>       for (i in seq_len(length(Sl[[b]]$S))) { ## S loop within blocks
517c517
<   for (b in 1:nb) { ## block loop
---
>   for (b in seq_len(nb)) { ## block loop
533c533
<       for (i in 1:length(Sl[[b]]$S)) { ## work through S terms
---
>       for (i in seq_len(length(Sl[[b]]$S))) { ## work through S terms
575c575
<   for (i in 1:nd) { 
---
>   for (i in seq_len(nd)) { 
602c602
<   for (i in 1:nd) { ## compute the first derivatives
---
>   for (i in seq_len(nd)) { ## compute the first derivatives
612c612
<   for (k in 1:nd) { ## second derivative loop 
---
>   for (k in seq_len(nd)) { ## second derivative loop 
636c636
<   for (i in 1:nd) { ## compute the first derivatives
---
>   for (i in seq_len(nd)) { ## compute the first derivatives
647c647
<   for (k in 1:nd) { ## second derivative loop 
---
>   for (k in seq_len(nd)) { ## second derivative loop 
852c852
<   for (iter in 1:200) { ## the Newton loop
---
>   for (iter in seq_len(200)) { ## the Newton loop
876c876
<     trial <- Sl.fit(Sl,X,y,rho1[1:nr],fixed,log.phi,phi.fixed,rss.extra,nobs,Mp,nt=nt)
---
>     trial <- Sl.fit(Sl,X,y,rho1[seq_len(nr)],fixed,log.phi,phi.fixed,rss.extra,nobs,Mp,nt=nt)
881c881
<       trial <- Sl.fit(Sl,X,y,rho1[1:nr],fixed,log.phi,phi.fixed,rss.extra,nobs,Mp,nt=nt)
---
>       trial <- Sl.fit(Sl,X,y,rho1[seq_len(nr)],fixed,log.phi,phi.fixed,rss.extra,nobs,Mp,nt=nt)
909,911c909,911
<   if (step.failed) best$conv <- "step failed" else
<   if (iter==200) best$conv <- "no convergence in 200 iterations" else
<   best$conv <- "full convergence"
---
>   if (step.failed) best$conv <- gettext("step failed", domain = "R-mgcv") else
>   if (iter==200) best$conv <- gettext("no convergence in 200 iterations", domain = "R-mgcv") else
>   best$conv <- gettext("full convergence", domain = "R-mgcv")
957c957
<   for (b in 1:length(Sl)) {
---
>   for (b in seq_len(length(Sl))) {
977c977
<       for (i in 1:length(Sl[[b]]$S)) {
---
>       for (i in seq_len(length(Sl[[b]]$S))) {
987c987
<     for (i in 1:length(Sl)) {
---
>     for (i in seq_len(length(Sl))) {
1010c1010
<   for (b in 1:length(Sl)) rank <- rank + Sl[[b]]$rank ## the total penalty rank
---
>   for (b in seq_len(length(Sl))) rank <- rank + Sl[[b]]$rank ## the total penalty rank
1030c1030
<     for (i in 1:ncol(d1b)) d1b[,i] <- 
---
>     for (i in seq_len(ncol(d1b))) d1b[,i] <- 
diff -rEZbwB '--exclude=*.[lo,d,pdf,mo,po,tgz,gz,save]*' '--exclude=MD5' '--exclude=Makefile*' '--exclude=all.R' '--exclude=Changes' R-recommended/mgcv/R/gamlss.r Recommended/mgcv/R/gamlss.r
258,259c258,259
<     ind <- 1:n 
<     for (i in 1:K) { 
---
>     ind <- seq_len(n) 
>     for (i in seq_len(K)) { 
273,274c273,274
<     ind <- 1:n
<     for (i in 1:K) { 
---
>     ind <- seq_len(n)
>     for (i in seq_len(K)) { 
280c280
<     for (k in 1:m) for (l in k:m) { ## looping over smoothing parameters...
---
>     for (k in seq_len(m)) for (l in k:m) { ## looping over smoothing parameters...
282,284c282,284
<       for (i in 1:K) for (j in 1:K) {
<         v <- rep(0,n);ind <- 1:n
<         for (q in 1:K) { ## accumulate the diagonal matrix for X_i'diag(v)X_j
---
>       for (i in seq_len(K)) for (j in seq_len(K)) {
>         v <- rep(0,n);ind <- seq_len(n)
>         for (q in seq_len(K)) { ## accumulate the diagonal matrix for X_i'diag(v)X_j
286,287c286,287
<           ins <- 1:n
<           for (s in 1:K) { 
---
>           ins <- seq_len(n)
>           for (s in seq_len(K)) { 
294c294
<           rind <- 1:n + (i-1)*n
---
>           rind <- seq_len(n) + (i-1)*n
297,298c297,298
<           rind1 <- 1:n + (i-1)*n
<           rind2 <- 1:n + (j-1)*n
---
>           rind1 <- seq_len(n) + (i-1)*n
>           rind2 <- seq_len(n) + (j-1)*n
460c460
<   if (length(link)!=2) stop("gaulss requires 2 links specified as character strings")
---
>   if (length(link)!=2) stop(gettextf("'%s' function requires 2 links specified as character strings", "gaulss()"))
464c464
<   stop(link[[1]]," link not available for mu parameter of gaulss")
---
>   stop(gettextf("\"%s\" link not available for mu parameter of gaulss", link[[1]]))
486c486
<   } else stop(link[[2]]," link not available for precision parameter of gaulss")
---
>   } else stop(gettextf("\"%s\" link not available for precision parameter of gaulss", link[[2]]))
854c854
<   if (length(link)!=2) stop("ziplss requires 2 links specified as character strings")
---
>   if (length(link)!=2) stop(gettextf("'%s' function requires 2 links specified as character strings", "ziplss()"))
860c860
<     stop(link[[i]]," link not available for ",param.names[i]," parameter of ziplss")
---
>     stop(gettextf("\"%s\" link not available for parameter of ziplss %s", param.names[i], link[[i]]))
diff -rEZbwB '--exclude=*.[lo,d,pdf,mo,po,tgz,gz,save]*' '--exclude=MD5' '--exclude=Makefile*' '--exclude=all.R' '--exclude=Changes' R-recommended/mgcv/R/gamm.r Recommended/mgcv/R/gamm.r
134c134
<   if (sum(is.na(value))>0) warning("NA's in pdTens factor")
---
>   if (sum(is.na(value))>0) warning("NA values in factor of class \"pdTens\"")
157c157
<   if (sum(is.na(value))>0) warning("NA's in pdTens matrix")
---
>   if (sum(is.na(value))>0) warning("NA values in matrix of class \"pdTens\"")
179c179
<   function(object, structName = "Tensor product smooth term", ...)
---
>   function(object, structName = gettext("Tensor product smooth term", domain = "R-mgcv"), ...)
246,247c246
<     stop(paste("An object of length", length(val),
< 	       "does not match the required parameter size"))
---
>     stop(gettextf("An object of length %d does not match the required parameter size", length(val)))
250,251c249
<     stop(paste("Must give names when initializing pdIdnot from parameter.",
< 	       "without a formula"))
---
>     stop("Must give names when initializing pdIdnot from parameter without a formula")
273c271
<     stop(paste("Cannot extract the matrix with uninitialized dimensions"))
---
>     stop("Cannot extract the matrix with uninitialized dimensions")
331c329
<   function(object, structName = "Multiple of an Identity", ...)
---
>   function(object, structName = gettext("Multiple of an Identity", domain = "R-mgcv"), ...)
366c364
<   for (i in 1:length(object$S)) { ## work through penalties
---
>   for (i in seq_len(length(object$S))) { ## work through penalties
392c390
<       for (j in 1:n.lev) { ## assemble full sparse model matrix
---
>       for (j in seq_len(n.lev)) { ## assemble full sparse model matrix
446c444
<   for (i in 1:length(object$S)) { ## work through penalties
---
>   for (i in seq_len(length(object$S))) { ## work through penalties
585,586c583
<   if (sum(D<=0)) stop(
<   "Tensor product penalty rank appears to be too low: please email Simon.Wood@R-project.org with details.")
---
>   if (sum(D<=0)) stop("Tensor product penalty rank appears to be too low: please email Simon.Wood@R-project.org with details.")
593c590
<   for (l in 1:length(object$S)) {   # transform penalty explicitly
---
>   for (l in seq_len(length(object$S))) {   # transform penalty explicitly
620c617
<                       data=stop("No data supplied to gamm.setup"),knots=NULL,
---
>                       data=stop(gettextf("No data supplied to '%s' function", "gamm.setup()")),knots=NULL,
644c641
<   if (!is.null(G$L)) stop("gamm can not handle linked smoothing parameters (probably from use of `id' or adaptive smooths)")
---
>   if (!is.null(G$L)) stop("gamm can not handle linked smoothing parameters (probably from use of 'id' or adaptive smooths)")
666c663
<     for (i in 1:G$m) if (is.null(G$smooth[[i]]$fac)) { 
---
>     for (i in seq_len(G$m)) if (is.null(G$smooth[[i]]$fac)) { 
673c670
<       if (!is.null(attr(G$smooth[[i]],"del.index"))) stop("side conditions not allowed for nested smooths")
---
>       if (!is.null(attr(G$smooth[[i]],"del.index"))) stop("side conditions are not allowed for nested smooths")
675c672
<     if (k < G$m) pord[(k+1):G$m] <- (1:G$m)[!done] 
---
>     if (k < G$m) pord[(k+1):G$m] <- seq_len(G$m)[!done] 
679c676
<   if (G$m) for (i in 1:G$m) { ## work through the smooths
---
>   if (G$m) for (i in seq_len(G$m)) { ## work through the smooths
696c693
<       for (k in 1:length(rasm$rand)) {
---
>       for (k in seq_len(length(rasm$rand))) {
718c715
<       for (j in 1:ncol(rasm$Xf)) {
---
>       for (j in seq_len(ncol(rasm$Xf))) {
801c798
< { if (!inherits(b,"lme")) stop("object does not appear to be of class lme")
---
> { if (!inherits(b,"lme")) stop(gettextf("'%s' argument is not an object of class %s", "b", dQuote("lme")))
848c845
<     for (i in 1:n.cg) size.cg[i] <- sum(Cgrps==Clevel[i]) # size of each coarse group
---
>     for (i in seq_len(n.cg)) size.cg[i] <- sum(Cgrps==Clevel[i]) # size of each coarse group
874c871
<       for (i in 1:n.cg) { 
---
>       for (i in seq_len(n.cg)) { 
885c882
<       for (i in 1:n.g) # work through innermost groups
---
>       for (i in seq_len(n.g)) # work through innermost groups
902c899
<       for (k in 1:n.cg) { # pasting correlations into right place in each matrix
---
>       for (k in seq_len(n.cg)) { # pasting correlations into right place in each matrix
909c906
<   { for (i in 1:n.cg)
---
>   { for (i in seq_len(n.cg))
932c929
<   { for (i in 1:(n.levels-start.level+1)) # work through the r.e. groupings inner to outer
---
>   { for (i in seq_len(n.levels-start.level+1)) # work through the r.e. groupings inner to outer
948c945
<     for (i in 1:(n.levels-start.level+1))
---
>     for (i in seq_len(n.levels-start.level+1))
950c947
<       for (j in 1:b$dims$ngrps[i]) 
---
>       for (j in seq_len(b$dims$ngrps[i])) 
969c966
<       for (i in 1:n.cg) {
---
>       for (i in seq_len(n.cg)) {
976c973
<         for (i in 1:n.cg) V[[i]] <- V[[i]]+Vz[[i]] 
---
>         for (i in seq_len(n.cg)) V[[i]] <- V[[i]]+Vz[[i]] 
979c976
<         for (i in 1:n.cg) {
---
>         for (i in seq_len(n.cg)) {
998c995
< { if (!inherits(b,"lme")) stop("object does not appear to be of class lme")
---
> { if (!inherits(b,"lme")) stop(gettextf("'%s' argument is not an object of class %s", "b", dQuote("lme")))
1024c1021
<       for (i in 1:n.g) 
---
>       for (i in seq_len(n.g)) 
1046c1043
<   { for (i in 1:(n.levels-start.level+1)) # work through the r.e. groupings inner to outer
---
>   { for (i in seq_len(n.levels-start.level+1)) # work through the r.e. groupings inner to outer
1062c1059
<     for (i in 1:(n.levels-start.level+1))
---
>     for (i in seq_len(n.levels-start.level+1))
1064c1061
<       for (j in 1:b$dims$ngrps[i]) 
---
>       for (j in seq_len(b$dims$ngrps[i])) 
1084c1081
<     for (i in 1:length(V$V))
---
>     for (i in seq_len(length(V$V)))
1142,1143c1139
<   eval(parse(text=paste("fit0 <- glm(formula = fixed, family = family, data = data,",
<                         "weights =",wts.name,",...)")))
---
>   eval(parse(text=paste("fit0 <- glm(formula = fixed, family = family, data = data,", "weights =",wts.name,",...)")))
1166c1162
<   for (i in 1:niter) {
---
>   for (i in seq_len(niter)) {
1182c1178
<   } ## end i in 1:niter
---
>   } ## end i in seq_len(niter)
1198c1194
< { if (inherits(family,"extended.family")) warning("family are not designed for use with gamm!")
---
> { if (inherits(family,"extended.family")) warning("family are not designed for use with 'gamm()' function!")
1208c1204
<       else stop("gamm() can only handle random effects defined as named lists")
---
>       else stop("'gamm()' can only handle random effects defined as named lists")
1223c1219
<         for (i in 1:length(weights)) {
---
>         for (i in seq_len(length(weights))) {
1312c1308
<       for (i in 1:r.m) rand[[n.sr+i]]<-random[[i]]   
---
>       for (i in seq_len(r.m)) rand[[n.sr+i]]<-random[[i]]   
1354c1350
<       if (verbosePQL) cat("\n Maximum number of PQL iterations: ",niterPQL,"\n")
---
>       if (verbosePQL) cat("\n ", gettext("Maximum number of PQL iterations: ", domain = "R-mgcv"), niterPQL, "\n", sep = "")
1393c1389
<     if (G$m>0) for (i in 1:G$m)
---
>     if (G$m>0) for (i in seq_len(G$m))
1403c1399
<           for (j in 1:length(flev)) {
---
>           for (j in seq_len(length(flev))) {
1423c1419
<     if (G$m>0) for (i in 1:G$m) # var.param in reverse term order, but forward order within terms!!
---
>     if (G$m>0) for (i in seq_len(G$m)) # var.param in reverse term order, but forward order within terms!!
1438c1434
<     if (length(spl)) for (i in 1:length(spl)) if (!is.null(spl[[i]])) object$sp <- c(object$sp,spl[[i]]) 
---
>     if (length(spl)) for (i in seq_len(length(spl))) if (!is.null(spl[[i]])) object$sp <- c(object$sp,spl[[i]]) 
1450c1446
<       if (G$m>0) for (i in 1:G$m) {# Accumulate the total model matrix
---
>       if (G$m>0) for (i in seq_len(G$m)) {# Accumulate the total model matrix
1459c1455
<           for (k in 1:length(flev)) {
---
>           for (k in seq_len(length(flev))) {
1470c1466
<       if (G$m>0) for (i in 1:G$m) {
---
>       if (G$m>0) for (i in seq_len(G$m)) {
1485c1481
<     if (G$m>0) for (i in 1:G$m) {# Accumulate the total penalty matrix 
---
>     if (G$m>0) for (i in seq_len(G$m)) {# Accumulate the total penalty matrix 
1489c1485
<         if (ns) for (l in 1:ns) { 
---
>         if (ns) for (l in seq_len(ns)) { 
1498,1499c1494,1495
<         for (j in 1:length(flev)) {
<            if (ns) for (l in 1:ns) { 
---
>         for (j in seq_len(length(flev))) {
>            if (ns) for (l in seq_len(ns)) { 
1513c1509
<     if (G$m) for (i in 1:G$m) { 
---
>     if (G$m) for (i in seq_len(G$m)) { 
1555c1551
<       for (i in 1:n.smooth)
---
>       for (i in seq_len(n.smooth))
1604,1606c1600,1602
<     if (fit.cor<.999) { cat("FAILED: fit.cor = ",fit.cor,"\n");return()}
<     if (edf.diff>edf.tol) { cat("FAILED: edf.diff = ",edf.diff,"\n");return()}
<     cat("PASSED \n")
---
>     if (fit.cor<.999) { cat(gettextf("TEST FAILED: fit.cor = %s",fit.cor, domain = "R-mgcv"), "\n", sep = "");return()}
>     if (edf.diff>edf.tol) { cat(gettext("TEST FAILED: edf.diff = %s",edf.diff, domain = "R-mgcv"), "\n", sep = "");return()}
>     cat(gettext("TEST PASSED", domain = "R-mgcv"), "\n", sep = "")
1612c1608
<   cat("testing covariate scale invariance ... ")  
---
>   cat(gettext("testing covariate scale invariance ... ", domain = "R-mgcv"))
1618c1614
<   cat("testing invariance w.r.t. response ... ")
---
>   cat(gettext("testing invariance w.r.t. response ... ", domain = "R-mgcv"))
1623c1619
<   cat("testing equivalence of te(x) and s(x) ... ")
---
>   cat(gettext("testing equivalence of te(x) and s(x) ... ", domain = "R-mgcv"))
1628c1624
<   cat("testing equivalence of gam and gamm with same sp ... ")
---
>   cat(gettext("testing equivalence of gam and gamm with same sp ... ", domain = "R-mgcv"))
diff -rEZbwB '--exclude=*.[lo,d,pdf,mo,po,tgz,gz,save]*' '--exclude=MD5' '--exclude=Makefile*' '--exclude=all.R' '--exclude=Changes' R-recommended/mgcv/R/jagam.r Recommended/mgcv/R/jagam.r
50c50
<   } else stop("family not implemented yet")
---
>   } else stop("family not implemented yet") #IVORY
81c81
<   rp <- qrx$pivot;rp[rp] <- 1:ncol(X)
---
>   rp <- qrx$pivot;rp[rp] <- seq_len(ncol(X))
96c96
<   if (is.null(file)) stop("jagam requires a file for the JAGS model specification")
---
>   if (is.null(file)) stop("'jagam()' function requires a file for the JAGS model specification")
99c99
<     warning("smoothing parameter prior choise not recognised, reset to gamma")
---
>     warning("smoothing parameter prior choise not recognised, reset to 'gamma'")
204c204
<       if (M>0) for (j in 1:M) {
---
>       if (M>0) for (j in seq_len(M)) {
216c216
<       } else for (j in 1:M) {
---
>       } else for (j in seq_len(M)) {
302c302
<       warning("burnin too large, reset")
---
>       warning(gettextf("'%s' argument is too large, reset", "burnin"))
329c329
<     warning("rho missing from simulation data edf.type reset to 2")
---
>     warning("'rho' slot for 'sam' argument is missing from simulation data, 'edf.type' argument reset to 2")
345c345
<     for (i in 1:length(lambda)) {
---
>     for (i in seq_len(length(lambda))) {
369,372c369,372
<     if ("residuals"%in% arg.names) stop("residuals argument not supported")
<     if ("unconditional"%in% arg.names) stop("unconditional argument not meaningful here")
<     if ("by.resids"%in% arg.names) stop("by.resids argument not supported")
<     if ("all.terms"%in% arg.names) stop("all.terms argument not supported")
---
>     if ("residuals"%in% arg.names) stop(gettextf("'%s' argument is not supported", "residuals"))
>     if ("unconditional"%in% arg.names) stop(gettextf("'%s' argument is not meaningful here", "unconfitional"))
>     if ("by.resids"%in% arg.names) stop(gettextf("'%s' argument is not supported", "by.resids"))
>     if ("all.terms"%in% arg.names) stop(gettextf("'%s' argument is not supported", "all.terms"))
388c388
<     if ("unconditional"%in% arg.names) warning("unconditional argument not meaningful here")
---
>     if ("unconditional"%in% arg.names) warning(gettextf("'%s' argument is not meaningful here", "unconditional"))
diff -rEZbwB '--exclude=*.[lo,d,pdf,mo,po,tgz,gz,save]*' '--exclude=MD5' '--exclude=Makefile*' '--exclude=all.R' '--exclude=Changes' R-recommended/mgcv/R/mgcv.r Recommended/mgcv/R/mgcv.r
32c32
<    if (k<0) stop("argument k must be positive.")
---
>    if (k<0) stop("argument 'k' must be positive")
36c36
<    if (n != ncol(A)) stop("A not square")
---
>    if (n != ncol(A)) stop("matrix 'A' is not square")
59c59
<   for (i in 1:length(na)) {
---
>   for (i in seq_len(length(na))) {
93,96c93,96
<   if (nrow(M$X)!=nar[1]) stop("nrow(M$X) != length(M$y)") 
<   if (ncol(M$X)!=nar[2]) stop("ncol(M$X) != length(M$p)")
<   if (length(M$w)!=nar[1]) stop("length(M$w) != length(M$y)")
<   if (nar[3]!=length(M$bin)) stop("nrow(M$Ain) != length(M$bin)")
---
>   if (nrow(M$X)!=nar[1]) stop("nrow(M$X) != length(M$y)", domain = NA)
>   if (ncol(M$X)!=nar[2]) stop("ncol(M$X) != length(M$p)", domain = NA)
>   if (length(M$w)!=nar[1]) stop("length(M$w) != length(M$y)", domain = NA)
>   if (nar[3]!=length(M$bin)) stop("nrow(M$Ain) != length(M$bin)", domain = NA)
98c98
<     if (ncol(M$Ain)!=nar[2]) stop("nrow(M$Ain) != length(M$p)") 
---
>     if (ncol(M$Ain)!=nar[2]) stop("nrow(M$Ain) != length(M$p)", domain = NA) 
103c103
<       warning("initial point very close to some inequality constraints")
---
>       warning("initial point is very close to some inequality constraints")
106c106
<       warning("initial parameters very close to inequality constraints")
---
>       warning("initial parameters are very close to inequality constraints")
109,111c109,111
<   if (nrow(M$C)>0) if (ncol(M$C)!=nar[2]) stop("ncol(M$C) != length(M$p)")  
<   if (length(M$S)!=length(M$off)) stop("M$S and M$off have different lengths")
<   if (length(M$S)!=length(M$sp)) stop("M$sp has different length to M$S and M$off")
---
>   if (nrow(M$C)>0) if (ncol(M$C)!=nar[2]) stop("ncol(M$C) != length(M$p)", domain = NA) 
>   if (length(M$S)!=length(M$off)) stop(gettextf("'%s' and '%s' components should have the same length", "M$S", "M$off"))
>   if (length(M$S)!=length(M$sp)) stop(gettextf("'%s', '%s' and '%s' components should have the same length", "M$sp", "M$S", "M$off"))
117c117
<   if (m>0) for (i in 1:m)
---
>   if (m>0) for (i in seq_len(m))
174c174
<   if (length(sp)>0) for (i in 1:length(sp)) {
---
>   if (length(sp)>0) for (i in seq_len(length(sp))) {
178c178
<   if (length(tp)>0) for (i in 1:length(tp)) {
---
>   if (length(tp)>0) for (i in seq_len(length(tp))) {
182c182
<   if (length(tip)>0) for (i in 1:length(tip)) {
---
>   if (length(tip)>0) for (i in seq_len(length(tip))) {
186c186
<    if (length(t2p)>0) for (i in 1:length(t2p)) {
---
>    if (length(t2p)>0) for (i in seq_len(length(t2p))) {
200c200
<   if (nt) for (i in 1:nt) { # work through all terms
---
>   if (nt) for (i in seq_len(nt)) { # work through all terms
248c248
<   for (i in 1:length(smooth.spec)) {
---
>   for (i in seq_len(length(smooth.spec))) {
301c301
<     for (i in 1:d) {
---
>     for (i in seq_len(d)) {
329c329
<     for (i in 1:d) if (max(ret[[i]]$lpi)>nlp||min(ret[[i]]$lpi)<1) stop("linear predictor labels out of range")
---
>     for (i in seq_len(d)) if (max(ret[[i]]$lpi)>nlp||min(ret[[i]]$lpi)<1) stop("linear predictor labels out of range")
407c407
<   for (i in 1:m) { ## collect all term names and max smooth `dim'
---
>   for (i in seq_len(m)) { ## collect all term names and max smooth `dim'
436c436
<   for (i in 1:length(sm.id)) sm.id[[i]]<-array(0,0)
---
>   for (i in seq_len(length(sm.id))) sm.id[[i]]<-array(0,0)
438,440c438,440
<   for (d in 1:maxDim) {
<     for (i in 1:m) {
<       if (sm[[i]]$dim==d) for (j in 1:d) { ## work through terms
---
>   for (d in seq_len(maxDim)) {
>     for (i in seq_len(m)) {
>       if (sm[[i]]$dim==d) for (j in seq_len(d)) { ## work through terms
452c452
<   if (maxDim==1) warning("model has repeated 1-d smooths of same variable.")
---
>   if (maxDim==1) warning("model has repeated 1-d smooths of same variable")
458c458
<     for (i in 1:m) { ## create parameter indices for each term
---
>     for (i in seq_len(m)) { ## create parameter indices for each term
467,468c467,468
<   for (d in 1:maxDim) { ## work up through dimensions 
<     for (i in 1:m) { ## work through smooths
---
>   for (d in seq_len(maxDim)) { ## work up through dimensions 
>     for (i in seq_len(m)) { ## work through smooths
472c472
<         for (j in 1:d) { ## work through variables
---
>         for (j in seq_len(d)) { ## work through variables
475c475
<           if (k>1) for (l in 1:(k-1)) { ## collect X columns
---
>           if (k>1) for (l in seq_len(k-1)) { ## collect X columns
509c509
<             if (mi>1) for (j in 1:mi) St <- St + 
---
>             if (mi>1) for (j in seq_len(mi)) St <- St + 
539c539
<     } ## end i in 1:m loop
---
>     } ## end i in seq_len(m) loop
541c541
<   if (with.pen) for (i in 1:m) { ## remove working variables that were added
---
>   if (with.pen) for (i in seq_len(m)) { ## remove working variables that were added
553c553
<  if (specb$dim!=spec$dim) stop("`id' linked smooths must have same number of arguments") 
---
>  if (specb$dim!=spec$dim) stop("'id' linked smooths must have same number of arguments") 
560c560
<     for (i in 1:length(specb$margin)) {
---
>     for (i in seq_len(length(specb$margin))) {
562c562
<          for (j in 1:length(specb$margin[[i]]$term)) {
---
>          for (j in seq_len(length(specb$margin[[i]]$term))) {
599c599
<   if (n.t>0) for (j in 1:n.t) if (tind[j]>0) {
---
>   if (n.t>0) for (j in seq_len(n.t)) if (tind[j]>0) {
610,611c610,611
<       if (!is.null(ranki)&&length(ranki)!=np) stop("`rank' has wrong length in `paraPen'") 
<       if (np) for (i in 1:np) { ## unpack penalty matrices, offsets and ranks
---
>       if (!is.null(ranki)&&length(ranki)!=np) stop("'rank' has wrong length in 'paraPen'") 
>       if (np) for (i in seq_len(np)) { ## unpack penalty matrices, offsets and ranks
624c624
<         if (nrow(Li)!=np) stop("L has wrong dimension in `paraPen'")
---
>         if (nrow(Li)!=np) stop("'L' has wrong dimension in 'paraPen'")
632c632
<           if (length(spi)!=ncol(Li)) stop("`sp' dimension wrong in `paraPen'")
---
>           if (length(spi)!=ncol(Li)) stop("'sp' dimension wrong in 'paraPen'")
646c646
<     if (length(sp0)<length(sp)) stop("`sp' too short")
---
>     if (length(sp0)<length(sp)) stop("'sp' is too short")
696c696
<   ii <- 1:n
---
>   ii <- seq_len(n)
700c700
<   for (i in 1:nf) {
---
>   for (i in seq_len(nf)) {
703c703
<       ind <- pstart[i] + 1:nsdf[i] - 1
---
>       ind <- pstart[i] + seq_len(nsdf[i]) - 1
728c728
<       for (i in 1:nlp) { 
---
>       for (i in seq_len(nlp)) { 
742c742
<                     data=stop("No data supplied to gam.setup"),knots=NULL,sp=NULL,
---
>                     data=stop(gettextf("No data supplied to '%s' function", "gam.setup()")),knots=NULL,sp=NULL,
749,750c749,750
<   if (!is.null(paraPen)) stop("paraPen not supported for multi-formula models")
<   if (!absorb.cons) stop("absorb.cons must be TRUE for multi-formula models")
---
>   if (!is.null(paraPen)) stop("'paraPen' argument is not supported for multi-formula models")
>   if (!absorb.cons) stop("'absorb.cons' argument must be TRUE for multi-formula models")
767,768c767,768
<   for (i in 1:formula$nlp) lpi[[i]] <- rep(0,0)
<   lpi[[1]] <- 1:ncol(G$X) ## lpi[[j]] is index of cols for jth linear predictor 
---
>   for (i in seq_len(formula$nlp)) lpi[[i]] <- rep(0,0)
>   lpi[[1]] <- seq_len(ncol(G$X)) ## lpi[[j]] is index of cols for jth linear predictor 
786c786
<       lpi[[j]] <- c(lpi[[j]],pof + 1:ncol(um$X)) ## add these cols to lpi[[j]]
---
>       lpi[[j]] <- c(lpi[[j]],pof + seq_len(ncol(um$X))) ## add these cols to lpi[[j]]
800c800
<     if (um$m) for (j in 1:um$m) {
---
>     if (um$m) for (j in seq_len(um$m)) {
817c817
<     if (M) for (j in 1:M) {
---
>     if (M) for (j in seq_len(M)) {
832c832
<     if (um$nsdf>0) um$term.names[1:um$nsdf] <- paste(um$term.names[1:um$nsdf],i-1,sep=".")
---
>     if (um$nsdf>0) um$term.names[seq_len(um$nsdf)] <- paste(um$term.names[1:um$nsdf],i-1,sep=".")
851c851
<       for (i in 1:length(G$smooth)) {
---
>       for (i in seq_len(length(G$smooth))) {
856c856
<       for (i in 1:length(G$off)) G$off[i] <- G$off[i] - sum(rt$dind < G$off[i])
---
>       for (i in seq_len(length(G$off))) G$off[i] <- G$off[i] - sum(rt$dind < G$off[i])
872c872
<                      data=stop("No data supplied to gam.setup"),knots=NULL,sp=NULL,
---
>                      data=stop(gettextf("No data supplied to '%s' function", "gam.setup()")),knots=NULL,sp=NULL,
963c963
<     if (m>0) for (i in 1:m) attr(split$smooth.spec[[i]],"gamm") <- TRUE
---
>     if (m>0) for (i in seq_len(m)) attr(split$smooth.spec[[i]],"gamm") <- TRUE
968c968
<     for (i in 1:m) if (!is.null(split$smooth.spec[[i]]$id)) {
---
>     for (i in seq_len(m)) if (!is.null(split$smooth.spec[[i]]$id)) {
984c984
<         for (j in 1:length(temp.term)) id.list[[id]]$data[[j]] <- cbind(id.list[[id]]$data[[j]],
---
>         for (j in seq_len(length(temp.term))) id.list[[id]]$data[[j]] <- cbind(id.list[[id]]$data[[j]],
993c993
<         for (j in 1:length(term)) id.list[[id]]$data[[j]] <- get.var(term[j],data,vecMat=FALSE)
---
>         for (j in seq_len(length(term))) id.list[[id]]$data[[j]] <- get.var(term[j],data,vecMat=FALSE)
1002c1002
<   if (m>0) for (i in 1:m) {
---
>   if (m>0) for (i in seq_len(m)) {
1019c1019
<     for (j in 1:length(sml)) {
---
>     for (j in seq_len(length(sml))) {
1031c1031
<     if (!apply.by) for (i in 1:length(sm)) { ## restore any by-free model matrices
---
>     if (!apply.by) for (i in seq_len(length(sm))) { ## restore any by-free model matrices
1045c1045
<   if (m>0) for (i in 1:m) {
---
>   if (m>0) for (i in seq_len(m)) {
1074c1074
<         stop("Later terms sharing an `id' can not have more smoothing parameters than the first such term")
---
>         stop("Later terms sharing an 'id' can not have more smoothing parameters than the first such term")
1087c1087
<   if (m>0) for (i in 1:m) {
---
>   if (m>0) for (i in seq_len(m)) {
1157,1158c1157,1158
<   { if (length(sp)!=ncol(L)) { warning("Supplied smoothing parameter vector is too short - ignored.")}
<     if (sum(is.na(sp))) { warning("NA's in supplied smoothing parameter vector - ignoring.")}
---
>   { if (length(sp)!=ncol(L)) { warning("Supplied smoothing parameter vector is too short - ignored")}
>     if (sum(is.na(sp))) { warning("NA values in supplied smoothing parameter vector - ignoring")}
1171c1171
<   if (m>0) for (i in 1:m) {
---
>   if (m>0) for (i in seq_len(m)) {
1197,1198c1197,1198
<   if (length(idx)) for (i in 1:length(idx)) idx[[i]]$sp.done <- FALSE
<   if (m>0) for (i in 1:m) { ## work through all smooths
---
>   if (length(idx)) for (i in seq_len(length(idx))) idx[[i]]$sp.done <- FALSE
>   if (m>0) for (i in seq_len(m)) { ## work through all smooths
1218,1220c1218,1220
<   { if (length(min.sp)!=nrow(L)) stop("length of min.sp is wrong.")
<     if (sum(is.na(min.sp))) stop("NA's in min.sp.")
<     if (sum(min.sp<0)) stop("elements of min.sp must be non negative.")
---
>   { if (length(min.sp)!=nrow(L)) stop(gettextf("'%s' argument is of the wrong length", "min.sp"))
>     if (sum(is.na(min.sp))) stop("NA values in 'min.sp' argument")
>     if (sum(min.sp<0)) stop("elements of 'min.sp' argument must be non negative")
1225c1225
<   if (m>0) for (i in 1:m) {
---
>   if (m>0) for (i in seq_len(m)) {
1228c1228
<     for (j in 1:length(sm$S)) {  # work through penalty matrices
---
>     for (j in seq_len(length(sm$S))) {  # work through penalty matrices
1254c1254
<       for (i in 1:length(PP$S)) {
---
>       for (i in seq_len(length(PP$S))) {
1271c1271
<     if (length(indi)>0) for (i in 1:length(indi)) {
---
>     if (length(indi)>0) for (i in seq_len(length(indi))) {
1294c1294
<       for (i in 1:m) {
---
>       for (i in seq_len(m)) {
1320c1320
<   for (i in 1:n.smooth) { ## create coef names, if smooth has any coefs!
---
>   for (i in seq_len(n.smooth)) { ## create coef names, if smooth has any coefs!
1358c1358
<   warning("`negbin' with unknown theta and outer iteration is deprecated - use `nb'. ")
---
>   warning("'negbin()' with unknown theta and outer iteration is deprecated - use 'nb()'.")
1378c1378
<   for (i in 1:n.th) { ## search through theta values
---
>   for (i in seq_len(n.th)) { ## search through theta values
1503c1503
<   if (!optimizer[2]%in%c("newton","bfgs","nlm","optim","nlm.fd")) stop("unknown outer optimization method.")
---
>   if (!optimizer[2]%in%c("newton","bfgs","nlm","optim","nlm.fd")) stop("unknown outer optimization method")
1535c1535
<       warning("only outer methods `newton' & `bfgs' supports `negbin' family and theta selection: reset")
---
>       warning("only outer methods 'newton' & 'bfgs' supports 'negbin' family and theta selection: reset")
1674c1674
<   if (length(G$S)>0) for (i in 1:length(G$S)) G$UrS[[i]] <- t(Ssp$Y)%*%G$rS[[i]] else i <- 0
---
>   if (length(G$S)>0) for (i in seq_len(length(G$S))) G$UrS[[i]] <- t(Ssp$Y)%*%G$rS[[i]] else i <- 0
1796c1796
<       ind <- 1:nlsp + nth ## only used if nlsp>0
---
>       ind <- seq_len(nlsp) + nth ## only used if nlsp>0
1873c1873
<    ## if (v.n) for (i in 1:v.n) if (length(dl[[i]])<n) dl[[i]] <- NULL 
---
>    ## if (v.n) for (i in seq_len(v.n)) if (length(dl[[i]])<n) dl[[i]] <- NULL 
1878c1878
<      for (i in 1:v.n) if (length(dl[[i]])>=n) { 
---
>      for (i in seq_len(v.n)) if (length(dl[[i]])>=n) { 
1889c1889
<    if (v.n>0) for (i in 1:v.n) {
---
>    if (v.n>0) for (i in seq_len(v.n)) {
1973c1973
<       for (i in 1:length(formula)) {
---
>       for (i in seq_len(length(formula))) {
2022c2022
<     if (G$m) for (i in 1:G$m) G$min.edf<-G$min.edf+G$smooth[[i]]$null.space.dim
---
>     if (G$m) for (i in seq_len(G$m)) G$min.edf<-G$min.edf+G$smooth[[i]]$null.space.dim
2082c2082
<   if (is.list(x$formula)) for (i in 1:length(x$formula)) print(x$formula[[i]]) else
---
>   if (is.list(x$formula)) for (i in seq_len(length(x$formula))) print(x$formula[[i]]) else
2086c2086
<   cat("Total model degrees of freedom",sum(x$edf),"\n")
---
>   cat(gettextf("Total model degrees of freedom %s",sum(x$edf), domain = "R-mgcv"), "\n", sep = "")
2089,2090c2089,2090
<     cat("\nEstimated degrees of freedom:\n")
<     for (i in 1:n.smooth)
---
>     cat("\n", gettext("Estimated degrees of freedom:", domain = "R-mgcv"), "\n", sep = "")
>     for (i in seq_len(n.smooth))
2093c2093
<     for (i in 1:n.smooth) {   
---
>     for (i in seq_len(n.smooth)) {   
2097c2097
<     cat(" total =",round(sum(x$edf),digits=2),"\n")
---
>     cat(gettextf(" total df = %s",round(sum(x$edf),digits=2), domain = "R-mgcv"), "\n", sep = "")
2100,2101c2100,2101
<   cat("\n",x$method," score: ",x$gcv.ubre,"     ",sep="")
<   if (!is.null(x$rank) && x$rank< length(x$coefficients)) cat("rank: ",x$rank,"/",length(x$coefficients),sep="") 
---
>   cat("\n", gettextf("%s score = %s", sQuote(x$method), x$gcv.ubre, domain = "R-mgcv"), "     ", sep = "")
>   if (!is.null(x$rank) && x$rank< length(x$coefficients)) cat(gettextf("Rank: %s/%s", x$rank, length(x$coefficients), domain = "R-mgcv"), sep = "") 
2122,2123c2122,2123
<     if (!is.numeric(nthreads) || nthreads <1) stop("nthreads must be a positive integer") 
<     if (!is.numeric(irls.reg) || irls.reg <0.0) stop("IRLS regularizing parameter must be a non-negative number.")
---
>     if (!is.numeric(nthreads) || nthreads <1) stop("'nthreads' argument must be a positive integer") 
>     if (!is.numeric(irls.reg) || irls.reg <0.0) stop("IRLS regularizing parameter must be a non-negative number")
2130c2130
<       warning("silly value supplied for rank.tol: reset to square root of machine precision.")
---
>       warning("silly value supplied for rank.tol: reset to square root of machine precision")
2222c2222
<   for (i in 1:length(G$S))
---
>   for (i in seq_len(length(G$S)))
2277c2277
<       for (i in 1:n.S) S.size[i]<-mean(abs(G$S[[i]])) 
---
>       for (i in seq_len(n.S)) S.size[i]<-mean(abs(G$S[[i]])) 
2289c2289
<         stop("illegal `family' argument")
---
>         stop("invalid 'family' argument")
2304c2304
<         stop("y must be univariate unless binomial")
---
>         stop("'y' must be univariate unless binomial")
2312c2312
<     stop(gettextf("Length of start should equal %d and correspond to initial coefs.",nvars)) 
---
>     stop(gettextf("Length of start should equal %d and correspond to initial coefs", nvars))
2332c2332
<     for (iter in 1:(control$maxit)) 
---
>     for (iter in seq_len(control$maxit)) 
2337c2337
<             stop("NAs in V(mu)")
---
>             stop("NA values in V(mu)")
2342c2342
<             stop("NAs in d(mu)/d(eta)")
---
>             stop("NA values in d(mu)/d(eta)")
2366c2366
<         stop("iterative weights or data non-finite in gam.fit - regularization may help. See ?gam.control.")
---
>         stop("iterative weights or data non-finite in gam.fit - regularization may help. See ?gam.control")
2404,2405c2404
<             stop("no valid set of coefficients has been found:please supply starting values",
<             call. = FALSE)
---
>             stop("no valid set of coefficients has been found:please supply starting values", call. = FALSE)
2410c2409
<                   stop("inner loop 1; can't correct step size")
---
>                   stop(gettextf("inner loop %d; can't correct step size", 1))
2420c2419
<                 cat("Step halved: new deviance =", dev, "\n")
---
>                 cat(gettextf("Step halved: new deviance = %g", dev, domain = "R-mgcv"), "\n", sep = "")
2423c2422
<             warning("Step size truncated: out of bounds.",call.=FALSE)
---
>             warning("Step size truncated: out of bounds",call. = FALSE)
2427c2426
<                   stop("inner loop 2; can't correct step size")
---
>                   stop(gettextf("inner loop %d; can't correct step size", 2))
2437c2436
<                 cat("Step halved: new deviance =", dev, "\n")
---
>                 cat(gettextf("Step halved: new deviance = %g", dev, domain = "R-mgcv"), "\n", sep = "")
2508c2507
< { if (!inherits(object,"gam")) stop("`object' is not of class \"gam\"")
---
> { if (!inherits(object,"gam")) stop(gettextf("'%s' argument is not an object of class %s", "object", dQuote("gam")))
2558c2557
<     warning("Unknown type, reset to terms.")
---
>     warning("Unknown type, reset to terms")
2590,2591c2589
<         if (sum(!(names(object$model)%in%names(newdata)))) stop(
<         "newdata is a model.frame: it should contain all required variables\n")
---
>         if (sum(!(names(object$model)%in%names(newdata)))) stop("newdata is a model.frame: it should contain all required variables\n")
2648c2646
<     for (i in 1:length(newdata)) 
---
>     for (i in seq_len(length(newdata))) 
2653c2651
<         msg <- paste(paste(levn[!levn%in%levm],collapse=", "),"not in original fit",collapse="")
---
>         msg <- gettextf("%s not in original fit", paste(levn[!levn%in%levm], collapse = ", "), domain = "R-mgcv")
2716c2714
<       warning("type iterms not available for multiple predictor cases")
---
>       warning("type 'iterms' is not available for multiple predictor cases")
2722c2720
<     for (i in 1:length(object$nsdf)) {
---
>     for (i in seq_len(length(object$nsdf))) {
2724c2722
<       if (object$nsdf[i]>0) pind <- c(pind,pstart[i]-1+1:object$nsdf[i])
---
>       if (object$nsdf[i]>0) pind <- c(pind,pstart[i]-1+seq_len(object$nsdf[i]))
2730c2728
<     pind <- 1:object$nsdf ## index of parameteric coefficients
---
>     pind <- seq_len(object$nsdf) ## index of parameteric coefficients
2738c2736
<     for (i in 1:length(Terms)) attr(Terms[[i]],"intercept") <- 1 
---
>     for (i in seq_len(length(Terms))) attr(Terms[[i]],"intercept") <- 1 
2753c2751
<   if (n.blocks > 0) for (b in 1:n.blocks) { # work through prediction blocks
---
>   if (n.blocks > 0) for (b in seq_len(n.blocks)) { # work through prediction blocks
2759c2757
<     for (i in 1:length(Terms)) { ## loop for parametric components (1 per lp)
---
>     for (i in seq_len(length(Terms))) { ## loop for parametric components (1 per lp)
2778c2776
<       if (object$nsdf[i]>0) X[,pstart[i]-1 + 1:object$nsdf[i]] <- Xp
---
>       if (object$nsdf[i]>0) X[,pstart[i]-1 + seq_len(object$nsdf[i])] <- Xp
2783c2781
<     if (n.smooth) for (k in 1:n.smooth) { ## loop through smooths
---
>     if (n.smooth) for (k in seq_len(n.smooth)) { ## loop through smooths
2808,2809c2806,2807
<       for (j in 1:length(lass)) if (length(lass[[j]])) { ## work through assign list
<         ind <- 1:length(lass[[j]]) ## index vector for coefs involved
---
>       for (j in seq_len(length(lass))) if (length(lass[[j]])) { ## work through assign list
>         ind <- seq_len(length(lass[[j]])) ## index vector for coefs involved
2811c2809
<         if (nptj>0) for (i in 1:nptj) { ## work through parametric part
---
>         if (nptj>0) for (i in seq_len(nptj)) { ## work through parametric part
2820c2818
<         for (k in 1:n.smooth) # work through the smooth terms 
---
>         for (k in seq_len(n.smooth)) # work through the smooth terms 
2865,2866c2863,2864
<           off.ind <- (1:n.smooth)[as.logical(colSums(abs(Xoff)))]
<           for (j in 1:nlp) { ## looping over the model formulae
---
>           off.ind <- seq_len(n.smooth)[as.logical(colSums(abs(Xoff)))]
>           for (j in seq_len(nlp)) { ## looping over the model formulae
3004c3002
<   if (!inherits(b,"gam")) stop("requires an object of class gam")
---
>   if (!inherits(b,"gam")) stop(gettextf("'%s' argument is not an object of class %s", "b", dQuote("gam")))
3013c3011
<   for (i in 1:m) { ## loop through smooths
---
>   for (i in seq_len(m)) { ## loop through smooths
3031c3029
<     for (i in 1:m) {
---
>     for (i in seq_len(m)) {
3052,3053c3050,3051
<     for (i in 1:n.measures) conc[[i]] <- matrix(1,m,m) ## concurvity matrix
<     for (i in 1:m) { ## concurvity calculation loop
---
>     for (i in seq_len(n.measures)) conc[[i]] <- matrix(1,m,m) ## concurvity matrix
>     for (i in seq_len(m)) { ## concurvity calculation loop
3056c3054
<       for (j in 1:m) if (i!=j) { 
---
>       for (j in seq_len(m)) if (i!=j) { 
3078c3076
<     for (i in 1:n.measures) rownames(conc[[i]]) <- colnames(conc[[i]]) <- lab
---
>     for (i in seq_len(n.measures)) rownames(conc[[i]]) <- colnames(conc[[i]]) <- lab
3112c3110
<       warning("Pearson residuals not available for this family - returning deviance residuals")
---
>       warning("Pearson residuals are not available for this family - returning deviance residuals")
3139c3137
<   f <- t(ed$vectors[,1:k])%*%R%*%b
---
>   f <- t(ed$vectors[,seq_len(k)])%*%R%*%b
3162c3160
< #    for (i in 1:length(x)) r[i] <- davies(x[i],lambda,h)$Qq
---
> #    for (i in seq_len(length(x))) r[i] <- davies(x[i],lambda,h)$Qq
3166c3164
<   if (length(h) != length(lambda)) stop("lambda and h should have the same length!")
---
>   if (length(h) != length(lambda)) stop(gettextf("'%s' and '%s' arguments should have the same length", "lambda", "h"))
3225c3223
<   if (!inherits(b,"gam")) stop("recov works with fitted gam objects only") 
---
>   if (!inherits(b,"gam")) stop(gettextf("'%s' argument is not an object of class %s", "b", dQuote("gam")))
3232c3230
<       for (i in 1:length(b$smooth)) { 
---
>       for (i in seq_len(length(b$smooth))) { 
3235c3233
<         if (ns>0) for (j in 1:ns) {
---
>         if (ns>0) for (j in seq_len(ns)) {
3251c3249
<   if (m%in%re) stop("m can't be in re")
---
>   if (m%in%re) stop("'m' argument  can't be in 're' argument")
3255c3253
<   for (i in 1:length(re)) {
---
>   for (i in seq_len(length(re))) {
3273c3271
<   for (i in 1:length(b$smooth)) { 
---
>   for (i in seq_len(length(b$smooth))) { 
3277c3275
<     if (ns>0) for (j in 1:ns) {
---
>     if (ns>0) for (j in seq_len(ns)) {
3336c3334
<   for (i in 1:length(b$smooth)) if (!is.null(b$smooth[[i]]$random)&&b$smooth[[i]]$random&&i!=m) rind <- c(rind,i)
---
>   for (i in seq_len(length(b$smooth))) if (!is.null(b$smooth[[i]]$random)&&b$smooth[[i]]$random&&i!=m) rind <- c(rind,i)
3429c3427
<             t(t(vec)/sqrt(ed$val[1:k]))
---
>             t(t(vec)/sqrt(ed$val[seq_len(k)]))
3506c3504
<     warning("p-values for any terms that can be penalized to zero will be unreliable: refit model to fix this.")
---
>     warning("p-values for any terms that can be penalized to zero will be unreliable: refit model to fix this")
3512c3510
<   if (p.type!=0) warning("p.type!=0 is deprecated, and liable to be removed in future")
---
>   if (p.type!=0) warning("'p.type != 0' is deprecated, and liable to be removed in future")
3615c3613
<     for (i in 1:m) { 
---
>     for (i in seq_len(m)) { 
3648c3646
<     for (i in 1:m) { ## loop through smooths
---
>     for (i in seq_len(m)) { ## loop through smooths
3734c3732
<   cat("Formula:\n") 
---
>   cat(gettext("Formula:", domain = "R-mgcv"), "\n", sep = "")
3740c3738
<   { cat("\nParametric coefficients:\n")
---
>   { cat("\n", gettext("Parametric coefficients:", domain = "R-mgcv"), "\n", sep = "")
3745c3743
<   { cat("Approximate significance of smooth terms:\n")
---
>   { cat(gettext("Approximate significance of smooth terms:", domain = "R-mgcv"), "\n", sep = "")
3749,3751c3747,3749
<   if (!is.null(x$rank) && x$rank< x$np) cat("Rank: ",x$rank,"/",x$np,"\n",sep="") 
<   if (!is.null(x$r.sq)) cat("R-sq.(adj) = ",formatC(x$r.sq,digits=3,width=5),"  ")
<   if (length(x$dev.expl)>0) cat("Deviance explained = ",formatC(x$dev.expl*100,digits=3,width=4),"%",sep="")
---
>   if (!is.null(x$rank) && x$rank< x$np) cat(gettextf("Rank: %s/%s", x$rank, x$np, domain = "R-mgcv"), "\n", sep = "")
>   if (!is.null(x$r.sq)) cat(gettextf("R-sq.(adj) = %s", formatC(x$r.sq,digits=3,width=5), domain = "R-mgcv"), "  ", sep = "")
>   if (length(x$dev.expl)>0) cat(gettextf("Deviance explained = %s %%", formatC(x$dev.expl*100,digits=3,width=4), domain = "R-mgcv"), sep = "")
3756c3754
<   cat("  Scale est. = ",formatC(x$scale,digits=5,width=8,flag="-"),"  n = ",x$n,"\n",sep="")
---
>   cat(gettextf("  Scale est. = %s  n = %s", formatC(x$scale,digits=5,width=8,flag="-"), x$n, domain = "R-mgcv"), "\n", sep = "")
3769,3770c3767
<         warning("The following arguments to anova.glm(..) are invalid and dropped: ",
<             paste(deparse(dotargs[named]), collapse = ", "))
---
>         warning(gettext("The following arguments to anova.glm(..) are invalid and dropped: ", domain = "R-mgcv"), paste(deparse(dotargs[named]), collapse = ", "), domain = NA)
3780,3781c3777,3778
<     if (!is.null(test)) warning("test argument ignored")
<     if (!inherits(object,"gam")) stop("anova.gam called with non gam object")
---
>     if (!is.null(test)) warning("'test' argument ignored")
>     if (!inherits(object,"gam")) stop(gettextf("'%s' argument is not an object of class %s", "object", dQuote("gam")))
3792c3789
<   cat("Formula:\n") 
---
>   cat(gettext("Formula:", domain = "R-mgcv"), "\n", sep = "")
3796c3793
<   { cat("\nParametric Terms:\n")
---
>   { cat("\n", gettext("Parametric Terms:", domain = "R-mgcv"), "\n", sep = "")
3801c3798
<   { cat("Approximate significance of smooth terms:\n")
---
>   { cat(gettext("Approximate significance of smooth terms:", domain = "R-mgcv"), "\n", sep = "")
3815c3812
<   if (!inherits(x,"gam")) stop("not a gam object")
---
>   if (!inherits(x,"gam")) stop(gettextf("'%s' argument is not an object of class %s", "x", dQuote("gam")))
3820c3817
<   for (i in 1:length(x$smooth)) { ## work through smooths
---
>   for (i in seq_len(length(x$smooth))) { ## work through smooths
3826c3823
<       for (j in 1:length(x$smooth[[i]]$S)) {
---
>       for (j in seq_len(length(x$smooth[[i]]$S))) {
3852c3849
<   if (!inherits(x,"gam")) stop("argument is not a gam object")
---
>   if (!inherits(x,"gam")) stop(gettextf("'%s' argument is not an object of class %s", "x", dQuote("gam")))
3861c3858
<   if (!inherits(x,"gam")) stop("requires an object of class gam")
---
>   if (!inherits(x,"gam")) stop(gettextf("'%s' argument is not an object of class %s", "x", dQuote("gam")))
3875c3872
<     if (m>0) for (i in 1:m) { ## loop through all smooths
---
>     if (m>0) for (i in seq_len(m)) { ## loop through all smooths
3887,3888c3884,3885
<          warning("S.scale vector doesn't match S list - please report to maintainer")
<         for (j in 1:length(x$smooth[[i]]$S.scale)) {
---
>          warning("'S.scale' vector doesn't match S list - please report to maintainer")
>         for (j in seq_len(length(x$smooth[[i]]$S.scale))) {
3903c3900
<         for (j in 1:length(x$smooth[[ii]]$S.scale)) {
---
>         for (j in seq_len(length(x$smooth[[ii]]$S.scale))) {
3955c3952
<     cat(paste("Standard deviations and",conf.lev,"confidence intervals:\n\n"))
---
>     cat(gettextf("Standard deviations and %s confidence intervals:", conf.lev, domain = "R-mgcv"), "\n\n", sep = "")
3957c3954
<     cat("\nRank: ");cat(rank);cat("/");cat(ncol(H));cat("\n")
---
>     cat("\n", gettextf("Rank: %s/%s", rank, ncol(H), domain = "R-mgcv"), "\n", sep = "")
3959c3956
<       cat("\nAll smooth components:\n")
---
>       cat("\n", gettext("All smooth components:", domain = "R-mgcv"), "\n", sep = "")
4034,4035c4031,4032
<     d<-um$d[1:rank]^0.5
<     return(t(t(um$u[,1:rank])*as.vector(d))) # note recycling rule used for efficiency
---
>     d<-um$d[seq_len(rank)]^0.5
>     return(t(t(um$u[,seq_len(rank)])*as.vector(d))) # note recycling rule used for efficiency
4047c4044
<     L <- L[,piv,drop=FALSE]; L <- t(L[1:rank,,drop=FALSE])
---
>     L <- L[,piv,drop=FALSE]; L <- t(L[seq_len(rank),,drop=FALSE])
4050c4047
<   stop("method not recognised.")
---
>   stop("method was not recognised")
4127c4124
<     for (i in 1:length(S)) {
---
>     for (i in seq_len(length(S))) {
4155c4152
<       for (i in 1:length(S)) {
---
>       for (i in seq_len(length(S))) {
4186c4183
<     for (i in 1:n.p) { # loop over penalties
---
>     for (i in seq_len(n.p)) { # loop over penalties
4200c4197
<       if (sizeS <= 0) stop(gettextf("S[[%d]] matrix is not +ve definite.", i)) 
---
>       if (sizeS <= 0) stop(gettextf("S[[%d]] matrix is not +ve definite", i))
4261,4263c4258,4260
<     if (!inherits(L,"matrix")) stop("L must be a matrix.")
<     if (nrow(L)<ncol(L)) stop("L must have at least as many rows as columns.")
<     if (nrow(L)!=n.p||ncol(L)!=length(sp)) stop("L has inconsistent dimensions.")
---
>     if (!inherits(L,"matrix")) stop("'L' argument must be a matrix")
>     if (nrow(L)<ncol(L)) stop("'L' argument must have at least as many rows as columns")
>     if (nrow(L)!=n.p||ncol(L)!=length(sp)) stop("'L' argument has inconsistent dimensions")
4270c4267
<   { for (i in 1:n.p) 
---
>   { for (i in seq_len(n.p)) 
4290c4287
<     if (n.p>0) for (i in 1:n.p) { 
---
>     if (n.p>0) for (i in seq_len(n.p)) { 
4307c4304
<     { if (dim(w)[1]!=dim(w)[2]||dim(w)[2]!=dim(X)[1]) stop("dimensions of supplied w wrong.")
---
>     { if (dim(w)[1]!=dim(w)[2]||dim(w)[2]!=dim(X)[1]) stop("dimensions of supplied 'w' argument is wrong")
4311c4308
<     { if (length(y)!=length(w)) stop("w different length from y!")
---
>     { if (length(y)!=length(w)) stop("'w' argument has different length from 'y' argument!")
4318c4315
<     if (n!=length(X)) stop("X lost dimensions in magic!!")
---
>     if (n!=length(X)) stop("'X' lost dimensions in magic!!")
4323c4320
<   if (n.p>0) for (i in 1:n.p) { 
---
>   if (n.p>0) for (i in seq_len(n.p)) { 
4364c4361
< } ## magic
---
> }
4372c4369
<   hello <- paste("This is mgcv ",version,". For overview type 'help(\"mgcv-package\")'.",sep="")
---
>   hello <- gettextf("This is mgcv %s. For overview type 'help(\"mgcv-package\")'", paste(version, collapse = ""), domain = "R-mgcv")
diff -rEZbwB '--exclude=*.[lo,d,pdf,mo,po,tgz,gz,save]*' '--exclude=MD5' '--exclude=Makefile*' '--exclude=all.R' '--exclude=Changes' R-recommended/mgcv/R/misc.r Recommended/mgcv/R/misc.r
11c11
<     if (ncol(mu)!=p||nrow(mu)!=n) stop("mu dimensions wrong")
---
>     if (ncol(mu)!=p||nrow(mu)!=n) stop("'mu' dimensions are wrong")
14c14
<     if (length(mu)!=p) stop("mu dimensions wrong")
---
>     if (length(mu)!=p) stop("'mu' dimensions are wrong")
46,47c46,47
<     dH <- list();ind <- 1:(nb*nb)
<     for (i in 1:nsp) { 
---
>     dH <- list();ind <- seq_len(nb*nb)
>     for (i in seq_len(nsp)) { 
69c69
<   for (i in 1:nt) pt <- pt + prod(p[ts[i]:(ts[i]+dt[i]-1)]) - as.numeric(qc[i]>0) 
---
>   for (i in seq_len(nt)) pt <- pt + prod(p[ts[i]:(ts[i]+dt[i]-1)]) - as.numeric(qc[i]>0) 
83c83
<   for (i in 1:nt) pt <- pt + prod(p[ts[i]:(ts[i]+dt[i]-1)]) - as.numeric(qc[i]>0) 
---
>   for (i in seq_len(nt)) pt <- pt + prod(p[ts[i]:(ts[i]+dt[i]-1)]) - as.numeric(qc[i]>0) 
133c133
<     piv <- 1:ncol(X); piv[qrx$pivot] <- 1:ncol(X)
---
>     piv <- seq_len(ncol(X)); piv[qrx$pivot] <- seq_len(ncol(X))
135c135
<     d <- er$d*0;d[1:rr] <- 1/er$d[1:rr]
---
>     d <- er$d*0;d[seq_len(rr)] <- 1/er$d[seq_len(rr)]
139c139
<     Ri[1:rr,1:rr] <- backsolve(R[1:rr,1:rr],diag(rr))
---
>     Ri[seq_len(rr),seq_len(rr)] <- backsolve(R[seq_len(rr),seq_len(rr)],diag(rr))
268,269c268,269
<     if (is.matrix(a)) { if (nrow(a) != x$r) stop("a has wrong number of rows") }
<     else if (length(a) != x$r) stop("a has wrong number of rows")
---
>     if (is.matrix(a)) { if (nrow(a) != x$r) stop("'a' argument has wrong number of rows") }
>     else if (length(a) != x$r) stop("'a' argument has wrong number of rows")
271,272c271,272
<     if (is.matrix(a)) { if (nrow(a) != x$c) stop("a has wrong number of rows") }
<     else if (length(a) != x$c)  stop("a has wrong number of rows")
---
>     if (is.matrix(a)) { if (nrow(a) != x$c) stop("'a' argument has wrong number of rows") }
>     else if (length(a) != x$c)  stop("'a' argument has wrong number of rows")
diff -rEZbwB '--exclude=*.[lo,d,pdf,mo,po,tgz,gz,save]*' '--exclude=MD5' '--exclude=Makefile*' '--exclude=all.R' '--exclude=Changes' R-recommended/mgcv/R/mvam.r Recommended/mgcv/R/mvam.r
195c195
<       for (i in 1:(m-1)) lpstart[i] <- lpi[[i+1]][1]
---
>       for (i in seq_len(m-1)) lpstart[i] <- lpi[[i+1]][1]
219c219
<         for (i in 1:nsp) { 
---
>         for (i in seq_len(nsp)) { 
226,227c226,227
<         d1H <- list();ind <- 1:(nb*nb)
<         for (i in 1:nsp) { 
---
>         d1H <- list();ind <- seq_len(nb*nb)
>         for (i in seq_len(nsp)) { 
diff -rEZbwB '--exclude=*.[lo,d,pdf,mo,po,tgz,gz,save]*' '--exclude=MD5' '--exclude=Makefile*' '--exclude=all.R' '--exclude=Changes' R-recommended/mgcv/R/plots.r Recommended/mgcv/R/plots.r
26c26
<         stop("fam not a family object")
---
>         stop(gettextf("'%s' argument is not an object of class %s", "fam", dQuote("family")))
53c53
<         stop("fam not a family object")
---
>         stop(gettextf("'%s' argument is not an object of class %s", "fam", dQuote("family")))
90c90
<   } else stop("object is not a glm or gam")
---
>   } else stop("'object' argument is not an object of class \"glm\" or \"gam\"")
117c117
<       for (i in 1:rep) { 
---
>       for (i in seq_len(rep)) { 
126c126
<       Dq <- quantile(as.numeric(dm),(1:n - .5)/n) 
---
>       Dq <- quantile(as.numeric(dm),(seq_len(n) - .5)/n) 
141c141
<       for (i in 1:s.rep) { 
---
>       for (i in seq_len(s.rep)) { 
159c159
<   { qqplot(Dq,D,ylab=ylab,xlab="theoretical quantiles",ylim=range(c(lim,D)),
---
>   { qqplot(Dq,D,ylab=ylab,xlab=gettext("theoretical quantiles", domain = "R-mgcv"), ylim=range(c(lim,D)),
163c163
<       if (level>=1) for (i in 1:rep) lines(Dq,dm[,i],col=rep.col) else {
---
>       if (level>=1) for (i in seq_len(rep)) lines(Dq,dm[,i],col=rep.col) else {
193c193
<   for (k in 1:m) { ## work through smooths
---
>   for (k in seq_len(m)) { ## work through smooths
205c205
<     for (j in 1:nc) if (is.factor(dat[[j]])) ok <- FALSE 
---
>     for (j in seq_len(nc)) if (is.factor(dat[[j]])) ok <- FALSE 
212c212
<         for (i in 1:n.rep) {
---
>         for (i in seq_len(n.rep)) {
224c224
<           for (i in 1:nc) {
---
>           for (i in seq_len(nc)) {
230c230
<           for (i in 1:nc) { ## rescale distances
---
>           for (i in seq_len(nc)) { ## rescale distances
240c240
<         for (i in 1:n.rep) {
---
>         for (i in seq_len(n.rep)) {
275,277c275,277
<     plot(linpred, resid,main="Resids vs. linear pred.",
<          xlab="linear predictor",ylab="residuals",...)
<     hist(resid,xlab="Residuals",main="Histogram of residuals",...)
---
>     plot(linpred, resid,main=gettext("Resids vs. linear pred.", domain = "R-mgcv"),
>          xlab=gettext("linear predictor", domain = "R-mgcv"), ylab=gettext("Residuals", domain = "R-mgcv"),...)
>     hist(resid,xlab=gettext("Residuals", domain = "R-mgcv"), main=gettext("Histogram of residuals", domain = "R-mgcv"),...)
281c281
<          xlab="Fitted Values",ylab="Response",main="Response vs. Fitted Values",...)
---
>          xlab=gettext("Fitted Values", domain = "R-mgcv"), ylab=gettext("Response", domain = "R-mgcv"), main=gettext("Response vs. Fitted Values", domain = "R-mgcv"),...)
287c287
<     cat("\nMethod:",b$method,"  Optimizer:",b$optimizer)
---
>     cat("\n", gettextf("Method: %s  Optimizer: %s", paste(b$method, collapse = ""), paste(b$optimizer, collapse = ""), domain = "R-mgcv"))
291,294c291,293
<         cat("\n",boi$conv," after ",boi$iter," iteration",sep="")
<         if (boi$iter==1) cat(".") else cat("s.")
<         cat("\nGradient range [",min(boi$grad),",",max(boi$grad),"]",sep="")
<         cat("\n(score ",b$gcv.ubre," & scale ",b$sig2,").",sep="")
---
>         cat("\n", sprintf(ngettext(boi$iter, "%s after %d iteration.", "%s after %d iterations.", domain = "R-mgcv"), boi$conv, boi$iter), sep = "")
>         cat("\n", gettextf("Gradient range [%s, %s]", min(boi$grad), max(boi$grad), domain = "R-mgcv"), sep = "")
>         cat("\n", gettextf("(score %s & scale %s).", b$gcv.ubre, b$sig2, domain = "R-mgcv"), sep = "")
296,297c295,296
<         if (min(ev)>0) cat("\nHessian positive definite, ") else cat("\n")
<         cat("eigenvalue range [",min(ev),",",max(ev),"].\n",sep="")
---
>         if (min(ev)>0) cat("\n", gettext("Hessian positive definite, eigenvalue range [%s, %s].", domain = "R-mgcv"), "\n", sep = "")
> 	 else cat("\n", gettextf("eigenvalue range [%s, %s].", min(ev), max(ev), domain = "R-mgcv"), "\n", sep = "")
303c302
<         cat("\nModel required no smoothing parameter selection")
---
>         cat("\n", gettext("Model required no smoothing parameter selection", domain = "R-mgcv"), "\n", sep = "")
305,310c304,312
<         cat("\nSmoothing parameter selection converged after",b$mgcv.conv$iter,"iteration")       
<         if (b$mgcv.conv$iter>1) cat("s")
<          
<         if (!b$mgcv.conv$fully.converged)
<         cat(" by steepest\ndescent step failure.\n") else cat(".\n")
<         cat("The RMS",b$method,"score gradiant at convergence was",b$mgcv.conv$rms.grad,".\n")
---
>      if (!b$mgcv.conv$fully.converged) {
>         cat("\n", sprintf(ngettext(b$mgcv.conv$iter, "Smoothing parameter selection converged after %d iteration by steepest descent step failure.",
> 				"Smoothing parameter selection converged after %d iterations by steepest descent step failure.",
> 				 domain = "R-mgcv"), b$mgcv.conv$iter), "\n", sep = "")
>      } else {
>         cat("\n", sprintf(ngettext(b$mgcv.conv$iter, "Smoothing parameter selection converged after %d iteration.",
> 				"Smoothing parameter selection converged after %d iterations.", domain = "R-mgcv"), b$mgcv.conv$iter), sep = "")       
>     }
>         cat(gettextf("The RMS %s score gradient at convergence was %s.", b$method, b$mgcv.conv$rms.grad, domain = "R-mgcv"),"\n", sep = "")
312,314c314,315
<         cat("The Hessian was positive definite.\n") else cat("The Hessian was not positive definite.\n")
<         cat("The estimated model rank was ",b$mgcv.conv$rank,
<                    " (maximum possible: ",b$mgcv.conv$full.rank,")\n",sep="")
---
>         cat(gettext("The Hessian was positive definite.", domain = "R-mgcv"), "\n", sep = "") else cat(gettext("The Hessian was not positive definite.", domain = "R-mgcv"), "\n", sep = "")
>         cat(gettextf("The estimated model rank was %s (maximum possible: %s)", b$mgcv.conv$rank, b$mgcv.conv$full.rank, domain = "R-mgcv"), "\n", sep = "")
318c319
<       cat("Model rank = ",b$rank,"/",length(b$coefficients),"\n")
---
>       cat(gettextf("Model rank = %s/%s", b$rank, length(b$coefficients), domain = "R-mgcv"), "\n", sep = "")
325,326c326
<       cat("Basis dimension (k) checking results. Low p-value (k-index<1) may\n") 
<       cat("indicate that k is too low, especially if edf is close to k\'.\n\n")
---
>       cat(gettext("Basis dimension (k) checking results. Low p-value (k-index<1) may\nindicate that k is too low, especially if edf is close to k.", domain = "R-mgcv"), "\n\n", sep = "")
349,350c349,350
<       if (is.null(xlab)) xlabel<- "Gaussian quantiles" else xlabel <- xlab
<       if (is.null(ylab)) ylabel <- "effects" else ylabel <- ylab
---
>       if (is.null(xlab)) xlabel<- gettext("Gaussian quantiles", domain = "R-mgcv") else xlabel <- xlab
>       if (is.null(ylab)) ylabel <- gettext("effects", domain = "R-mgcv") else ylabel <- ylab
567c567
<   for (i in 1:length(pc)) {
---
>   for (i in seq_len(length(pc))) {
587c587
<      for (i in 1:length(pc)) { 
---
>      for (i in seq_len(length(pc))) { 
595c595
<       if (all.equal(sort(nz),sort(npc))!=TRUE) stop("names of z and pc must match")
---
>       if (all.equal(sort(nz),sort(npc))!=TRUE) stop("names of 'z' and 'pc' must match")
611c611
<     for (i in 1:length(pc)) pc[[i]][,2] <- zlim[1] + 
---
>     for (i in seq_len(length(pc))) pc[[i]][,2] <- zlim[1] + 
616c616
<     for (i in 1:length(pc)) {
---
>     for (i in seq_len(length(pc))) {
630c630
<     for (i in 1:n.col) {
---
>     for (i in seq_len(n.col)) {
1040c1040
<     warn <- paste("scheme should be a single number, or a vector with",m,"elements")
---
>     warn <- gettextf("scheme should be a single number, or a vector with %d elements", m)
1079c1079
<   if (m>0) for (i in 1:m) { ## work through smooth terms
---
>   if (m>0) for (i in seq_len(m)) { ## work through smooth terms
1130c1130
<   if (m>0) for (i in 1:m) n.plots <- n.plots + as.numeric(pd[[i]]$plot.me) 
---
>   if (m>0) for (i in seq_len(m)) n.plots <- n.plots + as.numeric(pd[[i]]$plot.me) 
1171c1171
<     if (m>0) for (i in 1:m) if (pd[[i]]$plot.me&&pd[[i]]$scale) { ## loop through plot data 
---
>     if (m>0) for (i in seq_len(m)) if (pd[[i]]$plot.me&&pd[[i]]$scale) { ## loop through plot data 
1202c1202
<   if (m>0) for (i in 1:m) if (pd[[i]]$plot.me&&(is.null(select)||i==select)) {
---
>   if (m>0) for (i in seq_len(m)) if (pd[[i]]$plot.me&&(is.null(select)||i==select)) {
1301c1301
<     for (i in 1:length(v.names)) {
---
>     for (i in seq_len(length(v.names))) {
1318,1319c1318
< 
<     for (i in 1:2) 
---
>     for (i in seq_len(2)) 
1325c1324
<   for (i in 1:2) if (is.factor(x$var.summary[[view[i]]])) {
---
>   for (i in seq_len(2)) if (is.factor(x$var.summary[[view[i]]])) {
1345c1344
<   for (i in 1:length(x$var.summary)) { 
---
>   for (i in seq_len(length(x$var.summary))) { 
1358,1359c1357,1358
<   if (type=="link") zlab<-paste("linear predictor") ## ignore codetools
<   else if (type=="response") zlab<-type
---
>   if (type=="link") zlab<-gettext("linear predictor", domain = "R-mgcv") ## ignore codetools
>   else if (type=="response") zlab<-gettext("response", domain = "R-mgcv")
diff -rEZbwB '--exclude=*.[lo,d,pdf,mo,po,tgz,gz,save]*' '--exclude=MD5' '--exclude=Makefile*' '--exclude=all.R' '--exclude=Changes' R-recommended/mgcv/R/smooth.r Recommended/mgcv/R/smooth.r
43c43
<     E <- rep(1,ncol(X));E[1:rank] <- sqrt(er$value[1:rank])
---
>     E <- rep(1,ncol(X));E[seq_len(rank)] <- sqrt(er$value[seq_len(rank)])
48c48
<     av.norm <- mean(col.norm[1:rank])
---
>     av.norm <- mean(col.norm[seq_len(rank)])
73c73
<       ind <- 1:rank
---
>       ind <- seq_len(rank)
96c96
<   D <- er$values[1:rank] 
---
>   D <- er$values[seq_len(rank)]
111c111
<     ind <- 1:rank
---
>     ind <- seq_len(rank)
143c143
<   if (n<4) stop("At least three knots required in call to mono.con.")
---
>   if (n<4) stop("At least three knots required in call passed to 'mono.con()'")
146c146
<   if (lo*hi==1&&lower>=upper) stop("lower bound >= upper bound in call to mono.con()")
---
>   if (lo*hi==1&&lower>=upper) stop("lower bound >= upper bound in call passed to 'mono.con()'")
158c158
<   if (is.null(x)) stop("x is null")
---
>   if (is.null(x)) stop("'x' argument is null")
160,161c160,161
<   #if (is.null(nrow(x))) stop("x has no row attribute")
<   #if (is.null(ncol(x))) stop("x has no col attribute")
---
>   #if (is.null(nrow(x))) stop(gettextf("'%s' argument has no '%s' attribute", "x", "row"))
>   #if (is.null(ncol(x))) stop(gettextf("'%s' argument has no '%s' attribute", "x", "col"))
170c170
<   x <- matrix(res$x[1:n],res$r,res$c)
---
>   x <- matrix(res$x[seq_len(n)],res$r,res$c)
174c174
<     for (i in 1:ncol(xo)) if (is.factor(xo[,i])) { ## may need to reset factors to factors
---
>     for (i in seq_len(ncol(xo))) if (is.factor(xo[,i])) { ## may need to reset factors to factors
191c191
<   if (min(x)<k1||max(x)>knots[nk]) stop("x out of range")
---
>   if (min(x)<k1||max(x)>knots[nk]) stop("'x' out of range")
266c266
<   for (i in 1:dim) term[i] <- attr(terms(reformulate(term[i])),"term.labels")
---
>   for (i in seq_len(dim)) term[i] <- attr(terms(reformulate(term[i])),"term.labels")
279c279
<     { warning("something wrong with argument d.")
---
>     { warning("something wrong with argument 'd'")
298c298
<   { warning("dimension of fx is wrong") 
---
>   { warning("dimension of 'fx' is wrong") 
304c304
<   if (is.null(xt)||length(xt)==1) for (i in 1:n.bases) xtra[[i]] <- xt else
---
>   if (is.null(xt)||length(xt)==1) for (i in seq_len(n.bases)) xtra[[i]] <- xt else
306c306
<   stop("xt argument is faulty.")
---
>   stop(gettextf("'%s' argument is faulty", "xt"))
310c310
<   if (length(bs)!=n.bases) {warning("bs wrong length and ignored.");bs<-rep("cr",n.bases)}
---
>   if (length(bs)!=n.bases) { warning(gettextf("'%s' argument is of the wrong length and ignored", "bs")); bs <- rep("cr",n.bases) }
316c316
<     warning("m wrong length and ignored.");
---
>     warning(gettextf("'%s' argument is of the wrong length and ignored", "m"));
326c326
<   for (i in 1:n.bases)
---
>   for (i in seq_len(n.bases))
345c345
<       warning("only first element of `id' used")
---
>       warning("only first element of 'id' used")
374c374
<   for (i in 1:dim) term[i] <- attr(terms(reformulate(term[i])),"term.labels")
---
>   for (i in seq_len(dim)) term[i] <- attr(terms(reformulate(term[i])),"term.labels")
387c387
<     { warning("something wrong with argument d.")
---
>     { warning("something wrong with argument 'd'")
406c406
<   if (is.null(xt)||length(xt)==1) for (i in 1:n.bases) xtra[[i]] <- xt else
---
>   if (is.null(xt)||length(xt)==1) for (i in seq_len(n.bases)) xtra[[i]] <- xt else
408c408
<   stop("xt argument is faulty.")
---
>   stop(gettextf("'%s' argument is faulty", "xt"))
412c412
<   if (length(bs)!=n.bases) {warning("bs wrong length and ignored.");bs<-rep("cr",n.bases)}
---
>   if (length(bs)!=n.bases) { warning(gettextf("'%s' argument is of the wrong length and ignored", "bs")); bs<-rep("cr",n.bases) }
418c418
<     warning("m wrong length and ignored.");
---
>     warning(gettextf("'%s' argument is of the wrong length and ignored", "m"));
428c428
<   for (i in 1:n.bases)
---
>   for (i in seq_len(n.bases))
442c442
<       warning("ord is wrong. reset to NULL.")
---
>       warning("ord is wrong. reset to NULL")
455c455
<       warning("only first element of `id' used")
---
>       warning("only first element of 'id' used")
482c482
<   if (by.var==".") stop("by=. not allowed")
---
>   if (by.var==".") stop("'by=.' is not allowed")
484c484
<   if (term[1]==".") stop("s(.) not yet supported.")
---
>   if (term[1]==".") stop("'s(.)' function is not yet supported")
488c488
<     if (term[i]==".") stop("s(.) not yet supported.")
---
>     if (term[i]==".") stop("'s(.)' function is not yet supported")
490c490
<   for (i in 1:d) term[i] <- attr(terms(reformulate(term[i])),"term.labels")
---
>   for (i in seq_len(d)) term[i] <- attr(terms(reformulate(term[i])),"term.labels")
494c494
<   if (all.equal(k.new,k)!=TRUE) {warning("argument k of s() should be integer and has been rounded")}
---
>   if (all.equal(k.new,k)!=TRUE) {warning("argument 'k' of 's()' function should be integer and has been rounded")}
505c505
<       warning("only first element of `id' used")
---
>       warning("only first element of 'id' used")
530c530
<     for (j in 1:ncol(X[[i]]))
---
>     for (j in seq_len(ncol(X[[i]])))
562c562
<   I<-list(); for (i in 1:m) { 
---
>   I<-list(); for (i in seq_len(m)) { 
569c569
<   for (i in 1:m)
---
>   for (i in seq_len(m))
594c594
<   for (i in 1:m) { 
---
>   for (i in seq_len(m)) { 
597c597
<     for (j in 1:length(term)) { 
---
>     for (j in seq_len(length(term))) { 
610c610
<     stop("Sorry, tensor products of smooths with multiple penalties are not supported.")
---
>     stop("Sorry, tensor products of smooths with multiple penalties are not supported")
619c619
<   for (i in 1:m) {
---
>   for (i in seq_len(m)) {
648c648
<   for (i in 1:m)  Sm[[i]] <- Sm[[i]]/eigen(Sm[[i]],symmetric=TRUE,only.values=TRUE)$values[1] 
---
>   for (i in seq_len(m))  Sm[[i]] <- Sm[[i]]/eigen(Sm[[i]],symmetric=TRUE,only.values=TRUE)$values[1] 
688c688
<   for (i in 1:m) { 
---
>   for (i in seq_len(m)) { 
691c691
<     for (j in 1:length(term)) dat[[term[j]]] <- data[[term[j]]]
---
>     for (j in seq_len(length(term))) dat[[term[j]]] <- data[[term[j]]]
697c697
<   for (i in 1:mxp) if (!is.null(object$XP[[i]])) X[[i]] <- X[[i]]%*%object$XP[[i]]
---
>   for (i in seq_len(mxp)) if (!is.null(object$XP[[i]])) X[[i]] <- X[[i]]%*%object$XP[[i]]
720c720
<   Zi <- Xm[[1]][,1:rank[1],drop=FALSE] ## range space basis for first margin
---
>   Zi <- Xm[[1]][,seq_len(rank)[1],drop=FALSE] ## range space basis for first margin
731c731
<       colnames(Xi) <- as.character(1:ncol(Xi)) 
---
>       colnames(Xi) <- as.character(seq_len(ncol(Xi))) 
742c742
<     Zi <- Xm[[i]][,1:rank[i],drop=FALSE]   ## margin i range space
---
>     Zi <- Xm[[i]][,seq_len(rank)[i],drop=FALSE]   ## margin i range space
746c746
<       if (full) colnames(Xi)  <- as.character(1:ncol(Xi))
---
>       if (full) colnames(Xi)  <- as.character(seq_len(ncol(Xi)))
753c753
<     for (ii in 1:length(X1)) { ## form products with Zi
---
>     for (ii in seq_len(length(X1))) { ## form products with Zi
756c756
<         for (j in 1:ncol(X1[[ii]])) A <- cbind(A,X1[[ii]][,j]*Zi)
---
>         for (j in seq_len(ncol(X1[[ii]]))) A <- cbind(A,X1[[ii]][,j]*Zi)
764c764
<         for (j in 1:ncol(X1[[ii]])) {
---
>         for (j in seq_len(ncol(X1[[ii]]))) {
775c775
<       for (ii in 1:length(X1)) { ## form products with Xi
---
>       for (ii in seq_len(length(X1))) { ## form products with Xi
782c782
<           for (j in 1:ncol(X1[[ii]])) { 
---
>           for (j in seq_len(ncol(X1[[ii]]))) { 
794c794
<            for (j in 1:ncol(Xi)) {
---
>            for (j in seq_len(ncol(Xi))) {
838c838
<   for (i in 1:m) { ## create marginal model matrices and penalties...
---
>   for (i in seq_len(m)) { ## create marginal model matrices and penalties...
842c842
<     for (j in 1:length(term)) { 
---
>     for (j in seq_len(length(term))) { 
854c854
<     stop("Sorry, tensor products of smooths with multiple penalties are not supported.")
---
>     stop("Sorry, tensor products of smooths with multiple penalties are not supported")
865c865
<     dS <- rep(0,ncol(Xm[[i]]));dS[1:r[i]] <- 1;
---
>     dS <- rep(0,ncol(Xm[[i]]));dS[seq_len(r[i])] <- 1;
884c884
<   if (nsc>0) for (j in 1:nsc) {
---
>   if (nsc>0) for (j in seq_len(nsc)) {
906c906
<   nup <- sum(sub.cols[1:nsc]) ## range space rank
---
>   nup <- sum(sub.cols[seq_len(nsc)]) ## range space rank
912,913c912,913
<     ##  X.shift <- colMeans(X[,1:nup])
<     ##  X[,1:nup] <- sweep(X[,1:nup],2,X.shift) ## make penalized columns orthog to constant col.
---
>     ##  X.shift <- colMeans(X[,seq_len(nup)])
>     ##  X[,seq_len(nup)] <- sweep(X[,seq_len(nup)],2,X.shift) ## make penalized columns orthog to constant col.
928c928
<   object$rank <- sub.cols[1:nsc] ## ranks of individual penalties
---
>   object$rank <- sub.cols[seq_len(nsc)] ## ranks of individual penalties
940c940
<   for (i in 1:m) { 
---
>   for (i in seq_len(m)) { 
943c943
<     for (j in 1:length(term)) dat[[term[j]]] <- data[[term[j]]]
---
>     for (j in seq_len(length(term))) dat[[term[j]]] <- data[[term[j]]]
954c954
<   ind <- 1:ncol(object$S[[1]])                   ## index of penalty columns 
---
>   ind <- seq_len(ncol(object$S[[1]]))                   ## index of penalty columns 
959c959
<   for (i in 1:length(object$S)) { ## work through penalties
---
>   for (i in seq_len(length(object$S))) { ## work through penalties
999c999
<   for (i in 1:m) if (inherits(sm[[i]],"t2.smooth")&&length(sm[[i]]$S)>1) { not.needed <- FALSE;break}
---
>   for (i in seq_len(m)) if (inherits(sm[[i]],"t2.smooth")&&length(sm[[i]]$S)>1) { not.needed <- FALSE;break}
1003c1003
<   for (i in 1:m) {
---
>   for (i in seq_len(m)) {
1007c1007
<       for (j in 1:length(smi)) {
---
>       for (j in seq_len(length(smi))) {
1025c1025
< { if (sum(d<0)) stop("d can not be negative in call to null.space.dimension().")
---
> { if (sum(d<0)) stop("'d' can not be negative in call passed to 'null.space.dimension()'")
1057c1057
<   for (i in 1:object$dim) 
---
>   for (i in seq_len(object$dim)) 
1069c1069
<     for (i in 1:object$dim) 
---
>     for (i in seq_len(object$dim)) 
1080c1080
<   warning("more knots than data in a tp term: knots ignored.")}
---
>   warning("more knots than data in a tp term: knots ignored")}
1095c1095
<       ind <- sample(1:nu,nk,replace=FALSE)  ## by sampling these rows from xu
---
>       ind <- sample(seq_len(nu),nk,replace=FALSE)  ## by sampling these rows from xu
1148c1148
<   object$UZ<-matrix(oo$UZ[1:UZ.len],oo$n.Xu+M,k)         # truncated basis matrix
---
>   object$UZ<-matrix(oo$UZ[seq_len(UZ.len)],oo$n.Xu+M,k)         # truncated basis matrix
1150c1150
<   object$Xu<-matrix(oo$Xu[1:Xu.len],oo$n.Xu,object$dim)  # unique covariate combinations
---
>   object$Xu<-matrix(oo$Xu[seq_len(Xu.len)],oo$n.Xu,object$dim)  # unique covariate combinations
1158c1158
<     ind <- 1:(k-M)
---
>     ind <- seq_len(k-M)
1191c1191
<   for (i in 1:object$dim) 
---
>   for (i in seq_len(object$dim)) 
1204c1204
<   ind <- 1:object$bs.dim
---
>   ind <- seq_len(object$bs.dim)
1263,1264c1263
<   { msg <- paste(object$term," has insufficient unique values to support ",
<                  nk," knots: reduce k.",sep="")
---
>   { msg <- gettextf("%s has insufficient unique values to support %d knots: reduce k", object$term, nk)
1364,1365c1363,1364
<   lbi<-floor(delta*1:(nk-2))+1 # lower interval bound index
<   frac<-delta*1:(nk-2)+1-lbi # left over proportion of interval  
---
>   lbi<-floor(delta*seq_len(nk-2))+1 # lower interval bound index
>   frac<-delta*seq_len(nk-2)+1-lbi # left over proportion of interval  
1381c1380
<     h<-x[2:n]-x[1:(n-1)]
---
>     h<-x[2:n]-x[seq_len(n-1)]
1456c1455
<     h<-knots[2:n]-knots[1:(n-1)]
---
>     h<-knots[2:n]-knots[seq_len(n-1)]
1508c1507
<     stop(paste("there should be ",nk," supplied knots"))
---
>     stop(gettextf("there should be %d supplied knots", nk))
1511c1510
<   if (length(k)!=nk) stop(paste("there should be",nk,"knots supplied"))
---
>   if (length(k)!=nk) stop(gettextf("there should be %d knots supplied", nk))
1526,1528c1525,1527
<     for (i in 1:p.ord) De <- diff(De)
<     D <- De[,-(1:p.ord)]
<     D[,(np-p.ord+1):np] <-  D[,(np-p.ord+1):np] + De[,1:p.ord]
---
>     for (i in seq_len(p.ord)) De <- diff(De)
>     D <- De[,-seq_len(p.ord)]
>     D[,(np-p.ord+1):np] <-  D[,(np-p.ord+1):np] + De[,seq_len(p.ord)]
1578c1577
<     stop(paste("there should be ",nk+2*m[1]+2," supplied knots"))
---
>     stop(gettextf("there should be %d supplied knots",nk+2*m[1]+2))
1587c1586
<   if (m[2]) for (i in 1:m[2]) S <- diff(S)
---
>   if (m[2]) for (i in seq_len(m)[2]) S <- diff(S)
1655c1654
<   for (i in 1:length(object$term)) if (is.factor(data[[object$term[i]]])) { 
---
>   for (i in seq_len(length(object$term))) if (is.factor(data[[object$term[i]]])) { 
1678c1677
<   for (i in 1:object$dim) if (object$term[i]!=fterm) {
---
>   for (i in seq_len(object$dim)) if (object$term[i]!=fterm) {
1704c1703
<   for (i in 1:null.d) { ## create null space element penalties
---
>   for (i in seq_len(null.d)) { ## create null space element penalties
1716c1715
<   #for (i in 1:null.d) { ## null space penalties
---
>   #for (i in seq_len(null.d)) { ## null space penalties
1738c1737
<     for (i in 1:null.d) { ## null space penalties
---
>     for (i in seq_len(null.d)) { ## null space penalties
1785c1784
<   for (i in 1:length(object$flev)) {
---
>   for (i in seq_len(length(object$flev))) {
1797c1796
< ## sets M[i[k],j[k]] <- m[k] for all k in 1:length(m) without
---
> ## sets M[i[k],j[k]] <- m[k] for all k in seq_len(length(m)) without
1816,1818c1815,1817
<   Ind <- matrix(1:(ni*nj),ni,nj) ## the indexing matrix
<   rmt <- rep(1:ni,nj) ## the row index
<   cmt <- rep(1:nj,rep(ni,nj)) ## the column index
---
>   Ind <- matrix(seq_len(ni*nj),ni,nj) ## the indexing matrix
>   rmt <- rep(seq_len(ni),nj) ## the row index
>   cmt <- rep(seq_len(nj),rep(ni,nj)) ## the column index
1820c1819
<   ci <- Ind[2:(ni-1),1:nj] ## column index
---
>   ci <- Ind[2:(ni-1),seq_len(nj)] ## column index
1826,1830c1825,1829
<   Drr <- mfil(Drr,1:n.ci,ci,-2) ## central coefficient
<   ci <- Ind[1:(ni-2),1:nj] 
<   Drr <- mfil(Drr,1:n.ci,ci,1) ## back coefficient
<   ci <- Ind[3:ni,1:nj]
<   Drr <- mfil(Drr,1:n.ci,ci,1) ## forward coefficient
---
>   Drr <- mfil(Drr,seq_len(n.ci),ci,-2) ## central coefficient
>   ci <- Ind[seq_len(ni-2),seq_len(nj)] 
>   Drr <- mfil(Drr,seq_len(n.ci),ci,1) ## back coefficient
>   ci <- Ind[3:ni,seq_len(nj)]
>   Drr <- mfil(Drr,seq_len(n.ci),ci,1) ## forward coefficient
1833c1832
<   ci <- Ind[1:ni,2:(nj-1)] ## column index
---
>   ci <- Ind[seq_len(ni),2:(nj-1)] ## column index
1839,1843c1838,1842
<   Dcc <- mfil(Dcc,1:n.ci,ci,-2) ## central coefficient
<   ci <- Ind[1:ni,1:(nj-2)]
<   Dcc <- mfil(Dcc,1:n.ci,ci,1) ## back coefficient
<   ci <- Ind[1:ni,3:nj]
<   Dcc <- mfil(Dcc,1:n.ci,ci,1) ## forward coefficient
---
>   Dcc <- mfil(Dcc,seq_len(n.ci),ci,-2) ## central coefficient
>   ci <- Ind[seq_len(ni),seq_len(nj-2)]
>   Dcc <- mfil(Dcc,seq_len(n.ci),ci,1) ## back coefficient
>   ci <- Ind[seq_len(ni),3:nj]
>   Dcc <- mfil(Dcc,seq_len(n.ci),ci,1) ## forward coefficient
1852c1851
<   ci <- Ind[1:(ni-2),1:(nj-2)] 
---
>   ci <- Ind[seq_len(ni-2),seq_len(nj-2)] 
1877c1876
<   if (object$dim> 2 )  stop("the adaptive smooth class is limited to 1 or 2 covariates.")
---
>   if (object$dim> 2 )  stop("the adaptive smooth class is limited to 1 or 2 covariates")
1910c1909
<      # for (i in 1:k) D[[i]] <- as.numeric(V[,i])*Db
---
>      # for (i in seq_len(k)) D[[i]] <- as.numeric(V[,i])*Db
1913c1912
<       for (i in 1:k) {
---
>       for (i in seq_len(k)) {
1929c1928
<       for (i in 1:2) {
---
>       for (i in seq_len(2)) {
1975c1974
<         for (i in 1:kp.tot) {
---
>         for (i in seq_len(kp.tot)) {
2008c2007
<   if (!is.null(object$id)) stop("random effects don't work with ids.")
---
>   if (!is.null(object$id)) stop("random effects don't work with ids")
2021c2020
<     for (i in 1:object$dim) {
---
>     for (i in seq_len(object$dim)) {
2030c2029
<       ind <- 1:ns;ind[maxi] <- ns ;ind[ns] <- maxi
---
>       ind <- seq_len(ns);ind[maxi] <- ns ;ind[ns] <- maxi
2033c2032
<       for (i in 1:ns) object$term <- c(object$term,object$margin[[i]]$term)
---
>       for (i in seq_len(ns)) object$term <- c(object$term,object$margin[[i]]$term)
2094c2093
<   for (i in 1:n.poly) {
---
>   for (i in seq_len(n.poly)) {
2109c2108
<   for (i in 1:length(pc)) nb[[i]] <- rep(0,0)
---
>   for (i in seq_len(length(pc))) nb[[i]] <- rep(0,0)
2111c2110
<   for (k in 1:n.poly) { ## work through poly list looking for neighbours
---
>   for (k in seq_len(n.poly)) { ## work through poly list looking for neighbours
2120c2119
<     if (length(ind)>0) for (j in 1:length(ind)) {
---
>     if (length(ind)>0) for (j in seq_len(length(ind))) {
2129c2128
<   for (i in 1:length(pc)) nb[[i]] <- unique(nb[[i]])
---
>   for (i in seq_len(length(pc))) nb[[i]] <- unique(nb[[i]])
2186c2185
<     for (i in 1:length(d.name)) {
---
>     for (i in seq_len(length(d.name))) {
2209c2208
<     for (i in 1:np) {
---
>     for (i in seq_len(np)) {
2213c2212
<       if (lind>0) for (j in 1:lind) S[a.name[i],a.name[ind[j]]] <- -1
---
>       if (lind>0) for (j in seq_len(lind)) S[a.name[i],a.name[ind[j]]] <- -1
2242c2241
<       for (i in 1:length(mi)) object$X[i,mi[i]] <- 1
---
>       for (i in seq_len(length(mi))) object$X[i,mi[i]] <- 1
2248c2247
<     object$X <- if (length(mi)) rp$X[-(1:length(mi)),ind] else  rp$X[,ind] ## model matrix
---
>     object$X <- if (length(mi)) rp$X[-seq_len(length(mi)),ind] else  rp$X[,ind] ## model matrix
2393c2392
<   for (i in 1:2) {
---
>   for (i in seq_len(2)) {
2403c2402
<     for (i in 1:2) 
---
>     for (i in seq_len(2)) 
2415c2414
<     warning("more knots than data in an sos term: knots ignored.")
---
>     warning("more knots than data in an sos term: knots ignored")
2510c2509
<     for (i in 1:n.chunk) { ## build predict matrix in chunks
---
>     for (i in seq_len(n.chunk)) { ## build predict matrix in chunks
2559c2558
<   for (i in 1:M) {
---
>   for (i in seq_len(M)) {
2561c2560
<     for (j in 1:n) y <- y * x[,j]^p[i,j]
---
>     for (j in seq_len(n)) y <- y * x[,j]^p[i,j]
2600c2599
<   for (i in 1:object$dim) {
---
>   for (i in seq_len(object$dim)) {
2610c2609
<     for (i in 1:object$dim) 
---
>     for (i in seq_len(object$dim)) 
2622c2621
<     warning("more knots than data in a ds term: knots ignored.")
---
>     warning("more knots than data in a ds term: knots ignored")
2697c2696
<   ind <- 1:ncol(T)
---
>   ind <- seq_len(ncol(T))
2751c2750
<   for (i in 1:object$dim) {
---
>   for (i in seq_len(object$dim)) {
2764,2765c2763,2764
<     for (i in 1:n.chunk) { ## build predict matrix in chunks
<       ind <- 1:nk + (i-1)*nk
---
>     for (i in seq_len(n.chunk)) { ## build predict matrix in chunks
>       ind <- seq_len(nk) + (i-1)*nk
3056c3055
<    for (i in 1:length(object$term)) { 
---
>    for (i in seq_len(length(object$term))) { 
3068c3067
<          for (i in 1:m) dat[[i]] <- X[,i]     ## return only unique rows
---
>          for (i in seq_len(m)) dat[[i]] <- X[,i]     ## return only unique rows
3105c3104
<   if (!is.null(attr(sm,"qrc"))) warning("smooth objects should not have a qrc attribute.")
---
>   if (!is.null(attr(sm,"qrc"))) warning("smooth objects should not have a qrc attribute")
3129c3128
<         drop <- min((1:length(vcol))[vcol==min(vcol)])
---
>         drop <- min(seq_len(length(vcol))[vcol==min(vcol)])
3136c3135
<             sm$C <- ((1:length(xsd))[xsd==0])[1] ## index of coef to set to zero
---
>             sm$C <- (seq_len(length(xsd))[xsd==0])[1] ## index of coef to set to zero
3141c3140
<             sm$C <- ((1:length(xz))[xz==min(xz)])[1] ## index of coef to set to zero
---
>             sm$C <- (seq_len(length(xz))[xz==min(xz)])[1] ## index of coef to set to zero
3178c3177
<       for (i in 1:length(sm$S)) {
---
>       for (i in seq_len(length(sm$S))) {
3198c3197
<     if (!is.null(sm$by.done)) warning("handling `by' variables in smooth constructors may not work with the summation convention ")
---
>     if (!is.null(sm$by.done)) warning("handling 'by' variables in smooth constructors may not work with the summation convention")
3221c3220
<       if (matrixArg) stop("factor `by' variables can not be used with matrix arguments.")
---
>       if (matrixArg) stop("factor 'by' variables can not be used with matrix arguments")
3228c3227
<       for (j in 1:length(lev)) {
---
>       for (j in seq_len(length(lev))) {
3241c3240
<           (!is.null(sm$ind)&&length(by)!=length(sm$ind))) stop("`by' variable must be same dimension as smooth arguments")
---
>           (!is.null(sm$ind)&&length(by)!=length(sm$ind))) stop("'by' variable must be same dimension as smooth arguments")
3248c3247
<           ind <- 1:n 
---
>           ind <- seq_len(n)
3258c3257
<             ind <- 1:n 
---
>             ind <- seq_len(n)
3271c3270
<           for (i in 1:n) { ## in this case have to work down the rows
---
>           for (i in seq_len(n)) { ## in this case have to work down the rows
3323c3322
<       for (i in 1:length(sml)) { ## loop through smooth list
---
>       for (i in seq_len(length(sml))) { ## loop through smooth list
3328c3327
<           for (l in 1:length(sml[[i]]$S)) { # some smooths have > 1 penalty 
---
>           for (l in seq_len(length(sml[[i]]$S))) { # some smooths have > 1 penalty 
3339c3338
<         indi <- (1:ncol(sm$C))[colSums(sm$C)!=0] ## index of non-zero columns in C
---
>         indi <- seq_len(ncol(sm$C))[colSums(sm$C)!=0] ## index of non-zero columns in C
3345c3344
<           for (i in 1:length(sml)) { ## loop through smooth list
---
>           for (i in seq_len(length(sml))) { ## loop through smooth list
3347c3346
<             for (l in 1:length(sm$S)) # some smooths have > 1 penalty 
---
>             for (l in seq_len(length(sm$S))) # some smooths have > 1 penalty 
3349c3348
<               ZSZ[indi[1:nz],]<-qr.qty(qrc,sml[[i]]$S[[l]][indi,,drop=FALSE])[(nc+1):nx,] 
---
>               ZSZ[indi[seq_len(nz)],]<-qr.qty(qrc,sml[[i]]$S[[l]][indi,,drop=FALSE])[(nc+1):nx,] 
3351c3350
<               ZSZ[,indi[1:nz]]<-t(qr.qty(qrc,t(ZSZ[,indi,drop=FALSE]))[(nc+1):nx,])
---
>               ZSZ[,indi[seq_len(nz)]]<-t(qr.qty(qrc,t(ZSZ[,indi,drop=FALSE]))[(nc+1):nx,])
3357c3356
<             sml[[i]]$X[,indi[1:nz]]<-t(qr.qty(qrc,t(sml[[i]]$X[,indi,drop=FALSE]))[(nc+1):nx,])
---
>             sml[[i]]$X[,indi[seq_len(nz)]]<-t(qr.qty(qrc,t(sml[[i]]$X[,indi,drop=FALSE]))[(nc+1):nx,])
3373c3372
<             for (i in 1:length(sml)) { ## loop through smooth list
---
>             for (i in seq_len(length(sml))) { ## loop through smooth list
3378c3377
<               for (l in 1:length(sm$S)) { # some smooths have > 1 penalty 
---
>               for (l in seq_len(length(sm$S))) { # some smooths have > 1 penalty 
3384c3383
<             for (i in 1:length(sml)) { ## loop through smooth list
---
>             for (i in seq_len(length(sml))) { ## loop through smooth list
3386c3385
<               for (l in 1:length(sm$S)) { # some smooths have > 1 penalty 
---
>               for (l in seq_len(length(sm$S))) { # some smooths have > 1 penalty 
3396c3395
<           for (i in 1:length(sml)) { ## loop through smooth list
---
>           for (i in seq_len(length(sml))) { ## loop through smooth list
3406c3405
<         for (i in 1:length(sml)) {
---
>         for (i in seq_len(length(sml))) {
3412c3411
<        for (i in 1:length(sml)) { ## loop through smooth list
---
>        for (i in seq_len(length(sml))) { ## loop through smooth list
3414c3413
<           for (l in 1:length(sm$S)) { # some smooths have > 1 penalty 
---
>           for (l in seq_len(length(sm$S))) { # some smooths have > 1 penalty 
3427c3426
<        for (i in 1:length(sml)) { ## loop through smooth list
---
>        for (i in seq_len(length(sml))) { ## loop through smooth list
3429c3428
<           for (l in 1:length(sm$S)) { # some smooths have > 1 penalty 
---
>           for (l in seq_len(length(sm$S))) { # some smooths have > 1 penalty 
3445c3444
<       for (i in 1:length(sml)) { ## loop through smooth list
---
>       for (i in seq_len(length(sml))) { ## loop through smooth list
3452c3451
<   } else for (i in 1:length(sml)) attr(sml[[i]],"qrc") <-NULL ## no absorption
---
>   } else for (i in seq_len(length(sml))) attr(sml[[i]],"qrc") <-NULL ## no absorption
3493c3492
<         if (p>rank) for (i in 1:length(sml)) {
---
>         if (p>rank) for (i in seq_len(length(sml))) {
3511c3510
<         for (i in 1:length(sml)) {
---
>         for (i in seq_len(length(sml))) {
3521c3520
<   if (!apply.by) for (i in 1:length(sml)) {
---
>   if (!apply.by) for (i in seq_len(length(sml))) {
3547c3546
<     for (i in 1:n) { ## in this case have to work down the rows
---
>     for (i in seq_len(n)) { ## in this case have to work down the rows
3571c3570
<           if (length(by)!=nrow(X)) stop("`by' variable must be same dimension as smooth arguments")
---
>           if (length(by)!=nrow(X)) stop("'by' variable must be same dimension as smooth arguments")
3583c3582
<       ind <- 1:n 
---
>       ind <- seq_len(n)
3622c3621
<             X[ind,indi[1:nz]]<-t(qr.qty(qrc,t(X[ind,indi,drop=FALSE]))[(nc+1):nx,])
---
>             X[ind,indi[seq_len(nz)]]<-t(qr.qty(qrc,t(X[ind,indi,drop=FALSE]))[(nc+1):nx,])
3626c3625
<             X[,indi[1:nz]]<-t(qr.qty(qrc,t(X[,indi,drop=FALSE]))[(nc+1):nx,,drop=FALSE])
---
>             X[,indi[seq_len(nz)]]<-t(qr.qty(qrc,t(X[,indi,drop=FALSE]))[(nc+1):nx,,drop=FALSE])
diff -rEZbwB '--exclude=*.[lo,d,pdf,mo,po,tgz,gz,save]*' '--exclude=MD5' '--exclude=Makefile*' '--exclude=all.R' '--exclude=Changes' R-recommended/mgcv/R/soap.r Recommended/mgcv/R/soap.r
14c14
<     for (i in 1:length(beta.full)) {
---
>     for (i in seq_len(length(beta.full))) {
41c41
<           for (i in 1:length(beta.full)) {
---
>           for (i in seq_len(length(beta.full))) {
107c107
<   if (is.null(bnd.name)) for (i in 1:length(bnd)) { 
---
>   if (is.null(bnd.name)) for (i in seq_len(length(bnd))) { 
131c131
< { for (i in 1:length(bnd)) {
---
> { for (i in seq_len(length(bnd))) {
133c133
<     if (length(y)!=n) stop("x and y not same length")
---
>     if (length(y)!=n) stop("'x' and 'y' components of 'bnd' argument are not of same length")
157c157
<   for (k in 1:nk) {
---
>   for (k in seq_len(nk)) {
163c163
<         str <- paste("knot",k,"is on or outside boundary")
---
>         str <- gettextf("knot %d is on or outside boundary", k)
177c177
<   if (!inherits(bnd,"list")) stop("bnd must be a list.")
---
>   if (!inherits(bnd,"list")) stop("bnd must be a list")
181c181
<     else stop("lengths of k and bnd are not compatible.") 
---
>     else stop("lengths of 'k' and 'bnd' arguments are inconsistent") 
239c239
<   for (i in 1:length(bnd)) {
---
>   for (i in seq_len(length(bnd))) {
291c291
<     for (i in 1:length(sd$bc)) { ## work through boundary loops
---
>     for (i in seq_len(length(sd$bc))) { ## work through boundary loops
349c349
<     for (i in 1:length(sd$bc)) { ## work through boundary loops
---
>     for (i in seq_len(length(sd$bc))) { ## work through boundary loops
359c359
<         for (j in 1:ncol(sd$bc[[i]]$X)) { ## loop over loop basis cols
---
>         for (j in seq_len(ncol(sd$bc[[i]]$X))) { ## loop over loop basis cols
383c383
<     for (i in 1:nc) g[sd$ki[i],i] <- 1
---
>     for (i in seq_len(nc)) g[sd$ki[i],i] <- 1
392c392
<     for (i in 1:nc) {
---
>     for (i in seq_len(nc)) {
432c432
<   for (i in 1:length(bnd)) { ## re-lable boundary
---
>   for (i in seq_len(length(bnd))) { ## re-lable boundary
445c445
<     stop("k and bnd lengths are inconsistent")
---
>     stop("lengths of 'bs.dim' and 'bnd' components of 'object' argument are inconsistent")
466c466
<   if (n>0) for (i in 1:n) if (sd$bc[[i]]$free.bound) 
---
>   if (n>0) for (i in seq_len(n)) if (sd$bc[[i]]$free.bound) 
470c470
<   for (i in 1:length(sd$bc)) 
---
>   for (i in seq_len(length(sd$bc))) 
489c489
<     for (i in 1:length(b$S)) {
---
>     for (i in seq_len(length(b$S))) {
507c507
<   for (i in 1:length(sd$bc)) {
---
>   for (i in seq_len(length(sd$bc))) {
536c536
<   for (i in 1:length(bnd)) { ## re-lable boundary
---
>   for (i in seq_len(length(bnd))) { ## re-lable boundary
549c549
<     stop("k and bnd lengths are inconsistent")
---
>     stop("lengths of 'bs.dim' and 'bnd' components of 'object' argument are inconsistent")
571c571
<   if (n>0) for (i in 1:n) if (sd$bc[[i]]$free.bound) { 
---
>   if (n>0) for (i in seq_len(n)) if (sd$bc[[i]]$free.bound) { 
581c581
<   for (i in 1:length(sd$bc)) 
---
>   for (i in seq_len(length(sd$bc))) 
600c600
<     if (length(b$S)>0) for (i in 1:length(b$S)) {
---
>     if (length(b$S)>0) for (i in seq_len(length(b$S))) {
613c613
<   for (i in 1:length(sd$bc)) {
---
>   for (i in seq_len(length(sd$bc))) {
641c641
<   for (i in 1:length(bnd)) { ## re-lable boundary
---
>   for (i in seq_len(length(bnd))) { ## re-lable boundary
654c654
<     stop("k and bnd lengths are inconsistent")
---
>     stop("lengths of 'bs.dim' and 'bnd' components of 'object' argument are inconsistent")
685c685
<     for (i in 1:length(b$S)) {
---
>     for (i in seq_len(length(b$S))) {
702c702
<   for (i in 1:length(sd$bc)) {
---
>   for (i in seq_len(length(sd$bc))) {
765c765
<                 for (i in 1:length(P$bnd)) lines(P$bnd[[i]],lwd=2)
---
>                 for (i in seq_len(length(P$bnd))) lines(P$bnd[[i]],lwd=2)
801c801
<           for (i in 1:length(P$bnd)) lines(P$bnd[[i]],lwd=2)
---
>           for (i in seq_len(length(P$bnd))) lines(P$bnd[[i]],lwd=2)
diff -rEZbwB '--exclude=*.[lo,d,pdf,mo,po,tgz,gz,save]*' '--exclude=MD5' '--exclude=Makefile*' '--exclude=all.R' '--exclude=Changes' R-recommended/mgcv/R/sparse.r Recommended/mgcv/R/sparse.r
14c14
<   ## ni[1:off[1]] gives neighbours of point 1. 
---
>   ## ni[seq_len(off[1])] gives neighbours of point 1. 
16c16
<   return(list(ni = oo$T[1:oo$off[n]]+1,off=oo$off))
---
>   return(list(ni = oo$T[seq_len(oo$off[n])]+1,off=oo$off))
33,34c33,34
<   ii <- c(1:n,oo$ii[1:ni]+1) ## row index
<   jj <- c(1:n,oo$ni[1:ni]+1) ## col index
---
>   ii <- c(seq_len(n),oo$ii[seq_len(ni)]+1) ## row index
>   jj <- c(seq_len(n),oo$ni[seq_len(ni)]+1) ## col index
108c108
<   lo <- dd[,1:d];hi <- dd[,1:d+d]
---
>   lo <- dd[,seq_len(d)];hi <- dd[,seq_len(d)+d]
119c119
<   for (i in 1:nb) {
---
>   for (i in seq_len(nb)) {
140c140
<   } else { Xu <- X; ind <- 1:nrow(X)}
---
>   } else { Xu <- X; ind <- seq_len(nrow(X))}
146c146
<   if (get.a) a <- 1:n else a=1
---
>   if (get.a) a <- seq_len(n) else a=1
152,153c152,153
<   rind <- 1:nobs
<   rind[ind] <- 1:nobs
---
>   rind <- seq_len(nobs)
>   rind[ind] <- seq_len(nobs)
219c219
<   P <- sparseMatrix(i=1:n,j=ind,x=rep(1,n),dims=c(n,nrow(xu)))
---
>   P <- sparseMatrix(i=seq_len(n),j=ind,x=rep(1,n),dims=c(n,nrow(xu)))
259,260c259,260
<     for (i in 1:nb) {
<       ind[[i]] <- (1:n)[block==levels(block)[i]]
---
>     for (i in seq_len(nb)) {
>       ind[[i]] <- (seq_len(n))[block==levels(block)[i]]
265c265
<     ind[[1]] <- 1:n
---
>     ind[[1]] <- seq_len(n)
290c290
<   if (block==0) block <- 1:object$nblock
---
>   if (block==0) block <- seq_len(object$nblock)
328c328
<   } else for (i in 1:object$nblock) { ## work through all blocks 
---
>   } else for (i in seq_len(object$nblock)) { ## work through all blocks 
360,361c360,361
<     for (i in 1:nb) { 
<       ind[[i]] <- (1:n)[block==levels(block)[i]]
---
>     for (i in seq_len(nb)) { 
>       ind[[i]] <- (seq_len(n))[block==levels(block)[i]]
365c365
<     ind[[1]] <- 1:n
---
>     ind[[1]] <- seq_len(n)
diff -rEZbwB '--exclude=*.[lo,d,pdf,mo,po,tgz,gz,save]*' '--exclude=MD5' '--exclude=Makefile*' '--exclude=all.R' '--exclude=Changes' R-recommended/mgcv/src/general.h Recommended/mgcv/src/general.h
3,8d2
< #ifdef ENABLE_NLS
< #include <libintl.h>
< #define _(String) dgettext ("mgcv", String)
< #else
< #define _(String) (String)
< #endif
Only in Recommended/mgcv/src: localization.h
diff -rEZbwB '--exclude=*.[lo,d,pdf,mo,po,tgz,gz,save]*' '--exclude=MD5' '--exclude=Makefile*' '--exclude=all.R' '--exclude=Changes' R-recommended/mgcv/src/magic.c Recommended/mgcv/src/magic.c
27a28
> #include "localization.h"
diff -rEZbwB '--exclude=*.[lo,d,pdf,mo,po,tgz,gz,save]*' '--exclude=MD5' '--exclude=Makefile*' '--exclude=all.R' '--exclude=Changes' R-recommended/mgcv/src/mat.c Recommended/mgcv/src/mat.c
31a32
> #include "localization.h"
47c48
<     Rprintf("\nFailed to open file\n");
---
>     Rprintf(_("\nFailed to open file\n"));
69c70
<     Rprintf("\nFailed to open file\n");
---
>     Rprintf(_("\nFailed to open file\n"));
77c78
<    if (j!= *r * *c)  Rprintf("\nfile dim problem\n");
---
>    if (j!= *r * *c)  Rprintf(_("\nfile dim problem\n"));
2560c2561
<     if (k) Rprintf("Non orthogonal eigenvectors %d %g\n",k,x/k);
---
>     if (k) Rprintf(_("Non orthogonal eigenvectors %d %g\n"), k,x/k);
2565c2566
<     if (k) Rprintf("Eigenvectors not normalized %d %g\n",k,x/k);
---
>     if (k) Rprintf(_("Eigenvectors not normalized %d %g\n"), k,x/k);
diff -rEZbwB '--exclude=*.[lo,d,pdf,mo,po,tgz,gz,save]*' '--exclude=MD5' '--exclude=Makefile*' '--exclude=all.R' '--exclude=Changes' R-recommended/mgcv/src/matrix.c Recommended/mgcv/src/matrix.c
30a31
> #include "localization.h"
1320c1321
<     error(_("svd() not converged"));
---
>     error(_("'svd()' not converged"));
diff -rEZbwB '--exclude=*.[lo,d,pdf,mo,po,tgz,gz,save]*' '--exclude=MD5' '--exclude=Makefile*' '--exclude=all.R' '--exclude=Changes' R-recommended/mgcv/src/qp.c Recommended/mgcv/src/qp.c
28a29,30
> #include "localization.h"
> #include <R_ext/Minmax.h>
33,35d34
< #define max(a,b)    (((a) > (b)) ? (a) : (b))
< #define min(a,b)    (((a) < (b)) ? (a) : (b))
< 
58c57
<     { error(_("ERROR in addconQT."));}
---
>     { error(_("ERROR in 'addconQT()'"));}
diff -rEZbwB '--exclude=*.[lo,d,pdf,mo,po,tgz,gz,save]*' '--exclude=MD5' '--exclude=Makefile*' '--exclude=all.R' '--exclude=Changes' R-recommended/mgcv/src/sparse-smooth.c Recommended/mgcv/src/sparse-smooth.c
23a24
> #include "localization.h"
142c143
<     if (kd.box[i].p1-kd.box[i].p0>1) { Rprintf("More than 2 points in a box!!\n");ok=0;}
---
>     if (kd.box[i].p1-kd.box[i].p0>1) { Rprintf(_("More than 2 points in a box!!\n")); ok = 0; }
147c148
<     if (count[i]!=1) { Rprintf("point %d in %d boxes!\n",i,count[i]);ok=0;}
---
>     if (count[i]!=1) { Rprintf(_("point %d in %d boxes!\n"), i ,count[i]); ok = 0; }
309c310
<     if (bi>nb-1) Rprintf("too many boxes!!");
---
>     if (bi>nb-1) Rprintf(_("too many boxes!!"));
325c326
<     if (bi>nb-1) Rprintf("too many boxes!!");
---
>     if (bi>nb-1) Rprintf(_("too many boxes!!"));
341c342
<   if (bi!=nb-1) Rprintf("bi not equal to nb-1 %d %d\n",bi,nb-1);
---
>   if (bi!=nb-1) Rprintf(_("bi not equal to nb-1 %d %d\n"), bi, nb-1);
441c442
<     if (box[b1].hi[d]!=box[box[bi].child2].lo[d]) Rprintf("child boundary problem\n");
---
>     if (box[b1].hi[d]!=box[box[bi].child2].lo[d]) Rprintf(_("child boundary problem\n"));
550c551
<   if (kd->d!=2) Rprintf("\n star only useful in 2D\n");
---
>   if (kd->d!=2) Rprintf(_("\n 'star()' function is useful only in 2D\n"));
607c608
<       if (!check) Rprintf("indexing error in p_area!\n");
---
>       if (!check) Rprintf(_("indexing error in 'p_area()' function!\n"));
1053c1054
<       Rprintf("hello\n");
---
>       Rprintf(_("hello\n"));
1085c1086
<           Rprintf("%d upper neighbour claimed to be self d=%d!\n",i,j);
---
>           Rprintf(_("%d upper neighbour claimed to be self d=%d!\n"), i, j);
1148c1149
<           Rprintf("lower neighbour claimed to be self!\n");
---
>           Rprintf(_("lower neighbour claimed to be self!\n"));
diff -rEZbwB '--exclude=*.[lo,d,pdf,mo,po,tgz,gz,save]*' '--exclude=MD5' '--exclude=Makefile*' '--exclude=all.R' '--exclude=Changes' R-recommended/mgcv/src/tprs.c Recommended/mgcv/src/tprs.c
25a26
> #include "localization.h"
