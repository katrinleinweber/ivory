diff -rEZbwB '--exclude=*.[lo,d,pdf,mo,po,tgz,gz,save]*' '--exclude=MD5' '--exclude=Makefile*' '--exclude=all.R' '--exclude=Changes' R-recommended/nlme/R/VarCorr.R Recommended/nlme/R/VarCorr.R
49c49
<   trows <- 1 + c(0, cumsum(1 + nrows))[1:Q]
---
>   trows <- 1 + c(0, cumsum(1 + nrows))[seq_len(Q)]
67c67
<     rownames[ rr + (1:nrows[i]) ] <- dimnames( m[[i]] )[[1]]
---
>     rownames[ rr + seq_len(nrows[i]) ] <- dimnames( m[[i]] )[[1]]
69c69
<       v[ rr + (1:nrows[i]), 2 + (1:ncol(corr[[i]])) ] <- corr[[i]]
---
>       v[ rr + seq_len(nrows[i]), 2 + seq_len(ncol(corr[[i]])) ] <- corr[[i]]
diff -rEZbwB '--exclude=*.[lo,d,pdf,mo,po,tgz,gz,save]*' '--exclude=MD5' '--exclude=Makefile*' '--exclude=all.R' '--exclude=Changes' R-recommended/nlme/R/VarCov.R Recommended/nlme/R/VarCov.R
28c28
<         stop("not implemented for \"nlme\" objects")
---
>         stop(gettextf("'%s' function is not implemented for objects of class %s", "getVarCov.lme()", dQuote("nlme")))
30c30
<         stop("not implemented for multiple levels of nesting")
---
>         stop(gettextf("'%s' function is not implemented for multiple levels of nesting", "getVarCov.lme()"))
48,53c48,49
<             if (!length(indx))
<                 stop(gettextf("individual %s was not used in the fit",
<                               sQuote(individ)), domain = NA)
<             if (is.na(indx))
<                  stop(gettextf("individual %s was not used in the fit",
<                               sQuote(individ)), domain = NA)
---
>             if (!length(indx) || is.na(indx))
>                 stop(gettextf("individual %s was not used in the fit", sQuote(individ)), domain = "R-nlme")
112c108
<             cat("correlation matrix\n")
---
>             cat(gettext("correlation matrix", domain = "R-nlme"), "\n", sep = "")
118c114
<             cat("variance covariance matrix\n")
---
>             cat(gettext("variance covariance matrix", domain = "R-nlme"), "\n", sep = "")
123c119
<         if (stdevs) cat("  Standard Deviations:",signif(sds,digits),"\n")
---
>         if (stdevs) cat(gettext("  Standard Deviations: ", domain = "R-nlme"), signif(sds,digits), "\n", sep = "")
131c127
<             cat(attr(x,"group.levels"),nm,"\n")
---
>             cat(attr(x,"group.levels"), " ", nm, "\n", sep = "")
diff -rEZbwB '--exclude=*.[lo,d,pdf,mo,po,tgz,gz,save]*' '--exclude=MD5' '--exclude=Makefile*' '--exclude=all.R' '--exclude=Changes' R-recommended/nlme/R/corStruct.R Recommended/nlme/R/corStruct.R
62,63c62
<       stop(gettextf("do not know how to calculate correlation matrix of %s object",
<                     dQuote(class(object)[1])), domain = NA)
---
>       stop(gettextf("do not know how to calculate correlation matrix of %s object", dQuote(class(object)[1])), domain = "R-nlme")
68c67
< 	names(covariate) <- 1:length(covariate)
---
> 	names(covariate) <- seq_len(length(covariate))
83c82
<       val <- split(val, rep(1:corD[["M"]], (corD[["len"]])^2))
---
>       val <- split(val, rep(seq_len(corD[["M"]]), (corD[["len"]])^2))
110c109
<       stop("\"corStruct\" object must have a \"fixed\" attribute")
---
>       stop(gettextf("object of class %s must have a \"fixed\" attribute", dQuote("corStruct")))
118,119c117
<       stop(gettextf("do not know how to obtain parameters of %s object",
<                     dQuote(class(object)[1])), domain = NA)
---
>       stop(gettextf("do not know how to obtain parameters of %s object", dQuote(class(object)[1])), domain = "R-nlme")
129c127
<     stop("cannot change the length of the parameter of a \"corStruct\" object")
---
>     stop(gettextf("cannot change the length of the parameter of an object of class %s", dQuote("corStruct")))
164c162
<     warning("cannot change 'form'")
---
>     warning("cannot change 'form' argument")
168c166
<       stop("need data to calculate covariate of \"corStruct\" object")
---
>       stop(gettextf("'%s' argument is required in order to calculate covariate of an object of class %s", "data", dQuote("corStruct")))
189c187
<         covar <- 1:nrow(data)
---
>         covar <- seq_len(nrow(data))
191c189
< 	covar <- lapply(split(grps, grps), function(x) 1:length(x))
---
> 	covar <- lapply(split(grps, grps), function(x) seq_len(length(x)))
272c270
<     cat("Correlation structure of class", class(x)[1], "representing\n")
---
>     cat(gettextf("Correlation structure of class %s representing", dQuote(class(x)[1]), domain = "R-nlme"), "\n", sep = "")
275c273
<     cat("Uninitialized correlation structure of class", class(x)[1], "\n")
---
>     cat(gettextf("Uninitialized correlation structure of class %s", dQuote(class(x)[1]), domain = "R-nlme"), "\n", sep = "")
284,286c282,284
<   cat(paste("Correlation Structure: ", attr(x, "structName"), "\n", sep = ""))
<   cat(paste(" Formula:", deparse(formula(x)),"\n"))
<   cat(" Parameter estimate(s):\n")
---
>   cat(gettext("Correlation structure: ", domain = "R-nlme"), attr(x, "structName"), "\n", sep = "")
>   cat(gettext(" Formula: ", domain = "R-nlme"), deparse(formula(x)), "\n", sep = "")
>   cat(gettext(" Parameter estimates:", domain = "R-nlme"), "\n", sep = "")
360c358
<       names(covariate) <- 1:length(covariate)
---
>       names(covariate) <- seq_len(length(covariate))
387c385
<     val <- split(val, rep(1:corD[["M"]], (corD[["len"]])^2))
---
>     val <- split(val, rep(seq_len(corD[["M"]]), (corD[["len"]])^2))
422c420
<     stop("cannot change the length of the parameter of a \"corSymm\" object")
---
>     stop(gettextf("cannot change the length of the parameter of an object of class %s", dQuote("corSymm")))
452c450
<     stop("covariate must have unique values within groups for \"corSymm\" objects")
---
>     stop(gettextf("covariate must have unique values within groups for objects of class %s", dQuote("corSymm")))
457c455
<     stop("unique values of the covariate  for \"corSymm\" objects must be a sequence of consecutive integers")
---
>     stop(gettextf("unique values of the covariate  for objects of class %s must be a sequence of consecutive integers", dQuote("corSymm")))
469c467
<       stop("initial value for \"corSymm\" parameters of wrong dimension")
---
>       stop(gettextf("initial value for %s parameters of wrong dimension", dQuote("corSymm")))
472c470
<       stop("initial values for \"corSymm\" must be between -1 and 1")
---
>       stop(gettextf("initial values for %s must be between %d and %d", dQuote("corSymm"), -1, 1))
479c477
<       stop("initial values for \"corSymm\" do not define a positive-definite correlation structure")
---
>       stop(gettextf("initial values for %s do not define a positive-definite correlation structure", dQuote("corSymm")))
484c482
<       aux <- acos(natMat[1:(i-1),i]/sqrt(cumsum(natMat[i:1,i]^2)[i:2]))
---
>       aux <- acos(natMat[seq_len(i-1),i]/sqrt(cumsum(natMat[i:1,i]^2)[i:2]))
505c503
<     dimnames(val) <- list(1:mC, 1:mC)
---
>     dimnames(val) <- list(seq_len(mC), seq_len(mC))
508c506
<     cat("Correlation structure of class corSymm representing\n")
---
>     cat(gettextf("Correlation structure of class %s representing", dQuote("corSymm"), domain = "R-nlme"), "\n", sep = "")
511c509
<   else cat("Unitialized correlation structure of class corSymm\n")
---
>   else cat(gettextf("Uninitialized correlation structure of class %s", dQuote("corSymm"), domain = "R-nlme"), "\n", sep = "")
520,522c518,520
<     cat("Correlation Structure: General\n")
<     cat(paste(" Formula:", deparse(formula(x)),"\n"))
<     cat(" Parameter estimate(s):\n")
---
>     cat(gettext("Correlation Structure: General", domain = "R-nlme"), "\n", sep = "")
>     cat(gettext(" Formula: ", domain = "R-nlme"), deparse(formula(x)), "\n", sep = "")
>     cat(gettext(" Parameter estimates:", domain = "R-nlme"), "\n", sep = "")
524c522
<     dimnames(val) <- list(1:mC, 1:mC)
---
>     dimnames(val) <- list(seq_len(mC), seq_len(mC))
528c526
<   } else cat("Unitialized correlation structure of class corSymm\n")
---
>   } else cat(gettextf("Uninitialized correlation structure of class %s", dQuote("corSymm"), domain = "R-nlme"), "\n", sep = "")
550c548
<   function(object, structName = "General correlation", ...)
---
>   function(object, structName = gettext("General correlation", domain = "R-nlme"), ...)
595c593
<       names(covariate) <- 1:length(covariate)
---
>       names(covariate) <- seq_len(length(covariate))
622c620
<     val <- split(val, rep(1:corD[["M"]], (corD[["len"]])^2))
---
>     val <- split(val, rep(seq_len(corD[["M"]]), (corD[["len"]])^2))
651c649
<   names(val) <- outer(1:mC, 1:mC,
---
>   names(val) <- outer(seq_len(mC), seq_len(mC),
662c660
<     stop("cannot change the length of the parameter of a \"corNatural\" object")
---
>     stop(gettextf("cannot change the length of the parameter of an object of class %s", dQuote("corNatural")))
692c690
<     stop("covariate must have unique values within groups for \"corNatural\" objects")
---
>     stop(gettextf("covariate must have unique values within groups for objects of class %s", dQuote("corNatural")))
697c695
<     stop("unique values of the covariate for \"corNatural\" objects must be a sequence of consecutive integers")
---
>     stop(gettextf("unique values of the covariate  for objects of class %s must be a sequence of consecutive integers", dQuote("corNatural")))
709c707
<       stop("initial value for \"corNatural\" parameters of wrong dimension")
---
>       stop(gettextf("initial value for %s parameters of wrong dimension", dQuote("corNatural")))
712c710
<       stop("initial values for \"corNatural\" must be between -1 and 1")
---
>       stop(gettextf("initial values for %s must be between %d and %d", dQuote("corNatural"), -1, 1))
719c717
<       stop("initial values for \"corNatural\" do not define a positive-definite correlation structure")
---
>       stop(gettextf("initial values for %s do not define a positive-definite correlation structure", dQuote("corNatural")))
739c737
<     dimnames(val) <- list(1:mC, 1:mC)
---
>     dimnames(val) <- list(seq_len(mC), seq_len(mC))
742c740
<     cat("Correlation structure of class corNatural representing\n")
---
>     cat(gettextf("Correlation structure of class %s representing", dQuote("corNatural"), domain = "R-nlme"), "\n", sep = "")
745c743
<   else cat("Unitialized correlation structure of class corNatural\n")
---
>   else cat(gettextf("Uninitialized correlation structure of class %s", dQuote("corNatural"), domain = "R-nlme"), "\n", sep = "")
754,756c752,754
<     cat("Correlation Structure: General\n")
<     cat(paste(" Formula:", deparse(formula(x)),"\n"))
<     cat(" Parameter estimate(s):\n")
---
>     cat(gettext("Correlation Structure: General", domain = "R-nlme"), "\n", sep = "")
>     cat(gettext(" Formula: ", domain = "R-nlme"), deparse(formula(x)), "\n", sep = "")
>     cat(gettext(" Parameter estimates:", domain = "R-nlme"), "\n", sep = "")
759c757
<     dimnames(val) <- list(1:mC, 1:mC)
---
>     dimnames(val) <- list(seq_len(mC), seq_len(mC))
763c761
<   } else cat("Unitialized correlation structure of class corNatural\n")
---
>   } else cat(gettextf("Uninitialized correlation structure of class %s", dQuote("corNatural"), domain = "R-nlme"), "\n", sep = "")
786c784
<            structName = "General correlation, with natural parametrization",
---
>            structName = gettext("General correlation, with natural parametrization", domain = "R-nlme"),
846c844
<   function(object, structName = "Independent", ...)
---
>   function(object, structName = gettext("Independent", domain = "R-nlme"), ...)
860c858
<     stop("parameter in AR(1) structure must be between -1 and 1")
---
>     stop(gettextf("parameter in %s structure must be between %d and %d", dQuote("AR(1)"), -1, 1))
891c889
<       names(covariate) <- 1:length(covariate)
---
>       names(covariate) <- seq_len(length(covariate))
914c912
<     val <- split(val, rep(1:corD[["M"]], (corD[["len"]])^2))
---
>     val <- split(val, rep(seq_len(corD[["M"]]), (corD[["len"]])^2))
950c948
<     stop("cannot change the length of the parameter of a \"corAR1\" object")
---
>     stop(gettextf("cannot change the length of the parameter of an object of class %s", dQuote("corAR1")))
975c973
<     stop("covariate must have unique values within groups for \"corAR1\" objects")
---
>     stop(gettextf("covariate must have unique values within groups for objects of class %s", dQuote("corAR1")))
1022c1020
<     stop("parameter in CAR(1) structure must be between 0 and 1")
---
>     stop(gettextf("parameter in %s structure must be between %d and %d", dQuote("CAR(1)"), 0, 1))
1055c1053
<       names(covariate) <- 1:length(covariate)
---
>       names(covariate) <- seq_len(length(covariate))
1080c1078
<     val <- split(val, rep(1:corD[["M"]], (corD[["len"]])^2))
---
>     val <- split(val, rep(seq_len(corD[["M"]]), (corD[["len"]])^2))
1116c1114
<     stop("cannot change the length of the parameter of a \"corCAR1\" object")
---
>     stop(gettextf("cannot change the length of the parameter of an object of class %s", dQuote("corCAR1")))
1143c1141
<     stop("covariate must have unique values within groups for \"corCAR1\" objects")
---
>     stop(gettextf("covariate must have unique values within groups for objects of class %s", dQuote("corCAR1")))
1167c1165
<   function(object, structName = "Continuous AR(1)", ...)
---
>   function(object, structName = gettext("Continuous AR(1)", domain = "R-nlme"), ...)
1193c1191
<     stop("parameters in ARMA structure must be < 1 in absolute value")
---
>     stop(gettextf("parameters in %s structure must be between %d and %d", dQuote("ARMA"), -1, 1))
1212c1210
<     if(is.null(maxLag)) stop("'object' has not been Initialize()d")
---
>     if(is.null(maxLag)) stop("'object' argument has not been initialized with 'Initialize()' function")
1235c1233
<       names(covariate) <- 1:length(covariate)
---
>       names(covariate) <- seq_len(length(covariate))
1245c1243
<   if(is.null(maxLag)) stop("'object' has not been Initialize()d")
---
>   if(is.null(maxLag)) stop("'object' argument has not been initialized with 'Initialize()' function")
1270c1268
<     val <- split(val, rep(1:corD[["M"]], (corD[["len"]])^2))
---
>     val <- split(val, rep(seq_len(corD[["M"]]), (corD[["len"]])^2))
1298c1296
<       nams <- paste(rep("Phi", p), 1:p, sep="")
---
>       nams <- paste(rep("Phi", p), seq_len(p), sep = "")
1301c1299
<       nams <- c(nams, paste(rep("Theta", q), 1:q, sep=""))
---
>       nams <- c(nams, paste(rep("Theta", q), seq_len(q), sep = ""))
1315c1313
<   if(is.null(maxLag)) stop("'object' has not been Initialize()d")
---
>   if(is.null(maxLag)) stop("'object' argument has not been initialized with 'Initialize()' function")
1317c1315
<     stop("cannot change the length of the parameter of a \"corARMA\" object")
---
>     stop(gettextf("cannot change the length of the parameter of an object of class %s", dQuote("corARMA")))
1348c1346
<     stop("covariate must have unique values within groups for \"corARMA\" objects")
---
>     stop(gettextf("covariate must have unique values within groups for objects of class %s", dQuote("corARMA")))
1368c1366
<     if(is.null(maxLag)) stop("'object' has not been Initialize()d")
---
>     if(is.null(maxLag)) stop("'object' argument has not been initialized with 'Initialize()' function")
1401c1399
<     stop("parameter in \"corCompSymm\" structure must be < 1 in absolute value")
---
>     stop(gettextf("parameter in %s structure must be between %d and %d", dQuote("corCompSymm"), -1, 1))
1432c1430
<       names(covariate) <- 1:length(covariate)
---
>       names(covariate) <- seq_len(length(covariate))
1457c1455
<     val <- split(val, rep(1:corD[["M"]], (corD[["len"]])^2))
---
>     val <- split(val, rep(seq_len(corD[["M"]]), (corD[["len"]])^2))
1493c1491
<     stop("cannot change the length of the parameter of a \"corCompSymm\" object")
---
>     stop(gettextf("cannot change the length of the parameter of an object of class %s", dQuote("corCompSymm")))
1520,1521c1518
<       stop(gettextf("initial value in \"corCompSymm\" must be greater than %s",
<                     attr(object, "inf")), domain = NA)
---
>       stop(sprintf(gettext("initial value in \"corCompSymm\" must be greater than %s", domain = "R-nlme"), attr(object, "inf")), domain = NA)
1546c1543
<   function(object, structName = "Compound symmetry", ...)
---
>   function(object, structName = gettext("Compound symmetry", domain = "R-nlme"), ...)
1586c1583
< #      names(covariate) <- 1:length(covariate)
---
> #      names(covariate) <- seq_len(length(covariate))
1613c1610
< #    val <- split(val, rep(1:corD[["M"]], (corD[["len"]])^2))
---
> #    val <- split(val, rep(seq_len(corD[["M"]]), (corD[["len"]])^2))
1710c1707
< #  else cat("Unitialized correlation structure of class corHF\n")
---
> #  else cat("Uninitialized correlation structure of class corHF\n")
1787c1784
<       names(covariate) <- 1:length(covariate)
---
>       names(covariate) <- seq_len(length(covariate))
1817c1814
<     val <- split(val, rep(1:corD[["M"]], (corD[["len"]])^2))
---
>     val <- split(val, rep(seq_len(corD[["M"]]), (corD[["len"]])^2))
1884,1885c1881
<     match(class(object)[1], c("corSpher", "corExp", "corGaus", "corLin",
<                               "corRatio"), 0)
---
>     match(class(object)[1], c("corSpher", "corExp", "corGaus", "corLin", "corRatio"), 0)
1894c1890
<       stop("need data to calculate covariate")
---
>       stop(gettextf("'%s' argument is required in order to calculate covariate of an object of class %s", "data", dQuote("corSpatial")))
1914c1910
<                         function(x) as.vector(dist(1:length(x))))
---
>                         function(x) as.vector(dist(seq_len(length(x)))))
1929c1925
< 	covar <- as.vector(dist(1:nrow(data)))
---
> 	covar <- as.vector(dist(seq_len(nrow(data))))
1954c1950
<       stop("'range' must be > 0 in \"corSpatial\" initial value")
---
>       stop(gettextf("'%s' argument must be > 0 in %s initial value", "range", dQuote("corSpatial")))
1961c1957
< 	  stop("initial value for \"corSpatial\" parameters of wrong dimension")
---
> 	  stop(gettextf("initial value for %s parameters of wrong dimension", dQuote("corSpatial")))
1969c1965
< 	stop("initial value for \"corSpatial\" parameters of wrong dimension")
---
> 	stop(gettextf("initial value for %s parameters of wrong dimension", dQuote("corSpatial")))
2044c2040
<   function(object, structName = "Exponential spatial correlation", ...)
---
>   function(object, structName = gettext("Exponential spatial correlation", domain = "R-nlme"), ...)
2074c2070
<   function(object, structName = "Gaussian spatial correlation", ...)
---
>   function(object, structName = gettext("Gaussian spatial correlation", domain = "R-nlme"), ...)
2124c2120
<       stop("'range' must be > 0 in \"corLin\" initial value")
---
>       stop(gettextf("'%s' argument must be > 0 in %s initial value", "range", dQuote("corLin")))
2135c2131
< 	  stop("initial value for \"corLin\" parameters of wrong dimension")
---
> 	  stop(gettextf("initial value for %s parameters of wrong dimension", dQuote("corLin")))
2143c2139
< 	stop("initial value for \"corLin\" parameters of wrong dimension")
---
> 	stop(gettextf("initial value for %s parameters of wrong dimension", dQuote("corLin")))
2162c2158
<   function(object, structName = "Linear spatial correlation", ...)
---
>   function(object, structName = gettext("Linear spatial correlation", domain = "R-nlme"), ...)
2192c2188
<   function(object, structName = "Rational quadratic spatial correlation", ...)
---
>   function(object, structName = gettext("Rational quadratic spatial correlation", domain = "R-nlme"), ...)
2256c2252
< 	  stop("initial value for \"corSpher\" parameters of wrong dimension")
---
> 	  stop(gettextf("initial value for %s parameters of wrong dimension", dQuote("corSpher")))
2264c2260
< 	stop("initial value for \"corSpher\" parameters of wrong dimension")
---
> 	stop(gettextf("initial value for %s parameters of wrong dimension", dQuote("corSpher")))
2283c2279
<   function(object, structName = "Spherical spatial correlation", ...)
---
>   function(object, structName = gettext("Spherical spatial correlation", domain = "R-nlme"), ...)
diff -rEZbwB '--exclude=*.[lo,d,pdf,mo,po,tgz,gz,save]*' '--exclude=MD5' '--exclude=Makefile*' '--exclude=all.R' '--exclude=Changes' R-recommended/nlme/R/gls.R Recommended/nlme/R/gls.R
45c45
<         stop("\nmodel must be a formula of the form \"resp ~ pred\"")
---
>         stop("'model' argument must be a formula of the form \"resp ~ pred\"")
152,153c152,153
<         aConv <- c("beta" = max(conv[1:p]))
<         conv <- conv[-(1:p)]
---
>         aConv <- c("beta" = max(conv[seq_len(p)]))
>         conv <- conv[-(seq_len(p))]
161,162c161,162
<             cat("\nIteration:",numIter)
<             cat("\nObjective:", format(optRes$value), "\n")
---
>             cat("\n", gettext("Iteration: ", domain = "R-nlme"), numIter, sep = "")
>             cat("\n", gettext("Objective: ", domain = "R-nlme"), format(optRes$value), "\n", sep = "")
164c164
<             cat("\nConvergence:\n")
---
>             cat("\n", gettext("Convergence:", domain = "R-nlme"), "\n", sep = "")
207c207
<             "Approximate variance-covariance matrix not available"
---
>             gettext("Approximate variance-covariance matrix not available", domain = "R-nlme")
312c312
<             "Non-positive definite approximate variance-covariance"
---
>             gettext("Non-positive definite approximate variance-covariance", domain = "R-nlme")
335c335
<               pivot = as.integer(1:(p + 1L)),
---
>               pivot = as.integer(seq_len(p + 1L)),
340,341c340
<         stop(gettextf("computed \"gls\" fit is singular, rank %s", rnk),
<              domain = NA)
---
>         stop(gettextf("computed \"gls\" fit is singular, rank %s", rnk), domain = "R-nlme")
344c343
<     namCoef <- colnames(oXy)[val[["pivot"]][1:rnkm1] + 1L]	# coef names
---
>     namCoef <- colnames(oXy)[val[["pivot"]][seq_len(rnkm1)] + 1L]	# coef names
347c346
<     beta <- val[["beta"]][1:rnkm1]
---
>     beta <- val[["beta"]][seq_len(rnkm1)]
410c409
<                       nn[1:N] <- n + 1L - 1:N
---
>                       nn[seq_len(N)] <- n + 1L - seq_len(N)
412,413c411,412
<                       for(i in 1:N) {
<                           el1 <- el[1:(n-i+1L)]
---
>                       for(i in seq_len(N)) {
>                           el1 <- el[seq_len(n-i+1L)]
439c438
<             stop("object must inherit from class \"gls\"")
---
>             stop(gettextf("'%s' argument is not an object of class %s", "object", dQuote("gls")))
457c456
<         lab <- paste("Denom. DF:", dDF,"\n")
---
>         lab <- paste(gettext("Denom. DF: ", domain = "R-nlme"), dDF, "\n", sep = "")
463c462
<             for(i in 1:nTerms) {
---
>             for(i in seq_len(nTerms)) {
468c467
<                     c0i <- c(qr.qty(qr(vBeta[, assign[[i]], drop = FALSE]), c0))[1:nDF[i]]
---
>                     c0i <- c(qr.qty(qr(vBeta[, assign[[i]], drop = FALSE]), c0))[seq_len(nDF[i])]
483,484c482
<                         stop(gettextf("'Terms' must be between 1 and %d",
<                                       nTerms), domain = NA)
---
>                         stop(gettextf("'%s' argument must be between %d and %d", "Terms", 1, nTerms), domain = "R-nlme")
490,491c488,489
<                                                   "term %s not matched",
<                                                   "terms %s not matched"),
---
>                                                   "term %s was not matched",
>                                                   "terms %s were not matched", domain = "R-nlme"),
500,501c498
<                     paste(lab, "F-test for:",
<                           paste(names(assign[Terms]),collapse=", "),"\n")
---
>                     paste(lab, gettext(" F-test for: ", domain = "R-nlme"), paste(names(assign[Terms]), collapse = ", "), "\n", sep = "")
511c508
<                                           "'L' must have at most %d columns"),
---
>                                           "'L' must have at most %d columns", domain = "R-nlme"),
518c515
<                     L0[, 1:ncolL] <- L
---
>                     L0[, seq_len(ncolL)] <- L
522,525c519,521
<                                               "effect %s not matched",
<                                               "effects %s not matched"),
<                                      paste(dmsL2[noMatch],collapse=", ")),
<                              domain = NA)
---
>                                               "effect %s was not matched",
>                                               "effects %s were not matched", domain = "R-nlme"),
>                                      paste(dmsL2[noMatch], collapse = ", ")), domain = NA)
532,533c528,529
<                 rownames(L) <- if(is.null(dmsL1)) 1:nrowL else dmsL1[noZeroRowL]
<                 lab <- paste(lab, "F-test for linear combination(s)\n")
---
>                 rownames(L) <- if(is.null(dmsL1)) seq_len(nrowL) else dmsL1[noZeroRowL]
>                 lab <- paste(lab, gettext(" F-test for linear combinations", domain = "R-nlme"), "\n", sep = "")
536c532
<             c0 <- c(qr.qty(qr(vBeta %*% t(L)), c0))[1:nDF]
---
>             c0 <- c(qr.qty(qr(vBeta %*% t(L)), c0))[seq_len(nDF)]
568,569c564
<         stop(gettextf("data in %s call must evaluate to a data frame",
<                       sQuote(substitute(object))), domain = NA)
---
>         stop(gettextf("data in %s call must evaluate to a data frame", sQuote(substitute(object))), domain = "R-nlme")
573,574c568
<             stop(gettextf("%s without \"primary\" can only be used with fits of \"groupedData\" objects",
<                           sys.call()[[1L]]), domain = NA)
---
>             stop(gettextf("%s without \"primary\" can only be used with fits of \"groupedData\" objects", sys.call()[[1L]]), domain = "R-nlme")
682,683c676
<             stop(gettextf("%s and %s must have the same group levels", c1, c2),
<                  domain = NA)
---
>             stop(gettextf("%s and %s must have the same group levels", sQuote(c1), sQuote(c2)), domain = "R-nlme")
731c724
<     lab <- "Fitted values"
---
>     lab <- gettext("Fitted values", domain = "R-nlme")
781c774
<         attr(val[["coef"]], "label") <- "Coefficients:"
---
>         attr(val[["coef"]], "label") <- gettext("Coefficients:", domain = "R-nlme")
806,807c799
<                 stop(gettextf("cannot get confidence intervals on var-cov components: %s",
<                               aV), domain = NA)
---
>                 stop(gettextf("cannot get confidence intervals on var-cov components: %s", aV), domain = "R-nlme")
839c831
<                           label = "Residual standard error:")
---
>                           label = gettext("Residual standard error:", domain = "R-nlme"))
843c835
<             for(i in 1:3) {
---
>             for(i in seq_len(3)) {
852,853c844,845
<                            corStruct = "Correlation structure:",
<                            varStruct = "Variance function:",
---
>                            corStruct = gettext("Correlation structure:", domain = "R-nlme"),
>                            varStruct = gettext("Variance function:", domain = "R-nlme"),
924,927c916,918
<                                       "level %s not allowed for %s",
<                                       "levels %s not allowed for %s"),
<                              paste(levs[wch], collapse = ",")),
<                      domain = NA)
---
>                                       "level %s is not allowed for %s",
>                                       "levels %s are not allowed for %s", domain = "R-nlme"),
>                              paste(levs[wch], collapse = ", ")), domain = NA)
948c939
<     lab <- "Predicted values"
---
>     lab <- gettext("Predicted values", domain = "R-nlme")
958,959c949
<     cat(paste0("Approximate ", attr(x, "level") * 100,
<                "% confidence intervals\n"))
---
>     cat(gettextf("Approximate %s %% confidence intervals", attr(x, "level") * 100, domain = "R-nlme"), "\n", sep = "")
978c968,971
<         cat("Generalized nonlinear least squares fit\n")
---
>         cat(gettext("Generalized nonlinear least squares fit", domain = "R-nlme"), "\n", sep = "")
>     } else {
>        if(x$method == "REML") {
>         cat(gettext("Generalized least squares fit by REML", domain = "R-nlme"), "\n", sep = "")
980,981c973,974
<         cat("Generalized least squares fit by ")
<         cat(if(x$method == "REML") "REML\n" else "maximum likelihood\n")
---
>         cat(gettext("Generalized least squares fit by maximum likelihood", domain = "R-nlme"), "\n", sep = "")
>        }
983,984c976,977
<     cat("  Model:", deparse(mCall$model), "\n")
<     cat("  Data:", deparse( mCall$data ), "\n")
---
>     cat(gettext("  Model: ", domain = "R-nlme"), deparse(mCall$model), "\n", sep = "")
>     cat(gettext("  Data: ", domain = "R-nlme"), deparse( mCall$data ), "\n", sep = "")
986c979
<         cat("  Subset:", deparse(asOneSidedFormula(mCall$subset)[[2]]),"\n")
---
>         cat(gettext("  Subset: ", domain = "R-nlme"), deparse(asOneSidedFormula(mCall$subset)[[2]]), "\n", sep = "")
989c982
<         cat("  Log-likelihood: ", format(x$logLik), "\n", sep = "")
---
>         cat(gettext("  Log-likelihood: ", domain = "R-nlme"), format(x$logLik), "\n", sep = "")
991,992c984,988
<         cat("  Log-", if(x$method == "REML") "restricted-" else "",
<             "likelihood: ", format(x$logLik), "\n", sep = "")
---
>       if(x$method == "REML") {
>         cat(gettext("  Log-restricted-likelihood: ", domain = "R-nlme"), format(x$logLik), "\n", sep = "")
>       } else {
>         cat(gettext("  Log-likelihood: ", domain = "R-nlme"), format(x$logLik), "\n", sep = "")
>       }
994c990
<     cat("\nCoefficients:\n")
---
>     cat("\n", gettext("Coefficients:", domain = "R-nlme"), "\n", sep = "")
1000,1002c996,997
<     cat("Degrees of freedom:", dd[["N"]],"total;",dd[["N"]] - dd[["p"]],
<         "residual\n")
<     cat("Residual standard error:", format(x$sigma),"\n")
---
>     cat(gettextf("Degrees of freedom: %s total; %s residual", dd[["N"]], dd[["N"]] - dd[["p"]], domain = "R-nlme"), "\n", sep = "")
>     cat(gettext("Residual standard error: ", domain = "R-nlme"), format(x$sigma), "\n", sep = "")
1017c1012,1015
<         cat("Generalized nonlinear least squares fit\n")
---
>         cat(gettext("Generalized nonlinear least squares fit", domain = "R-nlme"), "\n", sep = "")
>     } else {
>        if(x$method == "REML") {
>         cat(gettext("Generalized least squares fit by REML", domain = "R-nlme"), "\n", sep = "")
1019,1020c1017
<         cat("Generalized least squares fit by ")
<         cat(if(x$method == "REML") "REML\n" else "maximum likelihood\n")
---
>         cat(gettext("Generalized least squares fit by maximum likelihood", domain = "R-nlme"), "\n", sep = "")
1022,1023c1019,1021
<     cat("  Model:", deparse(mCall$model), "\n")
<     cat("  Data:", deparse( mCall$data ), "\n")
---
>     }
>     cat(gettext("  Model: ", domain = "R-nlme"), deparse(mCall$model), "\n", sep = "")
>     cat(gettext("  Data: ", domain = "R-nlme"), deparse( mCall$data ), "\n", sep = "")
1025c1023
<         cat("  Subset:", deparse(asOneSidedFormula(mCall$subset)[[2]]),"\n")
---
>         cat(gettext("  Subset: ", domain = "R-nlme"), deparse(asOneSidedFormula(mCall$subset)[[2]]), "\n", sep = "")
1028c1026
<     if (verbose) { cat("Convergence at iteration:",x$numIter,"\n") }
---
>     if (verbose) { cat(gettext("Convergence at iteration: ", domain = "R-nlme"), x$numIter, "\n", sep = "") }
1033c1031
<     cat("\nCoefficients:\n")
---
>     cat("\n", gettext("Coefficients:", domain = "R-nlme"), "\n", sep = "")
1049,1050c1047
<               title = "\n Correlation:",
<               ...)
---
>               title = paste("\n ", gettext("Correlation:", domain = "R-nlme"), collapse = ""), ...)
1052c1049
<     cat("\nStandardized residuals:\n")
---
>     cat("\n", gettext("Standardized residuals:", domain = "R-nlme"), "\n", sep = "")
1055,1057c1052,1053
<     cat("Residual standard error:", format(x$sigma),"\n")
<     cat("Degrees of freedom:", dd[["N"]],"total;",dd[["N"]] - dd[["p"]],
<         "residual\n")
---
>     cat(gettext("Residual standard error: ", domain = "R-nlme"), format(x$sigma), "\n", sep = "")
>     cat(gettextf("Degrees of freedom: %s total; %s residual", dd[["N"]], dd[["N"]] - dd[["p"]], domain = "R-nlme"), "\n", sep = "")
1068c1064
<         lab <- "Standardized residuals"
---
>         lab <- gettext("Standardized residuals", domain = "R-nlme")
1073c1069
<                 lab <- "Normalized residuals"
---
>                 lab <- gettext("Normalized residuals", domain = "R-nlme")
1077c1073
<         lab <- "Residuals"
---
>         lab <- gettext("Residuals", domain = "R-nlme")
1136c1132
< 	stop("need an object with call component")
---
> 	stop("an object with 'call' component is required")
1210c1206
<                     covar <- 1:nrow(data)
---
>                     covar <- seq_len(nrow(data))
1260c1256
<                 stop("'nint' is not consistent with 'breaks'")
---
>                 stop(gettextf("'%s' is not consistent with '%s'", "nint", "breaks"))
1291c1287
<     row.names(val) <- 1:nrow(val)
---
>     row.names(val) <- seq_len(nrow(val))
diff -rEZbwB '--exclude=*.[lo,d,pdf,mo,po,tgz,gz,save]*' '--exclude=MD5' '--exclude=Makefile*' '--exclude=all.R' '--exclude=Changes' R-recommended/nlme/R/gnls.R Recommended/nlme/R/gnls.R
68c68
<     stop("'object' must be a formula")
---
>     stop(gettextf("'%s' argument is not an object of class %s", "model", dQuote("formula")))
70c70
<     stop("object formula must be of the form \"resp ~ pred\"")
---
>     stop("model formula must be of the form \"resp ~ pred\"")
82c82
<           stop("'data' must be given explicitly to use 'nls' to get initial estimates")
---
>           stop(gettextf("'%s' argument must be given explicitly to use %s function to get initial estimates", "data", sQuote("nls()")))
123c123
<       stop ("'params' must be a formula or list of formulae")
---
>       stop(gettextf("'%s' argument must be a formula or list of formulae", "params"))
125c125
<       stop ("formulae in 'params' must be of the form \"parameter ~ expr\"")
---
>       stop(gettextf("formulae in '%s' must be of the form \"parameter ~ expr\"", "params"))
127c127
<       stop ("formulae in 'params' must be of the form \"parameter ~ expr\"")
---
>       stop(gettextf("formulae in '%s' must be of the form \"parameter ~ expr\"", "params"))
378c378
<             cat("\n**Iteration", numIter)
---
>             cat("\n**", gettextf("Iteration %d", numIter, domain = "R-nlme"), sep = "")
380c380
<             cat("GLS step: Objective:", format(optRes$value))
---
>             cat(gettext("GLS step: Objective: ", domain = "R-nlme"), format(optRes$value), sep = "")
429,431c429,431
<       cat("\nNLS step: RSS = ", format(work$set[6]), "\n model parameters:")
<       for (i in 1:pLen) cat(format(signif(spar[i]))," ")
<       cat("\n iterations:",work$set[5],"\n")
---
>       cat("\n", gettextf("NLS step: RSS = %s", format(work$set[6]), domain = "R-nlme"), "\n ", gettext("model parameters:", domain = "R-nlme"), sep = "")
>       for (i in seq_len(pLen)) cat(format(signif(spar[i]))," ")
>       cat("\n ", gettext("iterations: ", domain = "R-nlme"), work$set[5], "\n", sep = "")
437c437
<     aConv <- c(max(conv[1:pLen]))
---
>     aConv <- c(max(conv[seq_len(pLen)]))
440c440
<       conv <- conv[-(1:pLen)]
---
>       conv <- conv[-(seq_len(pLen))]
450c450
<       cat("\nConvergence:\n")
---
>       cat("\n", gettext("Convergence:", domain = "R-nlme"), "\n", sep = "")
472c472
<   auxRes <- ww[NReal * pLen + (1:NReal)]
---
>   auxRes <- ww[NReal * pLen + seq_len(NReal)]
486c486
<   varBeta <- qr(attr(gnlsSt, "conLin")$Xy[ , 1:pLen, drop = FALSE])
---
>   varBeta <- qr(attr(gnlsSt, "conLin")$Xy[ , seq_len(pLen), drop = FALSE])
518c518
<     apVar <- "Approximate variance-covariance matrix not available"
---
>     apVar <- gettext("Approximate variance-covariance matrix not available", domain = "R-nlme")
622c622
<       "Non-positive definite approximate variance-covariance"
---
>       gettext("Non-positive definite approximate variance-covariance", domain = "R-nlme")
731,732c731,732
<                                 "level %s not allowed for %s",
<                                 "levels %s not allowed for %s"),
---
>                                 "level %s is not allowed for %s",
>                                 "levels %s are not allowed for %s", domain = "R-nlme"),
790c790
<   lab <- "Predicted values"
---
>   lab <- gettext("Predicted values", domain = "R-nlme")
804c804
< 	stop("need an object with call component")
---
> 	stop("an object with 'call' component is required")
diff -rEZbwB '--exclude=*.[lo,d,pdf,mo,po,tgz,gz,save]*' '--exclude=MD5' '--exclude=Makefile*' '--exclude=all.R' '--exclude=Changes' R-recommended/nlme/R/groupedData.R Recommended/nlme/R/groupedData.R
32c32
<     stop("first argument to 'groupedData' must be a two-sided formula")
---
>     stop(gettextf("first argument passed to %s function must be a two-sided formula", sQuote("GroupedData()")))
52c52
<     stop("first argument to 'nfGroupedData' must be a two-sided formula")
---
>     stop(gettextf("first argument passed to %s function must be a two-sided formula", sQuote("nfGroupedData()")))
69c69
<       stop("second argument to 'groupedData' must inherit from data.frame")
---
>       stop("second argument passed to 'groupedData()' function must inherit from \"data.frame\"")
152c152
<     stop("first argument to 'nmGroupedData' must be a two-sided formula")
---
>     stop(gettextf("first argument passed to %s function must be a two-sided formula", sQuote("nmGroupedData()")))
178c178
<       stop("second argument to 'groupedData' must inherit from data.frame")
---
>       stop("second argument passed to 'groupedData()' function must inherit from \"data.frame\"")
229c229
<       stop("'subset' must be a list")
---
>       stop(gettextf("'%s' argument must be a list", "subset"))
250,251c250
<       stop(gettextf("undefined display level %s for %s",
<                     displayLevel, sQuote(substitute(object))), domain = NA)
---
>       stop(gettextf("undefined display level %s for %s", displayLevel, sQuote(substitute(object))), domain = "R-nlme")
276,277c275
<         stop(gettextf("undefined collapsing level %s for %s",
<                       collapseLevel, sQuote(substitute(object))), domain = NA)
---
>         stop(gettextf("undefined collapsing level %s for %s", collapseLevel, sQuote(substitute(object))), domain = "R-nlme")
297c295
<           stop("'preserve' must be a two-sided formula")
---
>           stop(gettextf("'%s' argument must be a two-sided formula", "preserve"))
564c562
<   cat("Grouped Data: ")
---
>   cat(gettext("Grouped Data: ", domain = "R-nlme"))
630c628
<     stop("'asTable' cannot be used with multilevel grouped data")
---
>     stop("'asTable()' function cannot be used with multilevel grouped data")
634c632
<     stop("'asTable' can only be used with balanced 'groupedData' objects")
---
>     stop("'asTable()' function can only be used with balanced object of class \"groupedData\"")
diff -rEZbwB '--exclude=*.[lo,d,pdf,mo,po,tgz,gz,save]*' '--exclude=MD5' '--exclude=Makefile*' '--exclude=all.R' '--exclude=Changes' R-recommended/nlme/R/lmList.R Recommended/nlme/R/lmList.R
66c66
<       stop ("'data' must be a \"groupedData\" object if 'groups' argument is missing")
---
>       stop(gettextf("'%s' argument must be an object of class %s if 'groups' argument is missing", "data", dQuote("groupedData")))
114,115c114
<       stop(gettextf("'data' in %s call must evaluate to a data frame",
<                      sQuote(substitute(object))), domain = NA)
---
>       stop(gettextf("'data' in %s call must evaluate to a data frame", sQuote(substitute(object))), domain = "R-nlme")
119,120c118
<         stop(gettextf("%s without \"primary\" can only be used with fits of \"groupedData\" objects",
<                       sys.call()[[1]]), domain = NA)
---
>         stop(gettextf("%s without \"primary\" can only be used with fits of \"groupedData\" objects", sys.call()[[1]]), domain = "R-nlme")
219c217
<       attr(coefs, "label") <- "Coefficients"
---
>       attr(coefs, "label") <- gettext("Coefficients", domain = "R-nlme")
235c233
<         stop("nonexistent groups requested in 'subset'")
---
>         stop("nonexistent groups requested in 'subset' argument")
240c238
<           stop("nonexistent groups requested in 'subset'")
---
>           stop("nonexistent groups requested in 'subset' argument")
243c241
<         stop("'subset' can only be character or integer")
---
>         stop(gettextf("'%s' argument can only be character or integer", "subset"))
265c263
<   lab <- "Fitted values"
---
>   lab <- gettext("Fitted values", domain = "R-nlme")
390c388
<     stop("'form' must be a formula")
---
>     stop(gettextf("'%s' argument is not an object of class %s", "form", dQuote("formula")))
393c391
<     stop("'form' must be a one-sided formula")
---
>     stop(gettextf("'%s' argument must be a one-sided formula", "form"))
409,410c407,408
<                               "%s not found in data",
<                               "%s not found in data"),
---
>                               "%s was not found in data",
>                               "%s were not found in data", domain = "R-nlme"),
461c459
<     for(i in 1:length(gr)) {
---
>     for(i in seq_len(length(gr))) {
476c474
< 		 stop("'id' must be between 0 and 1")
---
> 		 stop(gettextf("'%s' argument must be between %d and %d", "id", 0, 1))
485c483
< 	     stop("'id' can only be a formula or numeric")
---
>              stop(gettextf("'%s' argument can only be a formula or numeric", "id"))
500c498
< 	  stop("'idLabels' of incorrect length")
---
>           stop(gettextf("'%s' argument is of incorrect length", "idLabels"))
504c502
< 	stop("'idLabels' can only be a formula or a vector")
---
> 	stop(gettextf("'%s' argument can only be a formula or a vector", "idLabels"))
652c650
<     stop("'form' must be a formula")
---
>     stop(gettextf("'%s' argument is not an object of class %s", "form", dQuote("formula")))
669,670c667,668
<                               "%s not found in data",
<                               "%s not found in data"),
---
>                               "%s was not found in data",
>                               "%s were not found in data", domain = "R-nlme"),
728c726
<     for(i in 1:length(gr)) {
---
>     for(i in seq_len(length(gr))) {
748c746
< 		 stop("'id' must be between 0 and 1")
---
> 		 stop(gettextf("'%s' argument must be between %d and %d", "id", 0, 1))
753c751
< 	     stop("'id' can only be a formula or numeric")
---
>              stop(gettextf("'%s' argument can only be a formula or numeric", "id"))
765c763
< 	  stop("'idLabels' of incorrect length")
---
>           stop(gettextf("'%s' argument is of incorrect length", "idLabels"))
769c767
< 	stop("'idLabels' can only be a formula or a vector")
---
> 	stop(gettextf("'%s' argument can only be a formula or a vector", "idLabels"))
873c871
<       stop("nonexistent group requested in 'subset'")
---
>       stop("nonexistent groups requested in 'subset' argument")
959c957
<       attr(val, "label") <- "Predicted values"
---
>       attr(val, "label") <- gettext("Predicted values", domain = "R-nlme")
981c979
<   cat("Call:\n")
---
>   cat(gettext("Call:", domain = "R-nlme"), "\n", sep = "")
983,985c981
<   cat("  Model:", deparse(getResponseFormula(form)[[2]]),
<       "~", c_deparse(getCovariateFormula(form)[[2]]), "|",
<       deparse(getGroupsFormula(x)[[2]]), "\n")
---
>   cat(gettext("  Model: ", domain = "R-nlme"), deparse(getResponseFormula(form)[[2]]), " ~ ", c_deparse(getCovariateFormula(form)[[2]]), " | ", deparse(getGroupsFormula(x)[[2]]), "\n", sep = "")
987c983
<     cat(" Level:", mCall$level, "\n")
---
>     cat(gettext(" Level: ", domain = "R-nlme"), mCall$level, "\n", sep = "")
989,990c985,986
<   cat("   Data:", deparse(mCall$data),"\n\n")
<   cat("Coefficients:\n")
---
>   cat(gettext("   Data: ", domain = "R-nlme"), deparse(mCall$data), "\n\n", sep = "")
>   cat(gettext("Coefficients:", domain = "R-nlme"), "\n", sep = "")
997,999c993,994
<     cat("Degrees of freedom: ", length(unlist(lapply(x, fitted))),
< 	" total; ", dfRes, " residual\n", sep = "")
<     cat("Residual standard error:", format(RSE))
---
>     cat(gettextf("Degrees of freedom: %s total; %s residual", length(unlist(lapply(x, fitted))), dfRes, domain = "R-nlme"), "\n", sep = "")
>     cat(gettext("Residual standard error: ", domain = "R-nlme"), format(RSE), sep = "")
1007c1002
<   cat("Call:\n")
---
>   cat(gettext("Call:", domain = "R-nlme"), "\n", sep = "")
1009,1011c1004,1005
<   cat("  Model:", deparse(getResponseFormula(form)[[2]]),
<       "~", c_deparse(getCovariateFormula(form)[[2]]), "|",
<       deparse(attr(x, "groupsForm")[[2]]), "\n")
---
>   cat(gettext("  Model: ", domain = "R-nlme"), deparse(getResponseFormula(form)[[2]]),
>       " ~ ", c_deparse(getCovariateFormula(form)[[2]]), " | ", deparse(attr(x, "groupsForm")[[2]]), "\n", sep = "")
1013c1007
<     cat(" Level:", x$call$level, "\n")
---
>     cat(gettext(" Level: ", domain = "R-nlme"), x$call$level, "\n", sep = "")
1015,1016c1009,1010
<   cat("   Data:", deparse(x$call$data),"\n\n")
<   cat("Coefficients:\n")
---
>   cat(gettext("   Data: ", domain = "R-nlme"), deparse(x$call$data), "\n\n", sep = "")
>   cat(gettext("Coefficients:", domain = "R-nlme"), "\n", sep = "")
1023,1024c1017
<     cat("Residual standard error:", format(x$RSE), "on",
< 	x$df.residual, "degrees of freedom\n")
---
>     cat(gettextf("Residual standard error: %s on %s degrees of freedom", format(x$RSE), x$df.residual, domain = "R-nlme"), "\n", sep = "")
1037c1030
<     stop("'form' must be a formula")
---
>     stop(gettextf("'%s' argument is not an object of class %s", "form", dQuote("formula")))
1052,1053c1045,1046
<                               "%s not found in data",
<                               "%s not found in data"),
---
>                               "%s was not found in data",
>                               "%s were not found in data", domain = "R-nlme"),
1070,1071c1063,1064
<     else if (!is.null(labs) && ((labs == "Standardized residuals") ||
<                                 (substr(labs, 1, 9) == "Residuals")))
---
>     else if (!is.null(labs) && ((labs == gettext("Standardized residuals", domain = "R-nlme")) ||
>                            (labs == gettext("Residuals", domain = "R-nlme"))))
1076c1069
<   if (is.null(args$ylab)) args$ylab <- "Quantiles of standard normal"
---
>   if (is.null(args$ylab)) args$ylab <- gettext("Quantiles of standard normal", domain = "R-nlme")
1090c1083
<                    stop("'id' must be between 0 and 1")
---
> 		   stop(gettextf("'%s' argument must be between %d and %d", "id", 0, 1))
1096c1089
<                stop("'id' can only be a formula or numeric")
---
>                stop(gettextf("'%s' argument can only be a formula or numeric", "id"))
1108c1101
<             stop("'idLabels' of incorrect length")
---
>             stop(gettextf("'%s' argument is of incorrect length", "idLabels"))
1112c1105
<           stop("'idLabels' can only be a formula or a vector")
---
> 	  stop(gettextf("'%s' argument can only be a formula or a vector", "idLabels"))
1143c1136
<                    stop("'id' must be between 0 and 1")
---
> 		   stop(gettextf("'%s' argument must be between %d and %d", "id", 0, 1))
1149c1142
<                stop("'id' can only be a formula or numeric")
---
>                stop(gettextf("'%s' argument can only be a formula or numeric", "id"))
1164c1157
<             stop("'idLabels' of incorrect length")
---
>             stop(gettextf("'%s' argument is of incorrect length", "idLabels"))
1168c1161
<           stop("'idLabels' can only be a formula or a vector")
---
> 	  stop(gettextf("'%s' argument can only be a formula or a vector", "idLabels"))
1243c1236
<     attr(val, "label") <- "Standardized random effects"
---
>     attr(val, "label") <- gettext("Standardized random effects", domain = "R-nlme")
1245c1238
<     attr(val, "label") <- "Random effects"
---
>     attr(val, "label") <- gettext("Random effects", domain = "R-nlme")
1264c1257
<         stop("nonexistent groups requested in 'subset'")
---
>         stop("nonexistent groups requested in 'subset' argument")
1269c1262
<           stop("nonexistent groups requested in 'subset'")
---
>           stop("nonexistent groups requested in 'subset' argument")
1272c1265
<         stop("'subset' can only be character or integer")
---
>         stop(gettextf("'%s' argument can only be character or integer", "subset"))
1315c1308
<     lab <- "Residuals"
---
>     lab <- gettext("Residuals", domain = "R-nlme")
1319c1312
<   } else lab <- "Standardized residuals"
---
>   } else lab <- gettext("Standardized residuals", domain = "R-nlme")
1341c1334
< 		for (ii in 1:length(lst))
---
> 		for (ii in seq_len(length(lst)))
1351c1344
< 		for (ii in 1:length(lst))
---
> 		for (ii in seq_len(length(lst)))
diff -rEZbwB '--exclude=*.[lo,d,pdf,mo,po,tgz,gz,save]*' '--exclude=MD5' '--exclude=Makefile*' '--exclude=all.R' '--exclude=Changes' R-recommended/nlme/R/lme.R Recommended/nlme/R/lme.R
67c67
<     stop("can only fit \"lmList\" objects with single grouping variable")
---
>     stop(gettextf("can only fit objects of class %s with single grouping variable", dQuote("lmList")))
72c72
<     warning("'lme.lmList' will redefine 'data'")
---
>     warning("'lme.lmList()' function will redefine 'data' argument")
108c108
<     stop("can only fit \"lmList\" objects with single grouping variable")
---
>     stop(gettextf("can only fit objects of class %s with single grouping variable", dQuote("lmList")))
113c113
<       warning("initial value for \"reStruct\" overwritten in 'lme.lmList'")
---
>       warning(gettextf("initial value for 'reStruct' overwritten in %s function", sQuote("lme.lmList()")))
158c158
<     stop("\nfixed-effects model must be a formula of the form \"resp ~ pred\"")
---
>     stop("fixed-effects model must be a formula of the form \"resp ~ pred\"")
171c171
<           stop("incompatible lengths for 'random' and grouping factors")
---
>           stop("incompatible lengths for 'random' argument and grouping factors")
175c175
<         for(i in 1:Q) randL[[i]] <- random
---
>         for(i in seq_len(Q)) randL[[i]] <- random
198c198
<           stop("incompatible formulas for groups in 'random' and 'correlation'")
---
>           stop("incompatible formulas for groups in 'random' and 'correlation' arguments")
209c209
<           stop("incompatible formulas for groups in 'random' and 'correlation'")
---
>           stop("incompatible formulas for groups in 'random' and 'correlation' arguments")
295,296c295
<     warning(gettextf("fewer observations than random effects in all level %s groups",
<                      Q), domain = NA)
---
>     warning(gettextf("fewer observations than random effects in all level %s groups", Q), domain = "R-nlme")
349c348
<           stop(msg, domain = NA)
---
>           stop(msg, domain = "R-nlme")
351c350
<           warning(msg, domain = NA)
---
>           warning(msg, domain = "R-nlme")
375c374
<         warning(msg, domain = NA)
---
>         warning(msg, domain = "R-nlme")
378c377
<         stop(msg, domain = NA)
---
>         stop(msg, domain = "R-nlme")
419c418
<       "Approximate variance-covariance matrix not available"
---
>       gettext("Approximate variance-covariance matrix not available", domain = "R-nlme")
628c627
<     "Non-positive definite approximate variance-covariance"
---
>     gettext("Non-positive definite approximate variance-covariance", domain = "R-nlme")
777c776
<   for(i in 1:Q) {
---
>   for(i in seq_len(Q)) {
799c798
<   for(i in 1:Q) lastBlock[[i]] <- c(strSizes[i, -N], strRows)
---
>   for(i in seq_len(Q)) lastBlock[[i]] <- c(strSizes[i, -N], strRows)
801c800
<   for(i in 1:Q) lastBlock[[i]] <- maxStr[as.logical(lastBlock[[i]])]
---
>   for(i in seq_len(Q)) lastBlock[[i]] <- maxStr[as.logical(lastBlock[[i]])]
812c811
<        DmOff = (c(0, cumsum(ncols^2)))[1:(Q+2)],
---
>        DmOff = (c(0, cumsum(ncols^2)))[seq_len(Q+2)],
845c844
<                   nn[1:N] <- n + 1L - 1:N
---
>                   nn[seq_len(N)] <- n + 1L - seq_len(N)
847,848c846,847
<                   for(i in 1:N) {
<                     tt[i] <- sum(el[1:(n-i+1)] * el[i:n])
---
>                   for(i in seq_len(N)) {
>                     tt[i] <- sum(el[seq_len(n-i+1)] * el[i:n])
874c873
<       stop("object must inherit from class \"lme\" ")
---
>       stop(gettextf("'%s' argument is not an object of class %s", "object", dQuote("lme")))
889c888
<       for(i in 1:nTerms) {
---
>       for(i in seq_len(nTerms)) {
911,912c910
<             stop(gettextf("'Terms' must be between 1 and %d", nTerms),
<                  domain = NA)
---
>             stop(gettextf("'%s' argument must be between %d and %d", "Terms", 1, nTerms), domain = "R-nlme")
918,919c916,917
<                                     "term %s not matched",
<                                     "terms %s not matched"),
---
>                                     "term %s was not matched",
>                                     "terms %s were not matched", domain = "R-nlme"),
932c930
<           paste("F-test for:",paste(names(assign[Terms]),collapse=", "),"\n")
---
>           paste(gettext("F-test for: ", domain = "R-nlme"), paste(names(assign[Terms]), collapse = ", "), "\n", sep = "")
942c940
<                                 "'L' must have at most %d columns"),
---
>                                 "'L' must have at most %d columns", domain = "R-nlme"),
949c947
<           L0[, 1:ncolL] <- L
---
>           L0[, seq_len(ncolL)] <- L
953,954c951,952
<                                   "effect %s not matched",
<                                   "effects %s not matched"),
---
>                                   "effect %s was not matched",
>                                   "effects %s were not matched", domain = "R-nlme"),
963c961
<           dmsL1 <- 1:nrowL
---
>           dmsL1 <- seq_len(nrowL)
974c972
<         lab <- "F-test for linear combination(s)\n"
---
>         lab <- paste(gettext("F-test for linear combinations", domain = "R-nlme"), "\n", sep = "")
1006c1004
<            domain=NA)
---
>            domain="R-nlme")
1066c1064
<                       Model = (1:rt),
---
>                       Model = seq_len(rt),
1108c1106
<                   sQuote(substitute(object))), domain = NA)
---
>                   sQuote(substitute(object))), domain = "R-nlme")
1146c1144
<   pred <- predict(object, value[1:(nrow(value)/nL), , drop = FALSE], level = level)
---
>   pred <- predict(object, value[seq_len(nrow(value)/nL), , drop = FALSE], level = level)
1211c1209
<   for (i in 1:level) {
---
>   for (i in seq_len(level)) {
1232c1230
<   attr(effs, "label") <- "Coefficients"
---
>   attr(effs, "label") <- gettext("Coefficients", domain = "R-nlme")
1250c1248
<                             "nonexistent levels %s"),
---
>                             "nonexistent levels %s", domain = "R-nlme"),
1266c1264
<     lab <- "Fitted values"
---
>     lab <- gettext("Fitted values", domain = "R-nlme")
1321c1319
<     attr(vfix, "label") <- "Fixed effects:"
---
>     attr(vfix, "label") <- gettext("Fixed effects:", domain = "R-nlme")
1327c1325
<                     aV, "which = \"fixed\""), domain = NA)
---
>                     aV, "which = \"fixed\""), domain = "R-nlme")
1358c1356
<     attr(vsig, "label") <- "Within-group standard error:"
---
>     attr(vsig, "label") <- gettext("Within-group standard error:", domain = "R-nlme")
1372c1370
<       attr(vsig, "label") <- "Within-group standard error:"
---
>       attr(vsig, "label") <- gettext("Within-group standard error:", domain = "R-nmle")
1392c1390
<     for(i in 1:3) {                     # re-express intervals in constrained pars
---
>     for(i in seq_len(3)) {                     # re-express intervals in constrained pars
1418,1420c1416,1418
<                reStruct = "Random Effects:",
<                corStruct = "Correlation structure:",
<                varStruct = "Variance function:",
---
>                reStruct = gettext("Random effects:", domain = "R-nlme"),
>                corStruct = gettext("Correlation structure:", domain = "R-nlme"),
>                varStruct = gettext("Variance function:", domain = "R-nlme"),
1466c1464
<     stop("'form' must be a formula")
---
>     stop(gettextf("'%s' argument is not an object of class %s", "form", dQuote("formula")))
1469c1467
<     stop("'form' must be a one-sided formula")
---
>     stop(gettextf("'%s' argument must be a one-sided formula", "form"))
1485,1486c1483,1484
<                               "%s not found in data",
<                               "%s not found in data"),
---
>                               "%s was not found in data",
>                               "%s were not found in data", domain = "R-nlme"),
1538c1536
<     for(i in 1:length(gr)) {
---
>     for(i in seq_len(length(gr))) {
1555c1553
<                  stop("'id' must be between 0 and 1")
---
>                  stop(gettextf("'%s' argument must be between %d and %d", "id", 0, 1))
1567c1565
<              stop("'id' can only be a formula or numeric")
---
>              stop(gettextf("'%s' argument can only be a formula or numeric", "id"))
1572c1570
<         stop("covariate must have a level attribute when 'id' is a formula")
---
>         stop(gettextf("covariate must have a level attribute when '%s' argument is a formula", "id"))
1585c1583
<           stop("'idLabels' of incorrect length")
---
>           stop(gettextf("'%s' argument is of incorrect length", "idLabels"))
1589c1587
<         stop("'idLabels' can only be a formula or a vector")
---
>         stop(gettextf("'%s' argument can only be a formula or a vector", "idLabels"))
1595c1593
<         stop("covariate must have a level attribute when 'idLabels' is a formula")
---
>         stop(gettextf("covariate must have a level attribute when '%s' argument is a formula", "idLabels"))
1728,1729c1726,1727
<                               "%s not available for plotting",
<                               "%s not available for plotting"),
---
>                               "%s is not available for plotting",
>                               "%s are not available for plotting", domain = "R-nlme"),
1767c1765
<       stop("'form' must be a formula when not NULL")
---
>       stop(gettextf("'%s' argument must be a formula when not NULL", "form"))
1777,1778c1775
<       stop(gettextf("%s is not a valid effect name", sQuote(reName)),
<            domain = NA)
---
>       stop(gettextf("%s is not a valid effect name", sQuote(reName)), domain = "R-nlme")
1786,1787c1783,1784
<                             "%s not available for plotting",
<                             "%s not available for plotting"),
---
>                             "%s is not available for plotting",
>                             "%s are not available for plotting", domain = "R-nlme"),
1800c1797
<     for(i in 1:nV) {
---
>     for(i in seq_len(nV)) {
1977,1978c1974,1975
<                               "level %s not allowed for %s",
<                               "levels %s not allowed for %s"),
---
>                               "level %s is not allowed for %s",
>                               "levels %s are not allowed for %s", domain = "R-nlme"),
2009c2006
<     attr(val, "label") <- "Predicted values"
---
>     attr(val, "label") <- gettext("Predicted values", domain = "R-nlme")
2051c2048
<     lab <- "Predicted values"
---
>     lab <- gettext("Predicted values", domain = "R-nlme")
2080c2077
<       cat("Call:\n")
---
>       cat(gettext("Call:", domain = "R-nlme"), "\n", sep = "")
2082c2079
<       for(i in 1:rt) {
---
>       for(i in seq_len(rt)) {
2084c2081
<         cat(" ",as.character(x[i,"call"]),"\n")
---
>         cat(" ", as.character(x[i,"call"]), "\n", sep = "")
2116,2117c2113
<   cat(paste("Approximate ", attr(x, "level") * 100,
<             "% confidence intervals\n", sep = ""))
---
>   cat(gettextf("Approximate %s %% confidence intervals", attr(x, "level") * 100,  domain = "R-nlme"), "\n", sep = "")
2123c2119
<         cat("  Level:", j, "\n")
---
>         cat(gettext("  Level: ",  domain = "R-nlme"), j, "\n", sep = "")
2139,2141c2135,2140
<     cat( "Nonlinear mixed-effects model fit by " )
<     cat( if(x$method == "REML") "REML\n" else "maximum likelihood\n")
<     cat("  Model:", deparse(x$call$model),"\n")
---
>     if(x$method == "REML") {
>      cat(gettext("Nonlinear mixed-effects model fit by REML", domain = "R-nlme"), "\n", sep = "")
>     } else {
>      cat(gettext("Nonlinear mixed-effects model fit by maximum likelihood", domain = "R-nlme"), "\n", sep = "")
>     }
>     cat(gettext("  Model: ", domain = "R-nlme"), deparse(x$call$model), "\n", sep = "")
2143,2144c2142,2146
<     cat( "Linear mixed-effects model fit by " )
<     cat( if(x$method == "REML") "REML\n" else "maximum likelihood\n")
---
>     if(x$method == "REML") {
>      cat(gettext("Linear mixed-effects model fit by REML", domain = "R-nlme"), "\n", sep = "")
>     } else {
>      cat(gettext("Linear mixed-effects model fit by maximum likelihood", domain = "R-nlme"), "\n", sep = "")
>     }
2146c2148
<   cat("  Data:", deparse( x$call$data ), "\n")
---
>   cat(gettext("  Data: ", domain = "R-nlme"), deparse( x$call$data ), "\n", sep = "")
2148c2150,2155
<     cat("  Subset:", deparse(asOneSidedFormula(x$call$subset)[[2L]]),"\n")
---
>     cat(gettext("  Subset: ", domain = "R-nlme"), deparse(asOneSidedFormula(x$call$subset)[[2L]]), "\n", sep = "")
>   }
>   if(x$method == "REML") {
>    cat(gettext("  Log-restricted-likelihood: ", domain = "R-nlme"), format(x$logLik), "\n", sep = "")
>   } else {
>    cat(gettext("  Log-likelihood: ", domain = "R-nlme"), format(x$logLik), "\n", sep = "")
2150,2151d2156
<   cat("  Log-", if(x$method == "REML") "restricted-" else "",
<       "likelihood: ", format(x$logLik), "\n", sep = "")
2154c2159
<     cat("  Fixed:", deparse(x$call$fixed), "\n")
---
>     cat(gettext("  Fixed: ", domain = "R-nlme"), deparse(x$call$fixed), "\n", sep = "")
2156,2157c2161
<     cat("  Fixed:", deparse(lapply(fixF, function(el)
<       as.name(deparse(el)))), "\n")
---
>     cat("  Fixed: ", deparse(lapply(fixF, function(el) as.name(deparse(el)))), "\n", sep = "")
2162,2163c2166,2167
<   cat("Number of Observations:", dd[["N"]])
<   cat("\nNumber of Groups: ")
---
>   cat(gettext("Number of Observations: ", domain = "R-nlme"), dd[["N"]], "\n", sep = "")
>   cat(gettext("Number of Groups: ", domain = "R-nlme"))
2186c2190
<       cat("Level:", attr(x, "grpNames")[i],"\n")
---
>       cat(gettext("Level: ", domain = "R-nlme"), attr(x, "grpNames")[i], "\n", sep = "")
2200,2202c2204,2209
<     cat( "Nonlinear mixed-effects model fit by " )
<     cat( if(x$method == "REML") "REML\n" else "maximum likelihood\n")
<     cat("  Model:", deparse(x$call$model),"\n")
---
>     if(x$method == "REML") {
>      cat(gettext("Nonlinear mixed-effects model fit by REML", domain = "R-nlme"), "\n", sep = "")
>     } else {
>      cat(gettext("Nonlinear mixed-effects model fit by maximum likelihood", domain = "R-nlme"), "\n", sep = "")
>     }
>     cat(gettext("  Model: ", domain = "R-nlme"), deparse(x$call$model), "\n", sep = "")
2204,2205c2211,2215
<     cat( "Linear mixed-effects model fit by " )
<     cat( if(x$method == "REML") "REML\n" else "maximum likelihood\n")
---
>     if(x$method == "REML") {
>      cat(gettext("Linear mixed-effects model fit by REML", domain = "R-nlme"), "\n", sep = "")
>     } else {
>      cat(gettext("Linear mixed-effects model fit by maximum likelihood", domain = "R-nlme"), "\n", sep = "")
>     }
2208c2218
<   cat(" Data:", deparse( x$call$data ), "\n")
---
>   cat(gettext(" Data: ", domain = "R-nlme"), deparse( x$call$data ), "\n", sep = "")
2210c2220
<     cat("  Subset:", deparse(asOneSidedFormula(x$call$subset)[[2L]]),"\n")
---
>     cat(gettext("  Subset: ", domain = "R-nlme"), deparse(asOneSidedFormula(x$call$subset)[[2L]]), "\n", sep = "")
2212,2214c2222,2223
<   print( data.frame( AIC = x$AIC, BIC = x$BIC, logLik = c(x$logLik),
<                     row.names = " ") )
<   if (verbose) { cat("Convergence at iteration:",x$numIter,"\n") }
---
>   print( data.frame( AIC = x$AIC, BIC = x$BIC, logLik = c(x$logLik), row.names = " ") )
>   if (verbose) { cat(gettext("Convergence at iteration: ", domain = "R-nlme"), x$numIter, "\n", sep = "") }
2218c2227
<   cat("Fixed effects: ")
---
>   cat(gettext("Fixed effects: ", domain = "R-nlme"))
2221c2230
<     cat(deparse(x$call$fixed), "\n")
---
>     cat(deparse(x$call$fixed), "\n", sep = "")
2241,2243c2250
<     print(corr,
<           title = " Correlation:",
<           ...)
---
>     print(corr, title = gettext(" Correlation:", domain = "R-nlme"), ...)
2245c2252
<   cat("\nStandardized Within-Group Residuals:\n")
---
>   cat("\n", gettext("Standardized Within-Group Residuals:", domain = "R-nlme"), "\n", sep = "")
2247,2249c2254,2256
<   cat("\nNumber of Observations:",x$dims[["N"]])
<   cat("\nNumber of Groups: ")
<   Ngrps <- dd$ngrps[1:dd$Q]
---
>   cat("\n", gettext("Number of Observations: ", domain = "R-nlme"), x$dims[["N"]], sep = "")
>   cat("\n", gettext("Number of Groups: ", domain = "R-nlme"), sep = "")
>   Ngrps <- dd$ngrps[seq_len(dd$Q)]
2253c2260
<     sNgrps <- 1:lNgrps
---
>     sNgrps <- seq_len(lNgrps)
2271c2278
<     stop("'form' must be a formula")
---
>     stop(gettextf("'%s' argument is not an object of class %s", "form", dQuote("formula")))
2287,2288c2294,2295
<                               "%s not found in data",
<                               "%s not found in data"),
---
>                               "%s was not found in data",
>                               "%s were not found in data", domain = "R-nlme"),
2305,2307c2312,2314
<   } else if (!is.null(labs) && ((labs == "Standardized residuals") ||
<                                 (labs == "Normalized residuals") ||
<                                 (substring(labs, 1, 9) == "Residuals"))) {
---
>   } else if (!is.null(labs) && ((labs == gettext("Standardized residuals", domain = "R-nlme")) ||
>                                 (labs == gettext("Normalized residuals", domain = "R-nlme")) ||
>                                 (labs == gettext("Residuals", domain = "R-nlme")))) {
2313c2320
<   if (is.null(args$ylab)) args$ylab <- "Quantiles of standard normal"
---
>   if (is.null(args$ylab)) args$ylab <- gettext("Quantiles of standard normal", domain = "R-nlme")
2327c2334
<                    stop("'Id' must be between 0 and 1")
---
>                    stop(gettextf("'%s' argument must be between %d and %d", "id", 0, 1))
2329,2331c2336,2337
<                  if (labs == "Normalized residuals") {
<                    as.logical(abs(resid(object, type="normalized"))
<                               > -qnorm(id / 2))
---
>                  if (labs == gettext("Normalized residuals", domain = "R-nlme")) {
>                    as.logical(abs(resid(object, type="normalized")) > -qnorm(id / 2))
2333,2334c2339
<                    as.logical(abs(resid(object, type="pearson"))
<                               > -qnorm(id / 2))
---
>                    as.logical(abs(resid(object, type="pearson")) > -qnorm(id / 2))
2338c2343
<                stop("'id' can only be a formula or numeric")
---
>                stop(gettextf("'%s' argument can only be a formula or numeric", "id"))
2350c2355
<             stop("'idLabels' of incorrect length")
---
>             stop(gettextf("'%s' argument is of incorrect length", "idLabels"))
2354c2359
<           stop("'idLabels' can only be a formula or a vector")
---
>           stop(gettextf("'%s' argument can only be a formula or a vector", "idLabels"))
2385c2390
<                    stop("'id' must be between 0 and 1")
---
>                    stop(gettextf("'%s' argument must be between %d and %d", "id", 0, 1))
2391c2396
<                stop("'id' can only be a formula or numeric")
---
>                stop(gettextf("'%s' argument can only be a formula or numeric", "id"))
2398d2402
<       idLabels <-
2400,2401c2404,2407
<           rep(row.names(.x), nc)
<         } else if (mode(idLabels) == "call") {
---
>         idLabels <- rep(row.names(.x), nc)
>       } else {
>         if (mode(idLabels) == "call") {
>           idLabels <-
2404,2408c2410,2417
<           if (length(idLabels <- unlist(idLabels)) != N)
<             stop("'idLabels' of incorrect length")
<           as.character(idLabels)
<         } else
<           stop("'idLabels' can only be a formula or a vector")
---
>           if (length(idLabels <- unlist(idLabels)) != N) {
>             stop(gettextf("'%s' argument is of incorrect length", "idLabels"))
>           }
>           idLabels <- as.character(idLabels)
>         } else {
>           stop(gettextf("'%s' argument can only be a formula or a vector", "idLabels"))
>         }
>       }
2450,2454c2459
<       if (!is.null(abl)) {
< 	if (length(abl) == 2)
< 	  panel.abline(a = abl, ...)
< 	else panel.abline(h = abl, ...)
<       }
---
>       if (!is.null(abl)) { if (length(abl) == 2) panel.abline(a = abl, ...) else panel.abline(h = abl, ...) }
2488,2489c2493
<         t(t(effects[[i]]) /
<           (object$sigma *
---
> 	t(t(effects[[i]]) / (object$sigma *
2504,2505c2508,2509
<     subset <- if (is.null(subset)) {  # nlme case
<                 eval(object$call[["naPattern"]])
---
>     if (is.null(subset)) {              # nlme case
>       subset <- eval(object$call[["naPattern"]])
2507c2511
<                 asOneSidedFormula(as.list(match.call())[["subset"]])
---
>       subset <- asOneSidedFormula(as.list(match.call())[["subset"]])
2520,2521c2524
<         data[, is.na(match(names(data), names(object$modelStruct$reStruct))),
<              drop = FALSE]
---
> 	data[, is.na(match(names(data), names(object$modelStruct$reStruct))), drop = FALSE]
2535,2542c2538,2548
<   structure(effects, class = c("ranef.lme", class(effects)),
<             label= if (standard)
<                      "Standardized random effects"
<                    else
<                      "Random effects",
<             level = max(level),
<             standardized = standard,
<             grpNames = grpNames)
---
>   attr(effects, "label") <-
>     if (standard) {
>       gettext("Standardized random effects", domain = "R-nlme")
>     } else {
>       gettext("Random effects", domain = "R-nlme")
>     }
>   attr(effects, "level") <- max(level)
>   attr(effects, "standardized") <- standard
>   attr(effects, "grpNames") <- grpNames
>   class(effects) <- c("ranef.lme", class(effects))
>   effects
2558c2564
<                             "nonexistent levels %s"),
---
>                               "nonexistent levels %s", domain = "R-nlme"),
2591,2593c2597,2601
<                if (!is.null(aux <- attr(object, "units")$y))
<                  paste("Residuals", aux)
<                else "Residuals"
---
>                lab <- gettext("Residuals", domain = "R-nlme")
>                if (!is.null(aux <- attr(object, "units")$y)) {
>                  lab <- paste(lab, aux)
>                }
>                lab
2595,2596c2603,2604
<              pearson = "Standardized residuals",
<              normalized = "Normalized residuals"
---
>              pearson = gettext("Standardized residuals", domain = "R-nlme"),
>              normalized = gettext("Normalized residuals", domain = "R-nlme")
2635,2636c2643,2647
<   structure(object, verbose = verbose, oClass = class(object),
<             class = c("summary.lme", class(object)))
---
>   attr(object, "oClass") <- class(object)
>   attr(object, "verbose") <- verbose
>   class(object) <- c("summary.lme", class(object))
> 
>   object
2639c2650
< ## based on R's update.default
---
> # based on R's update.default
2645c2656
<     stop("need an object with call component")
---
> 	stop("an object with 'call' component is required")
2662,2695c2673,2706
< ## update.lme <-
< ##  function(object, fixed, data, random, correlation, weights, subset,
< ##           method, na.action, control, contrasts, ...)
< ## {
< ##  thisCall <- as.list(match.call())[-(1:2)]
< ##  if (is.null(nextCall <- object$origCall) ||
< ##      !is.null(thisCall$fixed) ||
< ##      is.null(thisCall$random)) {
< ##    nextCall <- object$call
< ##  }
< ##  nextCall <- as.list(nextCall)[-1L]
< ##  if (is.null(thisCall$random)  && is.null(thisCall$subset)) {
< ##    ## no changes in ranef model and no subsetting
< ##    thisCall$random <- object$modelStruct$reStruct
< ##  }
< ##  if (is.na(match("correlation", names(thisCall))) &&
< ##      !is.null(thCor <- object$modelStruct$corStruct)) {
< ##    thisCall$correlation <- thCor
< ##  }
< ##  if (is.na(match("weights", names(thisCall))) &&
< ##      !is.null(thWgt <- object$modelStruct$varStruct)) {
< ##    thisCall$weights <- thWgt
< ##  }
< ##    argNams <- unique( c(names(nextCall), names(thisCall)) )
< ##    args <- vector("list", length(argNams))
< ##    names(args) <- argNams
< ##    args[ names(nextCall) ] <- nextCall
< ##    nextCall <- args
< ##  if (!is.null(thisCall$fixed)) {
< ##    thisCall$fixed <- update(as.formula(nextCall$fixed), fixed)
< ##  }
< ##  nextCall[names(thisCall)] <- thisCall
< ##  do.call(lme, nextCall)
< ## }
---
> #update.lme <-
> #  function(object, fixed, data, random, correlation, weights, subset,
> #           method, na.action, control, contrasts, ...)
> #{
> #  thisCall <- as.list(match.call())[-(1:2)]
> #  if (is.null(nextCall <- object$origCall) ||
> #      !is.null(thisCall$fixed) ||
> #      is.null(thisCall$random)) {
> #    nextCall <- object$call
> #  }
> #  nextCall <- as.list(nextCall)[-1L]
> #  if (is.null(thisCall$random)  && is.null(thisCall$subset)) {
> #    ## no changes in ranef model and no subsetting
> #    thisCall$random <- object$modelStruct$reStruct
> #  }
> #  if (is.na(match("correlation", names(thisCall))) &&
> #      !is.null(thCor <- object$modelStruct$corStruct)) {
> #    thisCall$correlation <- thCor
> #  }
> #  if (is.na(match("weights", names(thisCall))) &&
> #      !is.null(thWgt <- object$modelStruct$varStruct)) {
> #    thisCall$weights <- thWgt
> #  }
> #    argNams <- unique( c(names(nextCall), names(thisCall)) )
> #    args <- vector("list", length(argNams))
> #    names(args) <- argNams
> #    args[ names(nextCall) ] <- nextCall
> #    nextCall <- args
> #  if (!is.null(thisCall$fixed)) {
> #    thisCall$fixed <- update(as.formula(nextCall$fixed), fixed)
> #  }
> #  nextCall[names(thisCall)] <- thisCall
> #  do.call(lme, nextCall)
> #}
2779c2790
<         stop("'nint' is not consistent with 'breaks'")
---
>         stop(gettextf("'%s' is not consistent with '%s'", "nint", "breaks"))
2816,2817c2827,2829
<   structure(val, class = c("Variogram", "data.frame"),
<             collapse = (collapse != "none"))
---
>   attr(val, "collapse") <- collapse != "none"
>   class(val) <- c("Variogram", "data.frame")
>   val
2863c2875
<   for(i in 1:Q) {
---
>   for(i in seq_len(Q)) {
2964,2965c2976
<   else {
<     if(!is.finite(sigma) || length(sigma) != 1 || sigma <= 0)
---
>   else if (!is.numeric(sigma) || (length(sigma) != 1) || (sigma <= 0))
2967,2968d2977
<     if(missing(apVar)) apVar <- FALSE # not yet implemented
<   }
2977,2981d2985
< 
< 
< ## Local Variables:
< ## ess-indent-offset: 2
< ## End:
diff -rEZbwB '--exclude=*.[lo,d,pdf,mo,po,tgz,gz,save]*' '--exclude=MD5' '--exclude=Makefile*' '--exclude=all.R' '--exclude=Changes' R-recommended/nlme/R/modelStruct.R Recommended/nlme/R/modelStruct.R
63c63
<       cat(paste(i, " parameters:\n"))
---
>       cat(gettextf("%s parameters:", i, domain = "R-nlme"), "\n", sep = "")
diff -rEZbwB '--exclude=*.[lo,d,pdf,mo,po,tgz,gz,save]*' '--exclude=MD5' '--exclude=Makefile*' '--exclude=all.R' '--exclude=Changes' R-recommended/nlme/R/newFunc.R Recommended/nlme/R/newFunc.R
136c136
<     stop("object must inherit from \"data.frame\"")
---
>     stop(gettextf("'%s' argument is not an object of class %s", "object", dQuote("data.frame")))
141c141
<       stop("'form' must be a formula")
---
>       stop(gettextf("'%s' argument is not an object of class %s", "form", dQuote("formula")))
149c149
<       stop("only one level allowed in 'gapply'")
---
>       stop(gettextf("only one level allowed in %s function", sQuote("gapply")))
159,160c159,160
<                                        "%s not matched",
<                                        "%s not matched"),
---
>                                        "%s value was not matched",
>                                        "%s values were not matched", domain = "R-nlme"),
167,168c167
<                  stop(gettextf("'which' must be between 1 and %d",
<                                ncol(object)), domain = NA)
---
>                  stop(gettextf("'%s' argument must be between %d and %d", "which", 1, ncol(object)), domain = "R-nlme")
171c170
<            stop("'which' can only be character or integer")
---
>            stop(gettextf("'%s' argument can only be character or integer", "which"))
188c187
<     stop("formula(object) must return a formula")
---
>     stop(gettextf("'%s' argument is not an object of class %s", "object", dQuote("formula")))
203c202
<     stop("'form' must be a two-sided formula")
---
>     stop(gettextf("'%s' argument must be a two-sided formula", "form"))
218c217
<     stop("object must inherit from \"data.frame\"")
---
>     stop(gettextf("'%s' argument is not an object of class %s", "object", dQuote("data.frame")))
222c221
<       stop("'form' must be a formula")
---
>       stop(gettextf("'%s' argument is not an object of class %s", "form", dQuote("fomrula")))
230c229
<       stop("only one level allowed in 'gsummary'")
---
>       stop(gettextf("only one level allowed in %s function", sQuote("gsummary")))
255c254
< 	stop("'FUN' can only be a function or a list of functions")
---
> 	stop(gettextf("'%s' argument can only be a function or a list of functions", "FUN"))
303c302
<     stop("object must inherit from class \"lmList\"")
---
>     stop(gettextf("'%s' argument is not an object of class %s", "object", dQuote("lmList")))
315c314
<     stop("no degrees of freedom for estimating std. dev.")
---
>     stop("no degrees of freedom for estimating standard deviation")
diff -rEZbwB '--exclude=*.[lo,d,pdf,mo,po,tgz,gz,save]*' '--exclude=MD5' '--exclude=Makefile*' '--exclude=all.R' '--exclude=Changes' R-recommended/nlme/R/newMethods.R Recommended/nlme/R/newMethods.R
16c16
<     stop("'form' must be a formula")
---
>     stop(gettextf("'%s' argument is not an object of class %s", "form", dQuote("formula")))
53c53
<     stop( "data argument to \"data.frame\" method for 'getGroups' does not make sense" )
---
>     stop("'data' argument passed to \"data.frame\" method for 'getGroups()' does not make sense")
72c72
<       stop("'form' must have all components as formulas")
---
>       stop(gettextf("'%s' argument must have all components as formulae", "form"))
75c75
<     stop("'form' can only be a formula, or a list of formulas")
---
>     stop(gettextf("'%s' argument can only be a formula or a list of formulae", "form"))
94,96c94
<         stop(gettextf("level of %s does not match formula %s",
<                       level[aux], sQuote(deparse(form))),
<              domain = "NA")
---
>         stop(gettextf("level of %s does not match formula %s", level[aux], sQuote(deparse(form))), domain = "R-nlme")
101,103c99
<         stop(gettextf("level of %s does not match formula %s",
<                       level[aux], sQuote(deparse(form))),
<              domain = "NA")
---
>         stop(gettextf("level of %s does not match formula %s", level[aux], sQuote(deparse(form))), domain = "R-nlme")
127c123
<     stop("'form' must be a two-sided formula")
---
>     stop(gettextf("'%s' argument must be a two-sided formula", "form"))
140c136
<     stop("'form' argument must be a formula")
---
>     stop(gettextf("'%s' argument is not an object of class %s", "object", dQuote("formula")))
279c275
<     stop("'form' must be a formula")
---
>     stop(gettextf("'%s' argument is not an object of class %s", "form", dQuote("formula")))
295,296c291,292
<                                 "%s not found in data",
<                                 "%s not found in data"),
---
>                                 "%s was not found in data",
>                                 "%s were not found in data", domain = "R-nlme"),
352c348
<     for(i in 1:length(gr)) {
---
>     for(i in seq_len(length(gr))) {
376c372
< 		 stop("'id' must be between 0 and 1")
---
> 		 stop(gettextf("'%s' argument must be between %d and %d", "id", 0, 1))
382c378
< 	     stop("'id' can only be a formula or numeric")
---
> 	     stop(gettextf("'%s' argument can only be a formula or numeric", "id"))
394c390
< 	  stop("'idLabels' of incorrect length")
---
> 	  stop(gettextf("'%s' argument is of incorrect length", "idLabels"))
398c394
< 	stop("'idLabels' can only be a formula or a vector")
---
> 	stop(gettextf("'%s' argument can only be a formula or a vector", "idLabels"))
481c477
<   function(x, alpha = 0, xlab = "Lag", ylab = "Autocorrelation",
---
>   function(x, alpha = 0, xlab = gettext("Lag", domain = "R-nlme"), ylab = gettext("Autocorrelation", domain = "R-nlme"),
609c605
<            xlab = "Distance", ylab = "Semivariogram", type = "p", ylim,
---
>            xlab = gettext("Distance", domain = "R-nlme"), ylab = gettext("Semivariogram", domain = "R-nlme"), type = "p", ylim,
674c670
<   function(x, title = " Correlation:", rdig = 3, ...)
---
>   function(x, title = gettext(" Correlation:", domain = "R-nlme"), rdig = 3, ...)
699c695
<     stop("'form' must be a formula")
---
>     stop(gettextf("'%s' argument is not an object of class %s", "form", dQuote("formula")))
715,716c711,712
<                               "%s not found in data",
<                               "%s not found in data"),
---
>                               "%s was not found in data",
>                               "%s were not found in data", domain = "R-nlme"),
732,734c728,730
<   if (is.null(labs) || ((labs != "Standardized residuals") &&
<                         (labs != "Normalized residuals") &&
<                         (substring(labs, 1, 9) != "Residuals"))) {
---
>   if (is.null(labs) || ((labs != gettext("Standardized residuals", domain = "R-nlme")) &&
>                         (labs != gettext("Normalized residuals", domain = "R-nlme")) &&
>                         (labs != gettext("Residuals", domain = "R-nlme")))) {
738c734
<   if (is.null(args$ylab)) args$ylab <- "Quantiles of standard normal"
---
>   if (is.null(args$ylab)) args$ylab <- gettext("Quantiles of standard normal", domain = "R-nlme")
751c747
<                  stop("'id' must be between 0 and 1")
---
> 		 stop(gettextf("'%s' argument must be between %d and %d", "id", 0, 1))
753c749
<                if (labs == "Normalized residuals") {
---
>                if (labs == gettext("Normalized residuals", domain = "R-nlme")) {
762c758
<              stop("'id' can only be a formula or numeric")
---
>              stop(gettextf("'%s' argument can only be a formula or numeric", "id"))
774c770
<           stop("'idLabels' of incorrect length")
---
>           stop(gettextf("'%s' argument is of incorrect length", "idLabels"))
778c774
<         stop("'idLabels' can only be a formula or a vector")
---
>         stop(gettextf("'%s' argument can only be a formula or a vector", "idLabels"))
820c816
<     stop("'distance' and 'object' have incompatible lengths")
---
>     stop(gettextf("'%s' and '%s' arguments have incompatible lengths", "distance", "object"))
diff -rEZbwB '--exclude=*.[lo,d,pdf,mo,po,tgz,gz,save]*' '--exclude=MD5' '--exclude=Makefile*' '--exclude=all.R' '--exclude=Changes' R-recommended/nlme/R/nlme.R Recommended/nlme/R/nlme.R
61,63c61,62
<   if (any(!is.na(match(names(thisCall),
< 		       c("fixed", "data", "start"))))) {
<     warning("'nlme.nlsList' will redefine 'fixed', 'data', and 'start'")
---
>   if (any(!is.na(match(names(thisCall), c("fixed", "data", "start"))))) {
>     warning("'nlme.nlsList()' function will redefine 'fixed', 'data', and 'start' arguments")
90c89
<     stop("can only fit \"nlsList\" objects with single grouping variable")
---
>     stop(gettextf("can only fit objects of class %s with single grouping variable", dQuote("nlsList")))
122c121
<       warning("initial value for 'reStruct' overwritten in 'nlme.nlsList'")
---
>       warning(gettextf("initial value for 'reStruct' overwritten in %s function", sQuote("nlme.nlsList()")))
180c179
<     stop("'model' must be a formula")
---
>     stop(gettextf("'%s' argument is not an object of class %s", "model", dQuote("formula")))
200c199
< 	  stop("incompatible lengths for 'random' and grouping factors")
---
> 	  stop("incompatible lengths for 'random' argument and grouping factors")
203c202
<         for(i in 1:Q) randL[[i]] <- random
---
>         for(i in seq_len(Q)) randL[[i]] <- random
231c230
<       stop("'data' must be given explicitly to use 'nlsList'")
---
>       stop(gettextf("'%s' argument must be given explicitly to use %s function", "data", sQuote("nlsList()")))
265c264
<       stop ("'fixed' must be a formula or list of formulae")
---
>       stop(gettextf("'%s' argument must be a formula or list of formulae", "fixed"))
267c266
<       stop ("formulae in 'fixed' must be of the form \"parameter ~ expr\"")
---
>       stop(gettextf("formulae in '%s' must be of the form \"parameter ~ expr\"", "fixed"))
269c268
<       stop ("formulae in 'fixed' must be of the form \"parameter ~ expr\"")
---
>       stop(gettextf("formulae in '%s' must be of the form \"parameter ~ expr\"", "fixed"))
279c278
<   for(i in 1:Q) {
---
>   for(i in seq_len(Q)) {
284c283
<         stop ("'random' must be a formula or list of formulae")
---
>         stop(gettextf("'%s' argument must be a formula or list of formulae", "random"))
286c285
<         stop ("formulae in 'random' must be of the form \"parameter ~ expr\"")
---
>         stop(gettextf("formulae in '%s' must be of the form \"parameter ~ expr\"", "random"))
288c287
<         stop ("formulae in 'random' must be of the form \"parameter ~ expr\"")
---
>         stop(gettextf("formulae in '%s' must be of the form \"parameter ~ expr\"", "random"))
318,319c317,318
<         if (any(corGrpsForm != lmeGrpsForm[1:corQ])) {
<           stop("incompatible formulas for groups in \"random\" and \"correlation\"")
---
>         if (any(corGrpsForm != lmeGrpsForm[seq_len(corQ)])) {
>           stop("incompatible formulas for groups in 'random' and 'correlation' arguments")
322c321
<           warning("cannot use smaller level of grouping for \"correlation\" than for \"random\". Replacing the former with the latter.")
---
>           warning("cannot use smaller level of grouping for 'correlation' than for 'random'. Replacing the former with the latter.")
329,330c328,329
<         if (any(lmeGrpsForm != corGrpsForm[1:lmeQ])) {
<           stop("incompatible formulas for groups in \"random\" and \"correlation\"")
---
>         if (any(lmeGrpsForm != corGrpsForm[seq_len(lmeQ)])) {
>           stop("incompatible formulas for groups in 'random' and 'correlation' arguments")
426c425
<       for(i in 1:Q) {
---
>       for(i in seq_len(Q)) {
515c514
<   for(i in 1:Q) {
---
>   for(i in seq_len(Q)) {
544,545c543
<     warning(gettextf("fewer observations than random effects in all level %s groups",
<                      Q), domain = NA)
---
>     warning(gettextf("fewer observations than random effects in all level %s groups", Q), domain = "R-nlme")
562,563c560
<         stop(gettextf("list with starting values for random effects must have names or be of length %d",
<                       Q), domain = NA)
---
>         stop(gettextf("list with starting values for random effects must have names or be of length %d", Q), domain = "R-nlme")
570c567
<                               "group names not matched in starting values for random effects: %s"),
---
>                               "group names not matched in starting values for random effects: %s", domain = "R-nlme"),
575c572
<   for(i in 1:Q) {
---
>   for(i in seq_len(Q)) {
584,585c581
<         stop(gettextf("number of rows in starting values for random component at level %s should be %d",
<                       namGrp[i], Dims$ngrps[i]), domain = NA)
---
>         stop(gettextf("number of rows in starting values for random component at level %s should be %d", namGrp[i], Dims$ngrps[i]), domain = "R-nlme")
588,589c584
<         stop(gettextf("number of columns in starting values for random component at level %s should be %d",
<                       namGrp[i], rlength[i]), domain = NA)
---
>         stop(gettextf("number of columns in starting values for random component at level %s should be %d", namGrp[i], rlength[i]), domain = "R-nlme")
597,598c592
<           stop(gettextf("groups levels mismatch in 'random' and starting values for 'random' at level %s",
<                         namGrp[i]), domain = NA)
---
>           stop(gettextf("groups levels mismatch in 'random' and starting values for 'random' at level %s", namGrp[i]), domain = "R-nlme")
616,617c610
<                   stop (gettextf("names mismatch in 'random' and starting values  for 'random' at level %s",
<                                  namGrp[i]), domain = NA)
---
>                   stop (gettextf("names mismatch in 'random' and starting values  for 'random' at level %s", namGrp[i]), domain = "R-nlme")
655c648
<   for(i in 1:Q) {
---
>   for(i in seq_len(Q)) {
725c718
<       for(i in 1:Q) {
---
>       for(i in seq_len(Q)) {
754c747
<   w <- ww[NReal * pLen + (1:NReal)]
---
>   w <- ww[NReal * pLen + seq_len(NReal)]
757c750
<   w <- w + as.vector(ZX[, rLen + (1:fLen), drop = FALSE] %*% sfix)
---
>   w <- w + as.vector(ZX[, rLen + seq_len(fLen), drop = FALSE] %*% sfix)
760,761c753,754
<     for(i in 1:Q) {
<       w <- w + as.vector((ZX[, startRan + 1:ncols[i], drop = FALSE] *
---
>     for(i in seq_len(Q)) {
>       w <- w + as.vector((ZX[, startRan + seq_len(ncols[i]), drop = FALSE] *
830,832c823,825
<       cat("\n**Iteration", numIter)
<       cat(sprintf("\nLME step: Loglik: %s, %s iterations: %d\n",
<                   format(nlmeFit$logLik), controlvals$opt, convIter))
---
>       cat("\n**", gettextf("Iteration %d", numIter, domain = "R-nlme"), sep = "")
>       cat("\n")
>       cat(gettextf("LME step: Loglik: %s, %s iterations: %d", format(nlmeFit$logLik), controlvals$opt, convIter, domain = "R-nlme"), "\n", sep = "")
865c858
<       msg <- "step halving factor reduced below minimum in PNLS step"
---
>       msg <- gettext("step halving factor reduced below minimum in PNLS step", domain = "R-nlme")
883c876
<     for(i in 1:Q) sran[[i]][] <- work$thetaPNLS[(bmap[i]+1):bmap[i+1]]
---
>     for(i in seq_len(Q)) sran[[i]][] <- work$thetaPNLS[(bmap[i]+1):bmap[i+1]]
886,888c879,881
<       cat("PNLS step: RSS = ", format(work$settings[6]), "\n fixed effects: ")
<       for (i in 1:fLen) cat(format(sfix[i])," ")
<       cat("\n iterations:", work$settings[5],"\n")
---
>       cat("\n", gettextf("PNLS step: RSS = %s", format(work$set[6]), domain = "R-nlme"), "\n ", gettext("Fixed effects:", domain = "R-nlme"), sep = "")
>       for (i in seq_len(fLen)) cat(format(sfix[i])," ")
>       cat("\n ", gettext("iterations: ", domain = "R-nlme"), work$settings[5], "\n", sep = "")
891,893c884,886
<     w[] <- work$additional[(NReal * pLen) + 1:NReal]
<     ZX[] <- work$additional[1:(NReal * pLen)]
<     w <- w + as.vector(ZX[, rLen + (1:fLen), drop = FALSE] %*% sfix)
---
>     w[] <- work$additional[(NReal * pLen) + seq_len(NReal)]
>     ZX[] <- work$additional[seq_len(NReal * pLen)]
>     w <- w + as.vector(ZX[, rLen + seq_len(fLen), drop = FALSE] %*% sfix)
895,896c888,889
<     for(i in 1:Q) {
<       w <- w + as.vector((ZX[, startRan + 1:ncols[i], drop = FALSE] *
---
>     for(i in seq_len(Q)) {
>       w <- w + as.vector((ZX[, startRan + seq_len(ncols[i]), drop = FALSE] *
911,912c904,905
<     aConv <- c(fixed = max(conv[1:fLen]))
<     conv <- conv[-(1:fLen)]
---
>     aConv <- c(fixed = max(conv[seq_len(fLen)]))
>     conv <- conv[-seq_len(fLen)]
921,922c914,915
<       cat(sprintf("Convergence crit. (must all become <= tolerance = %g):\n",
<                   controlvals$tolerance))
---
>       cat(gettextf("Convergence crit. (must all become <= tolerance = %g):",
>                   controlvals$tolerance, domain = "R-nlme"), "\n", sep = "")
935c928
< 	controlvals$maxIter)
---
> 	controlvals$maxIter, domain = "R-nlme")
937c930
< 	warning(msg, domain=NA)
---
> 	warning("maximum number of iterations reached without convergence")
940c933
< 	stop(msg, domain=NA)
---
> 	stop("maximum number of iterations reached without convergence")
952c945
<   fixDF <- getFixDF(ZX[, rLen + (1:fLen), drop = FALSE],
---
>   fixDF <- getFixDF(ZX[, rLen + seq_len(fLen), drop = FALSE],
1175,1178c1168,1170
<                               "level %s not allowed for %s",
<                               "levels %s not allowed for %s"),
<                      paste(levs[wch], collapse = ",")),
<              domain = NA)
---
>                               "level %s is not allowed for %s",
>                               "levels %s ares not allowed for %s", domain = "R-nlme"),
>                      paste(levs[wch], collapse = ", ")), domain = NA)
1234c1226
<     for(i in 1:length(ranForm)) {
---
>     for(i in seq_len(length(ranForm))) {
1245c1237
<           wch <- (1:length(rnames[[i]]))[!is.na(match(rnames[[i]], nm))]
---
>           wch <- seq_len(length(rnames[[i]]))[!is.na(match(rnames[[i]], nm))]
1271c1263
<   for(i in 1:nlev) {
---
>   for(i in seq_len(nlev)) {
1307c1299
<     lab <- "Predicted values"
---
>     lab <- gettext("Predicted values", domain = "R-nlme")
1323c1315
<     stop("need an object with call component")
---
>     stop("an object with 'call' component is required")
1427c1419
<   for(i in 1:length(level)) {
---
>   for(i in seq_len(length(level))) {
diff -rEZbwB '--exclude=*.[lo,d,pdf,mo,po,tgz,gz,save]*' '--exclude=MD5' '--exclude=Makefile*' '--exclude=all.R' '--exclude=Changes' R-recommended/nlme/R/nlsList.R Recommended/nlme/R/nlsList.R
32c32
<     stop("second argument must be a groupedData object")
---
>     stop(gettextf("'%s' argument must be an object of class %s", "data", dQuote("groupedData")))
69c69
<       stop("'data' must be a \"groupedData\" object if 'formula' does not include groups")
---
>       stop(gettextf("'%s' argument must be an object of class %s if 'formula' argument does not include groups", "data", dQuote("groupedData")))
88c88
<       stop("old-style self-starting model functions\nare no longer supported.\nNew selfStart functions are available.\nUse\n  SSfpl instead of fpl,\n  SSfol instead of first.order.log,\n  SSbiexp instead of biexp,\n  SSlogis instead of logistic.\nIf writing your own selfStart model, see\n  \"help(selfStart)\"\nfor the new form of the \"initial\" attribute.")
---
>       stop("old-style self-starting model functions\nare no longer supported.\nNew selfStart functions are available.\nUse\n  SSfpl instead of fpl,\n  SSfol instead of first.order.log,\n  SSbiexp instead of biexp,\n  SSlogis instead of logistic.\nIf writing your own selfStart model, see\n  \"help(selfStart)\"\nfor the new form of the \"initial\" attribute.", domain = "R-nlme")
diff -rEZbwB '--exclude=*.[lo,d,pdf,mo,po,tgz,gz,save]*' '--exclude=MD5' '--exclude=Makefile*' '--exclude=all.R' '--exclude=Changes' R-recommended/nlme/R/pdMat.R Recommended/nlme/R/pdMat.R
91c91
< 	warning("ignoring argument 'form'")
---
> 	warning(gettextf("ignoring argument '%s'", "form"))
99c99
< 	warning("ignoring argument 'nam'")
---
> 	warning(gettextf("ignoring argument '%s'", "nam"))
134c134
< 	warning("ignoring argument 'form'")
---
> 	warning(gettextf("ignoring argument '%s'", "form"))
138,139c138
<         stop(gettextf("%s is not a valid object for \"pdMat\"",
<                       sQuote(deparse(object))), domain = NA)
---
>         stop(gettextf("%s is not a valid object for \"pdMat\"", sQuote(deparse(object))), domain = "R-nlme")
172c171
<         stop("'form' can only be a formula or a list of formulae")
---
>         stop(gettextf("'%s' argument can only be a formula or a list of formulae", "form"))
202c201
<           if (err) stop("'form' not consistent with 'nam'")
---
>           if (err) stop(gettextf("'%s' is not consistent with '%s'", "form", "nam"))
210c209
<       stop("length of 'nam' not consistent with dimensions of initial value")
---
>       stop("length of 'nam' is not consistent with dimensions of initial value")
325c324
<             stop(gettextf("Length of names should be %d", aux), domain = NA)
---
>             stop(gettextf("Length of names should be %d", aux), domain = "R-nlme")
332c331
<         stop(gettextf("Length of names should be %d", length(dn)), domain = NA)
---
>         stop(gettextf("Length of names should be %d", length(dn)), domain = "R-nlme")
421c420
< 			 stop("x-y data to splom got botched somehow")
---
> 			 stop("x-y data passed to 'splom()' function got botched somehow")
438c437
<     cat("Positive definite matrix structure of class", class(x)[1], "representing\n")
---
>     cat(gettextf("Positive definite matrix structure of class %s representing", dQuote(class(x)[1]), domain = "R-nlme"), "\n", sep = "")
441,442c440
<     cat("Uninitialized positive definite matrix structure of class ", class(x)[1],
< 	".\n", sep = "")
---
>     cat(gettextf("Uninitialized positive definite matrix structure of class %s.", dQuote(class(x)[1]), domain = "R-nlme"), "\n", sep = "")
453c451
<       cat(paste(" Formula: "))
---
>       cat(gettext(" Formula: ", domain = "R-nlme"))
464c462
<           cat("\n Level:", Level)
---
>           cat("\n ", gettext("Level: ", domain = "R-nlme"), Level, sep = "")
479c477
<       cat(paste(" Structure: ", attr(x, "structName"), "\n", sep = ""))
---
>       cat(gettext(" Structure: ", domain = "R-nlme"), attr(x, "structName"), "\n", sep = "")
513c511
<     cat(paste(" Composite Structure: ", attr(x, "structName"), "\n", sep =""))
---
>     cat(gettext(" Composite Structure: ", domain = "R-nlme"), attr(x, "structName"), "\n", sep ="")
615,616c613
<       stop(gettextf("an object of length %d does not match the required parameter size",
<                     length(val)), domain = NA)
---
>       stop(gettextf("an object of length %d does not match the required parameter size", length(val)), domain = "R-nlme")
741,742c738
<       stop(gettextf("an object of length %d does not match a Cholesky factor",
<                     length(val)), domain = NA)
---
>       stop(gettextf("an object of length %d does not match a Cholesky factor", length(val)), domain = "R-nlme")
1045c1041
< #    for(i in 1:(q-1)) {
---
> #    for(i in seq_len(q-1)) {
1147,1148c1143
<       stop(gettextf("an object of length %d does not match the required parameter size",
<                     length(val)), domain = NA)
---
>       stop(gettextf("an object of length %d does not match the required parameter size", length(val)), domain = "R-nlme")
1309,1310c1304
<         stop(gettextf("an object of length %d does not match the required parameter size",
<                       length(val)), domain = NA)
---
>         stop(gettextf("an object of length %d does not match the required parameter size", length(val)), domain = "R-nlme")
1326c1320
<     stop("cannot extract the matrix from an uninitialized object")
---
>     stop(gettextf("cannot extract the matrix from an uninitialized object of class %s", dQuote("pdDiag")))
1410c1404
<     stop("cannot extract the matrix from an uninitialized \"pdIdent\" object")
---
>     stop(gettextf("cannot extract the matrix from an uninitialized object of class %s", dQuote("pdIdent")))
1450,1451c1444
<       stop(gettextf("an object of length %d does not match the required parameter size",
<                     length(val)), domain = NA)
---
>       stop(gettextf("an object of length %d does not match the required parameter size", length(val)), domain = "R-nlme")
1454c1447
<     stop("must give names when initializing \"pdIdent\" from parameter without a formula")
---
>     stop(gettextf("must give names when initializing %s from parameter without a formula", dQuote("pdIdent")))
1472c1465
<     stop("cannot extract the matrix from an uninitialized \"pdIdent\" object")
---
>     stop(gettextf("cannot extract the matrix from an uninitialized object of class %s", dQuote("pdIdent")))
1549c1542
<     stop("cannot extract the matrix from an uninitialized \"pdCompSymm\" object")
---
>     stop(gettextf("cannot extract the matrix from an uninitialized object of class %s", dQuote("pdCompSymm")))
1601,1602c1594
<       stop(gettextf("an object of length %d does not match the required parameter size",
<                     length(val)), domain = NA)
---
>       stop(gettextf("an object of length %d does not match the required parameter size", length(val)), domain = "R-nlme")
1605c1597
<     stop("must give names when initializing \"pdCompSymm\" from parameter without a formula")
---
>     stop(gettextf("must give names when initializing %s from parameter without a formula", dQuote("pdCompSymm")))
1626c1618
<     stop("cannot extract the matrix from an uninitialized \"pdCompSymm\" object")
---
>     stop(gettextf("cannot extract the matrix from an uninitialized object of class %s", dQuote("pdCompSymm")))
1749c1741
<       stop("'form' must be a list")
---
>       stop(gettextf("'%s' argument must be a list", "form"))
1758c1750
<       stop("'nam' must be a list")
---
>       stop(gettextf("'%s' argument must be a list", "nam"))
1762c1754
<       stop("'form' and 'nam' have incompatible lengths")
---
>       stop(gettextf("'%s' and '%s' arguments have incompatible lengths", "form", "nam"))
1770c1762
<       stop("'pdClass' must be a character vector")
---
>       stop(gettextf("'%s' argument must be a character vector", "pdClass"))
1775c1767
< 	stop("'form' and 'pdClass' have incompatible lengths")
---
>         stop(gettextf("'%s' and '%s' arguments have incompatible lengths", "form", "pdClass"))
1778c1770
< 	stop("'nam' and 'pdClass' have incompatible lengths")
---
>         stop(gettextf("'%s' and '%s' arguments have incompatible lengths", "nam", "pdClass"))
1811c1803
<   for(i in 1:nB) {
---
>   for(i in seq_len(nB)) {
1872c1864
<     stop("all elements in the argument must generate \"pdMat\" objects")
---
>     stop(gettextf("all elements in the argument must generate objects of class %s", dQuote("pdMat")))
1884c1876
<       for(i in 1:nB) {
---
>       for(i in seq_len(nB)) {
1982c1974
<     stop("cannot change parameter length of initialized \"pdMat\" object")
---
>     stop(gettextf("cannot change parameter length of initialized object of class %s", dQuote("pdMat")))
diff -rEZbwB '--exclude=*.[lo,d,pdf,mo,po,tgz,gz,save]*' '--exclude=MD5' '--exclude=Makefile*' '--exclude=all.R' '--exclude=Changes' R-recommended/nlme/R/reStruct.R Recommended/nlme/R/reStruct.R
67c67
<       stop("\"pdMat\" element must have a formula")
---
>       stop(gettextf("'%s' argument must have a formula", "object"))
72c72
<       stop("'object' must be a list or a formula")
---
>       stop(gettextf("'%s' argument must be a list or a formula", "object"))
85c85
<                              stop("\"pdMat\" elements must have a formula")
---
>                              stop(gettextf("'%s' argument must have a formula", "object"))
102c102
<                  stop("elements in 'object' must be formulas or \"pdMat\" objects")
---
>                  stop("elements in 'object' argument must be formulae or objects of class \"pdMat\"")
190c190
<     stop("cannot change the parameter when ength of parameters is undefined")
---
>     stop("cannot change the parameter when length of parameters is undefined")
193c193
<     stop("cannot change parameter length of initialized objects")
---
>     stop(gettextf("cannot change parameter length of initialized object of class %s", dQuote("reStruct")))
254c254
<     stop("all elements of a \"reStruct\" object must have a non-zero size")
---
>     stop(gettextf("all elements of an object of class %s must have a non-zero size", dQuote("reStruct")))
319c319
<     stop("cannot change the length of 'object'")
---
>     stop("cannot change the length of 'object' argument")
413c413
<     cat("Random effects:\n")
---
>     cat(gettext("Random effects:", domain = "R-nlme"), "\n", sep = "")
418c418
< 	cat("Random effects estimates:\n")
---
> 	cat(gettext("Random effects estimates:", domain = "R-nlme"), "\n", sep = "")
424c424
<     cat("Uninitialized random effects structure\n")
---
>     cat(gettext("Uninitialized random effects structure", domain = "R-nlme"), "\n", sep = "")
diff -rEZbwB '--exclude=*.[lo,d,pdf,mo,po,tgz,gz,save]*' '--exclude=MD5' '--exclude=Makefile*' '--exclude=all.R' '--exclude=Changes' R-recommended/nlme/R/simulate.R Recommended/nlme/R/simulate.R
26c26
<         stop("\nfixed-effects model must be a formula of the form \"resp ~ pred\"")
---
>         stop("fixed-effects model must be a formula of the form \"resp ~ pred\"")
38c38
<                     stop("incompatible lengths for 'random' and grouping factors")
---
>                     stop("incompatible lengths for 'random' argument and grouping factors")
118c118
<              domain = NA)
---
>              domain = "R-nlme")
188c188
<     qvec <- nullD$qvec[1:Q]
---
>     qvec <- nullD$qvec[seq_len(Q)]
196c196
<     ind <- lapply(1:Q, function(i) rep(1:ngrp[i], nullD$ZXlen[[i]]))
---
>     ind <- lapply(seq_len(Q), function(i) rep(seq_len(ngrp[i]), nullD$ZXlen[[i]]))
198c198
<         nML   <- array(0, c(nsim, 2), list(1:nsim, c("info", "logLik")))
---
>         nML   <- array(0, c(nsim, 2), list(seq_len(nsim), c("info", "logLik")))
200c200
<         nREML <- array(0, c(nsim, 2), list(1:nsim, c("info", "logLik")))
---
>         nREML <- array(0, c(nsim, 2), list(seq_len(nsim), c("info", "logLik")))
230c230
<         ssq2 <- sum((altD$qvec[1:altD$Q])^2)
---
>         ssq2 <- sum((altD$qvec[seq_len(altD$Q)])^2)
239c239
<     for(i in 1:nsim) {
---
>     for(i in seq_len(nsim)) {
242c242
<         for(j in 1:Q) {
---
>         for(j in seq_len(Q)) {
245c245
<                         list(1:ngrp[j], NULL)) %*% DeltaInv[[j]])[ind[[j]], , drop = FALSE] *
---
>                         list(seq_len(ngrp[j]), NULL)) %*% DeltaInv[[j]])[ind[[j]], , drop = FALSE] *
399c399
<             MLx <- rep((1:length(MLstat) - 0.5)/length(MLstat), ldf + 1)
---
>             MLx <- rep((seq_len(length(MLstat)) - 0.5)/length(MLstat), ldf + 1)
403c403
<             MLx <- rep((1:length(MLstat) - 0.5)/length(MLstat), ldf)
---
>             MLx <- rep((seq_len(length(MLstat)) - 0.5)/length(MLstat), ldf)
441c441
<             REMLx <- rep((1:length(REMLstat) - 0.5)/length(REMLstat), ldf + 1)
---
>             REMLx <- rep((seq_len(length(REMLstat)) - 0.5)/length(REMLstat), ldf + 1)
445c445
<             REMLx <- rep((1:length(REMLstat) - 0.5)/length(REMLstat), ldf)
---
>             REMLx <- rep((seq_len(length(REMLstat)) - 0.5)/length(REMLstat), ldf)
diff -rEZbwB '--exclude=*.[lo,d,pdf,mo,po,tgz,gz,save]*' '--exclude=MD5' '--exclude=Makefile*' '--exclude=all.R' '--exclude=Changes' R-recommended/nlme/R/varFunc.R Recommended/nlme/R/varFunc.R
81,82c81
<       stop(gettextf("do not know how to get coefficients for %s object",
<                     dQuote(class(object)[1])), domain = NA)
---
>       stop(gettextf("do not know how to get coefficients for %s object", dQuote(class(object)[1])), domain = "R-nlme")
136,139c135,138
<     if (header) cat("Variance function:\n")
<     cat(paste(" Structure: ", attr(x, "structName"), "\n", sep = ""))
<     cat(paste(" Formula:", deparse(formula(x)),"\n"))
<     cat(" Parameter estimates:\n")
---
>     if (header) cat(gettext("Variance function:", domain = "R-nlme"), "\n", sep = "")
>     cat(gettext(" Structure: ", domain = "R-nlme"), attr(x, "structName"), "\n", sep = "")
>     cat(gettext(" Formula: ", domain = "R-nlme"), deparse(formula(x)), "\n", sep = "")
>     cat(gettext(" Parameter estimates:", domain = "R-nlme"), "\n", sep = "")
146,147c145
<     cat("Variance function structure of class", class(x)[1],
< 	"with no parameters, or uninitialized\n")
---
>     cat(gettextf("Variance function structure of class %s with no parameters, or uninitialized", dQuote(class(x)[1]), domain = "R-nlme"), "\n", sep = "")
156,157c154
<     cat("Variance function structure of class", class(x)[1],
< 	"representing\n")
---
>     cat(gettextf("Variance function structure of class %s representing", dQuote(class(x)[1]), domain = "R-nlme"), "\n", sep = "")
160,161c157
<     cat("Variance function structure of class", class(x)[1],
< 	"with no parameters, or uninitialized\n")
---
>     cat(gettextf("Variance function structure of class %s with no parameters, or uninitialized", dQuote(class(x)[1]), domain = "R-nlme"), "\n", sep = "")
203c199
<     stop("'value' must be a one sided formula")
---
>     stop(gettextf("'%s' argument is not an object of class %s", "value", dQuote("formula")))
207c203
<     stop("'form' must have a covariate")
---
>     stop(gettextf("'%s' argument must have a covariate", "value"))
211c207
<     warning("ignoring 'group' in \"varFixed\" formula")
---
>     warning("ignoring group in 'varFixed()' function")
233c229
<     stop("all variables used in 'formula' must be in 'data'")
---
>     stop("all variables used in 'object' argument must be in 'data' argument")
245,247c241,243
<   cat("Variance function:\n")
<   cat(" Structure: fixed weights\n")
<   cat(paste(" Formula:", deparse(formula(x)),"\n"))
---
>   cat(gettext("Variance function:", domain = "R-nlme"), "\n", sep = "")
>   cat(gettext(" Structure: fixed weights", domain = "R-nlme"), "\n", sep = "")
>   cat(gettext(" Formula: ", domain = "R-nlme"), deparse(formula(x)), "\n", sep = "")
271c267
< 	stop("initial values must have group names in 'varIdent'")
---
> 	stop(gettextf("initial values must have group names in %s function", sQuote("varIdent()")))
275c271
< 	stop("initial values for 'varIdent' must be > 0")
---
> 	stop("initial values for 'varIdent()' function must be > 0")
283c279
< 	stop("fixed parameters must have names in 'varIdent'")
---
> 	stop("fixed parameters must have names in 'varIdent()' function")
340c336
<       stop("cannot change the length of the \"varIdent\" parameter after initialization")
---
>       stop(gettextf("cannot change the length of the %s parameter after initialization", dQuote("varIdent")))
369c365
< 	stop("fixed parameter names in 'varIdent' must be a subset of group names")
---
> 	stop("fixed parameter names in 'varIdent()' function must be a subset of group names")
392,393c388
<             stop(gettextf("initial value for \"varIdent\" should be of length %d",
<                           len), domain = NA)
---
>             stop(gettextf("initial value for %s should be of length %d", dQuote("varIdent"), len), domain = "R-nlme")
398c393
< 	    stop("names of starting value for \"varIdent\" object must contain all but one of the stratum levels")
---
> 	    stop("names of starting value for object of class \"varIdent\" must contain all but one of the stratum levels")
403c398
< 	    stop("nonexistent group names for initial values in 'varIdent'")
---
> 	    stop(gettextf("nonexistent group names for initial values in %s function", sQuote("varIdent()")))
450,451c445,446
< 	   structName = if (is.null(formula(object))) "Constant variance"
< 	                else "Different standard deviations per stratum",
---
> 	   structName = if (is.null(formula(object))) gettext("Constant variance", domain = "R-nlme")
> 	                else gettext("Different standard deviations per stratum", domain = "R-nlme"),
469c464
<     stop("'form' must have a covariate")
---
>     stop(gettextf("'%s' argument must have a covariate", "form"))
473c468
<       stop("initial values must have group names in 'varPower'")
---
>       stop(gettextf("initial values must have group names in %s function", sQuote("varPower()")))
477c472
< 	stop("fixed parameters must have group names in 'varPower'")
---
> 	stop(gettextf("fixed parameters must have group names in %s function", sQuote("varPower()")))
524c519
<       stop("cannot change the length of the \"varStruct\" parameter after initialization")
---
>       stop(gettextf("cannot change the length of the %s parameter after initialization", dQuote("varStruct")))
562c557
< 	  stop("fixed parameters must have group names")
---
> 	  stop(gettextf("fixed parameters must have group names in %s function", sQuote("Initialize.varPower()")))
588,589c583
<               stop(gettextf("initial value for \"varPower\" should be of length %d",
<                             nStratVar), domain = NA)
---
>               stop(gettextf("initial value for %s should be of length %d", dQuote("varPower"), nStratVar), domain = "R-nlme")
594c588
< 	    stop("nonexistent group names for initial values in \"varPower\"")
---
> 	    stop(gettextf("nonexistent group names for initial values in %s function", sQuote("varPower()")))
631c625
<         stop("initial value for \"varPower\" should be of length 1")
---
>         stop(gettextf("initial value for %s should be of length %d", dQuote("varPower"), 1), domain = "R-nlme")
649c643
<   function(object, structName = "Power of variance covariate", ...)
---
>   function(object, structName = gettext("Power of variance covariate", domain = "R-nlme"), ...)
683c677
<     stop("'form' must have a covariate")
---
>     stop(gettextf("'%s' argument must have a covariate", "form"))
687c681
<       stop("initial values must have group names in 'varExp'")
---
>       stop(gettextf("initial values must have group names in %s function", sQuote("varExp()")))
691c685
< 	stop("fixed parameters must have group names in 'varExp'")
---
> 	stop(gettextf("fixed parameters must have group names in %s function", sQuote("varExp()")))
737c731
<       stop("cannot change the length of the \"varExp\" parameter after initialization")
---
>       stop(gettextf("cannot change the length of the %s parameter after initialization", dQuote("varExp")))
773c767
< 	  stop("fixed parameters must have group names")
---
> 	   stop(gettextf("fixed parameters must have group names in %s function", sQuote("Initialize.varExp()")))
799,800c793
<               stop(gettextf("initial value for \"varExp\" should be of length %d",
<                             nStratVar), domain = NA)
---
>               stop(gettextf("initial value for %s should be of length %d", dQuote("varExp"), nStratVar), domain = "R-nlme")
805c798
< 	    stop("nonexistent group names for initial values in \"varExp\"")
---
> 	    stop(gettextf("nonexistent group names for initial values in %s function", sQuote("varExp()")))
842c835
<         stop("initial value for \"varExp\" should be of length 1")
---
>         stop(gettextf("initial value for %s should be of length %d", dQuote("varExp"), 1), domain = "R-nlme")
897c890
<       stop(gettextf("%s can have at most two components", nam), domain = NA)
---
>       stop(gettextf("%s can have at most two components", nam), domain = "R-nlme")
903,904c896
<         stop(gettextf("%s can only have names \"const\" and \"power\"", nam),
<              domain = NA)
---
>         stop(gettextf("%s can only have names \"const\" and \"power\"", nam), domain = "R-nlme")
913c905
<         stop(gettextf("%s can only be a list or numeric", nam), domain = NA)
---
>         stop(gettextf("%s can only be a list or numeric", nam), domain = "R-nlme")
923,924c915
<         stop(gettextf("%s must have group names in 'varConstPower'", nam),
<              domain = NA)
---
>         stop(gettextf("%s must have group names in 'varConstPower'", nam), domain = "R-nlme")
939c930
<     stop("'form' must have a covariate")
---
>     stop(gettextf("'%s' argument must have a covariate", "form"))
1055c1046
< 	    stop("fixed parameters must have group names")
---
> 	     stop(gettextf("fixed parameters must have group names in %s function", sQuote("Initialize.varConstPower()")))
1080,1081c1071
<                 stop(gettext("initial value should be of length %d",
<                              nStratVar), domain = NA)
---
>                 stop(gettext("initial value should be of length %d", nStratVar), domain = "R-nlme")
1086c1076
< 	      stop("nonexistent group names for initial values")
---
> 	      stop(gettextf("nonexistent group names for initial values in %s function", sQuote("varConstPower()")))
1129c1119
<       stop(gettext("initial value should be of length %d", aux), domain = NA)
---
>       stop(gettext("initial value should be of length %d", aux), domain = "R-nlme")
1135c1125
<   function(object, structName = "Constant plus power of variance covariate",
---
>   function(object, structName = gettext("Constant plus power of variance covariate"),
1170c1160
<     stop("all arguments to 'varComb' must be of class \"varFunc\".")
---
>     stop("all arguments passed to 'varComb()' function must be of class \"varFunc\"")
1202c1192
<       stop("cannot change parameter length of initialized \"varComb\" object")
---
>       stop(gettextf("cannot change parameter length of initialized object of class %s", dQuote("varComb")))
1243c1233
<   cat("Combination of:\n")
---
>   cat(gettext("Combination of:", domain = "R-nlme"), "\n", sep = "")
1257c1247
<   function(object, structName = "Combination of variance functions:", ...)
---
>   function(object, structName = gettext("Combination of variance functions:", domain = "R-nlme"), ...)
diff -rEZbwB '--exclude=*.[lo,d,pdf,mo,po,tgz,gz,save]*' '--exclude=MD5' '--exclude=Makefile*' '--exclude=all.R' '--exclude=Changes' R-recommended/nlme/src/base.h Recommended/nlme/src/base.h
36,41d35
< #ifdef ENABLE_NLS
< #include <libintl.h>
< #define _(String) dgettext ("nlme", String)
< #else
< #define _(String) (String)
< #endif
diff -rEZbwB '--exclude=*.[lo,d,pdf,mo,po,tgz,gz,save]*' '--exclude=MD5' '--exclude=Makefile*' '--exclude=all.R' '--exclude=Changes' R-recommended/nlme/src/corStruct.c Recommended/nlme/src/corStruct.c
28c28
< 
---
> #include "localization.h"
32,34c32,33
< void
< corStruct_factList(double *mat, longint *pdims, double *FactorL, double *logdet)
< {
---
> void corStruct_factList(double *mat, longint *pdims, double *FactorL,
> 		double *logdet) {
56c55,56
< 	Free(work); Free(work1);
---
> 		Free(work);
> 		Free(work1);
62,64c62,63
< void
< corStruct_recalc(double *Xy, longint *pdims, longint *ZXcol, double *Factor)
< {
---
> void corStruct_recalc(double *Xy, longint *pdims, longint *ZXcol,
> 		double *Factor) {
76,77c75
< void
< symm_fullCorr(double *par, longint *maxC, double *crr)
---
> void symm_fullCorr(double *par, longint *maxC, double *crr)
92c90,91
< 	    dest++; src++;
---
> 			dest++;
> 			src++;
111,113c110,111
< static void
< symm_mat(double *crr, longint *time, longint *n, longint *maxC, double *mat)
< {
---
> static void symm_mat(double *crr, longint *time, longint *n, longint *maxC,
> 		double *mat) {
126,129c124,125
< void
< symm_matList(double *pars, longint *time, longint *maxC,
< 	     longint *pdims, double *mat)
< {
---
> void symm_matList(double *pars, longint *time, longint *maxC,
> longint *pdims, double *mat) {
142,145c138,139
< static void
< symm_fact(double *crr, longint *time, longint *n, longint *maxC, double *mat,
< 	  double *logdet)
< {
---
> static void symm_fact(double *crr, longint *time, longint *n, longint *maxC,
> 		double *mat, double *logdet) {
164c158,159
<     Free(work); Free(work1);
---
> 	Free(work);
> 	Free(work1);
167,170c162,163
< void
< symm_factList(double *pars, longint *time, longint *maxC, longint *pdims,
< 	      double *FactorL, double *logdet)
< {
---
> void symm_factList(double *pars, longint *time, longint *maxC, longint *pdims,
> 		double *FactorL, double *logdet) {
183,186c176,177
< void
< symm_recalc(double *Xy, longint *pdims, longint *ZXcol, double *pars,
< 	    longint *time, longint *maxC, double *logdet)
< {
---
> void symm_recalc(double *Xy, longint *pdims, longint *ZXcol, double *pars,
> longint *time, longint *maxC, double *logdet) {
203,204c194
< void
< nat_fullCorr(double *par, longint *maxC, double *crr)
---
> void nat_fullCorr(double *par, longint *maxC, double *crr)
216,219c206,207
< void
< nat_matList(double *pars, longint *time, longint *maxC,
< 	    longint *pdims, double *mat)
< {
---
> void nat_matList(double *pars, longint *time, longint *maxC,
> longint *pdims, double *mat) {
232,235c220,221
< void
< nat_factList(double *pars, longint *time, longint *maxC, longint *pdims,
< 	     double *FactorL, double *logdet)
< {
---
> void nat_factList(double *pars, longint *time, longint *maxC, longint *pdims,
> 		double *FactorL, double *logdet) {
248,251c234,235
< void
< nat_recalc(double *Xy, longint *pdims, longint *ZXcol, double *pars,
< 	   longint *time, longint *maxC, double *logdet)
< {
---
> void nat_recalc(double *Xy, longint *pdims, longint *ZXcol, double *pars,
> longint *time, longint *maxC, double *logdet) {
268,270c252
< static void
< AR1_mat(double *par, longint *n, double *mat)
< {
---
> static void AR1_mat(double *par, longint *n, double *mat) {
282,283c264
< static double
< safe_phi(double x)		/* returns (exp(x) - 1)/(exp(x) + 1), x < 0 */
---
> static double safe_phi(double x) /* returns (exp(x) - 1)/(exp(x) + 1), x < 0 */
294,296c275
< void
< AR1_matList(double *par, longint *pdims, double *mat)
< {
---
> void AR1_matList(double *par, longint *pdims, double *mat) {
307,309c286
< static void
< AR1_fact(double *par, longint *n, double *mat, double *logdet)
< {
---
> static void AR1_fact(double *par, longint *n, double *mat, double *logdet) {
322,325c299
< void
< AR1_factList(double *par, longint *pdims, double *FactorL,
< 	     double *logdet)
< {
---
> void AR1_factList(double *par, longint *pdims, double *FactorL, double *logdet) {
336,339c310,311
< void
< AR1_recalc(double *Xy, longint *pdims, longint *ZXcol, double *par,
< 	   double *logdet)
< {
---
> void AR1_recalc(double *Xy, longint *pdims, longint *ZXcol, double *par,
> 		double *logdet) {
356,358c327
< static void
< CAR1_mat(double *par, double *time, longint *n, double *mat)
< {
---
> static void CAR1_mat(double *par, double *time, longint *n, double *mat) {
370,372c339
< void
< CAR1_matList(double *par, double *time, longint *pdims, double *mat)
< {
---
> void CAR1_matList(double *par, double *time, longint *pdims, double *mat) {
384,386c351,352
< static void
< CAR1_fact(double *par, double *time, longint *n, double *mat, double *logdet)
< {
---
> static void CAR1_fact(double *par, double *time, longint *n, double *mat,
> 		double *logdet) {
402c368,369
<     Free(work); Free(work1);
---
> 	Free(work);
> 	Free(work1);
405,408c372,373
< void
< CAR1_factList(double *par, double *time, longint *pdims,
< 	      double *FactorL, double *logdet)
< {
---
> void CAR1_factList(double *par, double *time, longint *pdims, double *FactorL,
> 		double *logdet) {
420,423c385,386
< void
< CAR1_recalc(double *Xy, longint *pdims, longint *ZXcol,
< 	    double *par, double *time, double *logdet)
< {
---
> void CAR1_recalc(double *Xy, longint *pdims, longint *ZXcol, double *par,
> 		double *time, double *logdet) {
439,441c402
< static void
< ARMA_transPar(longint N, double *pars, double sgn)
< {
---
> static void ARMA_transPar(longint N, double *pars, double sgn) {
464,466c425
< void
< ARMA_unconstCoef(longint *p, longint *q, double *pars)
< {
---
> void ARMA_unconstCoef(longint *p, longint *q, double *pars) {
471,473c430
< static void
< ARMA_untransPar(longint N, double *pars, double sgn)
< {
---
> static void ARMA_untransPar(longint N, double *pars, double sgn) {
492,494c449
< void
< ARMA_constCoef(longint *p, longint *q, double *pars)
< {
---
> void ARMA_constCoef(longint *p, longint *q, double *pars) {
499,501c454
< static void
< ARMA_cross(longint *p, longint *q, double *pars, double *psi)
< {
---
> static void ARMA_cross(longint *p, longint *q, double *pars, double *psi) {
514,517c467,468
< static void
< ARMA_corr(longint *p, longint *q, longint *maxlag, double *pars, double *psi,
< 	  double *crr)
< {
---
> static void ARMA_corr(longint *p, longint *q, longint *maxlag, double *pars,
> 		double *psi, double *crr) {
523c474,475
<     if (sqrt_eps == 0.0) sqrt_eps = sqrt(DOUBLE_EPS);
---
> 	if (sqrt_eps == 0.0)
> 		sqrt_eps = sqrt(DOUBLE_EPS);
555c507,508
< 	    F77_CALL(dqrdc2) (coef, &P, &P, &P,  &sqrt_eps, &i, qraux, pivot, work);
---
> 			F77_CALL(dqrdc2)(coef, &P, &P, &P, &sqrt_eps, &i, qraux, pivot,
> 					work);
559c512,513
< 	    F77_CALL(dqrsl) (coef, &P, &P, &P, qraux, crr, DNULLP, crr, work1, DNULLP,
---
> 			F77_CALL(dqrsl)(coef, &P, &P, &P, qraux, crr, DNULLP, crr, work1,
> 					DNULLP,
579c533,537
< 	Free(qraux); Free(work); Free(coef); Free(pivot); Free(work1);
---
> 		Free(qraux);
> 		Free(work);
> 		Free(coef);
> 		Free(pivot);
> 		Free(work1);
584,587c542,543
< static void
< ARMA_fullCorr(longint *p, longint *q, longint *maxlag, double *pars,
< 	      double *crr)
< {
---
> static void ARMA_fullCorr(longint *p, longint *q, longint *maxlag, double *pars,
> 		double *crr) {
597,599c553
< static void
< ARMA_mat(double *crr, longint *time, longint *n, double *mat)
< {
---
> static void ARMA_mat(double *crr, longint *time, longint *n, double *mat) {
610,613c564,565
< void
< ARMA_matList(double *pars, longint *p, longint *q, longint *time,
< 	     longint *maxlag, longint *pdims, double *mat)
< {
---
> void ARMA_matList(double *pars, longint *p, longint *q, longint *time,
> longint *maxlag, longint *pdims, double *mat) {
627,629c579,580
< static void
< ARMA_fact(double *crr, longint *time, longint *n, double *mat, double *logdet)
< {
---
> static void ARMA_fact(double *crr, longint *time, longint *n, double *mat,
> 		double *logdet) {
647c598,599
<     Free(work); Free(work1);
---
> 	Free(work);
> 	Free(work1);
650,654c602,603
< void
< ARMA_factList(double *pars, longint *p, longint *q, longint *time,
< 	      longint *maxlag, longint *pdims, double *FactorL,
< 	      double *logdet)
< {
---
> void ARMA_factList(double *pars, longint *p, longint *q, longint *time,
> longint *maxlag, longint *pdims, double *FactorL, double *logdet) {
668,672c617,618
< void
< ARMA_recalc(double *Xy, longint *pdims, longint *ZXcol, double *pars,
< 	    longint *p, longint *q, longint *time, longint *maxlag,
< 	    double *logdet)
< {
---
> void ARMA_recalc(double *Xy, longint *pdims, longint *ZXcol, double *pars,
> longint *p, longint *q, longint *time, longint *maxlag, double *logdet) {
689,691c635
< static void
< compSymm_mat(double *par, longint *n, double *mat)
< {
---
> static void compSymm_mat(double *par, longint *n, double *mat) {
701,703c645
< void
< compSymm_matList(double *par, double *inf, longint *pdims, double *mat)
< {
---
> void compSymm_matList(double *par, double *inf, longint *pdims, double *mat) {
714,716c656
< static void
< compSymm_fact(double *par, longint *n, double *mat, double *logdet)
< {
---
> static void compSymm_fact(double *par, longint *n, double *mat, double *logdet) {
738,741c678,679
< void
< compSymm_factList(double *par, double *inf, longint *pdims,
< 		  double *FactorL, double *logdet)
< {
---
> void compSymm_factList(double *par, double *inf, longint *pdims,
> 		double *FactorL, double *logdet) {
752,755c690,691
< void
< compSymm_recalc(double *Xy, longint *pdims, longint *ZXcol, double *par,
< 		double *inf, double *logdet)
< {
---
> void compSymm_recalc(double *Xy, longint *pdims, longint *ZXcol, double *par,
> 		double *inf, double *logdet) {
771,773c707
< static void
< HF_mat(double *par, longint *time, longint *n, double *mat)
< {
---
> static void HF_mat(double *par, longint *time, longint *n, double *mat) {
778,779c712,713
< 	    *(mat + i + j * (*n)) = *(mat + j + i * (*n)) =
< 		0.5 * (par[time[i]] + par[time[j]]) - 1.0;
---
> 			*(mat + i + j * (*n)) = *(mat + j + i * (*n)) = 0.5
> 					* (par[time[i]] + par[time[j]]) - 1.0;
784,787c718,719
< void
< HF_matList(double *par, longint *maxC, longint *time, longint *pdims,
< 	   double *mat)
< {
---
> void HF_matList(double *par, longint *maxC, longint *time, longint *pdims,
> 		double *mat) {
801,803c733,734
< static void
< HF_fact(double *par, longint *time, longint *n, double *mat, double *logdet)
< {
---
> static void HF_fact(double *par, longint *time, longint *n, double *mat,
> 		double *logdet) {
821c752,753
<     Free(work); Free(work1);
---
> 	Free(work);
> 	Free(work1);
824,827c756,757
< void
< HF_factList(double *par, longint *maxC, longint *time, longint *pdims,
< 	    double *FactorL, double *logdet)
< {
---
> void HF_factList(double *par, longint *maxC, longint *time, longint *pdims,
> 		double *FactorL, double *logdet) {
841,844c771,772
< void
< HF_recalc(double *Xy, longint *pdims, longint *ZXcol, double *par,
< 	  longint *time, longint *maxC, double *logdet)
< {
---
> void HF_recalc(double *Xy, longint *pdims, longint *ZXcol, double *par,
> longint *time, longint *maxC, double *logdet) {
864,868c792,796
< static double
< spher_corr(double val)
< {
<     if (val < 1) return(1.0 - 1.5 * val + 0.5 * pow(val, 3));
<     else return(0.0);
---
> static double spher_corr(double val) {
> 	if (val < 1)
> 		return (1.0 - 1.5 * val + 0.5 * pow(val, 3));
> 	else
> 		return (0.0);
873,875c801
< static double
< exp_corr(double val)
< {
---
> static double exp_corr(double val) {
881,883c807
< static double
< Gaus_corr(double val)
< {
---
> static double Gaus_corr(double val) {
889,893c813,817
< static double
< lin_corr(double val)
< {
<     if (val < 1) return(1.0 - val);
<     else return(0.0);
---
> static double lin_corr(double val) {
> 	if (val < 1)
> 		return (1.0 - val);
> 	else
> 		return (0.0);
898,900c822
< static double
< ratio_corr(double val)
< {
---
> static double ratio_corr(double val) {
906,908c828
< static double
< dummy_corr(double val)
< {
---
> static double dummy_corr(double val) {
915,918c835,836
< static void
< spatial_mat(double *par, double *dist, longint *n, longint *nug,
< 	    double (*corr)(double ), double *mat)
< {
---
> static void spatial_mat(double *par, double *dist, longint *n, longint *nug,
> 		double (*corr)(double), double *mat) {
922c840,841
<     if (*nug) ratio = par[1];
---
> 	if (*nug)
> 		ratio = par[1];
932,937c851,854
< void
< spatial_matList(double *par, longint *nug, double *dist, longint *pdims,
< 		double *minD, double *mat)
< {
<     longint i, M = pdims[1], spClass = pdims[2], *len = pdims + 4,
< 	*start = len + M;
---
> void spatial_matList(double *par, longint *nug, double *dist, longint *pdims,
> 		double *minD, double *mat) {
> 	longint i, M = pdims[1], spClass = pdims[2], *len = pdims + 4, *start = len
> 			+ M;
973,977c890,891
< static void
< spatial_fact(double *par, double *dist, longint *n, longint *nug,
< 	     double (*corr) (double ), double *mat,
< 	     double *logdet)
< {
---
> static void spatial_fact(double *par, double *dist, longint *n, longint *nug,
> 		double (*corr)(double), double *mat, double *logdet) {
995c909,910
<     Free(work); Free(work1);
---
> 	Free(work);
> 	Free(work1);
998,1003c913,916
< void
< spatial_factList(double *par, longint *nug, double *dist, longint *pdims,
< 		 double *minD, double *FactorL, double *logdet)
< {
<     longint i, M = pdims[1], spClass = pdims[2], *len = pdims + 4,
< 	*start = len + M;
---
> void spatial_factList(double *par, longint *nug, double *dist, longint *pdims,
> 		double *minD, double *FactorL, double *logdet) {
> 	longint i, M = pdims[1], spClass = pdims[2], *len = pdims + 4, *start = len
> 			+ M;
1040,1045c953,956
< void
< spatial_recalc(double *Xy, longint *pdims, longint *ZXcol, double *par,
< 	       double *dist, double *minD, longint *nug, double *logdet)
< {
<     longint N = pdims[0], M = pdims[1], spClass = pdims[2],
< 	*len = pdims + 4, *start = len + M, i;
---
> void spatial_recalc(double *Xy, longint *pdims, longint *ZXcol, double *par,
> 		double *dist, double *minD, longint *nug, double *logdet) {
> 	longint N = pdims[0], M = pdims[1], spClass = pdims[2], *len = pdims + 4,
> 			*start = len + M, i;
diff -rEZbwB '--exclude=*.[lo,d,pdf,mo,po,tgz,gz,save]*' '--exclude=MD5' '--exclude=Makefile*' '--exclude=all.R' '--exclude=Changes' R-recommended/nlme/src/gnls.c Recommended/nlme/src/gnls.c
35,37c35,36
<   double *residuals, *gradient, *corFactor, *varWeights, minFactor,
<     tolerance, *newtheta, *theta, *incr, *add_ons,
<     new_objective, objective;
---
> 	double *residuals, *gradient, *corFactor, *varWeights, minFactor, tolerance,
> 			*newtheta, *theta, *incr, *add_ons, new_objective, objective;
46,47c45,46
< static gnlsPtr
< gnls_init(double *ptheta, longint *dims, double *corFactor, double *varWeights,
---
> static gnlsPtr gnls_init(double *ptheta, longint *dims, double *corFactor,
> 		double *varWeights,
49,50c48
< 	  longint corOpt, longint varOpt aMOD)
< {
---
> 		longint corOpt, longint varOpt aMOD) {
52c50,51
<   gnlsPtr gnls = Calloc(1, struct gnls_struct);
---
> 	gnlsPtr
> 	gnls = Calloc(1, struct gnls_struct);
78,80c77
< static void
< gnlsFree( gnlsPtr gnls )
< {
---
> static void gnlsFree(gnlsPtr gnls) {
89,91c86
< static double
< gnls_objective(gnlsPtr gnls)
< {
---
> static double gnls_objective(gnlsPtr gnls) {
101c96,97
<     corStruct_recalc(gnls->result[0], gnls->corDims, &gnls->ncol, gnls->corFactor);
---
> 		corStruct_recalc(gnls->result[0], gnls->corDims, &gnls->ncol,
> 				gnls->corFactor);
120,122c116
< static double
< gnls_increment(gnlsPtr gnls)
< {
---
> static double gnls_increment(gnlsPtr gnls) {
126c120,121
<   if (sqrt_eps == 0.0) sqrt_eps = sqrt(DOUBLE_EPS);
---
> 	if (sqrt_eps == 0.0)
> 		sqrt_eps = sqrt(DOUBLE_EPS);
137,138c132,134
<   return(sqrt(((double) gnls->nrdof) * regSS /
< 	      ((double) gnls->npar) * (gnls->new_objective - regSS)));
---
> 	return (sqrt(
> 			((double) gnls->nrdof) * regSS / ((double) gnls->npar)
> 					* (gnls->new_objective - regSS)));
141,143c137
< static longint
< gnls_iterate(gnlsPtr gnls aSEV)
< {
---
> static longint gnls_iterate(gnlsPtr gnls aSEV) {
155,156c149
<   for (factor = 1.0, iteration = 1; iteration <= gnls->maxIter;
<        iteration++) {		/* outer iteration loop */
---
> 	for (factor = 1.0, iteration = 1; iteration <= gnls->maxIter; iteration++) { /* outer iteration loop */
159,160c152,155
<     if (gnls->conv_failure) return(iteration); /* Unable to make increment */
<     if (criterion < gnls->tolerance) return(iteration); /* successful completion */
---
> 		if (gnls->conv_failure)
> 			return (iteration); /* Unable to make increment */
> 		if (criterion < gnls->tolerance)
> 			return (iteration); /* successful completion */
170c165,166
<       if (gnls->conv_failure) return(iteration); /* unable to evaluate objective */
---
> 			if (gnls->conv_failure)
> 				return (iteration); /* unable to evaluate objective */
183,185c179
< static void
< gnls_wrapup(gnlsPtr gnls aSEV)
< {
---
> static void gnls_wrapup(gnlsPtr gnls aSEV) {
196,200c190,192
< void
< fit_gnls(double *ptheta, longint *pdims, double *pcorFactor, double
< 	 *pvarWeights, longint *pcorDims, double *settings,
< 	 double *additional, longint *pcorOpt, longint *pvarOpt aMOD)
< {
---
> void fit_gnls(double *ptheta, longint *pdims, double *pcorFactor,
> 		double *pvarWeights, longint *pcorDims, double *settings,
> 		double *additional, longint *pcorOpt, longint *pvarOpt aMOD) {
207,209c199,202
<   if(sqrt_eps == 0.0) sqrt_eps = sqrt(DOUBLE_EPS);
<   gnls = gnls_init(ptheta, pdims, pcorFactor, pvarWeights, pcorDims,
<     settings, additional, *pcorOpt, *pvarOpt MOD);
---
> 	if (sqrt_eps == 0.0)
> 		sqrt_eps = sqrt(DOUBLE_EPS);
> 	gnls = gnls_init(ptheta, pdims, pcorFactor, pvarWeights, pcorDims, settings,
> 			additional, *pcorOpt, *pvarOpt MOD);
Only in Recommended/nlme/src: localization.h
diff -rEZbwB '--exclude=*.[lo,d,pdf,mo,po,tgz,gz,save]*' '--exclude=MD5' '--exclude=Makefile*' '--exclude=all.R' '--exclude=Changes' R-recommended/nlme/src/matrix.c Recommended/nlme/src/matrix.c
28c28,29
< void F77_NAME(dqrdc2)(double *x, int *ldx, int *n, int *p,
---
> void F77_NAME( dqrdc2)
> (double *x, int *ldx, int *n, int *p,
31c32,33
< void F77_NAME(dqrls)(double *x, int *n, int *p, double *y, int *ny,
---
> void F77_NAME( dqrls)
> (double *x, int *n, int *p, double *y, int *ny,
36,39c38,41
< void
< d_axpy(double *y, double a, double *x, longint n)
< {				/* y <- a * x + y  */
<   while (n-- > 0) { *y++ += a * *x++; }
---
> void d_axpy(double *y, double a, double *x, longint n) { /* y <- a * x + y  */
> 	while (n-- > 0) {
> 		*y++ += a * *x++;
> 	}
42,44c44
< double
< d_sum_sqr( double *x, longint n )
< {				/* sum(x * x) */
---
> double d_sum_sqr(double *x, longint n) { /* sum(x * x) */
46c46,49
<   while (n-- > 0) { accum += *x * *x; x++; }
---
> 	while (n-- > 0) {
> 		accum += *x * *x;
> 		x++;
> 	}
50,52c53
< double
< d_dot_prod( double *x, longint incx, double *y, longint incy, longint n )
< {				/* sum(x * y) */
---
> double d_dot_prod(double *x, longint incx, double *y, longint incy, longint n) { /* sum(x * y) */
54c55,59
<   while (n-- > 0) { accum += *x * *y; x +=incx; y += incy; }
---
> 	while (n-- > 0) {
> 		accum += *x * *y;
> 		x += incx;
> 		y += incy;
> 	}
60,61c65
< 	 longint nrow, longint ncol)
< {				/* y <- x */
---
> longint nrow, longint ncol) { /* y <- x */
63c67,71
<   while (ncol-- > 0) { Memcpy(y, x, nrow); y += ldy; x += ldx; }
---
> 	while (ncol-- > 0) {
> 		Memcpy(y, x, nrow);
> 		y += ldy;
> 		x += ldx;
> 	}
74c82,84
<     for (j = 0L; j < ncol; j++) { y[j] = x[i + j * ldx]; }
---
> 		for (j = 0L; j < ncol; j++) {
> 			y[j] = x[i + j * ldx];
> 		}
81,84c91,92
< mult_mat(double *z, longint ldz,
< 	 double *x, longint ldx, longint xrows, longint xcols,
< 	 double *y, longint ldy, longint ycols)
< {				/* z <- x %*% y */
---
> mult_mat(double *z, longint ldz, double *x, longint ldx, longint xrows,
> 		longint xcols, double *y, longint ldy, longint ycols) { /* z <- x %*% y */
101,103c109
< static void
< zero_mat(double *y, longint ldy, longint nrow, longint ncol)
< {				/* y[,] <- 0 */
---
> static void zero_mat(double *y, longint ldy, longint nrow, longint ncol) { /* y[,] <- 0 */
106c112,114
<     for (i = 0; i < nrow; i++) { y[i] = 0.0; }
---
> 		for (i = 0; i < nrow; i++) {
> 			y[i] = 0.0;
> 		}
110a119
> QRptr QR(double *mat, longint ldmat, longint nrow, longint ncol) { /* Constructor for a QR object */
112,115c121,123
< QR(double *mat, longint ldmat, longint nrow, longint ncol)
< {				/* Constructor for a QR object */
<   QRptr value = Calloc((size_t) 1, struct QR_struct);
<   longint j;  double *work;
---
> 	value = Calloc((size_t) 1, struct QR_struct);
> 	longint j;
> 	double *work;
117c125,127
<   if (sqrt_eps == 0.) { sqrt_eps = sqrt(DOUBLE_EPS); }
---
> 	if (sqrt_eps == 0.) {
> 		sqrt_eps = sqrt(DOUBLE_EPS);
> 	}
124c134,136
<   for (j = 0; j < ncol; j++) { (value->pivot)[j] = j; }
---
> 	for (j = 0; j < ncol; j++) {
> 		(value->pivot)[j] = j;
> 	}
132,134c144
< void
< QRfree(QRptr this)
< {				/* destructor for a QR object*/
---
> void QRfree(QRptr this) { /* destructor for a QR object*/
140,142c150
< longint
< QRqty(QRptr this, double *ymat, longint ldy, longint ycol)
< {				/* ymat <- qr.qty(this, ymat) */
---
> longint QRqty(QRptr this, double *ymat, longint ldy, longint ycol) { /* ymat <- qr.qty(this, ymat) */
147,148c155,156
< 		     this->qraux, col, DNULLP, col, DNULLP, DNULLP, DNULLP,
< 		     &task, &info);
---
> 				this->qraux, col, DNULLP, col, DNULLP, DNULLP, DNULLP, &task,
> 				&info);
153,156c161,162
< longint
< QRsolve( QRptr this, double *ymat, longint ldy, longint ycol,
< 	 double *beta, longint ldbeta )
< {				/* beta <- qr.beta(this, ymat) */
---
> longint QRsolve(QRptr this, double *ymat, longint ldy, longint ycol,
> 		double *beta, longint ldbeta) { /* beta <- qr.beta(this, ymat) */
170c176,177
<   Free( qty ); Free( bb );
---
> 	Free(qty);
> 	Free(bb);
174,176c181
< double
< QRlogAbsDet(QRptr this)
< {				/* log(abs(det(upper triangle))) */
---
> double QRlogAbsDet(QRptr this) { /* log(abs(det(upper triangle))) */
184,186c189
< void
< QRstoreR(QRptr this, double *dest, longint ldDest)
< {				/* store the R part into dest */
---
> void QRstoreR(QRptr this, double *dest, longint ldDest) { /* store the R part into dest */
194,197c197,199
< longint
< QR_and_rotate(double *mat, longint ldmat, longint nrow, longint ncol,
< 	      double *DmHalf, longint qi, longint ndecomp,
< 	      double *logdet, double *store, longint ldstr)
---
> longint QR_and_rotate(double *mat, longint ldmat, longint nrow, longint ncol,
> 		double *DmHalf, longint qi, longint ndecomp, double *logdet,
> 		double *store, longint ldstr)
210c212,214
<   if (logdet != DNULLP) { *logdet += QRlogAbsDet(aQR); }
---
> 	if (logdet != DNULLP) {
> 		*logdet += QRlogAbsDet(aQR);
> 	}
214,215c218,222
<     copy_mat(store + ndecomp * ldstr, ldstr, aug + ndecomp * arow,
< 	     arow, ndrow, ncol - ndecomp);
---
> 		copy_mat(store + ndecomp * ldstr, ldstr, aug + ndecomp * arow, arow,
> 				ndrow, ncol - ndecomp);
> 	}
> 	if (qi < ndecomp) {
> 		zero_mat(mat, ldmat, nrow, ncol);
217,219c224,225
<   if (qi < ndecomp) { zero_mat(mat, ldmat, nrow, ncol); }
<   copy_mat(mat + ndecomp * ldmat, ldmat, aug + ndecomp * (arow + 1L),
< 	   arow, arow - ndrow, ncol - ndecomp);
---
> 	copy_mat(mat + ndecomp * ldmat, ldmat, aug + ndecomp * (arow + 1L), arow,
> 			arow - ndrow, ncol - ndecomp);
221c227,228
<   QRfree(aQR); Free(aug);
---
> 	QRfree(aQR);
> 	Free(aug);
diff -rEZbwB '--exclude=*.[lo,d,pdf,mo,po,tgz,gz,save]*' '--exclude=MD5' '--exclude=Makefile*' '--exclude=all.R' '--exclude=Changes' R-recommended/nlme/src/matrix.h Recommended/nlme/src/matrix.h
27c27,28
< void F77_NAME(chol)(double *a, int *lda, int *n, double *v, int *info);
---
> void F77_NAME(chol)
> (double *a, int *lda, int *n, double *v, int *info);
33,34c34
<   double *mat, *qraux;
<   longint *pivot, rank, ldmat, nrow, ncol;
---
> 	double *mat, *qraux;longint *pivot, rank, ldmat, nrow, ncol;
52,54c52,53
< extern longint QR_and_rotate(double *, longint, longint, longint,
< 			     double *, longint, longint, double *,
< 			     double *, longint);
---
> extern longint QR_and_rotate(double *, longint, longint, longint, double *,
> 		longint, longint, double *, double *, longint);
diff -rEZbwB '--exclude=*.[lo,d,pdf,mo,po,tgz,gz,save]*' '--exclude=MD5' '--exclude=Makefile*' '--exclude=all.R' '--exclude=Changes' R-recommended/nlme/src/nlOptimizer.c Recommended/nlme/src/nlOptimizer.c
30,32c30
< int
< evaluate(double *param, longint nParam aMOD, double **value aSEV)
< {
---
> int evaluate(double *param, longint nParam aMOD, double **value aSEV) {
diff -rEZbwB '--exclude=*.[lo,d,pdf,mo,po,tgz,gz,save]*' '--exclude=MD5' '--exclude=Makefile*' '--exclude=all.R' '--exclude=Changes' R-recommended/nlme/src/nlOptimizer.h Recommended/nlme/src/nlOptimizer.h
34,35c34,35
< extern void fit_gnls(double *, longint *, double *, double *, longint
< 		     *, double *, double *, longint *, longint * aMOD);
---
> extern void fit_gnls(double *, longint *, double *, double *, longint *,
> 		double *, double *, longint *, longint * aMOD);
diff -rEZbwB '--exclude=*.[lo,d,pdf,mo,po,tgz,gz,save]*' '--exclude=MD5' '--exclude=Makefile*' '--exclude=all.R' '--exclude=Changes' R-recommended/nlme/src/nlme.c Recommended/nlme/src/nlme.c
28a29
> #include "localization.h"
39,43c40,43
<     double *residuals, *gradient, *DmHalf, *corFactor, *varWeights,
< 	*newtheta, *theta, *incr, *add_ons, new_objective, objective, RSS,
< 	*sigma; // <- 17-11-2015; Fixed sigma patch; E van Willigen; Quant.Sol.
<     longint corOpt, varOpt, nparTot, ngrpTot, nrdof, *sgroups, *corDims,
< 	*npar, *pdClass, *pdims, *ZXoff, *ZXlen;
---
> 	double *residuals, *gradient, *DmHalf, *corFactor, *varWeights, *newtheta,
> 			*theta, *incr, *add_ons, new_objective, objective, RSS, *sigma; // <- 17-11-2015; Fixed sigma patch; E van Willigen; Quant.Sol.
> 	longint corOpt, varOpt, nparTot, ngrpTot, nrdof, *sgroups, *corDims, *npar,
> 			*pdClass, *pdims, *ZXoff, *ZXlen;
55,56c55
< make_sequential(longint *dest, longint *src, longint n)
< {
---
> make_sequential(longint *dest, longint *src, longint n) {
61,62c60,63
<     if (n <= 0) return dest;
<     sval = *src++; *dest++ = val;
---
> 	if (n <= 0)
> 		return dest;
> 	sval = *src++;
> 	*dest++ = val;
64c65,68
< 	if (*src != sval) {sval = *src; val++;}
---
> 		if (*src != sval) {
> 			sval = *src;
> 			val++;
> 		}
71,74c75,77
< static nlmePtr
< nlme_init(double *ptheta, double *pDmHalf, longint *pgroups,
< 	  longint *pdims, longint *pdClass, double *pcorFactor,
< 	  double *pvarWeights, longint *pcorDims, double *additional,
---
> static nlmePtr nlme_init(double *ptheta, double *pDmHalf, longint *pgroups,
> longint *pdims, longint *pdClass, double *pcorFactor, double *pvarWeights,
> 		longint *pcorDims, double *additional,
77,78c80
< 	  , double *sigma aMOD)
< {
---
> 		, double *sigma aMOD) {
80c82,83
<     nlmePtr nlme = Calloc(1, struct nlme_struct);
---
> 	nlmePtr
> 	nlme = Calloc(1, struct nlme_struct);
105c108,110
<     for (i = 0; i < (nlme->dd->Q + 2); i++) { nlme->ngrpTot += nlme->dd->ngrp[i]; }
---
> 	for (i = 0; i < (nlme->dd->Q + 2); i++) {
> 		nlme->ngrpTot += nlme->dd->ngrp[i];
> 	}
121,123c126
< static void
< nlmeFree(nlmePtr nlme)
< {
---
> static void nlmeFree(nlmePtr nlme) {
136,137c139
< restore_dims(nlmePtr nlme)
< {
---
> restore_dims(nlmePtr nlme) {
143,145c145
< static void
< nlme_wtCorrAdj(nlmePtr nlme)
< {
---
> static void nlme_wtCorrAdj(nlmePtr nlme) {
160,162c160
< static double
< nlme_RSS(nlmePtr nlme)
< {
---
> static double nlme_RSS(nlmePtr nlme) {
169,171c167
< static double
< nlme_objective(nlmePtr nlme)
< {
---
> static double nlme_objective(nlmePtr nlme) {
188,190c184
< static void
< nlme_workingRes(nlmePtr nlme)
< {
---
> static void nlme_workingRes(nlmePtr nlme) {
197,198c190,191
< 	double *res =
< 	    nlme->gradient + nlme->dd->ZXrows * (nlme->dd->ZXcols - 1);
---
> 		double *res = nlme->gradient
> 				+ nlme->dd->ZXrows * (nlme->dd->ZXcols - 1);
242,244c235
< static double
< nlme_increment(nlmePtr nlme)
< {
---
> static double nlme_increment(nlmePtr nlme) {
254c245,246
<     if (sqrt_eps == 0.0) sqrt_eps = sqrt(DOUBLE_EPS);
---
> 	if (sqrt_eps == 0.0)
> 		sqrt_eps = sqrt(DOUBLE_EPS);
262,264c254,257
< 	statePTR st = Calloc(1, struct state_struct);
< 	int ntheta = count_DmHalf_pars( nlme->dd, nlme->pdClass ),
< 	    itrmcd, itncnt, msg, iagflg;
---
> 		statePTR
> 		st = Calloc(1, struct state_struct);
> 		int ntheta = count_DmHalf_pars(nlme->dd, nlme->pdClass), itrmcd, itncnt,
> 				msg, iagflg;
283c276,278
< 	for (i = 0; i < ntheta; i++) { typsiz[i] = 1.0; }
---
> 		for (i = 0; i < ntheta; i++) {
> 			typsiz[i] = 1.0;
> 		}
293,299c288,293
< 	optif9(ntheta, ntheta, theta, (fcn_p) mixed_fcn, (fcn_p)
< 	       mixed_grad, (d2fcn_p) 0,
< 	       st, typsiz, 1.0 /*fscale*/, 1 /*method*/, 1 /*iexp*/, &msg,
< 	       -1 /*ndigit*/, 20 /*itnlim*/, iagflg, 0 /*iahflg*/,
< 	       -1. /*dlt*/, pow(epsm, 1.0/3.0) /*gradtl*/, 0. /*stepmx*/,
< 	       sqrt(epsm) /*steptl*/, newtheta, &logLik, grad, &itrmcd, a,
< 	       work, &itncnt);
---
> 		optif9(ntheta, ntheta, theta, (fcn_p) mixed_fcn, (fcn_p) mixed_grad,
> 				(d2fcn_p) 0, st, typsiz, 1.0 /*fscale*/, 1 /*method*/,
> 				1 /*iexp*/, &msg, -1 /*ndigit*/, 20 /*itnlim*/, iagflg,
> 				0 /*iahflg*/, -1. /*dlt*/, pow(epsm, 1.0 / 3.0) /*gradtl*/,
> 				0. /*stepmx*/, sqrt(epsm) /*steptl*/, newtheta, &logLik, grad,
> 				&itrmcd, a, work, &itncnt);
313c307,308
<     internal_loglik(nlme->dd, nlme->result[0], nlme->DmHalf, &RML, dc, DNULLP, nlme->sigma);
---
> 	internal_loglik(nlme->dd, nlme->result[0], nlme->DmHalf, &RML, dc, DNULLP,
> 			nlme->sigma);
319c314,315
< 	    Memcpy(dest, src + ((nlme->dd->SToff)[i][j] - start), (nlme->dd->ncol)[i]);
---
> 			Memcpy(dest, src + ((nlme->dd->SToff)[i][j] - start),
> 					(nlme->dd->ncol)[i]);
330c326,327
<     Free(Ra); Free(dc);
---
> 	Free(Ra);
> 	Free(dc);
332,333c329,331
<     return(sqrt(((double) nlme->nrdof) * (nlme->objective - predObj) /
< 		(((double) nlme->nparTot) * predObj)));
---
> 	return (sqrt(
> 			((double) nlme->nrdof) * (nlme->objective - predObj)
> 					/ (((double) nlme->nparTot) * predObj)));
336,338c334
< static longint
< nlme_iterate(nlmePtr nlme, double *settings aSEV)
< {
---
> static longint nlme_iterate(nlmePtr nlme, double *settings aSEV) {
356,357c352
<     for (factor = 1.0, iteration = 1; iteration <= maxIter;
< 	 iteration++) {		/* outer iteration loop */
---
> 	for (factor = 1.0, iteration = 1; iteration <= maxIter; iteration++) { /* outer iteration loop */
360,361c355,358
< 	if (nlme->conv_failure) return(iteration); /* Unable to make increment  */
< 	if (criterion < tolerance) return(iteration); /* successful completion */
---
> 		if (nlme->conv_failure)
> 			return (iteration); /* Unable to make increment  */
> 		if (criterion < tolerance)
> 			return (iteration); /* successful completion */
374c371,372
< 	    if (nlme->conv_failure) return(iteration); /* unable to evaluate objective */
---
> 			if (nlme->conv_failure)
> 				return (iteration); /* unable to evaluate objective */
387,389c385
< static void
< nlme_wrapup(nlmePtr nlme aSEV)
< {
---
> static void nlme_wrapup(nlmePtr nlme aSEV) {
401,404c397,399
< void
< fit_nlme(double *ptheta, double *pDmHalf, longint *pgroups,
< 	 longint *pdims, longint *pdClass, double *pcorFactor,
< 	 double *pvarWeights, longint *pcorDims, double *settings,
---
> void fit_nlme(double *ptheta, double *pDmHalf, longint *pgroups,
> longint *pdims, longint *pdClass, double *pcorFactor, double *pvarWeights,
> 		longint *pcorDims, double *settings,
406,407c401,402
< 	 double *additional, longint *pcorOpt, longint *pvarOpt, double *sigma aMOD)
< {
---
> 		double *additional, longint *pcorOpt, longint *pvarOpt,
> 		double *sigma aMOD) {
414,415c409,410
<     nlme = nlme_init(ptheta, pDmHalf, pgroups, pdims, pdClass,
< 		     pcorFactor, pvarWeights, pcorDims,
---
> 	nlme = nlme_init(ptheta, pDmHalf, pgroups, pdims, pdClass, pcorFactor,
> 			pvarWeights, pcorDims,
418c413,414
<     if(sqrt_eps == 0.0) sqrt_eps = sqrt(DOUBLE_EPS);
---
> 	if (sqrt_eps == 0.0)
> 		sqrt_eps = sqrt(DOUBLE_EPS);
428,430c424
< void
< nlme_one_comp_open (longint *nrow, double *Resp, double *inmat)
< {
---
> void nlme_one_comp_open(longint *nrow, double *Resp, double *inmat) {
432,434c426,427
<     double ke, ka, tl = 0, delta, C = 0, Ca = 0, interval,
< 	*Subject, *Time, *Conc, *Dose, *Interval, *V, *Ka, *Ke,
< 	sl = DOUBLE_EPS;	/* sl is last subject number, usually */
---
> 	double ke, ka, tl = 0, delta, C = 0, Ca = 0, interval, *Subject, *Time,
> 			*Conc, *Dose, *Interval, *V, *Ka, *Ke, sl = DOUBLE_EPS; /* sl is last subject number, usually */
445,447c438,441
<     for(i = nn; i--; Resp++, Subject++, Time++, Conc++, Dose++,
< 	    Interval++, V++, Ka++, Ke++) {
< 	ke = *Ke; ka = *Ka;
---
> 	for (i = nn; i--;
> 			Resp++, Subject++, Time++, Conc++, Dose++, Interval++, V++, Ka++, Ke++) {
> 		ke = *Ke;
> 		ka = *Ka;
454,456c448,451
< 		C = *Dose * ka * (1/(1 - exp(-ke * interval)) -
< 				  1/(1 - exp(-ka * interval)))/
< 		    (*V * (ka - ke));
---
> 				C = *Dose * ka
> 						* (1 / (1 - exp(-ke * interval))
> 								- 1 / (1 - exp(-ka * interval)))
> 						/ (*V * (ka - ke));
466,468c461,464
< 		    C = *Dose * ka * (1/(1 - exp(-ke * interval)) -
< 				      1/(1 - exp(-ka * interval)))/
< 			(*V * (ka - ke));
---
> 					C = *Dose * ka
> 							* (1 / (1 - exp(-ke * interval))
> 									- 1 / (1 - exp(-ka * interval)))
> 							/ (*V * (ka - ke));
472,473c468,470
< 		    C = C*exp(-ke * delta) +
< 			Ca*ka*(exp(-ke*delta) - exp(-ka*delta))/(ka -ke);
---
> 					C = C * exp(-ke * delta)
> 							+ Ca * ka * (exp(-ke * delta) - exp(-ka * delta))
> 									/ (ka - ke);
480,482c477,481
< 		*Resp = C * exp(-ke * delta) + Ca * ka *
< 		    (exp(-ke * delta) - exp(-ka * delta))/(ka - ke);
< 	    } else *Resp = 0;
---
> 				*Resp = C * exp(-ke * delta)
> 						+ Ca * ka * (exp(-ke * delta) - exp(-ka * delta))
> 								/ (ka - ke);
> 			} else
> 				*Resp = 0;
489,491c488
< void
< nlme_one_comp_first (longint *nrow, double *Resp, double *inmat)
< {
---
> void nlme_one_comp_first(longint *nrow, double *Resp, double *inmat) {
504c501,502
< 	v = *V; cl = *Cl;
---
> 		v = *V;
> 		cl = *Cl;
526c524,525
<     Free(ds); Free(tl);
---
> 	Free(ds);
> 	Free(tl);
diff -rEZbwB '--exclude=*.[lo,d,pdf,mo,po,tgz,gz,save]*' '--exclude=MD5' '--exclude=Makefile*' '--exclude=all.R' '--exclude=Changes' R-recommended/nlme/src/nlmefit.c Recommended/nlme/src/nlmefit.c
28a29
> #include "localization.h"
38c39,40
< extern void F77_NAME(msmnh)();
---
> extern void F77_NAME( msmnh)
> ();
41,42c43
< setOffsets(longint ** base, longint * ngrp, longint Qp2)
< {
---
> setOffsets(longint ** base, longint * ngrp, longint Qp2) {
50a52
> dimPTR dims(longint *pdims) { /* constructor for a dims object */
52,54c54
< dims(longint *pdims)
< {				/* constructor for a dims object */
<     dimPTR value = Calloc((size_t) 1, struct dim_struct);
---
> 	value = Calloc((size_t) 1, struct dim_struct);
77,78c77
< SEXP getListElement(SEXP list, char *str)
< {
---
> SEXP getListElement(SEXP list, char *str) {
93,94c92,95
<     int i, Qp2;  SEXP tmp;
<     dimPTR value = Calloc((size_t) 1, struct dim_struct);
---
> 	int i, Qp2;
> 	SEXP tmp;
> 	dimPTR
> 	value = Calloc((size_t) 1, struct dim_struct);
100,103c101,102
<     value->Q =
< 	INTEGER(coerceVector(getListElement(d, "Q"), INTSXP))[0];
<     value->Srows =
< 	INTEGER(coerceVector(getListElement(d, "Srows"), INTSXP))[0];
---
> 	value->Q = INTEGER(coerceVector(getListElement(d, "Q"), INTSXP))[0];
> 	value->Srows = INTEGER(coerceVector(getListElement(d, "Srows"), INTSXP))[0];
142,144c141
< void
< dimFree(dimPTR this)
< {
---
> void dimFree(dimPTR this) {
153,155c150
< int
< count_DmHalf_pars( dimPTR dd, longint *pdClass )
< {
---
> int count_DmHalf_pars(dimPTR dd, longint *pdClass) {
159c154,156
< 	case 0: case 4: result += ( (dd->q)[ i ] * ( (dd->q)[ i ] + 1 ) ) / 2;
---
> 		case 0:
> 		case 4:
> 			result += ((dd->q)[i] * ((dd->q)[i] + 1)) / 2;
161c158,159
< 	case 1: result += (dd->q)[ i ];
---
> 		case 1:
> 			result += (dd->q)[i];
163c161,162
< 	case 2: result += 1;
---
> 		case 2:
> 			result += 1;
165c164,165
< 	case 3: result += 2;
---
> 		case 3:
> 			result += 2;
172,174c172,174
< generate_DmHalf( double *DmHalf, dimPTR dd, longint *pdClass, double *pars )
< {				/* Expand parameters to DmHalf arrays */
<     int i, j, q, Q = dd->Q; double diag;
---
> generate_DmHalf(double *DmHalf, dimPTR dd, longint *pdClass, double *pars) { /* Expand parameters to DmHalf arrays */
> 	int i, j, q, Q = dd->Q;
> 	double diag;
226,228c226,227
< scale_mat(double *y, longint ldy, double a,
< 	  double *x, longint ldx, longint nrow, longint ncol)
< {				/* y <- a * x */
---
> scale_mat(double *y, longint ldy, double a, double *x, longint ldx,
> 		longint nrow, longint ncol) { /* y <- a * x */
233,234c232,236
< 	for (i = 0; i < nrow; i++) { y[i] = a * x[i]; }
< 	y += ldy; x += ldx;
---
> 		for (i = 0; i < nrow; i++) {
> 			y[i] = a * x[i];
> 		}
> 		y += ldy;
> 		x += ldx;
241,242c243
< 		longint nrow, longint ncol)
< {				/* y <- y + x */
---
> longint nrow, longint ncol) { /* y <- y + x */
247,248c248,252
< 	for (i = 0; i < nrow; i++) { y[i] += x[i]; }
< 	y += ldy; x += ldx;
---
> 		for (i = 0; i < nrow; i++) {
> 			y[i] += x[i];
> 		}
> 		y += ldy;
> 		x += ldx;
255,256c259
< 	  longint nrot, longint ny)
< {
---
> longint nrot, longint ny) {
275,276c278
< invert_upper(double *mat, longint ldmat, longint ncol)
< {
---
> invert_upper(double *mat, longint ldmat, longint ncol) {
281c283,285
< 	for (j = 0; j < (i - 1L); j++) { b[j] = 0.0; }
---
> 		for (j = 0; j < (i - 1L); j++) {
> 			b[j] = 0.0;
> 		}
284c288,291
< 	if (info != 0) { Free(b); return info; }
---
> 		if (info != 0) {
> 			Free(b);
> 			return info;
> 		}
287c294,297
<     if (*mat == 0.0) { Free(b); return 1L; }
---
> 	if (*mat == 0.0) {
> 		Free(b);
> 		return 1L;
> 	}
289c299,300
<     Free(b); return 0L;
---
> 	Free(b);
> 	return 0L;
294,295c305
< 	     longint ncol, longint nright)
< {
---
> longint ncol, longint nright) {
299c309,310
<     if (info != 0L) return info;
---
> 	if (info != 0L)
> 		return info;
309,311c320,321
< 			    mult_mat(tmp, nabove, tpblk, ldmat, nabove, ncol,
< 				     rtblk, ldmat, nright),
< 			    nabove, nabove, nright);
---
> 					mult_mat(tmp, nabove, tpblk, ldmat, nabove, ncol, rtblk,
> 							ldmat, nright), nabove, nabove, nright);
323,324c332
< mixed_decomp(double *ZXy, longint *pdims)
< {
---
> mixed_decomp(double *ZXy, longint *pdims) {
330,332c338
< void
< internal_decomp(dimPTR dd, double *ZXy)
< {				/* decompose ZXy and re-write the dims */
---
> void internal_decomp(dimPTR dd, double *ZXy) { /* decompose ZXy and re-write the dims */
341,343c347,349
< 	    QR_and_rotate(ZXy + (dd->ZXoff)[i][j], dd->ZXrows, (dd->ZXlen)[i][j],
< 			  (dd->ncol)[i] + (dd->nrot)[i], DNULLP, 0L,
< 			  (dd->ncol)[i], DNULLP, dc + (dd->SToff)[i][j],
---
> 			QR_and_rotate(ZXy + (dd->ZXoff)[i][j], dd->ZXrows,
> 					(dd->ZXlen)[i][j], (dd->ncol)[i] + (dd->nrot)[i], DNULLP,
> 					0L, (dd->ncol)[i], DNULLP, dc + (dd->SToff)[i][j],
362,365c368,370
< 		double *sigma)
< {				/* if dc is NULL, don't attempt storage */
<     longint i, j, Q = dd->Q,  Qp2 = Q + 2, qi,
< 	ldstr = (dc != DNULLP) ? (dd->Srows) : 0L;
---
> 		double *sigma) { /* if dc is NULL, don't attempt storage */
> 	longint i, j, Q = dd->Q, Qp2 = Q + 2, qi, ldstr =
> 			(dc != DNULLP ) ? (dd->Srows) : 0L;
372,373c377,378
< 	    if (qi >
< 		QR_and_rotate(ZXy + (dd->ZXoff)[i][j], dd->ZXrows,
---
> 			if (qi
> 					> QR_and_rotate(ZXy + (dd->ZXoff)[i][j], dd->ZXrows,
376,378c381,382
< 			      lglk + i, dc + (dd->SToff)[i][j], ldstr))
< 	    {
< 		warning("Singular precision matrix in level %ld, block %ld",
---
> 							lglk + i, dc + (dd->SToff)[i][j], ldstr)) {
> 				warning(_("Singular precision matrix in level %ld, block %ld"),
387,388c391,392
< 	dmQR = QR( copy_mat( dmHlf, qi, DmHalf + (dd->DmOff)[i],
< 			     qi, qi, qi ), qi, qi, qi);
---
> 		dmQR = QR(copy_mat(dmHlf, qi, DmHalf + (dd->DmOff)[i], qi, qi, qi), qi,
> 				qi, qi);
390c394,395
< 	QRfree( dmQR ); Free( dmHlf );
---
> 		QRfree(dmQR);
> 		Free(dmHlf);
411,413c416
< void
< internal_estimate(dimPTR dd, double *dc)
< {				/* solve for Beta and b_i estimates */
---
> void internal_estimate(dimPTR dd, double *dc) { /* solve for Beta and b_i estimates */
419,421c422,423
< 			  (dd->SToff)[i][j] - (dd->DecOff)[i][j],
< 			  (dd->ncol)[i], (dd->nrot)[i], (dd->ncol)[Qp1]) != 0)
< 	    {
---
> 					(dd->SToff)[i][j] - (dd->DecOff)[i][j], (dd->ncol)[i],
> 					(dd->nrot)[i], (dd->ncol)[Qp1]) != 0) {
429,431c431
< static void
< internal_R_invert(dimPTR dd, double *dc)
< {				/* Invert the virtual R matrix in place */
---
> static void internal_R_invert(dimPTR dd, double *dc) { /* Invert the virtual R matrix in place */
436,437c436,437
< 			 (dd->SToff)[i][j] - (dd->DecOff)[i][j],
< 			 (dd->ncol)[i], (dd->nrot)[i] - 1L);
---
> 					(dd->SToff)[i][j] - (dd->DecOff)[i][j], (dd->ncol)[i],
> 					(dd->nrot)[i] - 1L);
445,447c445,447
< pt_prod( double *prod, double *a, double *b, longint len )
< {				/* prod <- a * b */
<     longint i; double *ret = prod;
---
> pt_prod(double *prod, double *a, double *b, longint len) { /* prod <- a * b */
> 	longint i;
> 	double *ret = prod;
454,456c454,455
< static void
< finite_diff_Hess(double (*func)(double*,double*), double *pars, int npar,
< 		 double *vals,
---
> static void finite_diff_Hess(double (*func)(double*, double*), double *pars,
> 		int npar, double *vals,
458,459c457
< 		 double *sigma)
< {				/* use Koshal design for finite-differences */
---
> 		double *sigma) { /* use Koshal design for finite-differences */
467c465,466
<     if (cube_root_eps == 0.0) cube_root_eps = exp( log( DOUBLE_EPS ) / 3.);
---
> 	if (cube_root_eps == 0.0)
> 		cube_root_eps = exp(log(DOUBLE_EPS) / 3.);
522c521,525
<     QRfree( xQR ); Free( incr ); Free( parray ); Free( div ); Free( Xmat );
---
> 	QRfree(xQR);
> 	Free(incr);
> 	Free(parray);
> 	Free(div);
> 	Free(Xmat);
527,528c530
< mixed_fcn(longint n, double *pars, double *g, void *state)
< {
---
> mixed_fcn(longint n, double *pars, double *g, void *state) {
535,537c537,540
< 			  generate_DmHalf(Delta, st->dd, st->pdClass, pars),
< 			  st->RML, DNULLP, DNULLP, st->sigma);// 17-11-2015; Fixed sigma ..
<     Free(Delta); Free(zxcopy);
---
> 			generate_DmHalf(Delta, st->dd, st->pdClass, pars), st->RML, DNULLP,
> 			DNULLP, st->sigma); // 17-11-2015; Fixed sigma ..
> 	Free(Delta);
> 	Free(zxcopy);
541,542c544
< mixed_grad(longint n, double *pars, double *g, void *state)
< {
---
> mixed_grad(longint n, double *pars, double *g, void *state) {
548,549c550,551
<     double  sqrtDF = sqrt((double) (st->dd->N -
< 				    *(st->RML)*(st->dd->ncol[st->dd->Q])));
---
> 	double sqrtDF = sqrt(
> 			(double) (st->dd->N - *(st->RML) * (st->dd->ncol[st->dd->Q])));
552,553c554,555
<     DmHalf = generate_DmHalf(Delta, st->dd, st->pdClass, pars),
< 	Memcpy(zxcopy, st->ZXy, st->dd->ZXrows * st->dd->ZXcols);
---
> 	DmHalf = generate_DmHalf(Delta, st->dd, st->pdClass, pars), Memcpy(zxcopy,
> 			st->ZXy, st->dd->ZXrows * st->dd->ZXcols);
562c564,565
< 	sigmainv = *(dc + (size_t)((st->dd->Srows) * (st->dd->ZXcols)) - 1)/sqrtDF;
---
> 		sigmainv = *(dc + (size_t) ((st->dd->Srows) * (st->dd->ZXcols)) - 1)
> 				/ sqrtDF;
571,572c574,575
< 	longint ncol = (st->dd->q)[i],
< 	    nright = (st->dd->nrot)[i] - (st->dd->nrot)[(st->dd->Q) - ( (*(st->RML)) ? 0 : 1 )];
---
> 		longint ncol = (st->dd->q)[i], nright = (st->dd->nrot)[i]
> 				- (st->dd->nrot)[(st->dd->Q) - ((*(st->RML)) ? 0 : 1)];
590c593,595
< 	    error(_("analytic gradient is not available with matrix logarithm"));
---
> 			error(
> 					_(
> 							"analytic gradient is not available with matrix logarithm"));
595c600,601
< 		*g++ = st->dd->ngrp[i] - tmp*tmp*d_sum_sqr(res + j * ncol, j + 1L);
---
> 				*g++ = st->dd->ngrp[i]
> 						- tmp * tmp * d_sum_sqr(res + j * ncol, j + 1L);
613c619,621
< 	    error(_("analytic gradient is not available with compound symmetry"));
---
> 			error(
> 					_(
> 							"analytic gradient is not available with compound symmetry"));
624,625c632,633
< 		    col_j[i1] = d_dot_prod(res + i1*ncol, 1, res +
< 					   j1*ncol, 1, 1+i1);
---
> 					col_j[i1] = d_dot_prod(res + i1 * ncol, 1, res + j1 * ncol,
> 							1, 1 + i1);
627,628c635,636
< 		    col_j[i1] = d_dot_prod(res + i1*ncol, 1, res +
< 					   j1*ncol, 1, 1+j1);
---
> 					col_j[i1] = d_dot_prod(res + i1 * ncol, 1, res + j1 * ncol,
> 							1, 1 + j1);
634,635c642,643
< 			sum += DmHalf[(st->dd->DmOff)[i] + i1*ncol + k1] *
< 			    col_j[k1];
---
> 						sum += DmHalf[(st->dd->DmOff)[i] + i1 * ncol + k1]
> 								* col_j[k1];
638,639c646,649
< 			*g++ = st->dd->ngrp[i] -
< 			    sum*DmHalf[(st->dd->DmOff)[i] + i1*(ncol + 1)];
---
> 						*g++ = st->dd->ngrp[i]
> 								- sum
> 										* DmHalf[(st->dd->DmOff)[i]
> 												+ i1 * (ncol + 1)];
649c659,661
<     Free(dc); Free(Delta); Free(zxcopy);
---
> 	Free(dc);
> 	Free(Delta);
> 	Free(zxcopy);
659,660c671
< static double
< logLik_fun( double *pars, double *sigma) // 17-11-2015; Fixed sigma patch; E van Willigen; Quantitative Solutions
---
> static double logLik_fun(double *pars, double *sigma) // 17-11-2015; Fixed sigma patch; E van Willigen; Quantitative Solutions
667,668c678
< static double
< negLogLik_fun( double *pars, double *sigma) // 17-11-2015; Fixed sigma patch; E van Willigen; Quantitative Solutions
---
> static double negLogLik_fun(double *pars, double *sigma) // 17-11-2015; Fixed sigma patch; E van Willigen; Quantitative Solutions
675,676c685
< void
< mixed_loglik(double *ZXy, longint *pdims, double *pars, longint *settings,
---
> void mixed_loglik(double *ZXy, longint *pdims, double *pars, longint *settings,
689,691c698,700
< 	    *logLik =
< 		internal_loglik( dd, ZXy, generate_DmHalf( Delta, dd, pdC, pars ),
< 				 settings, DNULLP, lRSS, sigma ); // 17-11-2015; Fixed sigma patch; E van Willigen; Quantitative Solutions
---
> 			*logLik = internal_loglik(dd, ZXy,
> 					generate_DmHalf(Delta, dd, pdC, pars), settings, DNULLP,
> 					lRSS, sigma); // 17-11-2015; Fixed sigma patch; E van Willigen; Quantitative Solutions
711,712c720
< 	       double *sigma)
< {				/* dc receives the decomposed ZXy array */
---
> 		double *sigma) { /* dc receives the decomposed ZXy array */
717c725,727
<     if (*invert != 0) { internal_R_invert( dd, dc ); }
---
> 	if (*invert != 0) {
> 		internal_R_invert(dd, dc);
> 	}
723,724c733
< 	    longint *pdClass, longint *RML, double *logLik, double *Ra,
< 	    double *lRSS,
---
> longint *pdClass, longint *RML, double *logLik, double *Ra, double *lRSS,
726,727c735
< 	    double *sigma)
< {
---
> 		double *sigma) {
743c751,752
< 	    sigmainv = *(dc + (size_t)((dd->Srows) * (dd->ZXcols)) - 1)/sqrtDF;
---
> 			sigmainv = *(dc + (size_t) ((dd->Srows) * (dd->ZXcols)) - 1)
> 					/ sqrtDF;
752,753c761,762
< 	    longint ncol = (dd->q)[i],
< 		nright = (dd->nrot)[i] - (dd->nrot)[(dd->Q) - ( (*RML) ? 0 : 1 )];
---
> 			longint ncol = (dd->q)[i], nright = (dd->nrot)[i]
> 					- (dd->nrot)[(dd->Q) - ((*RML) ? 0 : 1)];
758,759c767,768
< 		copy_trans(pt, nrow, dc + (dd->SToff)[i][j], dd->Srows,
< 			   ncol, ncol + nright);
---
> 				copy_trans(pt, nrow, dc + (dd->SToff)[i][j], dd->Srows, ncol,
> 						ncol + nright);
771c780,781
< 	    case 0: case 4:			/* default: unstructured */
---
> 			case 0:
> 			case 4: /* default: unstructured */
773c783,784
< 		copy_trans(DmHalf + (dd->DmOff)[i], ncol, res, nrow, ncol, ncol);
---
> 				copy_trans(DmHalf + (dd->DmOff)[i], ncol, res, nrow, ncol,
> 						ncol);
777,778c788,789
< 		    DmHalf[ (dd->DmOff)[i] + j * (ncol + 1)] =
< 			1. / sqrt( d_sum_sqr( res + j * nrow, j + 1L ) );
---
> 					DmHalf[(dd->DmOff)[i] + j * (ncol + 1)] = 1.
> 							/ sqrt(d_sum_sqr(res + j * nrow, j + 1L));
832c843,844
<     Free(dc); Free(zxcopy);
---
> 	Free(dc);
> 	Free(zxcopy);
835,838c847,848
< void
< mixed_EM(double *ZXy, longint *pdims, double *DmHalf, longint *nIter,
< 	 longint *pdClass, longint *RML, double *logLik, double *Ra,
< 	 double *lRSS,
---
> void mixed_EM(double *ZXy, longint *pdims, double *DmHalf, longint *nIter,
> longint *pdClass, longint *RML, double *logLik, double *Ra, double *lRSS,
840,841c850
< 	 double *sigma)
< {
---
> 		double *sigma) {
848,851c857,858
< mixed_calcf(longint *n, double *theta, longint *nf,
< 	    double *f, longint *uiparm, double *urparm,
< 	    void (*ufparm)(void))
< {
---
> mixed_calcf(longint *n, double *theta, longint *nf, double *f, longint *uiparm,
> 		double *urparm, void (*ufparm)(void)) {
860,863c867,868
< mixed_calcgh(longint *n, double *theta, longint *nf,
< 	     double *g, double *h, longint *uiparm,
< 	     double *urparm, void (*ufparm)(void))
< {
---
> mixed_calcgh(longint *n, double *theta, longint *nf, double *g, double *h,
> 		longint *uiparm, double *urparm, void (*ufparm)(void)) {
887,888c892,893
< 	    y[ i * ldy + j ] = y[ j * ldy + i ] =
< 		d_dot_prod( x + i * ldx, 1L, x + j * ldx, 1L, nrow );
---
> 			y[i * ldy + j] = y[j * ldy + i] = d_dot_prod(x + i * ldx, 1L,
> 					x + j * ldx, 1L, nrow);
898,900c903
< static void
< Delta2MatrixLog( double *theta, longint *q, double *Delta )
< {
---
> static void Delta2MatrixLog(double *theta, longint *q, double *Delta) {
911c914,915
< 	F77_CALL(rs) (q, q, DtransD, values, &one, vectors, workmat, work2, &info);
---
> 		F77_CALL(rs)(q, q, DtransD, values, &one, vectors, workmat, work2,
> 				&info);
929c933,936
< 	Free(vectors); Free(DtransD); Free(workmat), Free(work2); Free(values);
---
> 		Free(vectors);
> 		Free(DtransD);
> 		Free (workmat), Free( work2);
> 		Free(values);
933,935c940
< static void
< Delta2LogCholesky(double *theta, longint *q, double *Delta )
< {
---
> static void Delta2LogCholesky(double *theta, longint *q, double *Delta) {
957,958c962
< generate_theta( double *theta, dimPTR dd, longint *pdClass, double *DmHalf )
< {				/* Expand parameters to DmHalf arrays */
---
> generate_theta(double *theta, dimPTR dd, longint *pdClass, double *DmHalf) { /* Expand parameters to DmHalf arrays */
989,990c993,994
< 	       longint *pdClass, longint *RML, double *logLik, double *R0,
< 	       double *lRSS, longint *info,
---
> longint *pdClass, longint *RML, double *logLik, double *R0, double *lRSS,
> 		longint *info,
992,993c996
< 	       double *sigma)
< {
---
> 		double *sigma) {
1012c1015,1016
< 		*Delta = 0.375 * sqrt( d_sum_sqr( work, dd->ZXrows ) / (dd->ngrp)[i]);
---
> 				*Delta = 0.375
> 						* sqrt(d_sum_sqr(work, dd->ZXrows) / (dd->ngrp)[i]);
1019,1020c1023
<     internal_EM(dd, ZXy, DmHalf, *nIter, pdClass, RML, logLik, Ra, lRSS,
< 		sigma); // 17-11-2015; Fixed sigma patch ...
---
> 	internal_EM(dd, ZXy, DmHalf, *nIter, pdClass, RML, logLik, Ra, lRSS, sigma); // 17-11-2015; Fixed sigma patch ...
1074,1075c1077
< 	double *theta, *scale, ufparm[1],
< 	    *sigma; // 17-11-2015; Fixed sigma patch; E van Willigen; Quantitative Sol.
---
> 		double *theta, *scale, ufparm[1], *sigma; // 17-11-2015; Fixed sigma patch; E van Willigen; Quantitative Sol.
1090c1092,1094
< 	for( i = 0; i < ntheta; i++ ) { scale[i] = 1.; }
---
> 		for (i = 0; i < ntheta; i++) {
> 			scale[i] = 1.;
> 		}
1093,1094c1097,1098
< 	F77_CALL(msmnh) (&ntheta, scale, theta, mixed_calcf, mixed_calcgh,
< 			 iv, &liv, &lv, work, uiparm, ufparm, abort);
---
> 		F77_CALL(msmnh)(&ntheta, scale, theta, mixed_calcf, mixed_calcgh, iv,
> 				&liv, &lv, work, uiparm, ufparm, abort);
1098,1099c1102
< 				   generate_DmHalf( Delta, dd, pdC, theta ),
< 				   setngs, dc, lRSS,
---
> 				generate_DmHalf(Delta, dd, pdC, theta), setngs, dc, lRSS,
1103c1106,1111
< 	Free(scale); Free(work); Free(iv); Free(values); Free(theta); Free(zxcopy);
---
> 		Free(scale);
> 		Free(work);
> 		Free(iv);
> 		Free(values);
> 		Free(theta);
> 		Free(zxcopy);
1106c1114,1116
<     dimFree( dd ); Free( dc ); Free( Ra );
---
> 	dimFree(dd);
> 	Free(dc);
> 	Free(Ra);
1111,1112c1121
< static double
< inner_perc(double *x, longint *grp, longint n)
---
> static double inner_perc(double *x, longint *grp, longint n)
1139,1140c1148
< void
< inner_perc_table(double *X, longint *grps, longint *p, longint *Q,
---
> void inner_perc_table(double *X, longint *grps, longint *p, longint *Q,
1156,1157c1164
< void
< gls_loglik(double *Xy, longint *pdims, double *logLik, double *lRSS,
---
> void gls_loglik(double *Xy, longint *pdims, double *logLik, double *lRSS,
1159,1162c1166,1168
< 	   double *sigma)
< {
<     longint i, N = pdims[0], p = pdims[1], RML = pdims[2],
< 	Np1 = N + 1, Nr = N - RML * p, rnkm1;
---
> 		double *sigma) {
> 	longint i, N = pdims[0], p = pdims[1], RML = pdims[2], Np1 = N + 1, Nr = N
> 			- RML * p, rnkm1;
1216,1221c1222,1225
< void
< gls_estimate(double *Xy, longint *pdims, double *beta, double *sigma,
< 	     double *logLik, double *varBeta, longint *rank, longint *pivot)
< {
<     longint i, N = pdims[0], p = pdims[1], RML = pdims[2], pp1 = p + 1,
< 	Nr = N - RML * p, rk, rkm1, rkp1;
---
> void gls_estimate(double *Xy, longint *pdims, double *beta, double *sigma,
> 		double *logLik, double *varBeta, longint *rank, longint *pivot) {
> 	longint i, N = pdims[0], p = pdims[1], RML = pdims[2], pp1 = p + 1, Nr = N
> 			- RML * p, rk, rkm1, rkp1;
diff -rEZbwB '--exclude=*.[lo,d,pdf,mo,po,tgz,gz,save]*' '--exclude=MD5' '--exclude=Makefile*' '--exclude=all.R' '--exclude=Changes' R-recommended/nlme/src/nlmefit.h Recommended/nlme/src/nlmefit.h
31,32c31
<   longint
<     N,				/* number of observations in original data */
---
> 	longint N, /* number of observations in original data */
51,53c50
<   double *ZXy;
<   longint *pdClass,
<     *RML;
---
> 	double *ZXy;longint *pdClass, *RML;
67,72c64,69
< extern void mixed_loglik(double *, longint *, double *, longint *,
< 			 double *, double *, double *); // 17-11-2015; Fixed sigma patch; E van Willigen; Quantitative Solutions
< extern double internal_loglik(dimPTR, double *, double *, longint *,
< 			      double *, double *, double *); // 17-11-2015; Fixed sigma patch; E van Willigen; Quantitative Solutions
< extern void mixed_estimate(double *, longint *, double *, longint *,
< 			   double *, double *, longint *, double *); // 17-11-2015; Fixed sigma patch; E van Willigen; Quantitative Solutions
---
> extern void mixed_loglik(double *, longint *, double *, longint *, double *,
> 		double *, double *); // 17-11-2015; Fixed sigma patch; E van Willigen; Quantitative Solutions
> extern double internal_loglik(dimPTR, double *, double *, longint *, double *,
> 		double *, double *); // 17-11-2015; Fixed sigma patch; E van Willigen; Quantitative Solutions
> extern void mixed_estimate(double *, longint *, double *, longint *, double *,
> 		double *, longint *, double *); // 17-11-2015; Fixed sigma patch; E van Willigen; Quantitative Solutions
79,80c76
< 			   longint *, longint *, double *, double *,
< 			   double *, longint *, double *); // 17-11-2015; Fixed sigma patch; E van Willigen; Quantitative Solutions
---
> longint *, longint *, double *, double *, double *, longint *, double *); // 17-11-2015; Fixed sigma patch; E van Willigen; Quantitative Solutions
83,84c79,80
< extern void mixed_calcgh(longint *, double *, longint *, double *,
< 			 double *, longint *, double *, void (*)(void));
---
> extern void mixed_calcgh(longint *, double *, longint *, double *, double *,
> 		longint *, double *, void (*)(void));
86,87c82,83
< extern void gls_estimate(double *, longint *, double *, double *,
< 			 double *, double *, longint *, longint *);
---
> extern void gls_estimate(double *, longint *, double *, double *, double *,
> 		double *, longint *, longint *);
diff -rEZbwB '--exclude=*.[lo,d,pdf,mo,po,tgz,gz,save]*' '--exclude=MD5' '--exclude=Makefile*' '--exclude=all.R' '--exclude=Changes' R-recommended/nlme/src/nls.c Recommended/nlme/src/nls.c
29,31c29
< static double
< est_delta(double *x, longint i)
< {
---
> static double est_delta(double *x, longint i) {
33,34c31,34
<   if(sqrt_eps == 0.0) sqrt_eps = sqrt(DOUBLE_EPS);
<   if(!xlower) xlower = 100.*DOUBLE_XMIN;
---
> 	if (sqrt_eps == 0.0)
> 		sqrt_eps = sqrt(DOUBLE_EPS);
> 	if (!xlower)
> 		xlower = 100. * DOUBLE_XMIN;
38,39c38,41
<   if (xx < xlower) return sqrt_eps;
<   else return xx*sqrt_eps;
---
> 	if (xx < xlower)
> 		return sqrt_eps;
> 	else
> 		return xx * sqrt_eps;
42,45c44,45
< void
< nls_diff_gradient(longint *pnpar, longint *pnobs, double *theta, double
< 		  *base, double *gradient, longint *pneg aSEV)
< {
---
> void nls_diff_gradient(longint *pnpar, longint *pnobs, double *theta,
> 		double *base, double *gradient, longint *pneg aSEV) {
53,54c53,56
<     spread(theta, npar SEV); eval_model(FALSE SEV);
<     if(neg) di = -di;		/* want negative gradient? */
---
> 		spread(theta, npar SEV);
> 		eval_model(FALSE SEV);
> 		if (neg)
> 			di = -di; /* want negative gradient? */
diff -rEZbwB '--exclude=*.[lo,d,pdf,mo,po,tgz,gz,save]*' '--exclude=MD5' '--exclude=Makefile*' '--exclude=all.R' '--exclude=Changes' R-recommended/nlme/src/pdMat.c Recommended/nlme/src/pdMat.c
31,33c31
< static void
< Chol_pd(double *L, longint *q, double *l)
< {
---
> static void Chol_pd(double *L, longint *q, double *l) {
42,43c40
< logChol_pd(double *L, longint *q, double *l)
< {
---
> logChol_pd(double *L, longint *q, double *l) {
54,56c51
< void
< matrixLog_pd(double *L, longint *q, double *l)
< {
---
> void matrixLog_pd(double *L, longint *q, double *l) {
77c72,75
<     Free(vectors); Free(work1); Free(work2); Free(values);
---
> 		Free(vectors);
> 		Free(work1);
> 		Free(work2);
> 		Free(values);
81,83c79
< 
< void
< natural_pd(double *L, longint *q, double *l) /* natural parametrization  */
---
> void natural_pd(double *L, longint *q, double *l) /* natural parametrization  */
88c84,85
<   for(i = 0; i < *q; i++) std[i] = exp(std[i]);
---
> 	for (i = 0; i < *q; i++)
> 		std[i] = exp(std[i]);
108,109c105
< void
< compSymm_pd(double *L, longint *q, double *l) /* compound symmetry */
---
> void compSymm_pd(double *L, longint *q, double *l) /* compound symmetry */
